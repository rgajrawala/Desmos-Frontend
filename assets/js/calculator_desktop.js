////////////// FROM INDEX.HTML //////////////

// TODO - get console and pushstate into regular .js files
if(!window.Desmos) {
    window.Desmos = {};
}
if(!window.console) {
    window.console = {};
}

// Pull config information, and include it in Desmos.config
window.Desmos.config = {"workerURL": "/js/worker.js"};

// Make sure console.log is defined
if(!window.console.log) {
    window.console.log = function(){};
}

// Make sure we don't use pushstate on file protocol
if(window.location.protocol === 'file:') {
    window.history.pushState = function(){};
}

////////////// END INDEX.HTML SCRIPTS //////////////

/**
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("vendor/almond", function(){});

/*!
 * jQuery JavaScript Library v1.8.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: Tue Nov 13 2012 08:20:33 GMT-0500 (Eastern Standard Time)
 */
(function( window, undefined ) {
var
    // A central reference to the root jQuery(document)
    rootjQuery,

    // The deferred used on DOM ready
    readyList,

    // Use the correct document accordingly with window argument (sandbox)
    document = window.document,
    location = window.location,
    navigator = window.navigator,

    // Map over jQuery in case of overwrite
    _jQuery = window.jQuery,

    // Map over the $ in case of overwrite
    _$ = window.$,

    // Save a reference to some core methods
    core_push = Array.prototype.push,
    core_slice = Array.prototype.slice,
    core_indexOf = Array.prototype.indexOf,
    core_toString = Object.prototype.toString,
    core_hasOwn = Object.prototype.hasOwnProperty,
    core_trim = String.prototype.trim,

    // Define a local copy of jQuery
    jQuery = function( selector, context ) {
        // The jQuery object is actually just the init constructor 'enhanced'
        return new jQuery.fn.init( selector, context, rootjQuery );
    },

    // Used for matching numbers
    core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,

    // Used for detecting and trimming whitespace
    core_rnotwhite = /\S/,
    core_rspace = /\s+/,

    // Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

    // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

    // Match a standalone tag
    rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

    // JSON RegExp
    rvalidchars = /^[\],:{}\s]*$/,
    rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
    rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
    rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,

    // Matches dashed string for camelizing
    rmsPrefix = /^-ms-/,
    rdashAlpha = /-([\da-z])/gi,

    // Used by jQuery.camelCase as callback to replace()
    fcamelCase = function( all, letter ) {
        return ( letter + "" ).toUpperCase();
    },

    // The ready event handler and self cleanup method
    DOMContentLoaded = function() {
        if ( document.addEventListener ) {
            document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
            jQuery.ready();
        } else if ( document.readyState === "complete" ) {
            // we're here because readyState === "complete" in oldIE
            // which is good enough for us to call the dom ready!
            document.detachEvent( "onreadystatechange", DOMContentLoaded );
            jQuery.ready();
        }
    },

    // [[Class]] -> type pairs
    class2type = {};

jQuery.fn = jQuery.prototype = {
    constructor: jQuery,
    init: function( selector, context, rootjQuery ) {
        var match, elem, ret, doc;

        // Handle $(""), $(null), $(undefined), $(false)
        if ( !selector ) {
            return this;
        }

        // Handle $(DOMElement)
        if ( selector.nodeType ) {
            this.context = this[0] = selector;
            this.length = 1;
            return this;
        }

        // Handle HTML strings
        if ( typeof selector === "string" ) {
            if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
                // Assume that strings that start and end with <> are HTML and skip the regex check
                match = [ null, selector, null ];

            } else {
                match = rquickExpr.exec( selector );
            }

            // Match html or make sure no context is specified for #id
            if ( match && (match[1] || !context) ) {

                // HANDLE: $(html) -> $(array)
                if ( match[1] ) {
                    context = context instanceof jQuery ? context[0] : context;
                    doc = ( context && context.nodeType ? context.ownerDocument || context : document );

                    // scripts is true for back-compat
                    selector = jQuery.parseHTML( match[1], doc, true );
                    if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
                        this.attr.call( selector, context, true );
                    }

                    return jQuery.merge( this, selector );

                // HANDLE: $(#id)
                } else {
                    elem = document.getElementById( match[2] );

                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document #6963
                    if ( elem && elem.parentNode ) {
                        // Handle the case where IE and Opera return items
                        // by name instead of ID
                        if ( elem.id !== match[2] ) {
                            return rootjQuery.find( selector );
                        }

                        // Otherwise, we inject the element directly into the jQuery object
                        this.length = 1;
                        this[0] = elem;
                    }

                    this.context = document;
                    this.selector = selector;
                    return this;
                }

            // HANDLE: $(expr, $(...))
            } else if ( !context || context.jquery ) {
                return ( context || rootjQuery ).find( selector );

            // HANDLE: $(expr, context)
            // (which is just equivalent to: $(context).find(expr)
            } else {
                return this.constructor( context ).find( selector );
            }

        // HANDLE: $(function)
        // Shortcut for document ready
        } else if ( jQuery.isFunction( selector ) ) {
            return rootjQuery.ready( selector );
        }

        if ( selector.selector !== undefined ) {
            this.selector = selector.selector;
            this.context = selector.context;
        }

        return jQuery.makeArray( selector, this );
    },

    // Start with an empty selector
    selector: "",

    // The current version of jQuery being used
    jquery: "1.8.3",

    // The default length of a jQuery object is 0
    length: 0,

    // The number of elements contained in the matched element set
    size: function() {
        return this.length;
    },

    toArray: function() {
        return core_slice.call( this );
    },

    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function( num ) {
        return num == null ?

            // Return a 'clean' array
            this.toArray() :

            // Return just the object
            ( num < 0 ? this[ this.length + num ] : this[ num ] );
    },

    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function( elems, name, selector ) {

        // Build a new jQuery matched element set
        var ret = jQuery.merge( this.constructor(), elems );

        // Add the old object onto the stack (as a reference)
        ret.prevObject = this;

        ret.context = this.context;

        if ( name === "find" ) {
            ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
        } else if ( name ) {
            ret.selector = this.selector + "." + name + "(" + selector + ")";
        }

        // Return the newly-formed element set
        return ret;
    },

    // Execute a callback for every element in the matched set.
    // (You can seed the arguments with an array of args, but this is
    // only used internally.)
    each: function( callback, args ) {
        return jQuery.each( this, callback, args );
    },

    ready: function( fn ) {
        // Add the callback
        jQuery.ready.promise().done( fn );

        return this;
    },

    eq: function( i ) {
        i = +i;
        return i === -1 ?
            this.slice( i ) :
            this.slice( i, i + 1 );
    },

    first: function() {
        return this.eq( 0 );
    },

    last: function() {
        return this.eq( -1 );
    },

    slice: function() {
        return this.pushStack( core_slice.apply( this, arguments ),
            "slice", core_slice.call(arguments).join(",") );
    },

    map: function( callback ) {
        return this.pushStack( jQuery.map(this, function( elem, i ) {
            return callback.call( elem, i, elem );
        }));
    },

    end: function() {
        return this.prevObject || this.constructor(null);
    },

    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: core_push,
    sort: [].sort,
    splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
    var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    // Handle a deep copy situation
    if ( typeof target === "boolean" ) {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
    }

    // Handle case when target is a string or something (possible in deep copy)
    if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
        target = {};
    }

    // extend jQuery itself if only one argument is passed
    if ( length === i ) {
        target = this;
        --i;
    }

    for ( ; i < length; i++ ) {
        // Only deal with non-null/undefined values
        if ( (options = arguments[ i ]) != null ) {
            // Extend the base object
            for ( name in options ) {
                src = target[ name ];
                copy = options[ name ];

                // Prevent never-ending loop
                if ( target === copy ) {
                    continue;
                }

                // Recurse if we're merging plain objects or arrays
                if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                    if ( copyIsArray ) {
                        copyIsArray = false;
                        clone = src && jQuery.isArray(src) ? src : [];

                    } else {
                        clone = src && jQuery.isPlainObject(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[ name ] = jQuery.extend( deep, clone, copy );

                // Don't bring in undefined values
                } else if ( copy !== undefined ) {
                    target[ name ] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
};

jQuery.extend({
    noConflict: function( deep ) {
        if ( window.$ === jQuery ) {
            window.$ = _$;
        }

        if ( deep && window.jQuery === jQuery ) {
            window.jQuery = _jQuery;
        }

        return jQuery;
    },

    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,

    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,

    // Hold (or release) the ready event
    holdReady: function( hold ) {
        if ( hold ) {
            jQuery.readyWait++;
        } else {
            jQuery.ready( true );
        }
    },

    // Handle when the DOM is ready
    ready: function( wait ) {

        // Abort if there are pending holds or we're already ready
        if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
            return;
        }

        // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
        if ( !document.body ) {
            return setTimeout( jQuery.ready, 1 );
        }

        // Remember that the DOM is ready
        jQuery.isReady = true;

        // If a normal DOM Ready event fired, decrement, and wait if need be
        if ( wait !== true && --jQuery.readyWait > 0 ) {
            return;
        }

        // If there are functions bound, to execute
        readyList.resolveWith( document, [ jQuery ] );

        // Trigger any bound ready events
        if ( jQuery.fn.trigger ) {
            jQuery( document ).trigger("ready").off("ready");
        }
    },

    // See test/unit/core.js for details concerning isFunction.
    // Since version 1.3, DOM methods and functions like alert
    // aren't supported. They return false on IE (#2968).
    isFunction: function( obj ) {
        return jQuery.type(obj) === "function";
    },

    isArray: Array.isArray || function( obj ) {
        return jQuery.type(obj) === "array";
    },

    isWindow: function( obj ) {
        return obj != null && obj == obj.window;
    },

    isNumeric: function( obj ) {
        return !isNaN( parseFloat(obj) ) && isFinite( obj );
    },

    type: function( obj ) {
        return obj == null ?
            String( obj ) :
            class2type[ core_toString.call(obj) ] || "object";
    },

    isPlainObject: function( obj ) {
        // Must be an Object.
        // Because of IE, we also have to check the presence of the constructor property.
        // Make sure that DOM nodes and window objects don't pass through, as well
        if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
            return false;
        }

        try {
            // Not own constructor property must be Object
            if ( obj.constructor &&
                !core_hasOwn.call(obj, "constructor") &&
                !core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
                return false;
            }
        } catch ( e ) {
            // IE8,9 Will throw exceptions on certain host objects #9897
            return false;
        }

        // Own properties are enumerated firstly, so to speed up,
        // if last one is own, then all properties are own.

        var key;
        for ( key in obj ) {}

        return key === undefined || core_hasOwn.call( obj, key );
    },

    isEmptyObject: function( obj ) {
        var name;
        for ( name in obj ) {
            return false;
        }
        return true;
    },

    error: function( msg ) {
        throw new Error( msg );
    },

    // data: string of html
    // context (optional): If specified, the fragment will be created in this context, defaults to document
    // scripts (optional): If true, will include scripts passed in the html string
    parseHTML: function( data, context, scripts ) {
        var parsed;
        if ( !data || typeof data !== "string" ) {
            return null;
        }
        if ( typeof context === "boolean" ) {
            scripts = context;
            context = 0;
        }
        context = context || document;

        // Single tag
        if ( (parsed = rsingleTag.exec( data )) ) {
            return [ context.createElement( parsed[1] ) ];
        }

        parsed = jQuery.buildFragment( [ data ], context, scripts ? null : [] );
        return jQuery.merge( [],
            (parsed.cacheable ? jQuery.clone( parsed.fragment ) : parsed.fragment).childNodes );
    },

    parseJSON: function( data ) {
        if ( !data || typeof data !== "string") {
            return null;
        }

        // Make sure leading/trailing whitespace is removed (IE can't handle it)
        data = jQuery.trim( data );

        // Attempt to parse using the native JSON parser first
        if ( window.JSON && window.JSON.parse ) {
            return window.JSON.parse( data );
        }

        // Make sure the incoming data is actual JSON
        // Logic borrowed from http://json.org/json2.js
        if ( rvalidchars.test( data.replace( rvalidescape, "@" )
            .replace( rvalidtokens, "]" )
            .replace( rvalidbraces, "")) ) {

            return ( new Function( "return " + data ) )();

        }
        jQuery.error( "Invalid JSON: " + data );
    },

    // Cross-browser xml parsing
    parseXML: function( data ) {
        var xml, tmp;
        if ( !data || typeof data !== "string" ) {
            return null;
        }
        try {
            if ( window.DOMParser ) { // Standard
                tmp = new DOMParser();
                xml = tmp.parseFromString( data , "text/xml" );
            } else { // IE
                xml = new ActiveXObject( "Microsoft.XMLDOM" );
                xml.async = "false";
                xml.loadXML( data );
            }
        } catch( e ) {
            xml = undefined;
        }
        if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
            jQuery.error( "Invalid XML: " + data );
        }
        return xml;
    },

    noop: function() {},

    // Evaluates a script in a global context
    // Workarounds based on findings by Jim Driscoll
    // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
    globalEval: function( data ) {
        if ( data && core_rnotwhite.test( data ) ) {
            // We use execScript on Internet Explorer
            // We use an anonymous function so that context is window
            // rather than jQuery in Firefox
            ( window.execScript || function( data ) {
                window[ "eval" ].call( window, data );
            } )( data );
        }
    },

    // Convert dashed to camelCase; used by the css and data modules
    // Microsoft forgot to hump their vendor prefix (#9572)
    camelCase: function( string ) {
        return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
    },

    nodeName: function( elem, name ) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },

    // args is for internal usage only
    each: function( obj, callback, args ) {
        var name,
            i = 0,
            length = obj.length,
            isObj = length === undefined || jQuery.isFunction( obj );

        if ( args ) {
            if ( isObj ) {
                for ( name in obj ) {
                    if ( callback.apply( obj[ name ], args ) === false ) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if ( callback.apply( obj[ i++ ], args ) === false ) {
                        break;
                    }
                }
            }

        // A special, fast, case for the most common use of each
        } else {
            if ( isObj ) {
                for ( name in obj ) {
                    if ( callback.call( obj[ name ], name, obj[ name ] ) === false ) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if ( callback.call( obj[ i ], i, obj[ i++ ] ) === false ) {
                        break;
                    }
                }
            }
        }

        return obj;
    },

    // Use native String.trim function wherever possible
    trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
        function( text ) {
            return text == null ?
                "" :
                core_trim.call( text );
        } :

        // Otherwise use our own trimming functionality
        function( text ) {
            return text == null ?
                "" :
                ( text + "" ).replace( rtrim, "" );
        },

    // results is for internal usage only
    makeArray: function( arr, results ) {
        var type,
            ret = results || [];

        if ( arr != null ) {
            // The window, strings (and functions) also have 'length'
            // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
            type = jQuery.type( arr );

            if ( arr.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( arr ) ) {
                core_push.call( ret, arr );
            } else {
                jQuery.merge( ret, arr );
            }
        }

        return ret;
    },

    inArray: function( elem, arr, i ) {
        var len;

        if ( arr ) {
            if ( core_indexOf ) {
                return core_indexOf.call( arr, elem, i );
            }

            len = arr.length;
            i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

            for ( ; i < len; i++ ) {
                // Skip accessing in sparse arrays
                if ( i in arr && arr[ i ] === elem ) {
                    return i;
                }
            }
        }

        return -1;
    },

    merge: function( first, second ) {
        var l = second.length,
            i = first.length,
            j = 0;

        if ( typeof l === "number" ) {
            for ( ; j < l; j++ ) {
                first[ i++ ] = second[ j ];
            }

        } else {
            while ( second[j] !== undefined ) {
                first[ i++ ] = second[ j++ ];
            }
        }

        first.length = i;

        return first;
    },

    grep: function( elems, callback, inv ) {
        var retVal,
            ret = [],
            i = 0,
            length = elems.length;
        inv = !!inv;

        // Go through the array, only saving the items
        // that pass the validator function
        for ( ; i < length; i++ ) {
            retVal = !!callback( elems[ i ], i );
            if ( inv !== retVal ) {
                ret.push( elems[ i ] );
            }
        }

        return ret;
    },

    // arg is for internal usage only
    map: function( elems, callback, arg ) {
        var value, key,
            ret = [],
            i = 0,
            length = elems.length,
            // jquery objects are treated as arrays
            isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

        // Go through the array, translating each of the items to their
        if ( isArray ) {
            for ( ; i < length; i++ ) {
                value = callback( elems[ i ], i, arg );

                if ( value != null ) {
                    ret[ ret.length ] = value;
                }
            }

        // Go through every key on the object,
        } else {
            for ( key in elems ) {
                value = callback( elems[ key ], key, arg );

                if ( value != null ) {
                    ret[ ret.length ] = value;
                }
            }
        }

        // Flatten any nested arrays
        return ret.concat.apply( [], ret );
    },

    // A global GUID counter for objects
    guid: 1,

    // Bind a function to a context, optionally partially applying any
    // arguments.
    proxy: function( fn, context ) {
        var tmp, args, proxy;

        if ( typeof context === "string" ) {
            tmp = fn[ context ];
            context = fn;
            fn = tmp;
        }

        // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.
        if ( !jQuery.isFunction( fn ) ) {
            return undefined;
        }

        // Simulated bind
        args = core_slice.call( arguments, 2 );
        proxy = function() {
            return fn.apply( context, args.concat( core_slice.call( arguments ) ) );
        };

        // Set the guid of unique handler to the same of original handler, so it can be removed
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;

        return proxy;
    },

    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
        var exec,
            bulk = key == null,
            i = 0,
            length = elems.length;

        // Sets many values
        if ( key && typeof key === "object" ) {
            for ( i in key ) {
                jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
            }
            chainable = 1;

        // Sets one value
        } else if ( value !== undefined ) {
            // Optionally, function values get executed if exec is true
            exec = pass === undefined && jQuery.isFunction( value );

            if ( bulk ) {
                // Bulk operations only iterate when executing function values
                if ( exec ) {
                    exec = fn;
                    fn = function( elem, key, value ) {
                        return exec.call( jQuery( elem ), value );
                    };

                // Otherwise they run against the entire set
                } else {
                    fn.call( elems, value );
                    fn = null;
                }
            }

            if ( fn ) {
                for (; i < length; i++ ) {
                    fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
                }
            }

            chainable = 1;
        }

        return chainable ?
            elems :

            // Gets
            bulk ?
                fn.call( elems ) :
                length ? fn( elems[0], key ) : emptyGet;
    },

    now: function() {
        return ( new Date() ).getTime();
    }
});

jQuery.ready.promise = function( obj ) {
    if ( !readyList ) {

        readyList = jQuery.Deferred();

        // Catch cases where $(document).ready() is called after the browser event has already occurred.
        // we once tried to use readyState "interactive" here, but it caused issues like the one
        // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
        if ( document.readyState === "complete" ) {
            // Handle it asynchronously to allow scripts the opportunity to delay ready
            setTimeout( jQuery.ready, 1 );

        // Standards-based browsers support DOMContentLoaded
        } else if ( document.addEventListener ) {
            // Use the handy event callback
            document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

            // A fallback to window.onload, that will always work
            window.addEventListener( "load", jQuery.ready, false );

        // If IE event model is used
        } else {
            // Ensure firing before onload, maybe late but safe also for iframes
            document.attachEvent( "onreadystatechange", DOMContentLoaded );

            // A fallback to window.onload, that will always work
            window.attachEvent( "onload", jQuery.ready );

            // If IE and not a frame
            // continually check to see if the document is ready
            var top = false;

            try {
                top = window.frameElement == null && document.documentElement;
            } catch(e) {}

            if ( top && top.doScroll ) {
                (function doScrollCheck() {
                    if ( !jQuery.isReady ) {

                        try {
                            // Use the trick by Diego Perini
                            // http://javascript.nwbox.com/IEContentLoaded/
                            top.doScroll("left");
                        } catch(e) {
                            return setTimeout( doScrollCheck, 50 );
                        }

                        // and execute any waiting functions
                        jQuery.ready();
                    }
                })();
            }
        }
    }
    return readyList.promise( obj );
};

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
    class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

// All jQuery objects should point back to these
rootjQuery = jQuery(document);
// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
    var object = optionsCache[ options ] = {};
    jQuery.each( options.split( core_rspace ), function( _, flag ) {
        object[ flag ] = true;
    });
    return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *  options: an optional list of space-separated options that will change how
 *          the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *  once:           will ensure the callback list can only be fired once (like a Deferred)
 *
 *  memory:         will keep track of previous values and will call any callback added
 *                  after the list has been fired right away with the latest "memorized"
 *                  values (like a Deferred)
 *
 *  unique:         will ensure a callback can only be added once (no duplicate in the list)
 *
 *  stopOnFalse:    interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ?
        ( optionsCache[ options ] || createOptions( options ) ) :
        jQuery.extend( {}, options );

    var // Last fire value (for non-forgettable lists)
        memory,
        // Flag to know if list was already fired
        fired,
        // Flag to know if list is currently firing
        firing,
        // First callback to fire (used internally by add and fireWith)
        firingStart,
        // End of the loop when firing
        firingLength,
        // Index of currently firing callback (modified by remove if needed)
        firingIndex,
        // Actual callback list
        list = [],
        // Stack of fire calls for repeatable lists
        stack = !options.once && [],
        // Fire callbacks
        fire = function( data ) {
            memory = options.memory && data;
            fired = true;
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list.length;
            firing = true;
            for ( ; list && firingIndex < firingLength; firingIndex++ ) {
                if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
                    memory = false; // To prevent further calls using add
                    break;
                }
            }
            firing = false;
            if ( list ) {
                if ( stack ) {
                    if ( stack.length ) {
                        fire( stack.shift() );
                    }
                } else if ( memory ) {
                    list = [];
                } else {
                    self.disable();
                }
            }
        },
        // Actual Callbacks object
        self = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
                if ( list ) {
                    // First, we save the current length
                    var start = list.length;
                    (function add( args ) {
                        jQuery.each( args, function( _, arg ) {
                            var type = jQuery.type( arg );
                            if ( type === "function" ) {
                                if ( !options.unique || !self.has( arg ) ) {
                                    list.push( arg );
                                }
                            } else if ( arg && arg.length && type !== "string" ) {
                                // Inspect recursively
                                add( arg );
                            }
                        });
                    })( arguments );
                    // Do we need to add the callbacks to the
                    // current firing batch?
                    if ( firing ) {
                        firingLength = list.length;
                    // With memory, if we're not firing then
                    // we should call right away
                    } else if ( memory ) {
                        firingStart = start;
                        fire( memory );
                    }
                }
                return this;
            },
            // Remove a callback from the list
            remove: function() {
                if ( list ) {
                    jQuery.each( arguments, function( _, arg ) {
                        var index;
                        while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
                            list.splice( index, 1 );
                            // Handle firing indexes
                            if ( firing ) {
                                if ( index <= firingLength ) {
                                    firingLength--;
                                }
                                if ( index <= firingIndex ) {
                                    firingIndex--;
                                }
                            }
                        }
                    });
                }
                return this;
            },
            // Control if a given callback is in the list
            has: function( fn ) {
                return jQuery.inArray( fn, list ) > -1;
            },
            // Remove all callbacks from the list
            empty: function() {
                list = [];
                return this;
            },
            // Have the list do nothing anymore
            disable: function() {
                list = stack = memory = undefined;
                return this;
            },
            // Is it disabled?
            disabled: function() {
                return !list;
            },
            // Lock the list in its current state
            lock: function() {
                stack = undefined;
                if ( !memory ) {
                    self.disable();
                }
                return this;
            },
            // Is it locked?
            locked: function() {
                return !stack;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function( context, args ) {
                args = args || [];
                args = [ context, args.slice ? args.slice() : args ];
                if ( list && ( !fired || stack ) ) {
                    if ( firing ) {
                        stack.push( args );
                    } else {
                        fire( args );
                    }
                }
                return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
                self.fireWith( this, arguments );
                return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
                return !!fired;
            }
        };

    return self;
};
jQuery.extend({

    Deferred: function( func ) {
        var tuples = [
                // action, add listener, listener list, final state
                [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
                [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
                [ "notify", "progress", jQuery.Callbacks("memory") ]
            ],
            state = "pending",
            promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred.done( arguments ).fail( arguments );
                    return this;
                },
                then: function( /* fnDone, fnFail, fnProgress */ ) {
                    var fns = arguments;
                    return jQuery.Deferred(function( newDefer ) {
                        jQuery.each( tuples, function( i, tuple ) {
                            var action = tuple[ 0 ],
                                fn = fns[ i ];
                            // deferred[ done | fail | progress ] for forwarding actions to newDefer
                            deferred[ tuple[1] ]( jQuery.isFunction( fn ) ?
                                function() {
                                    var returned = fn.apply( this, arguments );
                                    if ( returned && jQuery.isFunction( returned.promise ) ) {
                                        returned.promise()
                                            .done( newDefer.resolve )
                                            .fail( newDefer.reject )
                                            .progress( newDefer.notify );
                                    } else {
                                        newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
                                    }
                                } :
                                newDefer[ action ]
                            );
                        });
                        fns = null;
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function( obj ) {
                    return obj != null ? jQuery.extend( obj, promise ) : promise;
                }
            },
            deferred = {};

        // Keep pipe for back-compat
        promise.pipe = promise.then;

        // Add list-specific methods
        jQuery.each( tuples, function( i, tuple ) {
            var list = tuple[ 2 ],
                stateString = tuple[ 3 ];

            // promise[ done | fail | progress ] = list.add
            promise[ tuple[1] ] = list.add;

            // Handle state
            if ( stateString ) {
                list.add(function() {
                    // state = [ resolved | rejected ]
                    state = stateString;

                // [ reject_list | resolve_list ].disable; progress_list.lock
                }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
            }

            // deferred[ resolve | reject | notify ] = list.fire
            deferred[ tuple[0] ] = list.fire;
            deferred[ tuple[0] + "With" ] = list.fireWith;
        });

        // Make the deferred a promise
        promise.promise( deferred );

        // Call given func if any
        if ( func ) {
            func.call( deferred, deferred );
        }

        // All done!
        return deferred;
    },

    // Deferred helper
    when: function( subordinate /* , ..., subordinateN */ ) {
        var i = 0,
            resolveValues = core_slice.call( arguments ),
            length = resolveValues.length,

            // the count of uncompleted subordinates
            remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

            // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
            deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

            // Update function for both resolve and progress values
            updateFunc = function( i, contexts, values ) {
                return function( value ) {
                    contexts[ i ] = this;
                    values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
                    if( values === progressValues ) {
                        deferred.notifyWith( contexts, values );
                    } else if ( !( --remaining ) ) {
                        deferred.resolveWith( contexts, values );
                    }
                };
            },

            progressValues, progressContexts, resolveContexts;

        // add listeners to Deferred subordinates; treat others as resolved
        if ( length > 1 ) {
            progressValues = new Array( length );
            progressContexts = new Array( length );
            resolveContexts = new Array( length );
            for ( ; i < length; i++ ) {
                if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                    resolveValues[ i ].promise()
                        .done( updateFunc( i, resolveContexts, resolveValues ) )
                        .fail( deferred.reject )
                        .progress( updateFunc( i, progressContexts, progressValues ) );
                } else {
                    --remaining;
                }
            }
        }

        // if we're not waiting on anything, resolve the master
        if ( !remaining ) {
            deferred.resolveWith( resolveContexts, resolveValues );
        }

        return deferred.promise();
    }
});
jQuery.support = (function() {

    var support,
        all,
        a,
        select,
        opt,
        input,
        fragment,
        eventName,
        i,
        isSupported,
        clickFn,
        div = document.createElement("div");

    // Setup
    div.setAttribute( "className", "t" );
    div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

    // Support tests won't run in some limited or non-browser environments
    all = div.getElementsByTagName("*");
    a = div.getElementsByTagName("a")[ 0 ];
    if ( !all || !a || !all.length ) {
        return {};
    }

    // First batch of tests
    select = document.createElement("select");
    opt = select.appendChild( document.createElement("option") );
    input = div.getElementsByTagName("input")[ 0 ];

    a.style.cssText = "top:1px;float:left;opacity:.5";
    support = {
        // IE strips leading whitespace when .innerHTML is used
        leadingWhitespace: ( div.firstChild.nodeType === 3 ),

        // Make sure that tbody elements aren't automatically inserted
        // IE will insert them into empty tables
        tbody: !div.getElementsByTagName("tbody").length,

        // Make sure that link elements get serialized correctly by innerHTML
        // This requires a wrapper element in IE
        htmlSerialize: !!div.getElementsByTagName("link").length,

        // Get the style information from getAttribute
        // (IE uses .cssText instead)
        style: /top/.test( a.getAttribute("style") ),

        // Make sure that URLs aren't manipulated
        // (IE normalizes it by default)
        hrefNormalized: ( a.getAttribute("href") === "/a" ),

        // Make sure that element opacity exists
        // (IE uses filter instead)
        // Use a regex to work around a WebKit issue. See #5145
        opacity: /^0.5/.test( a.style.opacity ),

        // Verify style float existence
        // (IE uses styleFloat instead of cssFloat)
        cssFloat: !!a.style.cssFloat,

        // Make sure that if no value is specified for a checkbox
        // that it defaults to "on".
        // (WebKit defaults to "" instead)
        checkOn: ( input.value === "on" ),

        // Make sure that a selected-by-default option has a working selected property.
        // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
        optSelected: opt.selected,

        // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
        getSetAttribute: div.className !== "t",

        // Tests for enctype support on a form (#6743)
        enctype: !!document.createElement("form").enctype,

        // Makes sure cloning an html5 element does not cause problems
        // Where outerHTML is undefined, this still works
        html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

        // jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
        boxModel: ( document.compatMode === "CSS1Compat" ),

        // Will be defined later
        submitBubbles: true,
        changeBubbles: true,
        focusinBubbles: false,
        deleteExpando: true,
        noCloneEvent: true,
        inlineBlockNeedsLayout: false,
        shrinkWrapBlocks: false,
        reliableMarginRight: true,
        boxSizingReliable: true,
        pixelPosition: false
    };

    // Make sure checked status is properly cloned
    input.checked = true;
    support.noCloneChecked = input.cloneNode( true ).checked;

    // Make sure that the options inside disabled selects aren't marked as disabled
    // (WebKit marks them as disabled)
    select.disabled = true;
    support.optDisabled = !opt.disabled;

    // Test to see if it's possible to delete an expando from an element
    // Fails in Internet Explorer
    try {
        delete div.test;
    } catch( e ) {
        support.deleteExpando = false;
    }

    if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
        div.attachEvent( "onclick", clickFn = function() {
            // Cloning a node shouldn't copy over any
            // bound event handlers (IE does this)
            support.noCloneEvent = false;
        });
        div.cloneNode( true ).fireEvent("onclick");
        div.detachEvent( "onclick", clickFn );
    }

    // Check if a radio maintains its value
    // after being appended to the DOM
    input = document.createElement("input");
    input.value = "t";
    input.setAttribute( "type", "radio" );
    support.radioValue = input.value === "t";

    input.setAttribute( "checked", "checked" );

    // #11217 - WebKit loses check when the name is after the checked attribute
    input.setAttribute( "name", "t" );

    div.appendChild( input );
    fragment = document.createDocumentFragment();
    fragment.appendChild( div.lastChild );

    // WebKit doesn't clone checked state correctly in fragments
    support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

    // Check if a disconnected checkbox will retain its checked
    // value of true after appended to the DOM (IE6/7)
    support.appendChecked = input.checked;

    fragment.removeChild( input );
    fragment.appendChild( div );

    // Technique from Juriy Zaytsev
    // http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
    // We only care about the case where non-standard event systems
    // are used, namely in IE. Short-circuiting here helps us to
    // avoid an eval call (in setAttribute) which can cause CSP
    // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
    if ( div.attachEvent ) {
        for ( i in {
            submit: true,
            change: true,
            focusin: true
        }) {
            eventName = "on" + i;
            isSupported = ( eventName in div );
            if ( !isSupported ) {
                div.setAttribute( eventName, "return;" );
                isSupported = ( typeof div[ eventName ] === "function" );
            }
            support[ i + "Bubbles" ] = isSupported;
        }
    }

    // Run tests that need a body at doc ready
    jQuery(function() {
        var container, div, tds, marginDiv,
            divReset = "padding:0;margin:0;border:0;display:block;overflow:hidden;",
            body = document.getElementsByTagName("body")[0];

        if ( !body ) {
            // Return for frameset docs that don't have a body
            return;
        }

        container = document.createElement("div");
        container.style.cssText = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px";
        body.insertBefore( container, body.firstChild );

        // Construct the test element
        div = document.createElement("div");
        container.appendChild( div );

        // Check if table cells still have offsetWidth/Height when they are set
        // to display:none and there are still other visible table cells in a
        // table row; if so, offsetWidth/Height are not reliable for use when
        // determining if an element has been hidden directly using
        // display:none (it is still safe to use offsets if a parent element is
        // hidden; don safety goggles and see bug #4512 for more information).
        // (only IE 8 fails this test)
        div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
        tds = div.getElementsByTagName("td");
        tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
        isSupported = ( tds[ 0 ].offsetHeight === 0 );

        tds[ 0 ].style.display = "";
        tds[ 1 ].style.display = "none";

        // Check if empty table cells still have offsetWidth/Height
        // (IE <= 8 fail this test)
        support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

        // Check box-sizing and margin behavior
        div.innerHTML = "";
        div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
        support.boxSizing = ( div.offsetWidth === 4 );
        support.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );

        // NOTE: To any future maintainer, we've window.getComputedStyle
        // because jsdom on node.js will break without it.
        if ( window.getComputedStyle ) {
            support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
            support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

            // Check if div with explicit width and no margin-right incorrectly
            // gets computed margin-right based on width of container. For more
            // info see bug #3333
            // Fails in WebKit before Feb 2011 nightlies
            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
            marginDiv = document.createElement("div");
            marginDiv.style.cssText = div.style.cssText = divReset;
            marginDiv.style.marginRight = marginDiv.style.width = "0";
            div.style.width = "1px";
            div.appendChild( marginDiv );
            support.reliableMarginRight =
                !parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
        }

        if ( typeof div.style.zoom !== "undefined" ) {
            // Check if natively block-level elements act like inline-block
            // elements when setting their display to 'inline' and giving
            // them layout
            // (IE < 8 does this)
            div.innerHTML = "";
            div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
            support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

            // Check if elements with layout shrink-wrap their children
            // (IE 6 does this)
            div.style.display = "block";
            div.style.overflow = "visible";
            div.innerHTML = "<div></div>";
            div.firstChild.style.width = "5px";
            support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );

            container.style.zoom = 1;
        }

        // Null elements to avoid leaks in IE
        body.removeChild( container );
        container = div = tds = marginDiv = null;
    });

    // Null elements to avoid leaks in IE
    fragment.removeChild( div );
    all = a = select = opt = input = fragment = div = null;

    return support;
})();
var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
    rmultiDash = /([A-Z])/g;

jQuery.extend({
    cache: {},

    deletedIds: [],

    // Remove at next major release (1.9/2.0)
    uuid: 0,

    // Unique for each copy of jQuery on the page
    // Non-digits removed to match rinlinejQuery
    expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

    // The following elements throw uncatchable exceptions if you
    // attempt to add expando properties to them.
    noData: {
        "embed": true,
        // Ban all objects except for Flash (which handle expandos)
        "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
        "applet": true
    },

    hasData: function( elem ) {
        elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
        return !!elem && !isEmptyDataObject( elem );
    },

    data: function( elem, name, data, pvt /* Internal Use Only */ ) {
        if ( !jQuery.acceptData( elem ) ) {
            return;
        }

        var thisCache, ret,
            internalKey = jQuery.expando,
            getByName = typeof name === "string",

            // We have to handle DOM nodes and JS objects differently because IE6-7
            // can't GC object references properly across the DOM-JS boundary
            isNode = elem.nodeType,

            // Only DOM nodes need the global jQuery cache; JS object data is
            // attached directly to the object so GC can occur automatically
            cache = isNode ? jQuery.cache : elem,

            // Only defining an ID for JS objects if its cache already exists allows
            // the code to shortcut on the same path as a DOM node with no cache
            id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

        // Avoid doing any more work than we need to when trying to get data on an
        // object that has no data at all
        if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined ) {
            return;
        }

        if ( !id ) {
            // Only DOM nodes need a new unique ID for each element since their data
            // ends up in the global cache
            if ( isNode ) {
                elem[ internalKey ] = id = jQuery.deletedIds.pop() || jQuery.guid++;
            } else {
                id = internalKey;
            }
        }

        if ( !cache[ id ] ) {
            cache[ id ] = {};

            // Avoids exposing jQuery metadata on plain JS objects when the object
            // is serialized using JSON.stringify
            if ( !isNode ) {
                cache[ id ].toJSON = jQuery.noop;
            }
        }

        // An object can be passed to jQuery.data instead of a key/value pair; this gets
        // shallow copied over onto the existing cache
        if ( typeof name === "object" || typeof name === "function" ) {
            if ( pvt ) {
                cache[ id ] = jQuery.extend( cache[ id ], name );
            } else {
                cache[ id ].data = jQuery.extend( cache[ id ].data, name );
            }
        }

        thisCache = cache[ id ];

        // jQuery data() is stored in a separate object inside the object's internal data
        // cache in order to avoid key collisions between internal data and user-defined
        // data.
        if ( !pvt ) {
            if ( !thisCache.data ) {
                thisCache.data = {};
            }

            thisCache = thisCache.data;
        }

        if ( data !== undefined ) {
            thisCache[ jQuery.camelCase( name ) ] = data;
        }

        // Check for both converted-to-camel and non-converted data property names
        // If a data property was specified
        if ( getByName ) {

            // First Try to find as-is property data
            ret = thisCache[ name ];

            // Test for null|undefined property data
            if ( ret == null ) {

                // Try to find the camelCased property
                ret = thisCache[ jQuery.camelCase( name ) ];
            }
        } else {
            ret = thisCache;
        }

        return ret;
    },

    removeData: function( elem, name, pvt /* Internal Use Only */ ) {
        if ( !jQuery.acceptData( elem ) ) {
            return;
        }

        var thisCache, i, l,

            isNode = elem.nodeType,

            // See jQuery.data for more information
            cache = isNode ? jQuery.cache : elem,
            id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

        // If there is already no cache entry for this object, there is no
        // purpose in continuing
        if ( !cache[ id ] ) {
            return;
        }

        if ( name ) {

            thisCache = pvt ? cache[ id ] : cache[ id ].data;

            if ( thisCache ) {

                // Support array or space separated string names for data keys
                if ( !jQuery.isArray( name ) ) {

                    // try the string as a key before any manipulation
                    if ( name in thisCache ) {
                        name = [ name ];
                    } else {

                        // split the camel cased version by spaces unless a key with the spaces exists
                        name = jQuery.camelCase( name );
                        if ( name in thisCache ) {
                            name = [ name ];
                        } else {
                            name = name.split(" ");
                        }
                    }
                }

                for ( i = 0, l = name.length; i < l; i++ ) {
                    delete thisCache[ name[i] ];
                }

                // If there is no data left in the cache, we want to continue
                // and let the cache object itself get destroyed
                if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
                    return;
                }
            }
        }

        // See jQuery.data for more information
        if ( !pvt ) {
            delete cache[ id ].data;

            // Don't destroy the parent cache unless the internal data object
            // had been the only thing left in it
            if ( !isEmptyDataObject( cache[ id ] ) ) {
                return;
            }
        }

        // Destroy the cache
        if ( isNode ) {
            jQuery.cleanData( [ elem ], true );

        // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
        } else if ( jQuery.support.deleteExpando || cache != cache.window ) {
            delete cache[ id ];

        // When all else fails, null
        } else {
            cache[ id ] = null;
        }
    },

    // For internal use only.
    _data: function( elem, name, data ) {
        return jQuery.data( elem, name, data, true );
    },

    // A method for determining if a DOM node can handle the data expando
    acceptData: function( elem ) {
        var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];

        // nodes accept data unless otherwise specified; rejection can be conditional
        return !noData || noData !== true && elem.getAttribute("classid") === noData;
    }
});

jQuery.fn.extend({
    data: function( key, value ) {
        var parts, part, attr, name, l,
            elem = this[0],
            i = 0,
            data = null;

        // Gets all values
        if ( key === undefined ) {
            if ( this.length ) {
                data = jQuery.data( elem );

                if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
                    attr = elem.attributes;
                    for ( l = attr.length; i < l; i++ ) {
                        name = attr[i].name;

                        if ( !name.indexOf( "data-" ) ) {
                            name = jQuery.camelCase( name.substring(5) );

                            dataAttr( elem, name, data[ name ] );
                        }
                    }
                    jQuery._data( elem, "parsedAttrs", true );
                }
            }

            return data;
        }

        // Sets multiple values
        if ( typeof key === "object" ) {
            return this.each(function() {
                jQuery.data( this, key );
            });
        }

        parts = key.split( ".", 2 );
        parts[1] = parts[1] ? "." + parts[1] : "";
        part = parts[1] + "!";

        return jQuery.access( this, function( value ) {

            if ( value === undefined ) {
                data = this.triggerHandler( "getData" + part, [ parts[0] ] );

                // Try to fetch any internally stored data first
                if ( data === undefined && elem ) {
                    data = jQuery.data( elem, key );
                    data = dataAttr( elem, key, data );
                }

                return data === undefined && parts[1] ?
                    this.data( parts[0] ) :
                    data;
            }

            parts[1] = value;
            this.each(function() {
                var self = jQuery( this );

                self.triggerHandler( "setData" + part, parts );
                jQuery.data( this, key, value );
                self.triggerHandler( "changeData" + part, parts );
            });
        }, null, value, arguments.length > 1, null, false );
    },

    removeData: function( key ) {
        return this.each(function() {
            jQuery.removeData( this, key );
        });
    }
});

function dataAttr( elem, key, data ) {
    // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute
    if ( data === undefined && elem.nodeType === 1 ) {

        var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

        data = elem.getAttribute( name );

        if ( typeof data === "string" ) {
            try {
                data = data === "true" ? true :
                data === "false" ? false :
                data === "null" ? null :
                // Only convert to a number if it doesn't change the string
                +data + "" === data ? +data :
                rbrace.test( data ) ? jQuery.parseJSON( data ) :
                    data;
            } catch( e ) {}

            // Make sure we set the data so it isn't changed later
            jQuery.data( elem, key, data );

        } else {
            data = undefined;
        }
    }

    return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
    var name;
    for ( name in obj ) {

        // if the public data object is empty, the private is still empty
        if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
            continue;
        }
        if ( name !== "toJSON" ) {
            return false;
        }
    }

    return true;
}
jQuery.extend({
    queue: function( elem, type, data ) {
        var queue;

        if ( elem ) {
            type = ( type || "fx" ) + "queue";
            queue = jQuery._data( elem, type );

            // Speed up dequeue by getting out quickly if this is just a lookup
            if ( data ) {
                if ( !queue || jQuery.isArray(data) ) {
                    queue = jQuery._data( elem, type, jQuery.makeArray(data) );
                } else {
                    queue.push( data );
                }
            }
            return queue || [];
        }
    },

    dequeue: function( elem, type ) {
        type = type || "fx";

        var queue = jQuery.queue( elem, type ),
            startLength = queue.length,
            fn = queue.shift(),
            hooks = jQuery._queueHooks( elem, type ),
            next = function() {
                jQuery.dequeue( elem, type );
            };

        // If the fx queue is dequeued, always remove the progress sentinel
        if ( fn === "inprogress" ) {
            fn = queue.shift();
            startLength--;
        }

        if ( fn ) {

            // Add a progress sentinel to prevent the fx queue from being
            // automatically dequeued
            if ( type === "fx" ) {
                queue.unshift( "inprogress" );
            }

            // clear up the last queue stop function
            delete hooks.stop;
            fn.call( elem, next, hooks );
        }

        if ( !startLength && hooks ) {
            hooks.empty.fire();
        }
    },

    // not intended for public consumption - generates a queueHooks object, or returns the current one
    _queueHooks: function( elem, type ) {
        var key = type + "queueHooks";
        return jQuery._data( elem, key ) || jQuery._data( elem, key, {
            empty: jQuery.Callbacks("once memory").add(function() {
                jQuery.removeData( elem, type + "queue", true );
                jQuery.removeData( elem, key, true );
            })
        });
    }
});

jQuery.fn.extend({
    queue: function( type, data ) {
        var setter = 2;

        if ( typeof type !== "string" ) {
            data = type;
            type = "fx";
            setter--;
        }

        if ( arguments.length < setter ) {
            return jQuery.queue( this[0], type );
        }

        return data === undefined ?
            this :
            this.each(function() {
                var queue = jQuery.queue( this, type, data );

                // ensure a hooks for this queue
                jQuery._queueHooks( this, type );

                if ( type === "fx" && queue[0] !== "inprogress" ) {
                    jQuery.dequeue( this, type );
                }
            });
    },
    dequeue: function( type ) {
        return this.each(function() {
            jQuery.dequeue( this, type );
        });
    },
    // Based off of the plugin by Clint Helfers, with permission.
    // http://blindsignals.com/index.php/2009/07/jquery-delay/
    delay: function( time, type ) {
        time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
        type = type || "fx";

        return this.queue( type, function( next, hooks ) {
            var timeout = setTimeout( next, time );
            hooks.stop = function() {
                clearTimeout( timeout );
            };
        });
    },
    clearQueue: function( type ) {
        return this.queue( type || "fx", [] );
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function( type, obj ) {
        var tmp,
            count = 1,
            defer = jQuery.Deferred(),
            elements = this,
            i = this.length,
            resolve = function() {
                if ( !( --count ) ) {
                    defer.resolveWith( elements, [ elements ] );
                }
            };

        if ( typeof type !== "string" ) {
            obj = type;
            type = undefined;
        }
        type = type || "fx";

        while( i-- ) {
            tmp = jQuery._data( elements[ i ], type + "queueHooks" );
            if ( tmp && tmp.empty ) {
                count++;
                tmp.empty.add( resolve );
            }
        }
        resolve();
        return defer.promise( obj );
    }
});
var nodeHook, boolHook, fixSpecified,
    rclass = /[\t\r\n]/g,
    rreturn = /\r/g,
    rtype = /^(?:button|input)$/i,
    rfocusable = /^(?:button|input|object|select|textarea)$/i,
    rclickable = /^a(?:rea|)$/i,
    rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
    getSetAttribute = jQuery.support.getSetAttribute;

jQuery.fn.extend({
    attr: function( name, value ) {
        return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
    },

    removeAttr: function( name ) {
        return this.each(function() {
            jQuery.removeAttr( this, name );
        });
    },

    prop: function( name, value ) {
        return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
    },

    removeProp: function( name ) {
        name = jQuery.propFix[ name ] || name;
        return this.each(function() {
            // try/catch handles cases where IE balks (such as removing a property on window)
            try {
                this[ name ] = undefined;
                delete this[ name ];
            } catch( e ) {}
        });
    },

    addClass: function( value ) {
        var classNames, i, l, elem,
            setClass, c, cl;

        if ( jQuery.isFunction( value ) ) {
            return this.each(function( j ) {
                jQuery( this ).addClass( value.call(this, j, this.className) );
            });
        }

        if ( value && typeof value === "string" ) {
            classNames = value.split( core_rspace );

            for ( i = 0, l = this.length; i < l; i++ ) {
                elem = this[ i ];

                if ( elem.nodeType === 1 ) {
                    if ( !elem.className && classNames.length === 1 ) {
                        elem.className = value;

                    } else {
                        setClass = " " + elem.className + " ";

                        for ( c = 0, cl = classNames.length; c < cl; c++ ) {
                            if ( setClass.indexOf( " " + classNames[ c ] + " " ) < 0 ) {
                                setClass += classNames[ c ] + " ";
                            }
                        }
                        elem.className = jQuery.trim( setClass );
                    }
                }
            }
        }

        return this;
    },

    removeClass: function( value ) {
        var removes, className, elem, c, cl, i, l;

        if ( jQuery.isFunction( value ) ) {
            return this.each(function( j ) {
                jQuery( this ).removeClass( value.call(this, j, this.className) );
            });
        }
        if ( (value && typeof value === "string") || value === undefined ) {
            removes = ( value || "" ).split( core_rspace );

            for ( i = 0, l = this.length; i < l; i++ ) {
                elem = this[ i ];
                if ( elem.nodeType === 1 && elem.className ) {

                    className = (" " + elem.className + " ").replace( rclass, " " );

                    // loop over each item in the removal list
                    for ( c = 0, cl = removes.length; c < cl; c++ ) {
                        // Remove until there is nothing to remove,
                        while ( className.indexOf(" " + removes[ c ] + " ") >= 0 ) {
                            className = className.replace( " " + removes[ c ] + " " , " " );
                        }
                    }
                    elem.className = value ? jQuery.trim( className ) : "";
                }
            }
        }

        return this;
    },

    toggleClass: function( value, stateVal ) {
        var type = typeof value,
            isBool = typeof stateVal === "boolean";

        if ( jQuery.isFunction( value ) ) {
            return this.each(function( i ) {
                jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
            });
        }

        return this.each(function() {
            if ( type === "string" ) {
                // toggle individual class names
                var className,
                    i = 0,
                    self = jQuery( this ),
                    state = stateVal,
                    classNames = value.split( core_rspace );

                while ( (className = classNames[ i++ ]) ) {
                    // check each className given, space separated list
                    state = isBool ? state : !self.hasClass( className );
                    self[ state ? "addClass" : "removeClass" ]( className );
                }

            } else if ( type === "undefined" || type === "boolean" ) {
                if ( this.className ) {
                    // store className if set
                    jQuery._data( this, "__className__", this.className );
                }

                // toggle whole className
                this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
            }
        });
    },

    hasClass: function( selector ) {
        var className = " " + selector + " ",
            i = 0,
            l = this.length;
        for ( ; i < l; i++ ) {
            if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
                return true;
            }
        }

        return false;
    },

    val: function( value ) {
        var hooks, ret, isFunction,
            elem = this[0];

        if ( !arguments.length ) {
            if ( elem ) {
                hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
                    return ret;
                }

                ret = elem.value;

                return typeof ret === "string" ?
                    // handle most common string cases
                    ret.replace(rreturn, "") :
                    // handle cases where value is null/undef or number
                    ret == null ? "" : ret;
            }

            return;
        }

        isFunction = jQuery.isFunction( value );

        return this.each(function( i ) {
            var val,
                self = jQuery(this);

            if ( this.nodeType !== 1 ) {
                return;
            }

            if ( isFunction ) {
                val = value.call( this, i, self.val() );
            } else {
                val = value;
            }

            // Treat null/undefined as ""; convert numbers to string
            if ( val == null ) {
                val = "";
            } else if ( typeof val === "number" ) {
                val += "";
            } else if ( jQuery.isArray( val ) ) {
                val = jQuery.map(val, function ( value ) {
                    return value == null ? "" : value + "";
                });
            }

            hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

            // If set returns undefined, fall back to normal setting
            if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
                this.value = val;
            }
        });
    }
});

jQuery.extend({
    valHooks: {
        option: {
            get: function( elem ) {
                // attributes.value is undefined in Blackberry 4.7 but
                // uses .value. See #6932
                var val = elem.attributes.value;
                return !val || val.specified ? elem.value : elem.text;
            }
        },
        select: {
            get: function( elem ) {
                var value, option,
                    options = elem.options,
                    index = elem.selectedIndex,
                    one = elem.type === "select-one" || index < 0,
                    values = one ? null : [],
                    max = one ? index + 1 : options.length,
                    i = index < 0 ?
                        max :
                        one ? index : 0;

                // Loop through all the selected options
                for ( ; i < max; i++ ) {
                    option = options[ i ];

                    // oldIE doesn't update selected after form reset (#2551)
                    if ( ( option.selected || i === index ) &&
                            // Don't return options that are disabled or in a disabled optgroup
                            ( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
                            ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

                        // Get the specific value for the option
                        value = jQuery( option ).val();

                        // We don't need an array for one selects
                        if ( one ) {
                            return value;
                        }

                        // Multi-Selects return an array
                        values.push( value );
                    }
                }

                return values;
            },

            set: function( elem, value ) {
                var values = jQuery.makeArray( value );

                jQuery(elem).find("option").each(function() {
                    this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
                });

                if ( !values.length ) {
                    elem.selectedIndex = -1;
                }
                return values;
            }
        }
    },

    // Unused in 1.8, left in so attrFn-stabbers won't die; remove in 1.9
    attrFn: {},

    attr: function( elem, name, value, pass ) {
        var ret, hooks, notxml,
            nType = elem.nodeType;

        // don't get/set attributes on text, comment and attribute nodes
        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
            return;
        }

        if ( pass && jQuery.isFunction( jQuery.fn[ name ] ) ) {
            return jQuery( elem )[ name ]( value );
        }

        // Fallback to prop when attributes are not supported
        if ( typeof elem.getAttribute === "undefined" ) {
            return jQuery.prop( elem, name, value );
        }

        notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

        // All attributes are lowercase
        // Grab necessary hook if one is defined
        if ( notxml ) {
            name = name.toLowerCase();
            hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
        }

        if ( value !== undefined ) {

            if ( value === null ) {
                jQuery.removeAttr( elem, name );
                return;

            } else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
                return ret;

            } else {
                elem.setAttribute( name, value + "" );
                return value;
            }

        } else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
            return ret;

        } else {

            ret = elem.getAttribute( name );

            // Non-existent attributes return null, we normalize to undefined
            return ret === null ?
                undefined :
                ret;
        }
    },

    removeAttr: function( elem, value ) {
        var propName, attrNames, name, isBool,
            i = 0;

        if ( value && elem.nodeType === 1 ) {

            attrNames = value.split( core_rspace );

            for ( ; i < attrNames.length; i++ ) {
                name = attrNames[ i ];

                if ( name ) {
                    propName = jQuery.propFix[ name ] || name;
                    isBool = rboolean.test( name );

                    // See #9699 for explanation of this approach (setting first, then removal)
                    // Do not do this for boolean attributes (see #10870)
                    if ( !isBool ) {
                        jQuery.attr( elem, name, "" );
                    }
                    elem.removeAttribute( getSetAttribute ? name : propName );

                    // Set corresponding property to false for boolean attributes
                    if ( isBool && propName in elem ) {
                        elem[ propName ] = false;
                    }
                }
            }
        }
    },

    attrHooks: {
        type: {
            set: function( elem, value ) {
                // We can't allow the type property to be changed (since it causes problems in IE)
                if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
                    jQuery.error( "type property can't be changed" );
                } else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
                    // Setting the type on a radio button after the value resets the value in IE6-9
                    // Reset value to it's default in case type is set after value
                    // This is for element creation
                    var val = elem.value;
                    elem.setAttribute( "type", value );
                    if ( val ) {
                        elem.value = val;
                    }
                    return value;
                }
            }
        },
        // Use the value property for back compat
        // Use the nodeHook for button elements in IE6/7 (#1954)
        value: {
            get: function( elem, name ) {
                if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
                    return nodeHook.get( elem, name );
                }
                return name in elem ?
                    elem.value :
                    null;
            },
            set: function( elem, value, name ) {
                if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
                    return nodeHook.set( elem, value, name );
                }
                // Does not return so that setAttribute is also used
                elem.value = value;
            }
        }
    },

    propFix: {
        tabindex: "tabIndex",
        readonly: "readOnly",
        "for": "htmlFor",
        "class": "className",
        maxlength: "maxLength",
        cellspacing: "cellSpacing",
        cellpadding: "cellPadding",
        rowspan: "rowSpan",
        colspan: "colSpan",
        usemap: "useMap",
        frameborder: "frameBorder",
        contenteditable: "contentEditable"
    },

    prop: function( elem, name, value ) {
        var ret, hooks, notxml,
            nType = elem.nodeType;

        // don't get/set properties on text, comment and attribute nodes
        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
            return;
        }

        notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

        if ( notxml ) {
            // Fix name and attach hooks
            name = jQuery.propFix[ name ] || name;
            hooks = jQuery.propHooks[ name ];
        }

        if ( value !== undefined ) {
            if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
                return ret;

            } else {
                return ( elem[ name ] = value );
            }

        } else {
            if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
                return ret;

            } else {
                return elem[ name ];
            }
        }
    },

    propHooks: {
        tabIndex: {
            get: function( elem ) {
                // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                var attributeNode = elem.getAttributeNode("tabindex");

                return attributeNode && attributeNode.specified ?
                    parseInt( attributeNode.value, 10 ) :
                    rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
                        0 :
                        undefined;
            }
        }
    }
});

// Hook for boolean attributes
boolHook = {
    get: function( elem, name ) {
        // Align boolean attributes with corresponding properties
        // Fall back to attribute presence where some booleans are not supported
        var attrNode,
            property = jQuery.prop( elem, name );
        return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
            name.toLowerCase() :
            undefined;
    },
    set: function( elem, value, name ) {
        var propName;
        if ( value === false ) {
            // Remove boolean attributes when set to false
            jQuery.removeAttr( elem, name );
        } else {
            // value is true since we know at this point it's type boolean and not false
            // Set boolean attributes to the same name and set the DOM property
            propName = jQuery.propFix[ name ] || name;
            if ( propName in elem ) {
                // Only set the IDL specifically if it already exists on the element
                elem[ propName ] = true;
            }

            elem.setAttribute( name, name.toLowerCase() );
        }
        return name;
    }
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

    fixSpecified = {
        name: true,
        id: true,
        coords: true
    };

    // Use this for any attribute in IE6/7
    // This fixes almost every IE6/7 issue
    nodeHook = jQuery.valHooks.button = {
        get: function( elem, name ) {
            var ret;
            ret = elem.getAttributeNode( name );
            return ret && ( fixSpecified[ name ] ? ret.value !== "" : ret.specified ) ?
                ret.value :
                undefined;
        },
        set: function( elem, value, name ) {
            // Set the existing or create a new attribute node
            var ret = elem.getAttributeNode( name );
            if ( !ret ) {
                ret = document.createAttribute( name );
                elem.setAttributeNode( ret );
            }
            return ( ret.value = value + "" );
        }
    };

    // Set width and height to auto instead of 0 on empty string( Bug #8150 )
    // This is for removals
    jQuery.each([ "width", "height" ], function( i, name ) {
        jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
            set: function( elem, value ) {
                if ( value === "" ) {
                    elem.setAttribute( name, "auto" );
                    return value;
                }
            }
        });
    });

    // Set contenteditable to false on removals(#10429)
    // Setting to empty string throws an error as an invalid value
    jQuery.attrHooks.contenteditable = {
        get: nodeHook.get,
        set: function( elem, value, name ) {
            if ( value === "" ) {
                value = "false";
            }
            nodeHook.set( elem, value, name );
        }
    };
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
    jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
        jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
            get: function( elem ) {
                var ret = elem.getAttribute( name, 2 );
                return ret === null ? undefined : ret;
            }
        });
    });
}

if ( !jQuery.support.style ) {
    jQuery.attrHooks.style = {
        get: function( elem ) {
            // Return undefined in the case of empty string
            // Normalize to lowercase since IE uppercases css property names
            return elem.style.cssText.toLowerCase() || undefined;
        },
        set: function( elem, value ) {
            return ( elem.style.cssText = value + "" );
        }
    };
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
    jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
        get: function( elem ) {
            var parent = elem.parentNode;

            if ( parent ) {
                parent.selectedIndex;

                // Make sure that it also works with optgroups, see #5701
                if ( parent.parentNode ) {
                    parent.parentNode.selectedIndex;
                }
            }
            return null;
        }
    });
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
    jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
    jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[ this ] = {
            get: function( elem ) {
                // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
                return elem.getAttribute("value") === null ? "on" : elem.value;
            }
        };
    });
}
jQuery.each([ "radio", "checkbox" ], function() {
    jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
        set: function( elem, value ) {
            if ( jQuery.isArray( value ) ) {
                return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
            }
        }
    });
});
var rformElems = /^(?:textarea|input|select)$/i,
    rtypenamespace = /^([^\.]*|)(?:\.(.+)|)$/,
    rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
    rkeyEvent = /^key/,
    rmouseEvent = /^(?:mouse|contextmenu)|click/,
    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    hoverHack = function( events ) {
        return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
    };

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

    add: function( elem, types, handler, data, selector ) {

        var elemData, eventHandle, events,
            t, tns, type, namespaces, handleObj,
            handleObjIn, handlers, special;

        // Don't attach events to noData or text/comment nodes (allow plain objects tho)
        if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
            return;
        }

        // Caller can pass in an object of custom data in lieu of the handler
        if ( handler.handler ) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
        }

        // Make sure that the handler has a unique ID, used to find/remove it later
        if ( !handler.guid ) {
            handler.guid = jQuery.guid++;
        }

        // Init the element's event structure and main handler, if this is the first
        events = elemData.events;
        if ( !events ) {
            elemData.events = events = {};
        }
        eventHandle = elemData.handle;
        if ( !eventHandle ) {
            elemData.handle = eventHandle = function( e ) {
                // Discard the second event of a jQuery.event.trigger() and
                // when an event is called after a page has unloaded
                return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
                    jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
                    undefined;
            };
            // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
            eventHandle.elem = elem;
        }

        // Handle multiple events separated by a space
        // jQuery(...).bind("mouseover mouseout", fn);
        types = jQuery.trim( hoverHack(types) ).split( " " );
        for ( t = 0; t < types.length; t++ ) {

            tns = rtypenamespace.exec( types[t] ) || [];
            type = tns[1];
            namespaces = ( tns[2] || "" ).split( "." ).sort();

            // If event changes its type, use the special event handlers for the changed type
            special = jQuery.event.special[ type ] || {};

            // If selector defined, determine special event api type, otherwise given type
            type = ( selector ? special.delegateType : special.bindType ) || type;

            // Update special based on newly reset type
            special = jQuery.event.special[ type ] || {};

            // handleObj is passed to all event handlers
            handleObj = jQuery.extend({
                type: type,
                origType: tns[1],
                data: data,
                handler: handler,
                guid: handler.guid,
                selector: selector,
                needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
                namespace: namespaces.join(".")
            }, handleObjIn );

            // Init the event handler queue if we're the first
            handlers = events[ type ];
            if ( !handlers ) {
                handlers = events[ type ] = [];
                handlers.delegateCount = 0;

                // Only use addEventListener/attachEvent if the special events handler returns false
                if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
                    // Bind the global event handler to the element
                    if ( elem.addEventListener ) {
                        elem.addEventListener( type, eventHandle, false );

                    } else if ( elem.attachEvent ) {
                        elem.attachEvent( "on" + type, eventHandle );
                    }
                }
            }

            if ( special.add ) {
                special.add.call( elem, handleObj );

                if ( !handleObj.handler.guid ) {
                    handleObj.handler.guid = handler.guid;
                }
            }

            // Add to the element's handler list, delegates in front
            if ( selector ) {
                handlers.splice( handlers.delegateCount++, 0, handleObj );
            } else {
                handlers.push( handleObj );
            }

            // Keep track of which events have ever been used, for event optimization
            jQuery.event.global[ type ] = true;
        }

        // Nullify elem to prevent memory leaks in IE
        elem = null;
    },

    global: {},

    // Detach an event or set of events from an element
    remove: function( elem, types, handler, selector, mappedTypes ) {

        var t, tns, type, origType, namespaces, origCount,
            j, events, special, eventType, handleObj,
            elemData = jQuery.hasData( elem ) && jQuery._data( elem );

        if ( !elemData || !(events = elemData.events) ) {
            return;
        }

        // Once for each type.namespace in types; type may be omitted
        types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
        for ( t = 0; t < types.length; t++ ) {
            tns = rtypenamespace.exec( types[t] ) || [];
            type = origType = tns[1];
            namespaces = tns[2];

            // Unbind all events (on this namespace, if provided) for the element
            if ( !type ) {
                for ( type in events ) {
                    jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                }
                continue;
            }

            special = jQuery.event.special[ type ] || {};
            type = ( selector? special.delegateType : special.bindType ) || type;
            eventType = events[ type ] || [];
            origCount = eventType.length;
            namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

            // Remove matching events
            for ( j = 0; j < eventType.length; j++ ) {
                handleObj = eventType[ j ];

                if ( ( mappedTypes || origType === handleObj.origType ) &&
                     ( !handler || handler.guid === handleObj.guid ) &&
                     ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
                     ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
                    eventType.splice( j--, 1 );

                    if ( handleObj.selector ) {
                        eventType.delegateCount--;
                    }
                    if ( special.remove ) {
                        special.remove.call( elem, handleObj );
                    }
                }
            }

            // Remove generic event handler if we removed something and no more handlers exist
            // (avoids potential for endless recursion during removal of special event handlers)
            if ( eventType.length === 0 && origCount !== eventType.length ) {
                if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
                    jQuery.removeEvent( elem, type, elemData.handle );
                }

                delete events[ type ];
            }
        }

        // Remove the expando if it's no longer used
        if ( jQuery.isEmptyObject( events ) ) {
            delete elemData.handle;

            // removeData also checks for emptiness and clears the expando if empty
            // so use it instead of delete
            jQuery.removeData( elem, "events", true );
        }
    },

    // Events that are safe to short-circuit if no handlers are attached.
    // Native DOM events should not be added, they may have inline handlers.
    customEvent: {
        "getData": true,
        "setData": true,
        "changeData": true
    },

    trigger: function( event, data, elem, onlyHandlers ) {
        // Don't do events on text and comment nodes
        if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
            return;
        }

        // Event object or event type
        var cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType,
            type = event.type || event,
            namespaces = [];

        // focus/blur morphs to focusin/out; ensure we're not firing them right now
        if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
            return;
        }

        if ( type.indexOf( "!" ) >= 0 ) {
            // Exclusive events trigger only for the exact event (no namespaces)
            type = type.slice(0, -1);
            exclusive = true;
        }

        if ( type.indexOf( "." ) >= 0 ) {
            // Namespaced trigger; create a regexp to match event type in handle()
            namespaces = type.split(".");
            type = namespaces.shift();
            namespaces.sort();
        }

        if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
            // No jQuery handlers for this event type, and it can't have inline handlers
            return;
        }

        // Caller can pass in an Event, Object, or just an event type string
        event = typeof event === "object" ?
            // jQuery.Event object
            event[ jQuery.expando ] ? event :
            // Object literal
            new jQuery.Event( type, event ) :
            // Just the event type (string)
            new jQuery.Event( type );

        event.type = type;
        event.isTrigger = true;
        event.exclusive = exclusive;
        event.namespace = namespaces.join( "." );
        event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
        ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

        // Handle a global trigger
        if ( !elem ) {

            // TODO: Stop taunting the data cache; remove global events and always attach to document
            cache = jQuery.cache;
            for ( i in cache ) {
                if ( cache[ i ].events && cache[ i ].events[ type ] ) {
                    jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
                }
            }
            return;
        }

        // Clean up the event in case it is being reused
        event.result = undefined;
        if ( !event.target ) {
            event.target = elem;
        }

        // Clone any incoming data and prepend the event, creating the handler arg list
        data = data != null ? jQuery.makeArray( data ) : [];
        data.unshift( event );

        // Allow special events to draw outside the lines
        special = jQuery.event.special[ type ] || {};
        if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
            return;
        }

        // Determine event propagation path in advance, per W3C events spec (#9951)
        // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
        eventPath = [[ elem, special.bindType || type ]];
        if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

            bubbleType = special.delegateType || type;
            cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
            for ( old = elem; cur; cur = cur.parentNode ) {
                eventPath.push([ cur, bubbleType ]);
                old = cur;
            }

            // Only add window if we got to document (e.g., not plain obj or detached DOM)
            if ( old === (elem.ownerDocument || document) ) {
                eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
            }
        }

        // Fire handlers on the event path
        for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

            cur = eventPath[i][0];
            event.type = eventPath[i][1];

            handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
            if ( handle ) {
                handle.apply( cur, data );
            }
            // Note that this is a bare JS function and not a jQuery handler
            handle = ontype && cur[ ontype ];
            if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
                event.preventDefault();
            }
        }
        event.type = type;

        // If nobody prevented the default action, do it now
        if ( !onlyHandlers && !event.isDefaultPrevented() ) {

            if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
                !(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

                // Call a native DOM method on the target with the same name name as the event.
                // Can't use an .isFunction() check here because IE6/7 fails that test.
                // Don't do default actions on window, that's where global variables be (#6170)
                // IE<9 dies on focus/blur to hidden element (#1486)
                if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

                    // Don't re-trigger an onFOO event when we call its FOO() method
                    old = elem[ ontype ];

                    if ( old ) {
                        elem[ ontype ] = null;
                    }

                    // Prevent re-triggering of the same event, since we already bubbled it above
                    jQuery.event.triggered = type;
                    elem[ type ]();
                    jQuery.event.triggered = undefined;

                    if ( old ) {
                        elem[ ontype ] = old;
                    }
                }
            }
        }

        return event.result;
    },

    dispatch: function( event ) {

        // Make a writable jQuery.Event from the native event object
        event = jQuery.event.fix( event || window.event );

        var i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related,
            handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
            delegateCount = handlers.delegateCount,
            args = core_slice.call( arguments ),
            run_all = !event.exclusive && !event.namespace,
            special = jQuery.event.special[ event.type ] || {},
            handlerQueue = [];

        // Use the fix-ed jQuery.Event rather than the (read-only) native event
        args[0] = event;
        event.delegateTarget = this;

        // Call the preDispatch hook for the mapped type, and let it bail if desired
        if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
            return;
        }

        // Determine handlers that should run if there are delegated events
        // Avoid non-left-click bubbling in Firefox (#3861)
        if ( delegateCount && !(event.button && event.type === "click") ) {

            for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {

                // Don't process clicks (ONLY) on disabled elements (#6911, #8165, #11382, #11764)
                if ( cur.disabled !== true || event.type !== "click" ) {
                    selMatch = {};
                    matches = [];
                    for ( i = 0; i < delegateCount; i++ ) {
                        handleObj = handlers[ i ];
                        sel = handleObj.selector;

                        if ( selMatch[ sel ] === undefined ) {
                            selMatch[ sel ] = handleObj.needsContext ?
                                jQuery( sel, this ).index( cur ) >= 0 :
                                jQuery.find( sel, this, null, [ cur ] ).length;
                        }
                        if ( selMatch[ sel ] ) {
                            matches.push( handleObj );
                        }
                    }
                    if ( matches.length ) {
                        handlerQueue.push({ elem: cur, matches: matches });
                    }
                }
            }
        }

        // Add the remaining (directly-bound) handlers
        if ( handlers.length > delegateCount ) {
            handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
        }

        // Run delegates first; they may want to stop propagation beneath us
        for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
            matched = handlerQueue[ i ];
            event.currentTarget = matched.elem;

            for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
                handleObj = matched.matches[ j ];

                // Triggered event must either 1) be non-exclusive and have no namespace, or
                // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

                    event.data = handleObj.data;
                    event.handleObj = handleObj;

                    ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                            .apply( matched.elem, args );

                    if ( ret !== undefined ) {
                        event.result = ret;
                        if ( ret === false ) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }
                }
            }
        }

        // Call the postDispatch hook for the mapped type
        if ( special.postDispatch ) {
            special.postDispatch.call( this, event );
        }

        return event.result;
    },

    // Includes some event props shared by KeyEvent and MouseEvent
    // *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
    props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

    fixHooks: {},

    keyHooks: {
        props: "char charCode key keyCode".split(" "),
        filter: function( event, original ) {

            // Add which for key events
            if ( event.which == null ) {
                event.which = original.charCode != null ? original.charCode : original.keyCode;
            }

            return event;
        }
    },

    mouseHooks: {
        props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
        filter: function( event, original ) {
            var eventDoc, doc, body,
                button = original.button,
                fromElement = original.fromElement;

            // Calculate pageX/Y if missing and clientX/Y available
            if ( event.pageX == null && original.clientX != null ) {
                eventDoc = event.target.ownerDocument || document;
                doc = eventDoc.documentElement;
                body = eventDoc.body;

                event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
            }

            // Add relatedTarget, if necessary
            if ( !event.relatedTarget && fromElement ) {
                event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            // Note: button is not normalized, so don't use it
            if ( !event.which && button !== undefined ) {
                event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
            }

            return event;
        }
    },

    fix: function( event ) {
        if ( event[ jQuery.expando ] ) {
            return event;
        }

        // Create a writable copy of the event object and normalize some properties
        var i, prop,
            originalEvent = event,
            fixHook = jQuery.event.fixHooks[ event.type ] || {},
            copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

        event = jQuery.Event( originalEvent );

        for ( i = copy.length; i; ) {
            prop = copy[ --i ];
            event[ prop ] = originalEvent[ prop ];
        }

        // Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
        if ( !event.target ) {
            event.target = originalEvent.srcElement || document;
        }

        // Target should not be a text node (#504, Safari)
        if ( event.target.nodeType === 3 ) {
            event.target = event.target.parentNode;
        }

        // For mouse/key events, metaKey==false if it's undefined (#3368, #11328; IE6/7/8)
        event.metaKey = !!event.metaKey;

        return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
    },

    special: {
        load: {
            // Prevent triggered image.load events from bubbling to window.load
            noBubble: true
        },

        focus: {
            delegateType: "focusin"
        },
        blur: {
            delegateType: "focusout"
        },

        beforeunload: {
            setup: function( data, namespaces, eventHandle ) {
                // We only want to do this special case on windows
                if ( jQuery.isWindow( this ) ) {
                    this.onbeforeunload = eventHandle;
                }
            },

            teardown: function( namespaces, eventHandle ) {
                if ( this.onbeforeunload === eventHandle ) {
                    this.onbeforeunload = null;
                }
            }
        }
    },

    simulate: function( type, elem, event, bubble ) {
        // Piggyback on a donor event to simulate a different one.
        // Fake originalEvent to avoid donor's stopPropagation, but if the
        // simulated event prevents default then we do the same on the donor.
        var e = jQuery.extend(
            new jQuery.Event(),
            event,
            { type: type,
                isSimulated: true,
                originalEvent: {}
            }
        );
        if ( bubble ) {
            jQuery.event.trigger( e, null, elem );
        } else {
            jQuery.event.dispatch.call( elem, e );
        }
        if ( e.isDefaultPrevented() ) {
            event.preventDefault();
        }
    }
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
    function( elem, type, handle ) {
        if ( elem.removeEventListener ) {
            elem.removeEventListener( type, handle, false );
        }
    } :
    function( elem, type, handle ) {
        var name = "on" + type;

        if ( elem.detachEvent ) {

            // #8545, #7054, preventing memory leaks for custom events in IE6-8
            // detachEvent needed property on element, by name of that event, to properly expose it to GC
            if ( typeof elem[ name ] === "undefined" ) {
                elem[ name ] = null;
            }

            elem.detachEvent( name, handle );
        }
    };

jQuery.Event = function( src, props ) {
    // Allow instantiation without the 'new' keyword
    if ( !(this instanceof jQuery.Event) ) {
        return new jQuery.Event( src, props );
    }

    // Event object
    if ( src && src.type ) {
        this.originalEvent = src;
        this.type = src.type;

        // Events bubbling up the document may have been marked as prevented
        // by a handler lower down the tree; reflect the correct value.
        this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
            src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

    // Event type
    } else {
        this.type = src;
    }

    // Put explicitly provided properties onto the event object
    if ( props ) {
        jQuery.extend( this, props );
    }

    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = src && src.timeStamp || jQuery.now();

    // Mark it as fixed
    this[ jQuery.expando ] = true;
};

function returnFalse() {
    return false;
}
function returnTrue() {
    return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
    preventDefault: function() {
        this.isDefaultPrevented = returnTrue;

        var e = this.originalEvent;
        if ( !e ) {
            return;
        }

        // if preventDefault exists run it on the original event
        if ( e.preventDefault ) {
            e.preventDefault();

        // otherwise set the returnValue property of the original event to false (IE)
        } else {
            e.returnValue = false;
        }
    },
    stopPropagation: function() {
        this.isPropagationStopped = returnTrue;

        var e = this.originalEvent;
        if ( !e ) {
            return;
        }
        // if stopPropagation exists run it on the original event
        if ( e.stopPropagation ) {
            e.stopPropagation();
        }
        // otherwise set the cancelBubble property of the original event to true (IE)
        e.cancelBubble = true;
    },
    stopImmediatePropagation: function() {
        this.isImmediatePropagationStopped = returnTrue;
        this.stopPropagation();
    },
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
}, function( orig, fix ) {
    jQuery.event.special[ orig ] = {
        delegateType: fix,
        bindType: fix,

        handle: function( event ) {
            var ret,
                target = this,
                related = event.relatedTarget,
                handleObj = event.handleObj,
                selector = handleObj.selector;

            // For mousenter/leave call the handler if related is outside the target.
            // NB: No relatedTarget if the mouse left/entered the browser window
            if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
                event.type = handleObj.origType;
                ret = handleObj.handler.apply( this, arguments );
                event.type = fix;
            }
            return ret;
        }
    };
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

    jQuery.event.special.submit = {
        setup: function() {
            // Only need this for delegated form submit events
            if ( jQuery.nodeName( this, "form" ) ) {
                return false;
            }

            // Lazy-add a submit handler when a descendant form may potentially be submitted
            jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
                // Node name check avoids a VML-related crash in IE (#9807)
                var elem = e.target,
                    form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
                if ( form && !jQuery._data( form, "_submit_attached" ) ) {
                    jQuery.event.add( form, "submit._submit", function( event ) {
                        event._submit_bubble = true;
                    });
                    jQuery._data( form, "_submit_attached", true );
                }
            });
            // return undefined since we don't need an event listener
        },

        postDispatch: function( event ) {
            // If form was submitted by the user, bubble the event up the tree
            if ( event._submit_bubble ) {
                delete event._submit_bubble;
                if ( this.parentNode && !event.isTrigger ) {
                    jQuery.event.simulate( "submit", this.parentNode, event, true );
                }
            }
        },

        teardown: function() {
            // Only need this for delegated form submit events
            if ( jQuery.nodeName( this, "form" ) ) {
                return false;
            }

            // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
            jQuery.event.remove( this, "._submit" );
        }
    };
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

    jQuery.event.special.change = {

        setup: function() {

            if ( rformElems.test( this.nodeName ) ) {
                // IE doesn't fire change on a check/radio until blur; trigger it on click
                // after a propertychange. Eat the blur-change in special.change.handle.
                // This still fires onchange a second time for check/radio after blur.
                if ( this.type === "checkbox" || this.type === "radio" ) {
                    jQuery.event.add( this, "propertychange._change", function( event ) {
                        if ( event.originalEvent.propertyName === "checked" ) {
                            this._just_changed = true;
                        }
                    });
                    jQuery.event.add( this, "click._change", function( event ) {
                        if ( this._just_changed && !event.isTrigger ) {
                            this._just_changed = false;
                        }
                        // Allow triggered, simulated change events (#11500)
                        jQuery.event.simulate( "change", this, event, true );
                    });
                }
                return false;
            }
            // Delegated event; lazy-add a change handler on descendant inputs
            jQuery.event.add( this, "beforeactivate._change", function( e ) {
                var elem = e.target;

                if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "_change_attached" ) ) {
                    jQuery.event.add( elem, "change._change", function( event ) {
                        if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
                            jQuery.event.simulate( "change", this.parentNode, event, true );
                        }
                    });
                    jQuery._data( elem, "_change_attached", true );
                }
            });
        },

        handle: function( event ) {
            var elem = event.target;

            // Swallow native change events from checkbox/radio, we already triggered them above
            if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
                return event.handleObj.handler.apply( this, arguments );
            }
        },

        teardown: function() {
            jQuery.event.remove( this, "._change" );

            return !rformElems.test( this.nodeName );
        }
    };
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
    jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

        // Attach a single capturing handler while someone wants focusin/focusout
        var attaches = 0,
            handler = function( event ) {
                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
            };

        jQuery.event.special[ fix ] = {
            setup: function() {
                if ( attaches++ === 0 ) {
                    document.addEventListener( orig, handler, true );
                }
            },
            teardown: function() {
                if ( --attaches === 0 ) {
                    document.removeEventListener( orig, handler, true );
                }
            }
        };
    });
}

jQuery.fn.extend({

    on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
        var origFn, type;

        // Types can be a map of types/handlers
        if ( typeof types === "object" ) {
            // ( types-Object, selector, data )
            if ( typeof selector !== "string" ) { // && selector != null
                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for ( type in types ) {
                this.on( type, selector, data, types[ type ], one );
            }
            return this;
        }

        if ( data == null && fn == null ) {
            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if ( fn == null ) {
            if ( typeof selector === "string" ) {
                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {
                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if ( fn === false ) {
            fn = returnFalse;
        } else if ( !fn ) {
            return this;
        }

        if ( one === 1 ) {
            origFn = fn;
            fn = function( event ) {
                // Can use an empty set, since event contains the info
                jQuery().off( event );
                return origFn.apply( this, arguments );
            };
            // Use same guid so caller can remove using origFn
            fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
        }
        return this.each( function() {
            jQuery.event.add( this, types, fn, data, selector );
        });
    },
    one: function( types, selector, data, fn ) {
        return this.on( types, selector, data, fn, 1 );
    },
    off: function( types, selector, fn ) {
        var handleObj, type;
        if ( types && types.preventDefault && types.handleObj ) {
            // ( event )  dispatched jQuery.Event
            handleObj = types.handleObj;
            jQuery( types.delegateTarget ).off(
                handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler
            );
            return this;
        }
        if ( typeof types === "object" ) {
            // ( types-object [, selector] )
            for ( type in types ) {
                this.off( type, selector, types[ type ] );
            }
            return this;
        }
        if ( selector === false || typeof selector === "function" ) {
            // ( types [, fn] )
            fn = selector;
            selector = undefined;
        }
        if ( fn === false ) {
            fn = returnFalse;
        }
        return this.each(function() {
            jQuery.event.remove( this, types, fn, selector );
        });
    },

    bind: function( types, data, fn ) {
        return this.on( types, null, data, fn );
    },
    unbind: function( types, fn ) {
        return this.off( types, null, fn );
    },

    live: function( types, data, fn ) {
        jQuery( this.context ).on( types, this.selector, data, fn );
        return this;
    },
    die: function( types, fn ) {
        jQuery( this.context ).off( types, this.selector || "**", fn );
        return this;
    },

    delegate: function( selector, types, data, fn ) {
        return this.on( types, selector, data, fn );
    },
    undelegate: function( selector, types, fn ) {
        // ( namespace ) or ( selector, types [, fn] )
        return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
    },

    trigger: function( type, data ) {
        return this.each(function() {
            jQuery.event.trigger( type, data, this );
        });
    },
    triggerHandler: function( type, data ) {
        if ( this[0] ) {
            return jQuery.event.trigger( type, data, this[0], true );
        }
    },

    toggle: function( fn ) {
        // Save reference to arguments for access in closure
        var args = arguments,
            guid = fn.guid || jQuery.guid++,
            i = 0,
            toggler = function( event ) {
                // Figure out which function to execute
                var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
                jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

                // Make sure that clicks stop
                event.preventDefault();

                // and execute the function
                return args[ lastToggle ].apply( this, arguments ) || false;
            };

        // link all the functions, so any of them can unbind this click handler
        toggler.guid = guid;
        while ( i < args.length ) {
            args[ i++ ].guid = guid;
        }

        return this.click( toggler );
    },

    hover: function( fnOver, fnOut ) {
        return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
    }
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
    "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
    "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

    // Handle event binding
    jQuery.fn[ name ] = function( data, fn ) {
        if ( fn == null ) {
            fn = data;
            data = null;
        }

        return arguments.length > 0 ?
            this.on( name, null, data, fn ) :
            this.trigger( name );
    };

    if ( rkeyEvent.test( name ) ) {
        jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
    }

    if ( rmouseEvent.test( name ) ) {
        jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
    }
});
/*!
 * Sizzle CSS Selector Engine
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://sizzlejs.com/
 */
(function( window, undefined ) {

var cachedruns,
    assertGetIdNotName,
    Expr,
    getText,
    isXML,
    contains,
    compile,
    sortOrder,
    hasDuplicate,
    outermostContext,

    baseHasDuplicate = true,
    strundefined = "undefined",

    expando = ( "sizcache" + Math.random() ).replace( ".", "" ),

    Token = String,
    document = window.document,
    docElem = document.documentElement,
    dirruns = 0,
    done = 0,
    pop = [].pop,
    push = [].push,
    slice = [].slice,
    // Use a stripped-down indexOf if a native one is unavailable
    indexOf = [].indexOf || function( elem ) {
        var i = 0,
            len = this.length;
        for ( ; i < len; i++ ) {
            if ( this[i] === elem ) {
                return i;
            }
        }
        return -1;
    },

    // Augment a function for special use by Sizzle
    markFunction = function( fn, value ) {
        fn[ expando ] = value == null || value;
        return fn;
    },

    createCache = function() {
        var cache = {},
            keys = [];

        return markFunction(function( key, value ) {
            // Only keep the most recent entries
            if ( keys.push( key ) > Expr.cacheLength ) {
                delete cache[ keys.shift() ];
            }

            // Retrieve with (key + " ") to avoid collision with native Object.prototype properties (see Issue #157)
            return (cache[ key + " " ] = value);
        }, cache );
    },

    classCache = createCache(),
    tokenCache = createCache(),
    compilerCache = createCache(),

    // Regex

    // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
    whitespace = "[\\x20\\t\\r\\n\\f]",
    // http://www.w3.org/TR/css3-syntax/#characters
    characterEncoding = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",

    // Loosely modeled on CSS identifier characters
    // An unquoted value should be a CSS identifier (http://www.w3.org/TR/css3-selectors/#attribute-selectors)
    // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
    identifier = characterEncoding.replace( "w", "w#" ),

    // Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
    operators = "([*^$|!~]?=)",
    attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
        "*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

    // Prefer arguments not in parens/brackets,
    //   then attribute selectors and non-pseudos (denoted by :),
    //   then anything else
    // These preferences are here to reduce the number of selectors
    //   needing tokenize in the PSEUDO preFilter
    pseudos = ":(" + characterEncoding + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + attributes + ")|[^:]|\\\\.)*|.*))\\)|)",

    // For matchExpr.POS and matchExpr.needsContext
    pos = ":(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
        "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)",

    // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

    rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
    rcombinators = new RegExp( "^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*" ),
    rpseudo = new RegExp( pseudos ),

    // Easily-parseable/retrievable ID or TAG or CLASS selectors
    rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,

    rnot = /^:not/,
    rsibling = /[\x20\t\r\n\f]*[+~]/,
    rendsWithNot = /:not\($/,

    rheader = /h\d/i,
    rinputs = /input|select|textarea|button/i,

    rbackslash = /\\(?!\\)/g,

    matchExpr = {
        "ID": new RegExp( "^#(" + characterEncoding + ")" ),
        "CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
        "NAME": new RegExp( "^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]" ),
        "TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
        "ATTR": new RegExp( "^" + attributes ),
        "PSEUDO": new RegExp( "^" + pseudos ),
        "POS": new RegExp( pos, "i" ),
        "CHILD": new RegExp( "^:(only|nth|first|last)-child(?:\\(" + whitespace +
            "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
            "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
        // For use in libraries implementing .is()
        "needsContext": new RegExp( "^" + whitespace + "*[>+~]|" + pos, "i" )
    },

    // Support

    // Used for testing something on an element
    assert = function( fn ) {
        var div = document.createElement("div");

        try {
            return fn( div );
        } catch (e) {
            return false;
        } finally {
            // release memory in IE
            div = null;
        }
    },

    // Check if getElementsByTagName("*") returns only elements
    assertTagNameNoComments = assert(function( div ) {
        div.appendChild( document.createComment("") );
        return !div.getElementsByTagName("*").length;
    }),

    // Check if getAttribute returns normalized href attributes
    assertHrefNotNormalized = assert(function( div ) {
        div.innerHTML = "<a href='#'></a>";
        return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
            div.firstChild.getAttribute("href") === "#";
    }),

    // Check if attributes should be retrieved by attribute nodes
    assertAttributes = assert(function( div ) {
        div.innerHTML = "<select></select>";
        var type = typeof div.lastChild.getAttribute("multiple");
        // IE8 returns a string for some attributes even when not present
        return type !== "boolean" && type !== "string";
    }),

    // Check if getElementsByClassName can be trusted
    assertUsableClassName = assert(function( div ) {
        // Opera can't find a second classname (in 9.6)
        div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
        if ( !div.getElementsByClassName || !div.getElementsByClassName("e").length ) {
            return false;
        }

        // Safari 3.2 caches class attributes and doesn't catch changes
        div.lastChild.className = "e";
        return div.getElementsByClassName("e").length === 2;
    }),

    // Check if getElementById returns elements by name
    // Check if getElementsByName privileges form controls or returns elements by ID
    assertUsableName = assert(function( div ) {
        // Inject content
        div.id = expando + 0;
        div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
        docElem.insertBefore( div, docElem.firstChild );

        // Test
        var pass = document.getElementsByName &&
            // buggy browsers will return fewer than the correct 2
            document.getElementsByName( expando ).length === 2 +
            // buggy browsers will return more than the correct 0
            document.getElementsByName( expando + 0 ).length;
        assertGetIdNotName = !document.getElementById( expando );

        // Cleanup
        docElem.removeChild( div );

        return pass;
    });

// If slice is not available, provide a backup
try {
    slice.call( docElem.childNodes, 0 )[0].nodeType;
} catch ( e ) {
    slice = function( i ) {
        var elem,
            results = [];
        for ( ; (elem = this[i]); i++ ) {
            results.push( elem );
        }
        return results;
    };
}

function Sizzle( selector, context, results, seed ) {
    results = results || [];
    context = context || document;
    var match, elem, xml, m,
        nodeType = context.nodeType;

    if ( !selector || typeof selector !== "string" ) {
        return results;
    }

    if ( nodeType !== 1 && nodeType !== 9 ) {
        return [];
    }

    xml = isXML( context );

    if ( !xml && !seed ) {
        if ( (match = rquickExpr.exec( selector )) ) {
            // Speed-up: Sizzle("#ID")
            if ( (m = match[1]) ) {
                if ( nodeType === 9 ) {
                    elem = context.getElementById( m );
                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document #6963
                    if ( elem && elem.parentNode ) {
                        // Handle the case where IE, Opera, and Webkit return items
                        // by name instead of ID
                        if ( elem.id === m ) {
                            results.push( elem );
                            return results;
                        }
                    } else {
                        return results;
                    }
                } else {
                    // Context is not a document
                    if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
                        contains( context, elem ) && elem.id === m ) {
                        results.push( elem );
                        return results;
                    }
                }

            // Speed-up: Sizzle("TAG")
            } else if ( match[2] ) {
                push.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );
                return results;

            // Speed-up: Sizzle(".CLASS")
            } else if ( (m = match[3]) && assertUsableClassName && context.getElementsByClassName ) {
                push.apply( results, slice.call(context.getElementsByClassName( m ), 0) );
                return results;
            }
        }
    }

    // All others
    return select( selector.replace( rtrim, "$1" ), context, results, seed, xml );
}

Sizzle.matches = function( expr, elements ) {
    return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
    return Sizzle( expr, null, null, [ elem ] ).length > 0;
};

// Returns a function to use in pseudos for input types
function createInputPseudo( type ) {
    return function( elem ) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
    };
}

// Returns a function to use in pseudos for buttons
function createButtonPseudo( type ) {
    return function( elem ) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
    };
}

// Returns a function to use in pseudos for positionals
function createPositionalPseudo( fn ) {
    return markFunction(function( argument ) {
        argument = +argument;
        return markFunction(function( seed, matches ) {
            var j,
                matchIndexes = fn( [], seed.length, argument ),
                i = matchIndexes.length;

            // Match elements found at the specified indexes
            while ( i-- ) {
                if ( seed[ (j = matchIndexes[i]) ] ) {
                    seed[j] = !(matches[j] = seed[j]);
                }
            }
        });
    });
}

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
    var node,
        ret = "",
        i = 0,
        nodeType = elem.nodeType;

    if ( nodeType ) {
        if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
            // Use textContent for elements
            // innerText usage removed for consistency of new lines (see #11153)
            if ( typeof elem.textContent === "string" ) {
                return elem.textContent;
            } else {
                // Traverse its children
                for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                    ret += getText( elem );
                }
            }
        } else if ( nodeType === 3 || nodeType === 4 ) {
            return elem.nodeValue;
        }
        // Do not include comment or processing instruction nodes
    } else {

        // If no nodeType, this is expected to be an array
        for ( ; (node = elem[i]); i++ ) {
            // Do not traverse comment nodes
            ret += getText( node );
        }
    }
    return ret;
};

isXML = Sizzle.isXML = function( elem ) {
    // documentElement is verified for cases where it doesn't yet exist
    // (such as loading iframes in IE - #4833)
    var documentElement = elem && (elem.ownerDocument || elem).documentElement;
    return documentElement ? documentElement.nodeName !== "HTML" : false;
};

// Element contains another
contains = Sizzle.contains = docElem.contains ?
    function( a, b ) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!( bup && bup.nodeType === 1 && adown.contains && adown.contains(bup) );
    } :
    docElem.compareDocumentPosition ?
    function( a, b ) {
        return b && !!( a.compareDocumentPosition( b ) & 16 );
    } :
    function( a, b ) {
        while ( (b = b.parentNode) ) {
            if ( b === a ) {
                return true;
            }
        }
        return false;
    };

Sizzle.attr = function( elem, name ) {
    var val,
        xml = isXML( elem );

    if ( !xml ) {
        name = name.toLowerCase();
    }
    if ( (val = Expr.attrHandle[ name ]) ) {
        return val( elem );
    }
    if ( xml || assertAttributes ) {
        return elem.getAttribute( name );
    }
    val = elem.getAttributeNode( name );
    return val ?
        typeof elem[ name ] === "boolean" ?
            elem[ name ] ? name : null :
            val.specified ? val.value : null :
        null;
};

Expr = Sizzle.selectors = {

    // Can be adjusted by the user
    cacheLength: 50,

    createPseudo: markFunction,

    match: matchExpr,

    // IE6/7 return a modified href
    attrHandle: assertHrefNotNormalized ?
        {} :
        {
            "href": function( elem ) {
                return elem.getAttribute( "href", 2 );
            },
            "type": function( elem ) {
                return elem.getAttribute("type");
            }
        },

    find: {
        "ID": assertGetIdNotName ?
            function( id, context, xml ) {
                if ( typeof context.getElementById !== strundefined && !xml ) {
                    var m = context.getElementById( id );
                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document #6963
                    return m && m.parentNode ? [m] : [];
                }
            } :
            function( id, context, xml ) {
                if ( typeof context.getElementById !== strundefined && !xml ) {
                    var m = context.getElementById( id );

                    return m ?
                        m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
                            [m] :
                            undefined :
                        [];
                }
            },

        "TAG": assertTagNameNoComments ?
            function( tag, context ) {
                if ( typeof context.getElementsByTagName !== strundefined ) {
                    return context.getElementsByTagName( tag );
                }
            } :
            function( tag, context ) {
                var results = context.getElementsByTagName( tag );

                // Filter out possible comments
                if ( tag === "*" ) {
                    var elem,
                        tmp = [],
                        i = 0;

                    for ( ; (elem = results[i]); i++ ) {
                        if ( elem.nodeType === 1 ) {
                            tmp.push( elem );
                        }
                    }

                    return tmp;
                }
                return results;
            },

        "NAME": assertUsableName && function( tag, context ) {
            if ( typeof context.getElementsByName !== strundefined ) {
                return context.getElementsByName( name );
            }
        },

        "CLASS": assertUsableClassName && function( className, context, xml ) {
            if ( typeof context.getElementsByClassName !== strundefined && !xml ) {
                return context.getElementsByClassName( className );
            }
        }
    },

    relative: {
        ">": { dir: "parentNode", first: true },
        " ": { dir: "parentNode" },
        "+": { dir: "previousSibling", first: true },
        "~": { dir: "previousSibling" }
    },

    preFilter: {
        "ATTR": function( match ) {
            match[1] = match[1].replace( rbackslash, "" );

            // Move the given value to match[3] whether quoted or unquoted
            match[3] = ( match[4] || match[5] || "" ).replace( rbackslash, "" );

            if ( match[2] === "~=" ) {
                match[3] = " " + match[3] + " ";
            }

            return match.slice( 0, 4 );
        },

        "CHILD": function( match ) {
            /* matches from matchExpr["CHILD"]
                1 type (only|nth|...)
                2 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                3 xn-component of xn+y argument ([+-]?\d*n|)
                4 sign of xn-component
                5 x of xn-component
                6 sign of y-component
                7 y of y-component
            */
            match[1] = match[1].toLowerCase();

            if ( match[1] === "nth" ) {
                // nth-child requires argument
                if ( !match[2] ) {
                    Sizzle.error( match[0] );
                }

                // numeric x and y parameters for Expr.filter.CHILD
                // remember that false/true cast respectively to 0/1
                match[3] = +( match[3] ? match[4] + (match[5] || 1) : 2 * ( match[2] === "even" || match[2] === "odd" ) );
                match[4] = +( ( match[6] + match[7] ) || match[2] === "odd" );

            // other types prohibit arguments
            } else if ( match[2] ) {
                Sizzle.error( match[0] );
            }

            return match;
        },

        "PSEUDO": function( match ) {
            var unquoted, excess;
            if ( matchExpr["CHILD"].test( match[0] ) ) {
                return null;
            }

            if ( match[3] ) {
                match[2] = match[3];
            } else if ( (unquoted = match[4]) ) {
                // Only check arguments that contain a pseudo
                if ( rpseudo.test(unquoted) &&
                    // Get excess from tokenize (recursively)
                    (excess = tokenize( unquoted, true )) &&
                    // advance to the next closing parenthesis
                    (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

                    // excess is a negative index
                    unquoted = unquoted.slice( 0, excess );
                    match[0] = match[0].slice( 0, excess );
                }
                match[2] = unquoted;
            }

            // Return only captures needed by the pseudo filter method (type and argument)
            return match.slice( 0, 3 );
        }
    },

    filter: {
        "ID": assertGetIdNotName ?
            function( id ) {
                id = id.replace( rbackslash, "" );
                return function( elem ) {
                    return elem.getAttribute("id") === id;
                };
            } :
            function( id ) {
                id = id.replace( rbackslash, "" );
                return function( elem ) {
                    var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                    return node && node.value === id;
                };
            },

        "TAG": function( nodeName ) {
            if ( nodeName === "*" ) {
                return function() { return true; };
            }
            nodeName = nodeName.replace( rbackslash, "" ).toLowerCase();

            return function( elem ) {
                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
            };
        },

        "CLASS": function( className ) {
            var pattern = classCache[ expando ][ className + " " ];

            return pattern ||
                (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
                classCache( className, function( elem ) {
                    return pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "" );
                });
        },

        "ATTR": function( name, operator, check ) {
            return function( elem, context ) {
                var result = Sizzle.attr( elem, name );

                if ( result == null ) {
                    return operator === "!=";
                }
                if ( !operator ) {
                    return true;
                }

                result += "";

                return operator === "=" ? result === check :
                    operator === "!=" ? result !== check :
                    operator === "^=" ? check && result.indexOf( check ) === 0 :
                    operator === "*=" ? check && result.indexOf( check ) > -1 :
                    operator === "$=" ? check && result.substr( result.length - check.length ) === check :
                    operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
                    operator === "|=" ? result === check || result.substr( 0, check.length + 1 ) === check + "-" :
                    false;
            };
        },

        "CHILD": function( type, argument, first, last ) {

            if ( type === "nth" ) {
                return function( elem ) {
                    var node, diff,
                        parent = elem.parentNode;

                    if ( first === 1 && last === 0 ) {
                        return true;
                    }

                    if ( parent ) {
                        diff = 0;
                        for ( node = parent.firstChild; node; node = node.nextSibling ) {
                            if ( node.nodeType === 1 ) {
                                diff++;
                                if ( elem === node ) {
                                    break;
                                }
                            }
                        }
                    }

                    // Incorporate the offset (or cast to NaN), then check against cycle size
                    diff -= last;
                    return diff === first || ( diff % first === 0 && diff / first >= 0 );
                };
            }

            return function( elem ) {
                var node = elem;

                switch ( type ) {
                    case "only":
                    case "first":
                        while ( (node = node.previousSibling) ) {
                            if ( node.nodeType === 1 ) {
                                return false;
                            }
                        }

                        if ( type === "first" ) {
                            return true;
                        }

                        node = elem;

                        /* falls through */
                    case "last":
                        while ( (node = node.nextSibling) ) {
                            if ( node.nodeType === 1 ) {
                                return false;
                            }
                        }

                        return true;
                }
            };
        },

        "PSEUDO": function( pseudo, argument ) {
            // pseudo-class names are case-insensitive
            // http://www.w3.org/TR/selectors/#pseudo-classes
            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
            // Remember that setFilters inherits from pseudos
            var args,
                fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                    Sizzle.error( "unsupported pseudo: " + pseudo );

            // The user may use createPseudo to indicate that
            // arguments are needed to create the filter function
            // just as Sizzle does
            if ( fn[ expando ] ) {
                return fn( argument );
            }

            // But maintain support for old signatures
            if ( fn.length > 1 ) {
                args = [ pseudo, pseudo, "", argument ];
                return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                    markFunction(function( seed, matches ) {
                        var idx,
                            matched = fn( seed, argument ),
                            i = matched.length;
                        while ( i-- ) {
                            idx = indexOf.call( seed, matched[i] );
                            seed[ idx ] = !( matches[ idx ] = matched[i] );
                        }
                    }) :
                    function( elem ) {
                        return fn( elem, 0, args );
                    };
            }

            return fn;
        }
    },

    pseudos: {
        "not": markFunction(function( selector ) {
            // Trim the selector passed to compile
            // to avoid treating leading and trailing
            // spaces as combinators
            var input = [],
                results = [],
                matcher = compile( selector.replace( rtrim, "$1" ) );

            return matcher[ expando ] ?
                markFunction(function( seed, matches, context, xml ) {
                    var elem,
                        unmatched = matcher( seed, null, xml, [] ),
                        i = seed.length;

                    // Match elements unmatched by `matcher`
                    while ( i-- ) {
                        if ( (elem = unmatched[i]) ) {
                            seed[i] = !(matches[i] = elem);
                        }
                    }
                }) :
                function( elem, context, xml ) {
                    input[0] = elem;
                    matcher( input, null, xml, results );
                    return !results.pop();
                };
        }),

        "has": markFunction(function( selector ) {
            return function( elem ) {
                return Sizzle( selector, elem ).length > 0;
            };
        }),

        "contains": markFunction(function( text ) {
            return function( elem ) {
                return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
            };
        }),

        "enabled": function( elem ) {
            return elem.disabled === false;
        },

        "disabled": function( elem ) {
            return elem.disabled === true;
        },

        "checked": function( elem ) {
            // In CSS3, :checked should return both checked and selected elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            var nodeName = elem.nodeName.toLowerCase();
            return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
        },

        "selected": function( elem ) {
            // Accessing this property makes selected-by-default
            // options in Safari work properly
            if ( elem.parentNode ) {
                elem.parentNode.selectedIndex;
            }

            return elem.selected === true;
        },

        "parent": function( elem ) {
            return !Expr.pseudos["empty"]( elem );
        },

        "empty": function( elem ) {
            // http://www.w3.org/TR/selectors/#empty-pseudo
            // :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
            //   not comment, processing instructions, or others
            // Thanks to Diego Perini for the nodeName shortcut
            //   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
            var nodeType;
            elem = elem.firstChild;
            while ( elem ) {
                if ( elem.nodeName > "@" || (nodeType = elem.nodeType) === 3 || nodeType === 4 ) {
                    return false;
                }
                elem = elem.nextSibling;
            }
            return true;
        },

        "header": function( elem ) {
            return rheader.test( elem.nodeName );
        },

        "text": function( elem ) {
            var type, attr;
            // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
            // use getAttribute instead to test this case
            return elem.nodeName.toLowerCase() === "input" &&
                (type = elem.type) === "text" &&
                ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === type );
        },

        // Input types
        "radio": createInputPseudo("radio"),
        "checkbox": createInputPseudo("checkbox"),
        "file": createInputPseudo("file"),
        "password": createInputPseudo("password"),
        "image": createInputPseudo("image"),

        "submit": createButtonPseudo("submit"),
        "reset": createButtonPseudo("reset"),

        "button": function( elem ) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === "button" || name === "button";
        },

        "input": function( elem ) {
            return rinputs.test( elem.nodeName );
        },

        "focus": function( elem ) {
            var doc = elem.ownerDocument;
            return elem === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },

        "active": function( elem ) {
            return elem === elem.ownerDocument.activeElement;
        },

        // Positional types
        "first": createPositionalPseudo(function() {
            return [ 0 ];
        }),

        "last": createPositionalPseudo(function( matchIndexes, length ) {
            return [ length - 1 ];
        }),

        "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
            return [ argument < 0 ? argument + length : argument ];
        }),

        "even": createPositionalPseudo(function( matchIndexes, length ) {
            for ( var i = 0; i < length; i += 2 ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        }),

        "odd": createPositionalPseudo(function( matchIndexes, length ) {
            for ( var i = 1; i < length; i += 2 ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        }),

        "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
            for ( var i = argument < 0 ? argument + length : argument; --i >= 0; ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        }),

        "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
            for ( var i = argument < 0 ? argument + length : argument; ++i < length; ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        })
    }
};

function siblingCheck( a, b, ret ) {
    if ( a === b ) {
        return ret;
    }

    var cur = a.nextSibling;

    while ( cur ) {
        if ( cur === b ) {
            return -1;
        }

        cur = cur.nextSibling;
    }

    return 1;
}

sortOrder = docElem.compareDocumentPosition ?
    function( a, b ) {
        if ( a === b ) {
            hasDuplicate = true;
            return 0;
        }

        return ( !a.compareDocumentPosition || !b.compareDocumentPosition ?
            a.compareDocumentPosition :
            a.compareDocumentPosition(b) & 4
        ) ? -1 : 1;
    } :
    function( a, b ) {
        // The nodes are identical, we can exit early
        if ( a === b ) {
            hasDuplicate = true;
            return 0;

        // Fallback to using sourceIndex (in IE) if it's available on both nodes
        } else if ( a.sourceIndex && b.sourceIndex ) {
            return a.sourceIndex - b.sourceIndex;
        }

        var al, bl,
            ap = [],
            bp = [],
            aup = a.parentNode,
            bup = b.parentNode,
            cur = aup;

        // If the nodes are siblings (or identical) we can do a quick check
        if ( aup === bup ) {
            return siblingCheck( a, b );

        // If no parents were found then the nodes are disconnected
        } else if ( !aup ) {
            return -1;

        } else if ( !bup ) {
            return 1;
        }

        // Otherwise they're somewhere else in the tree so we need
        // to build up a full list of the parentNodes for comparison
        while ( cur ) {
            ap.unshift( cur );
            cur = cur.parentNode;
        }

        cur = bup;

        while ( cur ) {
            bp.unshift( cur );
            cur = cur.parentNode;
        }

        al = ap.length;
        bl = bp.length;

        // Start walking down the tree looking for a discrepancy
        for ( var i = 0; i < al && i < bl; i++ ) {
            if ( ap[i] !== bp[i] ) {
                return siblingCheck( ap[i], bp[i] );
            }
        }

        // We ended someplace up the tree so do a sibling check
        return i === al ?
            siblingCheck( a, bp[i], -1 ) :
            siblingCheck( ap[i], b, 1 );
    };

// Always assume the presence of duplicates if sort doesn't
// pass them to our comparison function (as in Google Chrome).
[0, 0].sort( sortOrder );
baseHasDuplicate = !hasDuplicate;

// Document sorting and removing duplicates
Sizzle.uniqueSort = function( results ) {
    var elem,
        duplicates = [],
        i = 1,
        j = 0;

    hasDuplicate = baseHasDuplicate;
    results.sort( sortOrder );

    if ( hasDuplicate ) {
        for ( ; (elem = results[i]); i++ ) {
            if ( elem === results[ i - 1 ] ) {
                j = duplicates.push( i );
            }
        }
        while ( j-- ) {
            results.splice( duplicates[ j ], 1 );
        }
    }

    return results;
};

Sizzle.error = function( msg ) {
    throw new Error( "Syntax error, unrecognized expression: " + msg );
};

function tokenize( selector, parseOnly ) {
    var matched, match, tokens, type,
        soFar, groups, preFilters,
        cached = tokenCache[ expando ][ selector + " " ];

    if ( cached ) {
        return parseOnly ? 0 : cached.slice( 0 );
    }

    soFar = selector;
    groups = [];
    preFilters = Expr.preFilter;

    while ( soFar ) {

        // Comma and first run
        if ( !matched || (match = rcomma.exec( soFar )) ) {
            if ( match ) {
                // Don't consume trailing commas as valid
                soFar = soFar.slice( match[0].length ) || soFar;
            }
            groups.push( tokens = [] );
        }

        matched = false;

        // Combinators
        if ( (match = rcombinators.exec( soFar )) ) {
            tokens.push( matched = new Token( match.shift() ) );
            soFar = soFar.slice( matched.length );

            // Cast descendant combinators to space
            matched.type = match[0].replace( rtrim, " " );
        }

        // Filters
        for ( type in Expr.filter ) {
            if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
                (match = preFilters[ type ]( match ))) ) {

                tokens.push( matched = new Token( match.shift() ) );
                soFar = soFar.slice( matched.length );
                matched.type = type;
                matched.matches = match;
            }
        }

        if ( !matched ) {
            break;
        }
    }

    // Return the length of the invalid excess
    // if we're just parsing
    // Otherwise, throw an error or return tokens
    return parseOnly ?
        soFar.length :
        soFar ?
            Sizzle.error( selector ) :
            // Cache the tokens
            tokenCache( selector, groups ).slice( 0 );
}

function addCombinator( matcher, combinator, base ) {
    var dir = combinator.dir,
        checkNonElements = base && combinator.dir === "parentNode",
        doneName = done++;

    return combinator.first ?
        // Check against closest ancestor/preceding element
        function( elem, context, xml ) {
            while ( (elem = elem[ dir ]) ) {
                if ( checkNonElements || elem.nodeType === 1  ) {
                    return matcher( elem, context, xml );
                }
            }
        } :

        // Check against all ancestor/preceding elements
        function( elem, context, xml ) {
            // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
            if ( !xml ) {
                var cache,
                    dirkey = dirruns + " " + doneName + " ",
                    cachedkey = dirkey + cachedruns;
                while ( (elem = elem[ dir ]) ) {
                    if ( checkNonElements || elem.nodeType === 1 ) {
                        if ( (cache = elem[ expando ]) === cachedkey ) {
                            return elem.sizset;
                        } else if ( typeof cache === "string" && cache.indexOf(dirkey) === 0 ) {
                            if ( elem.sizset ) {
                                return elem;
                            }
                        } else {
                            elem[ expando ] = cachedkey;
                            if ( matcher( elem, context, xml ) ) {
                                elem.sizset = true;
                                return elem;
                            }
                            elem.sizset = false;
                        }
                    }
                }
            } else {
                while ( (elem = elem[ dir ]) ) {
                    if ( checkNonElements || elem.nodeType === 1 ) {
                        if ( matcher( elem, context, xml ) ) {
                            return elem;
                        }
                    }
                }
            }
        };
}

function elementMatcher( matchers ) {
    return matchers.length > 1 ?
        function( elem, context, xml ) {
            var i = matchers.length;
            while ( i-- ) {
                if ( !matchers[i]( elem, context, xml ) ) {
                    return false;
                }
            }
            return true;
        } :
        matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
    var elem,
        newUnmatched = [],
        i = 0,
        len = unmatched.length,
        mapped = map != null;

    for ( ; i < len; i++ ) {
        if ( (elem = unmatched[i]) ) {
            if ( !filter || filter( elem, context, xml ) ) {
                newUnmatched.push( elem );
                if ( mapped ) {
                    map.push( i );
                }
            }
        }
    }

    return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
    if ( postFilter && !postFilter[ expando ] ) {
        postFilter = setMatcher( postFilter );
    }
    if ( postFinder && !postFinder[ expando ] ) {
        postFinder = setMatcher( postFinder, postSelector );
    }
    return markFunction(function( seed, results, context, xml ) {
        var temp, i, elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,

            // Get initial elements from seed or context
            elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

            // Prefilter to get matcher input, preserving a map for seed-results synchronization
            matcherIn = preFilter && ( seed || !selector ) ?
                condense( elems, preMap, preFilter, context, xml ) :
                elems,

            matcherOut = matcher ?
                // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                    // ...intermediate processing is necessary
                    [] :

                    // ...otherwise use results directly
                    results :
                matcherIn;

        // Find primary matches
        if ( matcher ) {
            matcher( matcherIn, matcherOut, context, xml );
        }

        // Apply postFilter
        if ( postFilter ) {
            temp = condense( matcherOut, postMap );
            postFilter( temp, [], context, xml );

            // Un-match failing elements by moving them back to matcherIn
            i = temp.length;
            while ( i-- ) {
                if ( (elem = temp[i]) ) {
                    matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                }
            }
        }

        if ( seed ) {
            if ( postFinder || preFilter ) {
                if ( postFinder ) {
                    // Get the final matcherOut by condensing this intermediate into postFinder contexts
                    temp = [];
                    i = matcherOut.length;
                    while ( i-- ) {
                        if ( (elem = matcherOut[i]) ) {
                            // Restore matcherIn since elem is not yet a final match
                            temp.push( (matcherIn[i] = elem) );
                        }
                    }
                    postFinder( null, (matcherOut = []), temp, xml );
                }

                // Move matched elements from seed to results to keep them synchronized
                i = matcherOut.length;
                while ( i-- ) {
                    if ( (elem = matcherOut[i]) &&
                        (temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

                        seed[temp] = !(results[temp] = elem);
                    }
                }
            }

        // Add elements to results, through postFinder if defined
        } else {
            matcherOut = condense(
                matcherOut === results ?
                    matcherOut.splice( preexisting, matcherOut.length ) :
                    matcherOut
            );
            if ( postFinder ) {
                postFinder( null, results, matcherOut, xml );
            } else {
                push.apply( results, matcherOut );
            }
        }
    });
}

function matcherFromTokens( tokens ) {
    var checkContext, matcher, j,
        len = tokens.length,
        leadingRelative = Expr.relative[ tokens[0].type ],
        implicitRelative = leadingRelative || Expr.relative[" "],
        i = leadingRelative ? 1 : 0,

        // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator( function( elem ) {
            return elem === checkContext;
        }, implicitRelative, true ),
        matchAnyContext = addCombinator( function( elem ) {
            return indexOf.call( checkContext, elem ) > -1;
        }, implicitRelative, true ),
        matchers = [ function( elem, context, xml ) {
            return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                (checkContext = context).nodeType ?
                    matchContext( elem, context, xml ) :
                    matchAnyContext( elem, context, xml ) );
        } ];

    for ( ; i < len; i++ ) {
        if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
            matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
        } else {
            matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

            // Return special upon seeing a positional matcher
            if ( matcher[ expando ] ) {
                // Find the next relative operator (if any) for proper handling
                j = ++i;
                for ( ; j < len; j++ ) {
                    if ( Expr.relative[ tokens[j].type ] ) {
                        break;
                    }
                }
                return setMatcher(
                    i > 1 && elementMatcher( matchers ),
                    i > 1 && tokens.slice( 0, i - 1 ).join("").replace( rtrim, "$1" ),
                    matcher,
                    i < j && matcherFromTokens( tokens.slice( i, j ) ),
                    j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
                    j < len && tokens.join("")
                );
            }
            matchers.push( matcher );
        }
    }

    return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
    var bySet = setMatchers.length > 0,
        byElement = elementMatchers.length > 0,
        superMatcher = function( seed, context, xml, results, expandContext ) {
            var elem, j, matcher,
                setMatched = [],
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                outermost = expandContext != null,
                contextBackup = outermostContext,
                // We must always have either seed elements or context
                elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),
                // Nested matchers should use non-integer dirruns
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.E);

            if ( outermost ) {
                outermostContext = context !== document && context;
                cachedruns = superMatcher.el;
            }

            // Add elements passing elementMatchers directly to results
            for ( ; (elem = elems[i]) != null; i++ ) {
                if ( byElement && elem ) {
                    for ( j = 0; (matcher = elementMatchers[j]); j++ ) {
                        if ( matcher( elem, context, xml ) ) {
                            results.push( elem );
                            break;
                        }
                    }
                    if ( outermost ) {
                        dirruns = dirrunsUnique;
                        cachedruns = ++superMatcher.el;
                    }
                }

                // Track unmatched elements for set filters
                if ( bySet ) {
                    // They will have gone through all possible matchers
                    if ( (elem = !matcher && elem) ) {
                        matchedCount--;
                    }

                    // Lengthen the array for every element, matched or not
                    if ( seed ) {
                        unmatched.push( elem );
                    }
                }
            }

            // Apply set filters to unmatched elements
            matchedCount += i;
            if ( bySet && i !== matchedCount ) {
                for ( j = 0; (matcher = setMatchers[j]); j++ ) {
                    matcher( unmatched, setMatched, context, xml );
                }

                if ( seed ) {
                    // Reintegrate element matches to eliminate the need for sorting
                    if ( matchedCount > 0 ) {
                        while ( i-- ) {
                            if ( !(unmatched[i] || setMatched[i]) ) {
                                setMatched[i] = pop.call( results );
                            }
                        }
                    }

                    // Discard index placeholder values to get only actual matches
                    setMatched = condense( setMatched );
                }

                // Add matches to results
                push.apply( results, setMatched );

                // Seedless set matches succeeding multiple successful matchers stipulate sorting
                if ( outermost && !seed && setMatched.length > 0 &&
                    ( matchedCount + setMatchers.length ) > 1 ) {

                    Sizzle.uniqueSort( results );
                }
            }

            // Override manipulation of globals by nested matchers
            if ( outermost ) {
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
            }

            return unmatched;
        };

    superMatcher.el = 0;
    return bySet ?
        markFunction( superMatcher ) :
        superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
    var i,
        setMatchers = [],
        elementMatchers = [],
        cached = compilerCache[ expando ][ selector + " " ];

    if ( !cached ) {
        // Generate a function of recursive functions that can be used to check each element
        if ( !group ) {
            group = tokenize( selector );
        }
        i = group.length;
        while ( i-- ) {
            cached = matcherFromTokens( group[i] );
            if ( cached[ expando ] ) {
                setMatchers.push( cached );
            } else {
                elementMatchers.push( cached );
            }
        }

        // Cache the compiled function
        cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
    }
    return cached;
};

function multipleContexts( selector, contexts, results ) {
    var i = 0,
        len = contexts.length;
    for ( ; i < len; i++ ) {
        Sizzle( selector, contexts[i], results );
    }
    return results;
}

function select( selector, context, results, seed, xml ) {
    var i, tokens, token, type, find,
        match = tokenize( selector ),
        j = match.length;

    if ( !seed ) {
        // Try to minimize operations if there is only one group
        if ( match.length === 1 ) {

            // Take a shortcut and set the context if the root selector is an ID
            tokens = match[0] = match[0].slice( 0 );
            if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                    context.nodeType === 9 && !xml &&
                    Expr.relative[ tokens[1].type ] ) {

                context = Expr.find["ID"]( token.matches[0].replace( rbackslash, "" ), context, xml )[0];
                if ( !context ) {
                    return results;
                }

                selector = selector.slice( tokens.shift().length );
            }

            // Fetch a seed set for right-to-left matching
            for ( i = matchExpr["POS"].test( selector ) ? -1 : tokens.length - 1; i >= 0; i-- ) {
                token = tokens[i];

                // Abort if we hit a combinator
                if ( Expr.relative[ (type = token.type) ] ) {
                    break;
                }
                if ( (find = Expr.find[ type ]) ) {
                    // Search, expanding context for leading sibling combinators
                    if ( (seed = find(
                        token.matches[0].replace( rbackslash, "" ),
                        rsibling.test( tokens[0].type ) && context.parentNode || context,
                        xml
                    )) ) {

                        // If seed is empty or no tokens remain, we can return early
                        tokens.splice( i, 1 );
                        selector = seed.length && tokens.join("");
                        if ( !selector ) {
                            push.apply( results, slice.call( seed, 0 ) );
                            return results;
                        }

                        break;
                    }
                }
            }
        }
    }

    // Compile and execute a filtering function
    // Provide `match` to avoid retokenization if we modified the selector above
    compile( selector, match )(
        seed,
        context,
        xml,
        results,
        rsibling.test( selector )
    );
    return results;
}

if ( document.querySelectorAll ) {
    (function() {
        var disconnectedMatch,
            oldSelect = select,
            rescape = /'|\\/g,
            rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,

            // qSa(:focus) reports false when true (Chrome 21), no need to also add to buggyMatches since matches checks buggyQSA
            // A support test would require too much code (would include document ready)
            rbuggyQSA = [ ":focus" ],

            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
            // A support test would require too much code (would include document ready)
            // just skip matchesSelector for :active
            rbuggyMatches = [ ":active" ],
            matches = docElem.matchesSelector ||
                docElem.mozMatchesSelector ||
                docElem.webkitMatchesSelector ||
                docElem.oMatchesSelector ||
                docElem.msMatchesSelector;

        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function( div ) {
            // Select is set to empty string on purpose
            // This is to test IE's treatment of not explictly
            // setting a boolean content attribute,
            // since its presence should be enough
            // http://bugs.jquery.com/ticket/12359
            div.innerHTML = "<select><option selected=''></option></select>";

            // IE8 - Some boolean attributes are not treated correctly
            if ( !div.querySelectorAll("[selected]").length ) {
                rbuggyQSA.push( "\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)" );
            }

            // Webkit/Opera - :checked should return selected option elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            // IE8 throws error here (do not put tests after this one)
            if ( !div.querySelectorAll(":checked").length ) {
                rbuggyQSA.push(":checked");
            }
        });

        assert(function( div ) {

            // Opera 10-12/IE9 - ^= $= *= and empty values
            // Should not select anything
            div.innerHTML = "<p test=''></p>";
            if ( div.querySelectorAll("[test^='']").length ) {
                rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\"\"|'')" );
            }

            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
            // IE8 throws error here (do not put tests after this one)
            div.innerHTML = "<input type='hidden'/>";
            if ( !div.querySelectorAll(":enabled").length ) {
                rbuggyQSA.push(":enabled", ":disabled");
            }
        });

        // rbuggyQSA always contains :focus, so no need for a length check
        rbuggyQSA = /* rbuggyQSA.length && */ new RegExp( rbuggyQSA.join("|") );

        select = function( selector, context, results, seed, xml ) {
            // Only use querySelectorAll when not filtering,
            // when this is not xml,
            // and when no QSA bugs apply
            if ( !seed && !xml && !rbuggyQSA.test( selector ) ) {
                var groups, i,
                    old = true,
                    nid = expando,
                    newContext = context,
                    newSelector = context.nodeType === 9 && selector;

                // qSA works strangely on Element-rooted queries
                // We can work around this by specifying an extra ID on the root
                // and working up from there (Thanks to Andrew Dupont for the technique)
                // IE 8 doesn't work on object elements
                if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
                    groups = tokenize( selector );

                    if ( (old = context.getAttribute("id")) ) {
                        nid = old.replace( rescape, "\\$&" );
                    } else {
                        context.setAttribute( "id", nid );
                    }
                    nid = "[id='" + nid + "'] ";

                    i = groups.length;
                    while ( i-- ) {
                        groups[i] = nid + groups[i].join("");
                    }
                    newContext = rsibling.test( selector ) && context.parentNode || context;
                    newSelector = groups.join(",");
                }

                if ( newSelector ) {
                    try {
                        push.apply( results, slice.call( newContext.querySelectorAll(
                            newSelector
                        ), 0 ) );
                        return results;
                    } catch(qsaError) {
                    } finally {
                        if ( !old ) {
                            context.removeAttribute("id");
                        }
                    }
                }
            }

            return oldSelect( selector, context, results, seed, xml );
        };

        if ( matches ) {
            assert(function( div ) {
                // Check to see if it's possible to do matchesSelector
                // on a disconnected node (IE 9)
                disconnectedMatch = matches.call( div, "div" );

                // This should fail with an exception
                // Gecko does not error, returns false instead
                try {
                    matches.call( div, "[test!='']:sizzle" );
                    rbuggyMatches.push( "!=", pseudos );
                } catch ( e ) {}
            });

            // rbuggyMatches always contains :active and :focus, so no need for a length check
            rbuggyMatches = /* rbuggyMatches.length && */ new RegExp( rbuggyMatches.join("|") );

            Sizzle.matchesSelector = function( elem, expr ) {
                // Make sure that attribute selectors are quoted
                expr = expr.replace( rattributeQuotes, "='$1']" );

                // rbuggyMatches always contains :active, so no need for an existence check
                if ( !isXML( elem ) && !rbuggyMatches.test( expr ) && !rbuggyQSA.test( expr ) ) {
                    try {
                        var ret = matches.call( elem, expr );

                        // IE 9's matchesSelector returns false on disconnected nodes
                        if ( ret || disconnectedMatch ||
                                // As well, disconnected nodes are said to be in a document
                                // fragment in IE 9
                                elem.document && elem.document.nodeType !== 11 ) {
                            return ret;
                        }
                    } catch(e) {}
                }

                return Sizzle( expr, null, null, [ elem ] ).length > 0;
            };
        }
    })();
}

// Deprecated
Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Back-compat
function setFilters() {}
Expr.filters = setFilters.prototype = Expr.pseudos;
Expr.setFilters = new setFilters();

// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})( window );
var runtil = /Until$/,
    rparentsprev = /^(?:parents|prev(?:Until|All))/,
    isSimple = /^.[^:#\[\.,]*$/,
    rneedsContext = jQuery.expr.match.needsContext,
    // methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };

jQuery.fn.extend({
    find: function( selector ) {
        var i, l, length, n, r, ret,
            self = this;

        if ( typeof selector !== "string" ) {
            return jQuery( selector ).filter(function() {
                for ( i = 0, l = self.length; i < l; i++ ) {
                    if ( jQuery.contains( self[ i ], this ) ) {
                        return true;
                    }
                }
            });
        }

        ret = this.pushStack( "", "find", selector );

        for ( i = 0, l = this.length; i < l; i++ ) {
            length = ret.length;
            jQuery.find( selector, this[i], ret );

            if ( i > 0 ) {
                // Make sure that the results are unique
                for ( n = length; n < ret.length; n++ ) {
                    for ( r = 0; r < length; r++ ) {
                        if ( ret[r] === ret[n] ) {
                            ret.splice(n--, 1);
                            break;
                        }
                    }
                }
            }
        }

        return ret;
    },

    has: function( target ) {
        var i,
            targets = jQuery( target, this ),
            len = targets.length;

        return this.filter(function() {
            for ( i = 0; i < len; i++ ) {
                if ( jQuery.contains( this, targets[i] ) ) {
                    return true;
                }
            }
        });
    },

    not: function( selector ) {
        return this.pushStack( winnow(this, selector, false), "not", selector);
    },

    filter: function( selector ) {
        return this.pushStack( winnow(this, selector, true), "filter", selector );
    },

    is: function( selector ) {
        return !!selector && (
            typeof selector === "string" ?
                // If this is a positional/relative selector, check membership in the returned set
                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                rneedsContext.test( selector ) ?
                    jQuery( selector, this.context ).index( this[0] ) >= 0 :
                    jQuery.filter( selector, this ).length > 0 :
                this.filter( selector ).length > 0 );
    },

    closest: function( selectors, context ) {
        var cur,
            i = 0,
            l = this.length,
            ret = [],
            pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
                jQuery( selectors, context || this.context ) :
                0;

        for ( ; i < l; i++ ) {
            cur = this[i];

            while ( cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11 ) {
                if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
                    ret.push( cur );
                    break;
                }
                cur = cur.parentNode;
            }
        }

        ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

        return this.pushStack( ret, "closest", selectors );
    },

    // Determine the position of an element within
    // the matched set of elements
    index: function( elem ) {

        // No argument, return index in parent
        if ( !elem ) {
            return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
        }

        // index in selector
        if ( typeof elem === "string" ) {
            return jQuery.inArray( this[0], jQuery( elem ) );
        }

        // Locate the position of the desired element
        return jQuery.inArray(
            // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem, this );
    },

    add: function( selector, context ) {
        var set = typeof selector === "string" ?
                jQuery( selector, context ) :
                jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
            all = jQuery.merge( this.get(), set );

        return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
            all :
            jQuery.unique( all ) );
    },

    addBack: function( selector ) {
        return this.add( selector == null ?
            this.prevObject : this.prevObject.filter(selector)
        );
    }
});

jQuery.fn.andSelf = jQuery.fn.addBack;

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
    return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

function sibling( cur, dir ) {
    do {
        cur = cur[ dir ];
    } while ( cur && cur.nodeType !== 1 );

    return cur;
}

jQuery.each({
    parent: function( elem ) {
        var parent = elem.parentNode;
        return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function( elem ) {
        return jQuery.dir( elem, "parentNode" );
    },
    parentsUntil: function( elem, i, until ) {
        return jQuery.dir( elem, "parentNode", until );
    },
    next: function( elem ) {
        return sibling( elem, "nextSibling" );
    },
    prev: function( elem ) {
        return sibling( elem, "previousSibling" );
    },
    nextAll: function( elem ) {
        return jQuery.dir( elem, "nextSibling" );
    },
    prevAll: function( elem ) {
        return jQuery.dir( elem, "previousSibling" );
    },
    nextUntil: function( elem, i, until ) {
        return jQuery.dir( elem, "nextSibling", until );
    },
    prevUntil: function( elem, i, until ) {
        return jQuery.dir( elem, "previousSibling", until );
    },
    siblings: function( elem ) {
        return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
    },
    children: function( elem ) {
        return jQuery.sibling( elem.firstChild );
    },
    contents: function( elem ) {
        return jQuery.nodeName( elem, "iframe" ) ?
            elem.contentDocument || elem.contentWindow.document :
            jQuery.merge( [], elem.childNodes );
    }
}, function( name, fn ) {
    jQuery.fn[ name ] = function( until, selector ) {
        var ret = jQuery.map( this, fn, until );

        if ( !runtil.test( name ) ) {
            selector = until;
        }

        if ( selector && typeof selector === "string" ) {
            ret = jQuery.filter( selector, ret );
        }

        ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

        if ( this.length > 1 && rparentsprev.test( name ) ) {
            ret = ret.reverse();
        }

        return this.pushStack( ret, name, core_slice.call( arguments ).join(",") );
    };
});

jQuery.extend({
    filter: function( expr, elems, not ) {
        if ( not ) {
            expr = ":not(" + expr + ")";
        }

        return elems.length === 1 ?
            jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
            jQuery.find.matches(expr, elems);
    },

    dir: function( elem, dir, until ) {
        var matched = [],
            cur = elem[ dir ];

        while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
            if ( cur.nodeType === 1 ) {
                matched.push( cur );
            }
            cur = cur[dir];
        }
        return matched;
    },

    sibling: function( n, elem ) {
        var r = [];

        for ( ; n; n = n.nextSibling ) {
            if ( n.nodeType === 1 && n !== elem ) {
                r.push( n );
            }
        }

        return r;
    }
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

    // Can't pass null or undefined to indexOf in Firefox 4
    // Set to 0 to skip string check
    qualifier = qualifier || 0;

    if ( jQuery.isFunction( qualifier ) ) {
        return jQuery.grep(elements, function( elem, i ) {
            var retVal = !!qualifier.call( elem, i, elem );
            return retVal === keep;
        });

    } else if ( qualifier.nodeType ) {
        return jQuery.grep(elements, function( elem, i ) {
            return ( elem === qualifier ) === keep;
        });

    } else if ( typeof qualifier === "string" ) {
        var filtered = jQuery.grep(elements, function( elem ) {
            return elem.nodeType === 1;
        });

        if ( isSimple.test( qualifier ) ) {
            return jQuery.filter(qualifier, filtered, !keep);
        } else {
            qualifier = jQuery.filter( qualifier, filtered );
        }
    }

    return jQuery.grep(elements, function( elem, i ) {
        return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
    });
}
function createSafeFragment( document ) {
    var list = nodeNames.split( "|" ),
    safeFrag = document.createDocumentFragment();

    if ( safeFrag.createElement ) {
        while ( list.length ) {
            safeFrag.createElement(
                list.pop()
            );
        }
    }
    return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
        "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
    rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
    rleadingWhitespace = /^\s+/,
    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
    rtagName = /<([\w:]+)/,
    rtbody = /<tbody/i,
    rhtml = /<|&#?\w+;/,
    rnoInnerhtml = /<(?:script|style|link)/i,
    rnocache = /<(?:script|object|embed|option|style)/i,
    rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
    rcheckableType = /^(?:checkbox|radio)$/,
    // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    rscriptType = /\/(java|ecma)script/i,
    rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,
    wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        legend: [ 1, "<fieldset>", "</fieldset>" ],
        thead: [ 1, "<table>", "</table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
        area: [ 1, "<map>", "</map>" ],
        _default: [ 0, "", "" ]
    },
    safeFragment = createSafeFragment( document ),
    fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
// unless wrapped in a div with non-breaking characters in front of it.
if ( !jQuery.support.htmlSerialize ) {
    wrapMap._default = [ 1, "X<div>", "</div>" ];
}

jQuery.fn.extend({
    text: function( value ) {
        return jQuery.access( this, function( value ) {
            return value === undefined ?
                jQuery.text( this ) :
                this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
        }, null, value, arguments.length );
    },

    wrapAll: function( html ) {
        if ( jQuery.isFunction( html ) ) {
            return this.each(function(i) {
                jQuery(this).wrapAll( html.call(this, i) );
            });
        }

        if ( this[0] ) {
            // The elements to wrap the target around
            var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

            if ( this[0].parentNode ) {
                wrap.insertBefore( this[0] );
            }

            wrap.map(function() {
                var elem = this;

                while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
                    elem = elem.firstChild;
                }

                return elem;
            }).append( this );
        }

        return this;
    },

    wrapInner: function( html ) {
        if ( jQuery.isFunction( html ) ) {
            return this.each(function(i) {
                jQuery(this).wrapInner( html.call(this, i) );
            });
        }

        return this.each(function() {
            var self = jQuery( this ),
                contents = self.contents();

            if ( contents.length ) {
                contents.wrapAll( html );

            } else {
                self.append( html );
            }
        });
    },

    wrap: function( html ) {
        var isFunction = jQuery.isFunction( html );

        return this.each(function(i) {
            jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
        });
    },

    unwrap: function() {
        return this.parent().each(function() {
            if ( !jQuery.nodeName( this, "body" ) ) {
                jQuery( this ).replaceWith( this.childNodes );
            }
        }).end();
    },

    append: function() {
        return this.domManip(arguments, true, function( elem ) {
            if ( this.nodeType === 1 || this.nodeType === 11 ) {
                this.appendChild( elem );
            }
        });
    },

    prepend: function() {
        return this.domManip(arguments, true, function( elem ) {
            if ( this.nodeType === 1 || this.nodeType === 11 ) {
                this.insertBefore( elem, this.firstChild );
            }
        });
    },

    before: function() {
        if ( !isDisconnected( this[0] ) ) {
            return this.domManip(arguments, false, function( elem ) {
                this.parentNode.insertBefore( elem, this );
            });
        }

        if ( arguments.length ) {
            var set = jQuery.clean( arguments );
            return this.pushStack( jQuery.merge( set, this ), "before", this.selector );
        }
    },

    after: function() {
        if ( !isDisconnected( this[0] ) ) {
            return this.domManip(arguments, false, function( elem ) {
                this.parentNode.insertBefore( elem, this.nextSibling );
            });
        }

        if ( arguments.length ) {
            var set = jQuery.clean( arguments );
            return this.pushStack( jQuery.merge( this, set ), "after", this.selector );
        }
    },

    // keepData is for internal use only--do not document
    remove: function( selector, keepData ) {
        var elem,
            i = 0;

        for ( ; (elem = this[i]) != null; i++ ) {
            if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
                if ( !keepData && elem.nodeType === 1 ) {
                    jQuery.cleanData( elem.getElementsByTagName("*") );
                    jQuery.cleanData( [ elem ] );
                }

                if ( elem.parentNode ) {
                    elem.parentNode.removeChild( elem );
                }
            }
        }

        return this;
    },

    empty: function() {
        var elem,
            i = 0;

        for ( ; (elem = this[i]) != null; i++ ) {
            // Remove element nodes and prevent memory leaks
            if ( elem.nodeType === 1 ) {
                jQuery.cleanData( elem.getElementsByTagName("*") );
            }

            // Remove any remaining nodes
            while ( elem.firstChild ) {
                elem.removeChild( elem.firstChild );
            }
        }

        return this;
    },

    clone: function( dataAndEvents, deepDataAndEvents ) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

        return this.map( function () {
            return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
        });
    },

    html: function( value ) {
        return jQuery.access( this, function( value ) {
            var elem = this[0] || {},
                i = 0,
                l = this.length;

            if ( value === undefined ) {
                return elem.nodeType === 1 ?
                    elem.innerHTML.replace( rinlinejQuery, "" ) :
                    undefined;
            }

            // See if we can take a shortcut and just use innerHTML
            if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
                ( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
                ( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
                !wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

                value = value.replace( rxhtmlTag, "<$1></$2>" );

                try {
                    for (; i < l; i++ ) {
                        // Remove element nodes and prevent memory leaks
                        elem = this[i] || {};
                        if ( elem.nodeType === 1 ) {
                            jQuery.cleanData( elem.getElementsByTagName( "*" ) );
                            elem.innerHTML = value;
                        }
                    }

                    elem = 0;

                // If using innerHTML throws an exception, use the fallback method
                } catch(e) {}
            }

            if ( elem ) {
                this.empty().append( value );
            }
        }, null, value, arguments.length );
    },

    replaceWith: function( value ) {
        if ( !isDisconnected( this[0] ) ) {
            // Make sure that the elements are removed from the DOM before they are inserted
            // this can help fix replacing a parent with child elements
            if ( jQuery.isFunction( value ) ) {
                return this.each(function(i) {
                    var self = jQuery(this), old = self.html();
                    self.replaceWith( value.call( this, i, old ) );
                });
            }

            if ( typeof value !== "string" ) {
                value = jQuery( value ).detach();
            }

            return this.each(function() {
                var next = this.nextSibling,
                    parent = this.parentNode;

                jQuery( this ).remove();

                if ( next ) {
                    jQuery(next).before( value );
                } else {
                    jQuery(parent).append( value );
                }
            });
        }

        return this.length ?
            this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
            this;
    },

    detach: function( selector ) {
        return this.remove( selector, true );
    },

    domManip: function( args, table, callback ) {

        // Flatten any nested arrays
        args = [].concat.apply( [], args );

        var results, first, fragment, iNoClone,
            i = 0,
            value = args[0],
            scripts = [],
            l = this.length;

        // We can't cloneNode fragments that contain checked, in WebKit
        if ( !jQuery.support.checkClone && l > 1 && typeof value === "string" && rchecked.test( value ) ) {
            return this.each(function() {
                jQuery(this).domManip( args, table, callback );
            });
        }

        if ( jQuery.isFunction(value) ) {
            return this.each(function(i) {
                var self = jQuery(this);
                args[0] = value.call( this, i, table ? self.html() : undefined );
                self.domManip( args, table, callback );
            });
        }

        if ( this[0] ) {
            results = jQuery.buildFragment( args, this, scripts );
            fragment = results.fragment;
            first = fragment.firstChild;

            if ( fragment.childNodes.length === 1 ) {
                fragment = first;
            }

            if ( first ) {
                table = table && jQuery.nodeName( first, "tr" );

                // Use the original fragment for the last item instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                // Fragments from the fragment cache must always be cloned and never used in place.
                for ( iNoClone = results.cacheable || l - 1; i < l; i++ ) {
                    callback.call(
                        table && jQuery.nodeName( this[i], "table" ) ?
                            findOrAppend( this[i], "tbody" ) :
                            this[i],
                        i === iNoClone ?
                            fragment :
                            jQuery.clone( fragment, true, true )
                    );
                }
            }

            // Fix #11809: Avoid leaking memory
            fragment = first = null;

            if ( scripts.length ) {
                jQuery.each( scripts, function( i, elem ) {
                    if ( elem.src ) {
                        if ( jQuery.ajax ) {
                            jQuery.ajax({
                                url: elem.src,
                                type: "GET",
                                dataType: "script",
                                async: false,
                                global: false,
                                "throws": true
                            });
                        } else {
                            jQuery.error("no ajax");
                        }
                    } else {
                        jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "" ) );
                    }

                    if ( elem.parentNode ) {
                        elem.parentNode.removeChild( elem );
                    }
                });
            }
        }

        return this;
    }
});

function findOrAppend( elem, tag ) {
    return elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );
}

function cloneCopyEvent( src, dest ) {

    if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
        return;
    }

    var type, i, l,
        oldData = jQuery._data( src ),
        curData = jQuery._data( dest, oldData ),
        events = oldData.events;

    if ( events ) {
        delete curData.handle;
        curData.events = {};

        for ( type in events ) {
            for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                jQuery.event.add( dest, type, events[ type ][ i ] );
            }
        }
    }

    // make the cloned public data object a copy from the original
    if ( curData.data ) {
        curData.data = jQuery.extend( {}, curData.data );
    }
}

function cloneFixAttributes( src, dest ) {
    var nodeName;

    // We do not need to do anything for non-Elements
    if ( dest.nodeType !== 1 ) {
        return;
    }

    // clearAttributes removes the attributes, which we don't want,
    // but also removes the attachEvent events, which we *do* want
    if ( dest.clearAttributes ) {
        dest.clearAttributes();
    }

    // mergeAttributes, in contrast, only merges back on the
    // original attributes, not the events
    if ( dest.mergeAttributes ) {
        dest.mergeAttributes( src );
    }

    nodeName = dest.nodeName.toLowerCase();

    if ( nodeName === "object" ) {
        // IE6-10 improperly clones children of object elements using classid.
        // IE10 throws NoModificationAllowedError if parent is null, #12132.
        if ( dest.parentNode ) {
            dest.outerHTML = src.outerHTML;
        }

        // This path appears unavoidable for IE9. When cloning an object
        // element in IE9, the outerHTML strategy above is not sufficient.
        // If the src has innerHTML and the destination does not,
        // copy the src.innerHTML into the dest.innerHTML. #10324
        if ( jQuery.support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML)) ) {
            dest.innerHTML = src.innerHTML;
        }

    } else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
        // IE6-8 fails to persist the checked state of a cloned checkbox
        // or radio button. Worse, IE6-7 fail to give the cloned element
        // a checked appearance if the defaultChecked value isn't also set

        dest.defaultChecked = dest.checked = src.checked;

        // IE6-7 get confused and end up setting the value of a cloned
        // checkbox/radio button to an empty string instead of "on"
        if ( dest.value !== src.value ) {
            dest.value = src.value;
        }

    // IE6-8 fails to return the selected option to the default selected
    // state when cloning options
    } else if ( nodeName === "option" ) {
        dest.selected = src.defaultSelected;

    // IE6-8 fails to set the defaultValue to the correct value when
    // cloning other types of input fields
    } else if ( nodeName === "input" || nodeName === "textarea" ) {
        dest.defaultValue = src.defaultValue;

    // IE blanks contents when cloning scripts
    } else if ( nodeName === "script" && dest.text !== src.text ) {
        dest.text = src.text;
    }

    // Event data gets referenced instead of copied if the expando
    // gets copied too
    dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, context, scripts ) {
    var fragment, cacheable, cachehit,
        first = args[ 0 ];

    // Set context from what may come in as undefined or a jQuery collection or a node
    // Updated to fix #12266 where accessing context[0] could throw an exception in IE9/10 &
    // also doubles as fix for #8950 where plain objects caused createDocumentFragment exception
    context = context || document;
    context = !context.nodeType && context[0] || context;
    context = context.ownerDocument || context;

    // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
    // Cloning options loses the selected state, so don't cache them
    // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
    // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
    // Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
    if ( args.length === 1 && typeof first === "string" && first.length < 512 && context === document &&
        first.charAt(0) === "<" && !rnocache.test( first ) &&
        (jQuery.support.checkClone || !rchecked.test( first )) &&
        (jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

        // Mark cacheable and look for a hit
        cacheable = true;
        fragment = jQuery.fragments[ first ];
        cachehit = fragment !== undefined;
    }

    if ( !fragment ) {
        fragment = context.createDocumentFragment();
        jQuery.clean( args, context, fragment, scripts );

        // Update the cache, but only store false
        // unless this is a second parsing of the same content
        if ( cacheable ) {
            jQuery.fragments[ first ] = cachehit && fragment;
        }
    }

    return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
}, function( name, original ) {
    jQuery.fn[ name ] = function( selector ) {
        var elems,
            i = 0,
            ret = [],
            insert = jQuery( selector ),
            l = insert.length,
            parent = this.length === 1 && this[0].parentNode;

        if ( (parent == null || parent && parent.nodeType === 11 && parent.childNodes.length === 1) && l === 1 ) {
            insert[ original ]( this[0] );
            return this;
        } else {
            for ( ; i < l; i++ ) {
                elems = ( i > 0 ? this.clone(true) : this ).get();
                jQuery( insert[i] )[ original ]( elems );
                ret = ret.concat( elems );
            }

            return this.pushStack( ret, name, insert.selector );
        }
    };
});

function getAll( elem ) {
    if ( typeof elem.getElementsByTagName !== "undefined" ) {
        return elem.getElementsByTagName( "*" );

    } else if ( typeof elem.querySelectorAll !== "undefined" ) {
        return elem.querySelectorAll( "*" );

    } else {
        return [];
    }
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
    if ( rcheckableType.test( elem.type ) ) {
        elem.defaultChecked = elem.checked;
    }
}

jQuery.extend({
    clone: function( elem, dataAndEvents, deepDataAndEvents ) {
        var srcElements,
            destElements,
            i,
            clone;

        if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
            clone = elem.cloneNode( true );

        // IE<=8 does not properly clone detached, unknown element nodes
        } else {
            fragmentDiv.innerHTML = elem.outerHTML;
            fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
        }

        if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
                (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
            // IE copies events bound via attachEvent when using cloneNode.
            // Calling detachEvent on the clone will also remove the events
            // from the original. In order to get around this, we use some
            // proprietary methods to clear the events. Thanks to MooTools
            // guys for this hotness.

            cloneFixAttributes( elem, clone );

            // Using Sizzle here is crazy slow, so we use getElementsByTagName instead
            srcElements = getAll( elem );
            destElements = getAll( clone );

            // Weird iteration because IE will replace the length property
            // with an element if you are cloning the body and one of the
            // elements on the page has a name or id of "length"
            for ( i = 0; srcElements[i]; ++i ) {
                // Ensure that the destination node is not null; Fixes #9587
                if ( destElements[i] ) {
                    cloneFixAttributes( srcElements[i], destElements[i] );
                }
            }
        }

        // Copy the events from the original to the clone
        if ( dataAndEvents ) {
            cloneCopyEvent( elem, clone );

            if ( deepDataAndEvents ) {
                srcElements = getAll( elem );
                destElements = getAll( clone );

                for ( i = 0; srcElements[i]; ++i ) {
                    cloneCopyEvent( srcElements[i], destElements[i] );
                }
            }
        }

        srcElements = destElements = null;

        // Return the cloned set
        return clone;
    },

    clean: function( elems, context, fragment, scripts ) {
        var i, j, elem, tag, wrap, depth, div, hasBody, tbody, len, handleScript, jsTags,
            safe = context === document && safeFragment,
            ret = [];

        // Ensure that context is a document
        if ( !context || typeof context.createDocumentFragment === "undefined" ) {
            context = document;
        }

        // Use the already-created safe fragment if context permits
        for ( i = 0; (elem = elems[i]) != null; i++ ) {
            if ( typeof elem === "number" ) {
                elem += "";
            }

            if ( !elem ) {
                continue;
            }

            // Convert html string into DOM nodes
            if ( typeof elem === "string" ) {
                if ( !rhtml.test( elem ) ) {
                    elem = context.createTextNode( elem );
                } else {
                    // Ensure a safe container in which to render the html
                    safe = safe || createSafeFragment( context );
                    div = context.createElement("div");
                    safe.appendChild( div );

                    // Fix "XHTML"-style tags in all browsers
                    elem = elem.replace(rxhtmlTag, "<$1></$2>");

                    // Go to html and back, then peel off extra wrappers
                    tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
                    wrap = wrapMap[ tag ] || wrapMap._default;
                    depth = wrap[0];
                    div.innerHTML = wrap[1] + elem + wrap[2];

                    // Move to the right depth
                    while ( depth-- ) {
                        div = div.lastChild;
                    }

                    // Remove IE's autoinserted <tbody> from table fragments
                    if ( !jQuery.support.tbody ) {

                        // String was a <table>, *may* have spurious <tbody>
                        hasBody = rtbody.test(elem);
                            tbody = tag === "table" && !hasBody ?
                                div.firstChild && div.firstChild.childNodes :

                                // String was a bare <thead> or <tfoot>
                                wrap[1] === "<table>" && !hasBody ?
                                    div.childNodes :
                                    [];

                        for ( j = tbody.length - 1; j >= 0 ; --j ) {
                            if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
                                tbody[ j ].parentNode.removeChild( tbody[ j ] );
                            }
                        }
                    }

                    // IE completely kills leading whitespace when innerHTML is used
                    if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
                        div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
                    }

                    elem = div.childNodes;

                    // Take out of fragment container (we need a fresh div each time)
                    div.parentNode.removeChild( div );
                }
            }

            if ( elem.nodeType ) {
                ret.push( elem );
            } else {
                jQuery.merge( ret, elem );
            }
        }

        // Fix #11356: Clear elements from safeFragment
        if ( div ) {
            elem = div = safe = null;
        }

        // Reset defaultChecked for any radios and checkboxes
        // about to be appended to the DOM in IE 6/7 (#8060)
        if ( !jQuery.support.appendChecked ) {
            for ( i = 0; (elem = ret[i]) != null; i++ ) {
                if ( jQuery.nodeName( elem, "input" ) ) {
                    fixDefaultChecked( elem );
                } else if ( typeof elem.getElementsByTagName !== "undefined" ) {
                    jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
                }
            }
        }

        // Append elements to a provided document fragment
        if ( fragment ) {
            // Special handling of each script element
            handleScript = function( elem ) {
                // Check if we consider it executable
                if ( !elem.type || rscriptType.test( elem.type ) ) {
                    // Detach the script and store it in the scripts array (if provided) or the fragment
                    // Return truthy to indicate that it has been handled
                    return scripts ?
                        scripts.push( elem.parentNode ? elem.parentNode.removeChild( elem ) : elem ) :
                        fragment.appendChild( elem );
                }
            };

            for ( i = 0; (elem = ret[i]) != null; i++ ) {
                // Check if we're done after handling an executable script
                if ( !( jQuery.nodeName( elem, "script" ) && handleScript( elem ) ) ) {
                    // Append to fragment and handle embedded scripts
                    fragment.appendChild( elem );
                    if ( typeof elem.getElementsByTagName !== "undefined" ) {
                        // handleScript alters the DOM, so use jQuery.merge to ensure snapshot iteration
                        jsTags = jQuery.grep( jQuery.merge( [], elem.getElementsByTagName("script") ), handleScript );

                        // Splice the scripts into ret after their former ancestor and advance our index beyond them
                        ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
                        i += jsTags.length;
                    }
                }
            }
        }

        return ret;
    },

    cleanData: function( elems, /* internal */ acceptData ) {
        var data, id, elem, type,
            i = 0,
            internalKey = jQuery.expando,
            cache = jQuery.cache,
            deleteExpando = jQuery.support.deleteExpando,
            special = jQuery.event.special;

        for ( ; (elem = elems[i]) != null; i++ ) {

            if ( acceptData || jQuery.acceptData( elem ) ) {

                id = elem[ internalKey ];
                data = id && cache[ id ];

                if ( data ) {
                    if ( data.events ) {
                        for ( type in data.events ) {
                            if ( special[ type ] ) {
                                jQuery.event.remove( elem, type );

                            // This is a shortcut to avoid jQuery.event.remove's overhead
                            } else {
                                jQuery.removeEvent( elem, type, data.handle );
                            }
                        }
                    }

                    // Remove cache only if it was not already removed by jQuery.event.remove
                    if ( cache[ id ] ) {

                        delete cache[ id ];

                        // IE does not allow us to delete expando properties from nodes,
                        // nor does it have a removeAttribute function on Document nodes;
                        // we must handle all of these cases
                        if ( deleteExpando ) {
                            delete elem[ internalKey ];

                        } else if ( elem.removeAttribute ) {
                            elem.removeAttribute( internalKey );

                        } else {
                            elem[ internalKey ] = null;
                        }

                        jQuery.deletedIds.push( id );
                    }
                }
            }
        }
    }
});
// Limit scope pollution from any deprecated API
(function() {

var matched, browser;

// Use of jQuery.browser is frowned upon.
// More details: http://api.jquery.com/jQuery.browser
// jQuery.uaMatch maintained for back-compat
jQuery.uaMatch = function( ua ) {
    ua = ua.toLowerCase();

    var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
        /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
        /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
        /(msie) ([\w.]+)/.exec( ua ) ||
        ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
        [];

    return {
        browser: match[ 1 ] || "",
        version: match[ 2 ] || "0"
    };
};

matched = jQuery.uaMatch( navigator.userAgent );
browser = {};

if ( matched.browser ) {
    browser[ matched.browser ] = true;
    browser.version = matched.version;
}

// Chrome is Webkit, but Webkit is also Safari.
if ( browser.chrome ) {
    browser.webkit = true;
} else if ( browser.webkit ) {
    browser.safari = true;
}

jQuery.browser = browser;

jQuery.sub = function() {
    function jQuerySub( selector, context ) {
        return new jQuerySub.fn.init( selector, context );
    }
    jQuery.extend( true, jQuerySub, this );
    jQuerySub.superclass = this;
    jQuerySub.fn = jQuerySub.prototype = this();
    jQuerySub.fn.constructor = jQuerySub;
    jQuerySub.sub = this.sub;
    jQuerySub.fn.init = function init( selector, context ) {
        if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
            context = jQuerySub( context );
        }

        return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
    };
    jQuerySub.fn.init.prototype = jQuerySub.fn;
    var rootjQuerySub = jQuerySub(document);
    return jQuerySub;
};

})();
var curCSS, iframe, iframeDoc,
    ralpha = /alpha\([^)]*\)/i,
    ropacity = /opacity=([^)]*)/,
    rposition = /^(top|right|bottom|left)$/,
    // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
    // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    rmargin = /^margin/,
    rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
    rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
    rrelNum = new RegExp( "^([-+])=(" + core_pnum + ")", "i" ),
    elemdisplay = { BODY: "block" },

    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
    cssNormalTransform = {
        letterSpacing: 0,
        fontWeight: 400
    },

    cssExpand = [ "Top", "Right", "Bottom", "Left" ],
    cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],

    eventsToggle = jQuery.fn.toggle;

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

    // shortcut for names that are not vendor prefixed
    if ( name in style ) {
        return name;
    }

    // check for vendor prefixed names
    var capName = name.charAt(0).toUpperCase() + name.slice(1),
        origName = name,
        i = cssPrefixes.length;

    while ( i-- ) {
        name = cssPrefixes[ i ] + capName;
        if ( name in style ) {
            return name;
        }
    }

    return origName;
}

function isHidden( elem, el ) {
    elem = el || elem;
    return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
}

function showHide( elements, show ) {
    var elem, display,
        values = [],
        index = 0,
        length = elements.length;

    for ( ; index < length; index++ ) {
        elem = elements[ index ];
        if ( !elem.style ) {
            continue;
        }
        values[ index ] = jQuery._data( elem, "olddisplay" );
        if ( show ) {
            // Reset the inline display of this element to learn if it is
            // being hidden by cascaded rules or not
            if ( !values[ index ] && elem.style.display === "none" ) {
                elem.style.display = "";
            }

            // Set elements which have been overridden with display: none
            // in a stylesheet to whatever the default browser style is
            // for such an element
            if ( elem.style.display === "" && isHidden( elem ) ) {
                values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
            }
        } else {
            display = curCSS( elem, "display" );

            if ( !values[ index ] && display !== "none" ) {
                jQuery._data( elem, "olddisplay", display );
            }
        }
    }

    // Set the display of most of the elements in a second loop
    // to avoid the constant reflow
    for ( index = 0; index < length; index++ ) {
        elem = elements[ index ];
        if ( !elem.style ) {
            continue;
        }
        if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
            elem.style.display = show ? values[ index ] || "" : "none";
        }
    }

    return elements;
}

jQuery.fn.extend({
    css: function( name, value ) {
        return jQuery.access( this, function( elem, name, value ) {
            return value !== undefined ?
                jQuery.style( elem, name, value ) :
                jQuery.css( elem, name );
        }, name, value, arguments.length > 1 );
    },
    show: function() {
        return showHide( this, true );
    },
    hide: function() {
        return showHide( this );
    },
    toggle: function( state, fn2 ) {
        var bool = typeof state === "boolean";

        if ( jQuery.isFunction( state ) && jQuery.isFunction( fn2 ) ) {
            return eventsToggle.apply( this, arguments );
        }

        return this.each(function() {
            if ( bool ? state : isHidden( this ) ) {
                jQuery( this ).show();
            } else {
                jQuery( this ).hide();
            }
        });
    }
});

jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
        opacity: {
            get: function( elem, computed ) {
                if ( computed ) {
                    // We should always get a number back from opacity
                    var ret = curCSS( elem, "opacity" );
                    return ret === "" ? "1" : ret;

                }
            }
        }
    },

    // Exclude the following css properties to add px
    cssNumber: {
        "fillOpacity": true,
        "fontWeight": true,
        "lineHeight": true,
        "opacity": true,
        "orphans": true,
        "widows": true,
        "zIndex": true,
        "zoom": true
    },

    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {
        // normalize float css property
        "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
    },

    // Get and set the style property on a DOM Node
    style: function( elem, name, value, extra ) {
        // Don't set styles on text and comment nodes
        if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
            return;
        }

        // Make sure that we're working with the right name
        var ret, type, hooks,
            origName = jQuery.camelCase( name ),
            style = elem.style;

        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

        // gets hook for the prefixed version
        // followed by the unprefixed version
        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

        // Check if we're setting a value
        if ( value !== undefined ) {
            type = typeof value;

            // convert relative number strings (+= or -=) to relative numbers. #7345
            if ( type === "string" && (ret = rrelNum.exec( value )) ) {
                value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
                // Fixes bug #9237
                type = "number";
            }

            // Make sure that NaN and null values aren't set. See: #7116
            if ( value == null || type === "number" && isNaN( value ) ) {
                return;
            }

            // If a number was passed in, add 'px' to the (except for certain CSS properties)
            if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
                value += "px";
            }

            // If a hook was provided, use that value, otherwise just set the specified value
            if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
                // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
                // Fixes bug #5509
                try {
                    style[ name ] = value;
                } catch(e) {}
            }

        } else {
            // If a hook was provided get the non-computed value from there
            if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
                return ret;
            }

            // Otherwise just get the value from the style object
            return style[ name ];
        }
    },

    css: function( elem, name, numeric, extra ) {
        var val, num, hooks,
            origName = jQuery.camelCase( name );

        // Make sure that we're working with the right name
        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

        // gets hook for the prefixed version
        // followed by the unprefixed version
        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

        // If a hook was provided get the computed value from there
        if ( hooks && "get" in hooks ) {
            val = hooks.get( elem, true, extra );
        }

        // Otherwise, if a way to get the computed value exists, use that
        if ( val === undefined ) {
            val = curCSS( elem, name );
        }

        //convert "normal" to computed value
        if ( val === "normal" && name in cssNormalTransform ) {
            val = cssNormalTransform[ name ];
        }

        // Return, converting to number if forced or a qualifier was provided and val looks numeric
        if ( numeric || extra !== undefined ) {
            num = parseFloat( val );
            return numeric || jQuery.isNumeric( num ) ? num || 0 : val;
        }
        return val;
    },

    // A method for quickly swapping in/out CSS properties to get correct calculations
    swap: function( elem, options, callback ) {
        var ret, name,
            old = {};

        // Remember the old values, and insert the new ones
        for ( name in options ) {
            old[ name ] = elem.style[ name ];
            elem.style[ name ] = options[ name ];
        }

        ret = callback.call( elem );

        // Revert the old values
        for ( name in options ) {
            elem.style[ name ] = old[ name ];
        }

        return ret;
    }
});

// NOTE: To any future maintainer, we've window.getComputedStyle
// because jsdom on node.js will break without it.
if ( window.getComputedStyle ) {
    curCSS = function( elem, name ) {
        var ret, width, minWidth, maxWidth,
            computed = window.getComputedStyle( elem, null ),
            style = elem.style;

        if ( computed ) {

            // getPropertyValue is only needed for .css('filter') in IE9, see #12537
            ret = computed.getPropertyValue( name ) || computed[ name ];

            if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
                ret = jQuery.style( elem, name );
            }

            // A tribute to the "awesome hack by Dean Edwards"
            // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
            // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
            // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
            if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;

                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;

                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }

        return ret;
    };
} else if ( document.documentElement.currentStyle ) {
    curCSS = function( elem, name ) {
        var left, rsLeft,
            ret = elem.currentStyle && elem.currentStyle[ name ],
            style = elem.style;

        // Avoid setting ret to empty string here
        // so we don't default to auto
        if ( ret == null && style && style[ name ] ) {
            ret = style[ name ];
        }

        // From the awesome hack by Dean Edwards
        // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

        // If we're not dealing with a regular pixel number
        // but a number that has a weird ending, we need to convert it to pixels
        // but not position css attributes, as those are proportional to the parent element instead
        // and we can't measure the parent instead because it might trigger a "stacking dolls" problem
        if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

            // Remember the original values
            left = style.left;
            rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

            // Put in the new values to get a computed value out
            if ( rsLeft ) {
                elem.runtimeStyle.left = elem.currentStyle.left;
            }
            style.left = name === "fontSize" ? "1em" : ret;
            ret = style.pixelLeft + "px";

            // Revert the changed values
            style.left = left;
            if ( rsLeft ) {
                elem.runtimeStyle.left = rsLeft;
            }
        }

        return ret === "" ? "auto" : ret;
    };
}

function setPositiveNumber( elem, value, subtract ) {
    var matches = rnumsplit.exec( value );
    return matches ?
            Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
            value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox ) {
    var i = extra === ( isBorderBox ? "border" : "content" ) ?
        // If we already have the right measurement, avoid augmentation
        4 :
        // Otherwise initialize for horizontal or vertical properties
        name === "width" ? 1 : 0,

        val = 0;

    for ( ; i < 4; i += 2 ) {
        // both box models exclude margin, so add it if we want it
        if ( extra === "margin" ) {
            // we use jQuery.css instead of curCSS here
            // because of the reliableMarginRight CSS hook!
            val += jQuery.css( elem, extra + cssExpand[ i ], true );
        }

        // From this point on we use curCSS for maximum performance (relevant in animations)
        if ( isBorderBox ) {
            // border-box includes padding, so remove it if we want content
            if ( extra === "content" ) {
                val -= parseFloat( curCSS( elem, "padding" + cssExpand[ i ] ) ) || 0;
            }

            // at this point, extra isn't border nor margin, so remove border
            if ( extra !== "margin" ) {
                val -= parseFloat( curCSS( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
            }
        } else {
            // at this point, extra isn't content, so add padding
            val += parseFloat( curCSS( elem, "padding" + cssExpand[ i ] ) ) || 0;

            // at this point, extra isn't content nor padding, so add border
            if ( extra !== "padding" ) {
                val += parseFloat( curCSS( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
            }
        }
    }

    return val;
}

function getWidthOrHeight( elem, name, extra ) {

    // Start with offset property, which is equivalent to the border-box value
    var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
        valueIsBorderBox = true,
        isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing" ) === "border-box";

    // some non-html elements return undefined for offsetWidth, so check for null/undefined
    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
    if ( val <= 0 || val == null ) {
        // Fall back to computed then uncomputed css if necessary
        val = curCSS( elem, name );
        if ( val < 0 || val == null ) {
            val = elem.style[ name ];
        }

        // Computed unit is not pixels. Stop here and return.
        if ( rnumnonpx.test(val) ) {
            return val;
        }

        // we need the check for style in case a browser which returns unreliable values
        // for getComputedStyle silently falls back to the reliable elem.style
        valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );

        // Normalize "", auto, and prepare for extra
        val = parseFloat( val ) || 0;
    }

    // use the active box-sizing model to add/subtract irrelevant styles
    return ( val +
        augmentWidthOrHeight(
            elem,
            name,
            extra || ( isBorderBox ? "border" : "content" ),
            valueIsBorderBox
        )
    ) + "px";
}


// Try to determine the default display value of an element
function css_defaultDisplay( nodeName ) {
    if ( elemdisplay[ nodeName ] ) {
        return elemdisplay[ nodeName ];
    }

    var elem = jQuery( "<" + nodeName + ">" ).appendTo( document.body ),
        display = elem.css("display");
    elem.remove();

    // If the simple way fails,
    // get element's real default display by attaching it to a temp iframe
    if ( display === "none" || display === "" ) {
        // Use the already-created iframe if possible
        iframe = document.body.appendChild(
            iframe || jQuery.extend( document.createElement("iframe"), {
                frameBorder: 0,
                width: 0,
                height: 0
            })
        );

        // Create a cacheable copy of the iframe document on first call.
        // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
        // document to it; WebKit & Firefox won't allow reusing the iframe document.
        if ( !iframeDoc || !iframe.createElement ) {
            iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
            iframeDoc.write("<!doctype html><html><body>");
            iframeDoc.close();
        }

        elem = iframeDoc.body.appendChild( iframeDoc.createElement(nodeName) );

        display = curCSS( elem, "display" );
        document.body.removeChild( iframe );
    }

    // Store the correct default display
    elemdisplay[ nodeName ] = display;

    return display;
}

jQuery.each([ "height", "width" ], function( i, name ) {
    jQuery.cssHooks[ name ] = {
        get: function( elem, computed, extra ) {
            if ( computed ) {
                // certain elements can have dimension info if we invisibly show them
                // however, it must have a current display style that would benefit from this
                if ( elem.offsetWidth === 0 && rdisplayswap.test( curCSS( elem, "display" ) ) ) {
                    return jQuery.swap( elem, cssShow, function() {
                        return getWidthOrHeight( elem, name, extra );
                    });
                } else {
                    return getWidthOrHeight( elem, name, extra );
                }
            }
        },

        set: function( elem, value, extra ) {
            return setPositiveNumber( elem, value, extra ?
                augmentWidthOrHeight(
                    elem,
                    name,
                    extra,
                    jQuery.support.boxSizing && jQuery.css( elem, "boxSizing" ) === "border-box"
                ) : 0
            );
        }
    };
});

if ( !jQuery.support.opacity ) {
    jQuery.cssHooks.opacity = {
        get: function( elem, computed ) {
            // IE uses filters for opacity
            return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
                ( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
                computed ? "1" : "";
        },

        set: function( elem, value ) {
            var style = elem.style,
                currentStyle = elem.currentStyle,
                opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
                filter = currentStyle && currentStyle.filter || style.filter || "";

            // IE has trouble with opacity if it does not have layout
            // Force it by setting the zoom level
            style.zoom = 1;

            // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
            if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
                style.removeAttribute ) {

                // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                // if "filter:" is present at all, clearType is disabled, we want to avoid this
                // style.removeAttribute is IE Only, but so apparently is this code path...
                style.removeAttribute( "filter" );

                // if there there is no filter style applied in a css rule, we are done
                if ( currentStyle && !currentStyle.filter ) {
                    return;
                }
            }

            // otherwise, set new filter values
            style.filter = ralpha.test( filter ) ?
                filter.replace( ralpha, opacity ) :
                filter + " " + opacity;
        }
    };
}

// These hooks cannot be added until DOM ready because the support test
// for it is not run until after DOM ready
jQuery(function() {
    if ( !jQuery.support.reliableMarginRight ) {
        jQuery.cssHooks.marginRight = {
            get: function( elem, computed ) {
                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                // Work around by temporarily setting element display to inline-block
                return jQuery.swap( elem, { "display": "inline-block" }, function() {
                    if ( computed ) {
                        return curCSS( elem, "marginRight" );
                    }
                });
            }
        };
    }

    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // getComputedStyle returns percent when specified for top/left/bottom/right
    // rather than make the css module depend on the offset module, we just check for it here
    if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
        jQuery.each( [ "top", "left" ], function( i, prop ) {
            jQuery.cssHooks[ prop ] = {
                get: function( elem, computed ) {
                    if ( computed ) {
                        var ret = curCSS( elem, prop );
                        // if curCSS returns percentage, fallback to offset
                        return rnumnonpx.test( ret ) ? jQuery( elem ).position()[ prop ] + "px" : ret;
                    }
                }
            };
        });
    }

});

if ( jQuery.expr && jQuery.expr.filters ) {
    jQuery.expr.filters.hidden = function( elem ) {
        return ( elem.offsetWidth === 0 && elem.offsetHeight === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || curCSS( elem, "display" )) === "none");
    };

    jQuery.expr.filters.visible = function( elem ) {
        return !jQuery.expr.filters.hidden( elem );
    };
}

// These hooks are used by animate to expand properties
jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
}, function( prefix, suffix ) {
    jQuery.cssHooks[ prefix + suffix ] = {
        expand: function( value ) {
            var i,

                // assumes a single number if not a string
                parts = typeof value === "string" ? value.split(" ") : [ value ],
                expanded = {};

            for ( i = 0; i < 4; i++ ) {
                expanded[ prefix + cssExpand[ i ] + suffix ] =
                    parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
            }

            return expanded;
        }
    };

    if ( !rmargin.test( prefix ) ) {
        jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
    }
});
var r20 = /%20/g,
    rbracket = /\[\]$/,
    rCRLF = /\r?\n/g,
    rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
    rselectTextarea = /^(?:select|textarea)/i;

jQuery.fn.extend({
    serialize: function() {
        return jQuery.param( this.serializeArray() );
    },
    serializeArray: function() {
        return this.map(function(){
            return this.elements ? jQuery.makeArray( this.elements ) : this;
        })
        .filter(function(){
            return this.name && !this.disabled &&
                ( this.checked || rselectTextarea.test( this.nodeName ) ||
                    rinput.test( this.type ) );
        })
        .map(function( i, elem ){
            var val = jQuery( this ).val();

            return val == null ?
                null :
                jQuery.isArray( val ) ?
                    jQuery.map( val, function( val, i ){
                        return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                    }) :
                    { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
        }).get();
    }
});

//Serialize an array of form elements or a set of
//key/values into a query string
jQuery.param = function( a, traditional ) {
    var prefix,
        s = [],
        add = function( key, value ) {
            // If value is a function, invoke it and return its value
            value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
            s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
        };

    // Set traditional to true for jQuery <= 1.3.2 behavior.
    if ( traditional === undefined ) {
        traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }

    // If an array was passed in, assume that it is an array of form elements.
    if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
        // Serialize the form elements
        jQuery.each( a, function() {
            add( this.name, this.value );
        });

    } else {
        // If traditional, encode the "old" way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for ( prefix in a ) {
            buildParams( prefix, a[ prefix ], traditional, add );
        }
    }

    // Return the resulting serialization
    return s.join( "&" ).replace( r20, "+" );
};

function buildParams( prefix, obj, traditional, add ) {
    var name;

    if ( jQuery.isArray( obj ) ) {
        // Serialize array item.
        jQuery.each( obj, function( i, v ) {
            if ( traditional || rbracket.test( prefix ) ) {
                // Treat each array item as a scalar.
                add( prefix, v );

            } else {
                // If array item is non-scalar (array or object), encode its
                // numeric index to resolve deserialization ambiguity issues.
                // Note that rack (as of 1.0.0) can't currently deserialize
                // nested arrays properly, and attempting to do so may cause
                // a server error. Possible fixes are to modify rack's
                // deserialization algorithm or to provide an option or flag
                // to force array serialization to be shallow.
                buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
            }
        });

    } else if ( !traditional && jQuery.type( obj ) === "object" ) {
        // Serialize object item.
        for ( name in obj ) {
            buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
        }

    } else {
        // Serialize scalar item.
        add( prefix, obj );
    }
}
var
    // Document location
    ajaxLocParts,
    ajaxLocation,

    rhash = /#.*$/,
    rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
    // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
    rnoContent = /^(?:GET|HEAD)$/,
    rprotocol = /^\/\//,
    rquery = /\?/,
    rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
    rts = /([?&])_=[^&]*/,
    rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

    // Keep a copy of the old load method
    _load = jQuery.fn.load,

    /* Prefilters
     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
     * 2) These are called:
     *    - BEFORE asking for a transport
     *    - AFTER param serialization (s.data is a string if s.processData is true)
     * 3) key is the dataType
     * 4) the catchall symbol "*" can be used
     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
     */
    prefilters = {},

    /* Transports bindings
     * 1) key is the dataType
     * 2) the catchall symbol "*" can be used
     * 3) selection will start with transport dataType and THEN go to "*" if needed
     */
    transports = {},

    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
    ajaxLocation = location.href;
} catch( e ) {
    // Use the href attribute of an A element
    // since IE will modify it given document.location
    ajaxLocation = document.createElement( "a" );
    ajaxLocation.href = "";
    ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

    // dataTypeExpression is optional and defaults to "*"
    return function( dataTypeExpression, func ) {

        if ( typeof dataTypeExpression !== "string" ) {
            func = dataTypeExpression;
            dataTypeExpression = "*";
        }

        var dataType, list, placeBefore,
            dataTypes = dataTypeExpression.toLowerCase().split( core_rspace ),
            i = 0,
            length = dataTypes.length;

        if ( jQuery.isFunction( func ) ) {
            // For each dataType in the dataTypeExpression
            for ( ; i < length; i++ ) {
                dataType = dataTypes[ i ];
                // We control if we're asked to add before
                // any existing element
                placeBefore = /^\+/.test( dataType );
                if ( placeBefore ) {
                    dataType = dataType.substr( 1 ) || "*";
                }
                list = structure[ dataType ] = structure[ dataType ] || [];
                // then we add to the structure accordingly
                list[ placeBefore ? "unshift" : "push" ]( func );
            }
        }
    };
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
        dataType /* internal */, inspected /* internal */ ) {

    dataType = dataType || options.dataTypes[ 0 ];
    inspected = inspected || {};

    inspected[ dataType ] = true;

    var selection,
        list = structure[ dataType ],
        i = 0,
        length = list ? list.length : 0,
        executeOnly = ( structure === prefilters );

    for ( ; i < length && ( executeOnly || !selection ); i++ ) {
        selection = list[ i ]( options, originalOptions, jqXHR );
        // If we got redirected to another dataType
        // we try there if executing only and not done already
        if ( typeof selection === "string" ) {
            if ( !executeOnly || inspected[ selection ] ) {
                selection = undefined;
            } else {
                options.dataTypes.unshift( selection );
                selection = inspectPrefiltersOrTransports(
                        structure, options, originalOptions, jqXHR, selection, inspected );
            }
        }
    }
    // If we're only executing or nothing was selected
    // we try the catchall dataType if not done already
    if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
        selection = inspectPrefiltersOrTransports(
                structure, options, originalOptions, jqXHR, "*", inspected );
    }
    // unnecessary when only executing (prefilters)
    // but it'll be ignored by the caller in that case
    return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
    var key, deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for ( key in src ) {
        if ( src[ key ] !== undefined ) {
            ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
        }
    }
    if ( deep ) {
        jQuery.extend( true, target, deep );
    }
}

jQuery.fn.load = function( url, params, callback ) {
    if ( typeof url !== "string" && _load ) {
        return _load.apply( this, arguments );
    }

    // Don't do a request if no elements are being requested
    if ( !this.length ) {
        return this;
    }

    var selector, type, response,
        self = this,
        off = url.indexOf(" ");

    if ( off >= 0 ) {
        selector = url.slice( off, url.length );
        url = url.slice( 0, off );
    }

    // If it's a function
    if ( jQuery.isFunction( params ) ) {

        // We assume that it's the callback
        callback = params;
        params = undefined;

    // Otherwise, build a param string
    } else if ( params && typeof params === "object" ) {
        type = "POST";
    }

    // Request the remote document
    jQuery.ajax({
        url: url,

        // if "type" variable is undefined, then "GET" method will be used
        type: type,
        dataType: "html",
        data: params,
        complete: function( jqXHR, status ) {
            if ( callback ) {
                self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
            }
        }
    }).done(function( responseText ) {

        // Save response for use in complete callback
        response = arguments;

        // See if a selector was specified
        self.html( selector ?

            // Create a dummy div to hold the results
            jQuery("<div>")

                // inject the contents of the document in, removing the scripts
                // to avoid any 'Permission Denied' errors in IE
                .append( responseText.replace( rscript, "" ) )

                // Locate the specified elements
                .find( selector ) :

            // If not, just inject the full result
            responseText );

    });

    return this;
};

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
    jQuery.fn[ o ] = function( f ){
        return this.on( o, f );
    };
});

jQuery.each( [ "get", "post" ], function( i, method ) {
    jQuery[ method ] = function( url, data, callback, type ) {
        // shift arguments if data argument was omitted
        if ( jQuery.isFunction( data ) ) {
            type = type || callback;
            callback = data;
            data = undefined;
        }

        return jQuery.ajax({
            type: method,
            url: url,
            data: data,
            success: callback,
            dataType: type
        });
    };
});

jQuery.extend({

    getScript: function( url, callback ) {
        return jQuery.get( url, undefined, callback, "script" );
    },

    getJSON: function( url, data, callback ) {
        return jQuery.get( url, data, callback, "json" );
    },

    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function( target, settings ) {
        if ( settings ) {
            // Building a settings object
            ajaxExtend( target, jQuery.ajaxSettings );
        } else {
            // Extending ajaxSettings
            settings = target;
            target = jQuery.ajaxSettings;
        }
        ajaxExtend( target, settings );
        return target;
    },

    ajaxSettings: {
        url: ajaxLocation,
        isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
        global: true,
        type: "GET",
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
        processData: true,
        async: true,
        /*
        timeout: 0,
        data: null,
        dataType: null,
        username: null,
        password: null,
        cache: null,
        throws: false,
        traditional: false,
        headers: {},
        */

        accepts: {
            xml: "application/xml, text/xml",
            html: "text/html",
            text: "text/plain",
            json: "application/json, text/javascript",
            "*": allTypes
        },

        contents: {
            xml: /xml/,
            html: /html/,
            json: /json/
        },

        responseFields: {
            xml: "responseXML",
            text: "responseText"
        },

        // List of data converters
        // 1) key format is "source_type destination_type" (a single space in-between)
        // 2) the catchall symbol "*" can be used for source_type
        converters: {

            // Convert anything to text
            "* text": window.String,

            // Text to html (true = no transformation)
            "text html": true,

            // Evaluate text as a json expression
            "text json": jQuery.parseJSON,

            // Parse text as xml
            "text xml": jQuery.parseXML
        },

        // For options that shouldn't be deep extended:
        // you can add your own custom options here if
        // and when you create one that shouldn't be
        // deep extended (see ajaxExtend)
        flatOptions: {
            context: true,
            url: true
        }
    },

    ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
    ajaxTransport: addToPrefiltersOrTransports( transports ),

    // Main method
    ajax: function( url, options ) {

        // If url is an object, simulate pre-1.5 signature
        if ( typeof url === "object" ) {
            options = url;
            url = undefined;
        }

        // Force options to be an object
        options = options || {};

        var // ifModified key
            ifModifiedKey,
            // Response headers
            responseHeadersString,
            responseHeaders,
            // transport
            transport,
            // timeout handle
            timeoutTimer,
            // Cross-domain detection vars
            parts,
            // To know if global events are to be dispatched
            fireGlobals,
            // Loop variable
            i,
            // Create the final options object
            s = jQuery.ajaxSetup( {}, options ),
            // Callbacks context
            callbackContext = s.context || s,
            // Context for global events
            // It's the callbackContext if one was provided in the options
            // and if it's a DOM node or a jQuery collection
            globalEventContext = callbackContext !== s &&
                ( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
                        jQuery( callbackContext ) : jQuery.event,
            // Deferreds
            deferred = jQuery.Deferred(),
            completeDeferred = jQuery.Callbacks( "once memory" ),
            // Status-dependent callbacks
            statusCode = s.statusCode || {},
            // Headers (they are sent all at once)
            requestHeaders = {},
            requestHeadersNames = {},
            // The jqXHR state
            state = 0,
            // Default abort message
            strAbort = "canceled",
            // Fake xhr
            jqXHR = {

                readyState: 0,

                // Caches the header
                setRequestHeader: function( name, value ) {
                    if ( !state ) {
                        var lname = name.toLowerCase();
                        name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                        requestHeaders[ name ] = value;
                    }
                    return this;
                },

                // Raw string
                getAllResponseHeaders: function() {
                    return state === 2 ? responseHeadersString : null;
                },

                // Builds headers hashtable if needed
                getResponseHeader: function( key ) {
                    var match;
                    if ( state === 2 ) {
                        if ( !responseHeaders ) {
                            responseHeaders = {};
                            while( ( match = rheaders.exec( responseHeadersString ) ) ) {
                                responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                            }
                        }
                        match = responseHeaders[ key.toLowerCase() ];
                    }
                    return match === undefined ? null : match;
                },

                // Overrides response content-type header
                overrideMimeType: function( type ) {
                    if ( !state ) {
                        s.mimeType = type;
                    }
                    return this;
                },

                // Cancel the request
                abort: function( statusText ) {
                    statusText = statusText || strAbort;
                    if ( transport ) {
                        transport.abort( statusText );
                    }
                    done( 0, statusText );
                    return this;
                }
            };

        // Callback for when everything is done
        // It is defined here because jslint complains if it is declared
        // at the end of the function (which would be more logical and readable)
        function done( status, nativeStatusText, responses, headers ) {
            var isSuccess, success, error, response, modified,
                statusText = nativeStatusText;

            // Called once
            if ( state === 2 ) {
                return;
            }

            // State is "done" now
            state = 2;

            // Clear timeout if it exists
            if ( timeoutTimer ) {
                clearTimeout( timeoutTimer );
            }

            // Dereference transport for early garbage collection
            // (no matter how long the jqXHR object will be used)
            transport = undefined;

            // Cache response headers
            responseHeadersString = headers || "";

            // Set readyState
            jqXHR.readyState = status > 0 ? 4 : 0;

            // Get response data
            if ( responses ) {
                response = ajaxHandleResponses( s, jqXHR, responses );
            }

            // If successful, handle type chaining
            if ( status >= 200 && status < 300 || status === 304 ) {

                // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                if ( s.ifModified ) {

                    modified = jqXHR.getResponseHeader("Last-Modified");
                    if ( modified ) {
                        jQuery.lastModified[ ifModifiedKey ] = modified;
                    }
                    modified = jqXHR.getResponseHeader("Etag");
                    if ( modified ) {
                        jQuery.etag[ ifModifiedKey ] = modified;
                    }
                }

                // If not modified
                if ( status === 304 ) {

                    statusText = "notmodified";
                    isSuccess = true;

                // If we have data
                } else {

                    isSuccess = ajaxConvert( s, response );
                    statusText = isSuccess.state;
                    success = isSuccess.data;
                    error = isSuccess.error;
                    isSuccess = !error;
                }
            } else {
                // We extract error from statusText
                // then normalize statusText and status for non-aborts
                error = statusText;
                if ( !statusText || status ) {
                    statusText = "error";
                    if ( status < 0 ) {
                        status = 0;
                    }
                }
            }

            // Set data for the fake xhr object
            jqXHR.status = status;
            jqXHR.statusText = ( nativeStatusText || statusText ) + "";

            // Success/Error
            if ( isSuccess ) {
                deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
            } else {
                deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
            }

            // Status-dependent callbacks
            jqXHR.statusCode( statusCode );
            statusCode = undefined;

            if ( fireGlobals ) {
                globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
                        [ jqXHR, s, isSuccess ? success : error ] );
            }

            // Complete
            completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

            if ( fireGlobals ) {
                globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
                // Handle the global AJAX counter
                if ( !( --jQuery.active ) ) {
                    jQuery.event.trigger( "ajaxStop" );
                }
            }
        }

        // Attach deferreds
        deferred.promise( jqXHR );
        jqXHR.success = jqXHR.done;
        jqXHR.error = jqXHR.fail;
        jqXHR.complete = completeDeferred.add;

        // Status-dependent callbacks
        jqXHR.statusCode = function( map ) {
            if ( map ) {
                var tmp;
                if ( state < 2 ) {
                    for ( tmp in map ) {
                        statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
                    }
                } else {
                    tmp = map[ jqXHR.status ];
                    jqXHR.always( tmp );
                }
            }
            return this;
        };

        // Remove hash character (#7531: and string promotion)
        // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
        // We also use the url parameter if available
        s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

        // Extract dataTypes list
        s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( core_rspace );

        // A cross-domain request is in order when we have a protocol:host:port mismatch
        if ( s.crossDomain == null ) {
            parts = rurl.exec( s.url.toLowerCase() );
            s.crossDomain = !!( parts &&
                ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                    ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
                        ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
            );
        }

        // Convert data if not already a string
        if ( s.data && s.processData && typeof s.data !== "string" ) {
            s.data = jQuery.param( s.data, s.traditional );
        }

        // Apply prefilters
        inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

        // If request was aborted inside a prefilter, stop there
        if ( state === 2 ) {
            return jqXHR;
        }

        // We can fire global events as of now if asked to
        fireGlobals = s.global;

        // Uppercase the type
        s.type = s.type.toUpperCase();

        // Determine if request has content
        s.hasContent = !rnoContent.test( s.type );

        // Watch for a new set of requests
        if ( fireGlobals && jQuery.active++ === 0 ) {
            jQuery.event.trigger( "ajaxStart" );
        }

        // More options handling for requests with no content
        if ( !s.hasContent ) {

            // If data is available, append data to url
            if ( s.data ) {
                s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
                // #9682: remove data so that it's not used in an eventual retry
                delete s.data;
            }

            // Get ifModifiedKey before adding the anti-cache parameter
            ifModifiedKey = s.url;

            // Add anti-cache in url if needed
            if ( s.cache === false ) {

                var ts = jQuery.now(),
                    // try replacing _= if it is there
                    ret = s.url.replace( rts, "$1_=" + ts );

                // if nothing was replaced, add timestamp to the end
                s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
            }
        }

        // Set the correct header, if data is being sent
        if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
            jqXHR.setRequestHeader( "Content-Type", s.contentType );
        }

        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
        if ( s.ifModified ) {
            ifModifiedKey = ifModifiedKey || s.url;
            if ( jQuery.lastModified[ ifModifiedKey ] ) {
                jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
            }
            if ( jQuery.etag[ ifModifiedKey ] ) {
                jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
            }
        }

        // Set the Accepts header for the server, depending on the dataType
        jqXHR.setRequestHeader(
            "Accept",
            s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
                s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                s.accepts[ "*" ]
        );

        // Check for headers option
        for ( i in s.headers ) {
            jqXHR.setRequestHeader( i, s.headers[ i ] );
        }

        // Allow custom headers/mimetypes and early abort
        if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
                // Abort if not done already and return
                return jqXHR.abort();

        }

        // aborting is no longer a cancellation
        strAbort = "abort";

        // Install callbacks on deferreds
        for ( i in { success: 1, error: 1, complete: 1 } ) {
            jqXHR[ i ]( s[ i ] );
        }

        // Get transport
        transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

        // If no transport, we auto-abort
        if ( !transport ) {
            done( -1, "No Transport" );
        } else {
            jqXHR.readyState = 1;
            // Send global event
            if ( fireGlobals ) {
                globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
            }
            // Timeout
            if ( s.async && s.timeout > 0 ) {
                timeoutTimer = setTimeout( function(){
                    jqXHR.abort( "timeout" );
                }, s.timeout );
            }

            try {
                state = 1;
                transport.send( requestHeaders, done );
            } catch (e) {
                // Propagate exception as error if not done
                if ( state < 2 ) {
                    done( -1, e );
                // Simply rethrow otherwise
                } else {
                    throw e;
                }
            }
        }

        return jqXHR;
    },

    // Counter for holding the number of active queries
    active: 0,

    // Last-Modified header cache for next request
    lastModified: {},
    etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

    var ct, type, finalDataType, firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes,
        responseFields = s.responseFields;

    // Fill responseXXX fields
    for ( type in responseFields ) {
        if ( type in responses ) {
            jqXHR[ responseFields[type] ] = responses[ type ];
        }
    }

    // Remove auto dataType and get content-type in the process
    while( dataTypes[ 0 ] === "*" ) {
        dataTypes.shift();
        if ( ct === undefined ) {
            ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
        }
    }

    // Check if we're dealing with a known content-type
    if ( ct ) {
        for ( type in contents ) {
            if ( contents[ type ] && contents[ type ].test( ct ) ) {
                dataTypes.unshift( type );
                break;
            }
        }
    }

    // Check to see if we have a response for the expected dataType
    if ( dataTypes[ 0 ] in responses ) {
        finalDataType = dataTypes[ 0 ];
    } else {
        // Try convertible dataTypes
        for ( type in responses ) {
            if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
                finalDataType = type;
                break;
            }
            if ( !firstDataType ) {
                firstDataType = type;
            }
        }
        // Or just use first one
        finalDataType = finalDataType || firstDataType;
    }

    // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response
    if ( finalDataType ) {
        if ( finalDataType !== dataTypes[ 0 ] ) {
            dataTypes.unshift( finalDataType );
        }
        return responses[ finalDataType ];
    }
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

    var conv, conv2, current, tmp,
        // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice(),
        prev = dataTypes[ 0 ],
        converters = {},
        i = 0;

    // Apply the dataFilter if provided
    if ( s.dataFilter ) {
        response = s.dataFilter( response, s.dataType );
    }

    // Create converters map with lowercased keys
    if ( dataTypes[ 1 ] ) {
        for ( conv in s.converters ) {
            converters[ conv.toLowerCase() ] = s.converters[ conv ];
        }
    }

    // Convert to each sequential dataType, tolerating list modification
    for ( ; (current = dataTypes[++i]); ) {

        // There's only work to do if current dataType is non-auto
        if ( current !== "*" ) {

            // Convert response if prev dataType is non-auto and differs from current
            if ( prev !== "*" && prev !== current ) {

                // Seek a direct converter
                conv = converters[ prev + " " + current ] || converters[ "* " + current ];

                // If none found, seek a pair
                if ( !conv ) {
                    for ( conv2 in converters ) {

                        // If conv2 outputs current
                        tmp = conv2.split(" ");
                        if ( tmp[ 1 ] === current ) {

                            // If prev can be converted to accepted input
                            conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                converters[ "* " + tmp[ 0 ] ];
                            if ( conv ) {
                                // Condense equivalence converters
                                if ( conv === true ) {
                                    conv = converters[ conv2 ];

                                // Otherwise, insert the intermediate dataType
                                } else if ( converters[ conv2 ] !== true ) {
                                    current = tmp[ 0 ];
                                    dataTypes.splice( i--, 0, current );
                                }

                                break;
                            }
                        }
                    }
                }

                // Apply converter (if not an equivalence)
                if ( conv !== true ) {

                    // Unless errors are allowed to bubble, catch and return them
                    if ( conv && s["throws"] ) {
                        response = conv( response );
                    } else {
                        try {
                            response = conv( response );
                        } catch ( e ) {
                            return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
                        }
                    }
                }
            }

            // Update prev for next iteration
            prev = current;
        }
    }

    return { state: "success", data: response };
}
var oldCallbacks = [],
    rquestion = /\?/,
    rjsonp = /(=)\?(?=&|$)|\?\?/,
    nonce = jQuery.now();

// Default jsonp settings
jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
        var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
        this[ callback ] = true;
        return callback;
    }
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

    var callbackName, overwritten, responseContainer,
        data = s.data,
        url = s.url,
        hasCallback = s.jsonp !== false,
        replaceInUrl = hasCallback && rjsonp.test( url ),
        replaceInData = hasCallback && !replaceInUrl && typeof data === "string" &&
            !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") &&
            rjsonp.test( data );

    // Handle iff the expected data type is "jsonp" or we have a parameter to set
    if ( s.dataTypes[ 0 ] === "jsonp" || replaceInUrl || replaceInData ) {

        // Get callback name, remembering preexisting value associated with it
        callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
            s.jsonpCallback() :
            s.jsonpCallback;
        overwritten = window[ callbackName ];

        // Insert callback into url or form data
        if ( replaceInUrl ) {
            s.url = url.replace( rjsonp, "$1" + callbackName );
        } else if ( replaceInData ) {
            s.data = data.replace( rjsonp, "$1" + callbackName );
        } else if ( hasCallback ) {
            s.url += ( rquestion.test( url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
        }

        // Use data converter to retrieve json after script execution
        s.converters["script json"] = function() {
            if ( !responseContainer ) {
                jQuery.error( callbackName + " was not called" );
            }
            return responseContainer[ 0 ];
        };

        // force json dataType
        s.dataTypes[ 0 ] = "json";

        // Install callback
        window[ callbackName ] = function() {
            responseContainer = arguments;
        };

        // Clean-up function (fires after converters)
        jqXHR.always(function() {
            // Restore preexisting value
            window[ callbackName ] = overwritten;

            // Save back as free
            if ( s[ callbackName ] ) {
                // make sure that re-using the options doesn't screw things around
                s.jsonpCallback = originalSettings.jsonpCallback;

                // save the callback name for future use
                oldCallbacks.push( callbackName );
            }

            // Call if it was a function and we have a response
            if ( responseContainer && jQuery.isFunction( overwritten ) ) {
                overwritten( responseContainer[ 0 ] );
            }

            responseContainer = overwritten = undefined;
        });

        // Delegate to script
        return "script";
    }
});
// Install script dataType
jQuery.ajaxSetup({
    accepts: {
        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
        script: /javascript|ecmascript/
    },
    converters: {
        "text script": function( text ) {
            jQuery.globalEval( text );
            return text;
        }
    }
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
    if ( s.cache === undefined ) {
        s.cache = false;
    }
    if ( s.crossDomain ) {
        s.type = "GET";
        s.global = false;
    }
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

    // This transport only deals with cross domain requests
    if ( s.crossDomain ) {

        var script,
            head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

        return {

            send: function( _, callback ) {

                script = document.createElement( "script" );

                script.async = "async";

                if ( s.scriptCharset ) {
                    script.charset = s.scriptCharset;
                }

                script.src = s.url;

                // Attach handlers for all browsers
                script.onload = script.onreadystatechange = function( _, isAbort ) {

                    if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

                        // Handle memory leak in IE
                        script.onload = script.onreadystatechange = null;

                        // Remove the script
                        if ( head && script.parentNode ) {
                            head.removeChild( script );
                        }

                        // Dereference the script
                        script = undefined;

                        // Callback if not abort
                        if ( !isAbort ) {
                            callback( 200, "success" );
                        }
                    }
                };
                // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
                // This arises when a base node is used (#2709 and #4378).
                head.insertBefore( script, head.firstChild );
            },

            abort: function() {
                if ( script ) {
                    script.onload( 0, 1 );
                }
            }
        };
    }
});
var xhrCallbacks,
    // #5280: Internet Explorer will keep connections alive if we don't abort on unload
    xhrOnUnloadAbort = window.ActiveXObject ? function() {
        // Abort all pending requests
        for ( var key in xhrCallbacks ) {
            xhrCallbacks[ key ]( 0, 1 );
        }
    } : false,
    xhrId = 0;

// Functions to create xhrs
function createStandardXHR() {
    try {
        return new window.XMLHttpRequest();
    } catch( e ) {}
}

function createActiveXHR() {
    try {
        return new window.ActiveXObject( "Microsoft.XMLHTTP" );
    } catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
    /* Microsoft failed to properly
     * implement the XMLHttpRequest in IE7 (can't request local files),
     * so we use the ActiveXObject when it is available
     * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
     * we need a fallback.
     */
    function() {
        return !this.isLocal && createStandardXHR() || createActiveXHR();
    } :
    // For all other browsers, use the standard XMLHttpRequest object
    createStandardXHR;

// Determine support properties
(function( xhr ) {
    jQuery.extend( jQuery.support, {
        ajax: !!xhr,
        cors: !!xhr && ( "withCredentials" in xhr )
    });
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

    jQuery.ajaxTransport(function( s ) {
        // Cross domain only allowed if supported through XMLHttpRequest
        if ( !s.crossDomain || jQuery.support.cors ) {

            var callback;

            return {
                send: function( headers, complete ) {

                    // Get a new xhr
                    var handle, i,
                        xhr = s.xhr();

                    // Open the socket
                    // Passing null username, generates a login popup on Opera (#2865)
                    if ( s.username ) {
                        xhr.open( s.type, s.url, s.async, s.username, s.password );
                    } else {
                        xhr.open( s.type, s.url, s.async );
                    }

                    // Apply custom fields if provided
                    if ( s.xhrFields ) {
                        for ( i in s.xhrFields ) {
                            xhr[ i ] = s.xhrFields[ i ];
                        }
                    }

                    // Override mime type if needed
                    if ( s.mimeType && xhr.overrideMimeType ) {
                        xhr.overrideMimeType( s.mimeType );
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if ( !s.crossDomain && !headers["X-Requested-With"] ) {
                        headers[ "X-Requested-With" ] = "XMLHttpRequest";
                    }

                    // Need an extra try/catch for cross domain requests in Firefox 3
                    try {
                        for ( i in headers ) {
                            xhr.setRequestHeader( i, headers[ i ] );
                        }
                    } catch( _ ) {}

                    // Do send the request
                    // This may raise an exception which is actually
                    // handled in jQuery.ajax (so no try/catch here)
                    xhr.send( ( s.hasContent && s.data ) || null );

                    // Listener
                    callback = function( _, isAbort ) {

                        var status,
                            statusText,
                            responseHeaders,
                            responses,
                            xml;

                        // Firefox throws exceptions when accessing properties
                        // of an xhr when a network error occurred
                        // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
                        try {

                            // Was never called and is aborted or complete
                            if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

                                // Only called once
                                callback = undefined;

                                // Do not keep as active anymore
                                if ( handle ) {
                                    xhr.onreadystatechange = jQuery.noop;
                                    if ( xhrOnUnloadAbort ) {
                                        delete xhrCallbacks[ handle ];
                                    }
                                }

                                // If it's an abort
                                if ( isAbort ) {
                                    // Abort it manually if needed
                                    if ( xhr.readyState !== 4 ) {
                                        xhr.abort();
                                    }
                                } else {
                                    status = xhr.status;
                                    responseHeaders = xhr.getAllResponseHeaders();
                                    responses = {};
                                    xml = xhr.responseXML;

                                    // Construct response list
                                    if ( xml && xml.documentElement /* #4958 */ ) {
                                        responses.xml = xml;
                                    }

                                    // When requesting binary data, IE6-9 will throw an exception
                                    // on any attempt to access responseText (#11426)
                                    try {
                                        responses.text = xhr.responseText;
                                    } catch( e ) {
                                    }

                                    // Firefox throws an exception when accessing
                                    // statusText for faulty cross-domain requests
                                    try {
                                        statusText = xhr.statusText;
                                    } catch( e ) {
                                        // We normalize with Webkit giving an empty statusText
                                        statusText = "";
                                    }

                                    // Filter status for non standard behaviors

                                    // If the request is local and we have data: assume a success
                                    // (success with no data won't get notified, that's the best we
                                    // can do given current implementations)
                                    if ( !status && s.isLocal && !s.crossDomain ) {
                                        status = responses.text ? 200 : 404;
                                    // IE - #1450: sometimes returns 1223 when it should be 204
                                    } else if ( status === 1223 ) {
                                        status = 204;
                                    }
                                }
                            }
                        } catch( firefoxAccessException ) {
                            if ( !isAbort ) {
                                complete( -1, firefoxAccessException );
                            }
                        }

                        // Call complete if needed
                        if ( responses ) {
                            complete( status, statusText, responses, responseHeaders );
                        }
                    };

                    if ( !s.async ) {
                        // if we're in sync mode we fire the callback
                        callback();
                    } else if ( xhr.readyState === 4 ) {
                        // (IE6 & IE7) if it's in cache and has been
                        // retrieved directly we need to fire the callback
                        setTimeout( callback, 0 );
                    } else {
                        handle = ++xhrId;
                        if ( xhrOnUnloadAbort ) {
                            // Create the active xhrs callbacks list if needed
                            // and attach the unload handler
                            if ( !xhrCallbacks ) {
                                xhrCallbacks = {};
                                jQuery( window ).unload( xhrOnUnloadAbort );
                            }
                            // Add to list of active xhrs callbacks
                            xhrCallbacks[ handle ] = callback;
                        }
                        xhr.onreadystatechange = callback;
                    }
                },

                abort: function() {
                    if ( callback ) {
                        callback(0,1);
                    }
                }
            };
        }
    });
}
var fxNow, timerId,
    rfxtypes = /^(?:toggle|show|hide)$/,
    rfxnum = new RegExp( "^(?:([-+])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
    rrun = /queueHooks$/,
    animationPrefilters = [ defaultPrefilter ],
    tweeners = {
        "*": [function( prop, value ) {
            var end, unit,
                tween = this.createTween( prop, value ),
                parts = rfxnum.exec( value ),
                target = tween.cur(),
                start = +target || 0,
                scale = 1,
                maxIterations = 20;

            if ( parts ) {
                end = +parts[2];
                unit = parts[3] || ( jQuery.cssNumber[ prop ] ? "" : "px" );

                // We need to compute starting value
                if ( unit !== "px" && start ) {
                    // Iteratively approximate from a nonzero starting point
                    // Prefer the current property, because this process will be trivial if it uses the same units
                    // Fallback to end or a simple constant
                    start = jQuery.css( tween.elem, prop, true ) || end || 1;

                    do {
                        // If previous iteration zeroed out, double until we get *something*
                        // Use a string for doubling factor so we don't accidentally see scale as unchanged below
                        scale = scale || ".5";

                        // Adjust and apply
                        start = start / scale;
                        jQuery.style( tween.elem, prop, start + unit );

                    // Update scale, tolerating zero or NaN from tween.cur()
                    // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
                    } while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
                }

                tween.unit = unit;
                tween.start = start;
                // If a +=/-= token was provided, we're doing a relative animation
                tween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;
            }
            return tween;
        }]
    };

// Animations created synchronously will run synchronously
function createFxNow() {
    setTimeout(function() {
        fxNow = undefined;
    }, 0 );
    return ( fxNow = jQuery.now() );
}

function createTweens( animation, props ) {
    jQuery.each( props, function( prop, value ) {
        var collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
            index = 0,
            length = collection.length;
        for ( ; index < length; index++ ) {
            if ( collection[ index ].call( animation, prop, value ) ) {

                // we're done with this property
                return;
            }
        }
    });
}

function Animation( elem, properties, options ) {
    var result,
        index = 0,
        tweenerIndex = 0,
        length = animationPrefilters.length,
        deferred = jQuery.Deferred().always( function() {
            // don't match elem in the :animated selector
            delete tick.elem;
        }),
        tick = function() {
            var currentTime = fxNow || createFxNow(),
                remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
                // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
                temp = remaining / animation.duration || 0,
                percent = 1 - temp,
                index = 0,
                length = animation.tweens.length;

            for ( ; index < length ; index++ ) {
                animation.tweens[ index ].run( percent );
            }

            deferred.notifyWith( elem, [ animation, percent, remaining ]);

            if ( percent < 1 && length ) {
                return remaining;
            } else {
                deferred.resolveWith( elem, [ animation ] );
                return false;
            }
        },
        animation = deferred.promise({
            elem: elem,
            props: jQuery.extend( {}, properties ),
            opts: jQuery.extend( true, { specialEasing: {} }, options ),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function( prop, end, easing ) {
                var tween = jQuery.Tween( elem, animation.opts, prop, end,
                        animation.opts.specialEasing[ prop ] || animation.opts.easing );
                animation.tweens.push( tween );
                return tween;
            },
            stop: function( gotoEnd ) {
                var index = 0,
                    // if we are going to the end, we want to run all the tweens
                    // otherwise we skip this part
                    length = gotoEnd ? animation.tweens.length : 0;

                for ( ; index < length ; index++ ) {
                    animation.tweens[ index ].run( 1 );
                }

                // resolve when we played the last frame
                // otherwise, reject
                if ( gotoEnd ) {
                    deferred.resolveWith( elem, [ animation, gotoEnd ] );
                } else {
                    deferred.rejectWith( elem, [ animation, gotoEnd ] );
                }
                return this;
            }
        }),
        props = animation.props;

    propFilter( props, animation.opts.specialEasing );

    for ( ; index < length ; index++ ) {
        result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
        if ( result ) {
            return result;
        }
    }

    createTweens( animation, props );

    if ( jQuery.isFunction( animation.opts.start ) ) {
        animation.opts.start.call( elem, animation );
    }

    jQuery.fx.timer(
        jQuery.extend( tick, {
            anim: animation,
            queue: animation.opts.queue,
            elem: elem
        })
    );

    // attach callbacks from options
    return animation.progress( animation.opts.progress )
        .done( animation.opts.done, animation.opts.complete )
        .fail( animation.opts.fail )
        .always( animation.opts.always );
}

function propFilter( props, specialEasing ) {
    var index, name, easing, value, hooks;

    // camelCase, specialEasing and expand cssHook pass
    for ( index in props ) {
        name = jQuery.camelCase( index );
        easing = specialEasing[ name ];
        value = props[ index ];
        if ( jQuery.isArray( value ) ) {
            easing = value[ 1 ];
            value = props[ index ] = value[ 0 ];
        }

        if ( index !== name ) {
            props[ name ] = value;
            delete props[ index ];
        }

        hooks = jQuery.cssHooks[ name ];
        if ( hooks && "expand" in hooks ) {
            value = hooks.expand( value );
            delete props[ name ];

            // not quite $.extend, this wont overwrite keys already present.
            // also - reusing 'index' from above because we have the correct "name"
            for ( index in value ) {
                if ( !( index in props ) ) {
                    props[ index ] = value[ index ];
                    specialEasing[ index ] = easing;
                }
            }
        } else {
            specialEasing[ name ] = easing;
        }
    }
}

jQuery.Animation = jQuery.extend( Animation, {

    tweener: function( props, callback ) {
        if ( jQuery.isFunction( props ) ) {
            callback = props;
            props = [ "*" ];
        } else {
            props = props.split(" ");
        }

        var prop,
            index = 0,
            length = props.length;

        for ( ; index < length ; index++ ) {
            prop = props[ index ];
            tweeners[ prop ] = tweeners[ prop ] || [];
            tweeners[ prop ].unshift( callback );
        }
    },

    prefilter: function( callback, prepend ) {
        if ( prepend ) {
            animationPrefilters.unshift( callback );
        } else {
            animationPrefilters.push( callback );
        }
    }
});

function defaultPrefilter( elem, props, opts ) {
    var index, prop, value, length, dataShow, toggle, tween, hooks, oldfire,
        anim = this,
        style = elem.style,
        orig = {},
        handled = [],
        hidden = elem.nodeType && isHidden( elem );

    // handle queue: false promises
    if ( !opts.queue ) {
        hooks = jQuery._queueHooks( elem, "fx" );
        if ( hooks.unqueued == null ) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = function() {
                if ( !hooks.unqueued ) {
                    oldfire();
                }
            };
        }
        hooks.unqueued++;

        anim.always(function() {
            // doing this makes sure that the complete handler will be called
            // before this completes
            anim.always(function() {
                hooks.unqueued--;
                if ( !jQuery.queue( elem, "fx" ).length ) {
                    hooks.empty.fire();
                }
            });
        });
    }

    // height/width overflow pass
    if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
        // Make sure that nothing sneaks out
        // Record all 3 overflow attributes because IE does not
        // change the overflow attribute when overflowX and
        // overflowY are set to the same value
        opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

        // Set display property to inline-block for height/width
        // animations on inline elements that are having width/height animated
        if ( jQuery.css( elem, "display" ) === "inline" &&
                jQuery.css( elem, "float" ) === "none" ) {

            // inline-level elements accept inline-block;
            // block-level elements need to be inline with layout
            if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {
                style.display = "inline-block";

            } else {
                style.zoom = 1;
            }
        }
    }

    if ( opts.overflow ) {
        style.overflow = "hidden";
        if ( !jQuery.support.shrinkWrapBlocks ) {
            anim.done(function() {
                style.overflow = opts.overflow[ 0 ];
                style.overflowX = opts.overflow[ 1 ];
                style.overflowY = opts.overflow[ 2 ];
            });
        }
    }


    // show/hide pass
    for ( index in props ) {
        value = props[ index ];
        if ( rfxtypes.exec( value ) ) {
            delete props[ index ];
            toggle = toggle || value === "toggle";
            if ( value === ( hidden ? "hide" : "show" ) ) {
                continue;
            }
            handled.push( index );
        }
    }

    length = handled.length;
    if ( length ) {
        dataShow = jQuery._data( elem, "fxshow" ) || jQuery._data( elem, "fxshow", {} );
        if ( "hidden" in dataShow ) {
            hidden = dataShow.hidden;
        }

        // store state if its toggle - enables .stop().toggle() to "reverse"
        if ( toggle ) {
            dataShow.hidden = !hidden;
        }
        if ( hidden ) {
            jQuery( elem ).show();
        } else {
            anim.done(function() {
                jQuery( elem ).hide();
            });
        }
        anim.done(function() {
            var prop;
            jQuery.removeData( elem, "fxshow", true );
            for ( prop in orig ) {
                jQuery.style( elem, prop, orig[ prop ] );
            }
        });
        for ( index = 0 ; index < length ; index++ ) {
            prop = handled[ index ];
            tween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );
            orig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );

            if ( !( prop in dataShow ) ) {
                dataShow[ prop ] = tween.start;
                if ( hidden ) {
                    tween.end = tween.start;
                    tween.start = prop === "width" || prop === "height" ? 1 : 0;
                }
            }
        }
    }
}

function Tween( elem, options, prop, end, easing ) {
    return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
    constructor: Tween,
    init: function( elem, options, prop, end, easing, unit ) {
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || "swing";
        this.options = options;
        this.start = this.now = this.cur();
        this.end = end;
        this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
    },
    cur: function() {
        var hooks = Tween.propHooks[ this.prop ];

        return hooks && hooks.get ?
            hooks.get( this ) :
            Tween.propHooks._default.get( this );
    },
    run: function( percent ) {
        var eased,
            hooks = Tween.propHooks[ this.prop ];

        if ( this.options.duration ) {
            this.pos = eased = jQuery.easing[ this.easing ](
                percent, this.options.duration * percent, 0, 1, this.options.duration
            );
        } else {
            this.pos = eased = percent;
        }
        this.now = ( this.end - this.start ) * eased + this.start;

        if ( this.options.step ) {
            this.options.step.call( this.elem, this.now, this );
        }

        if ( hooks && hooks.set ) {
            hooks.set( this );
        } else {
            Tween.propHooks._default.set( this );
        }
        return this;
    }
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
    _default: {
        get: function( tween ) {
            var result;

            if ( tween.elem[ tween.prop ] != null &&
                (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
                return tween.elem[ tween.prop ];
            }

            // passing any value as a 4th parameter to .css will automatically
            // attempt a parseFloat and fallback to a string if the parse fails
            // so, simple values such as "10px" are parsed to Float.
            // complex values such as "rotate(1rad)" are returned as is.
            result = jQuery.css( tween.elem, tween.prop, false, "" );
            // Empty strings, null, undefined and "auto" are converted to 0.
            return !result || result === "auto" ? 0 : result;
        },
        set: function( tween ) {
            // use step hook for back compat - use cssHook if its there - use .style if its
            // available and use plain properties where available
            if ( jQuery.fx.step[ tween.prop ] ) {
                jQuery.fx.step[ tween.prop ]( tween );
            } else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
                jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
            } else {
                tween.elem[ tween.prop ] = tween.now;
            }
        }
    }
};

// Remove in 2.0 - this supports IE8's panic based approach
// to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function( tween ) {
        if ( tween.elem.nodeType && tween.elem.parentNode ) {
            tween.elem[ tween.prop ] = tween.now;
        }
    }
};

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
    var cssFn = jQuery.fn[ name ];
    jQuery.fn[ name ] = function( speed, easing, callback ) {
        return speed == null || typeof speed === "boolean" ||
            // special check for .toggle( handler, handler, ... )
            ( !i && jQuery.isFunction( speed ) && jQuery.isFunction( easing ) ) ?
            cssFn.apply( this, arguments ) :
            this.animate( genFx( name, true ), speed, easing, callback );
    };
});

jQuery.fn.extend({
    fadeTo: function( speed, to, easing, callback ) {

        // show any hidden elements after setting opacity to 0
        return this.filter( isHidden ).css( "opacity", 0 ).show()

            // animate to the value specified
            .end().animate({ opacity: to }, speed, easing, callback );
    },
    animate: function( prop, speed, easing, callback ) {
        var empty = jQuery.isEmptyObject( prop ),
            optall = jQuery.speed( speed, easing, callback ),
            doAnimation = function() {
                // Operate on a copy of prop so per-property easing won't be lost
                var anim = Animation( this, jQuery.extend( {}, prop ), optall );

                // Empty animations resolve immediately
                if ( empty ) {
                    anim.stop( true );
                }
            };

        return empty || optall.queue === false ?
            this.each( doAnimation ) :
            this.queue( optall.queue, doAnimation );
    },
    stop: function( type, clearQueue, gotoEnd ) {
        var stopQueue = function( hooks ) {
            var stop = hooks.stop;
            delete hooks.stop;
            stop( gotoEnd );
        };

        if ( typeof type !== "string" ) {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = undefined;
        }
        if ( clearQueue && type !== false ) {
            this.queue( type || "fx", [] );
        }

        return this.each(function() {
            var dequeue = true,
                index = type != null && type + "queueHooks",
                timers = jQuery.timers,
                data = jQuery._data( this );

            if ( index ) {
                if ( data[ index ] && data[ index ].stop ) {
                    stopQueue( data[ index ] );
                }
            } else {
                for ( index in data ) {
                    if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                        stopQueue( data[ index ] );
                    }
                }
            }

            for ( index = timers.length; index--; ) {
                if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
                    timers[ index ].anim.stop( gotoEnd );
                    dequeue = false;
                    timers.splice( index, 1 );
                }
            }

            // start the next in the queue if the last step wasn't forced
            // timers currently will call their complete callbacks, which will dequeue
            // but only if they were gotoEnd
            if ( dequeue || !gotoEnd ) {
                jQuery.dequeue( this, type );
            }
        });
    }
});

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
    var which,
        attrs = { height: type },
        i = 0;

    // if we include width, step value is 1 to do all cssExpand values,
    // if we don't include width, step value is 2 to skip over Left and Right
    includeWidth = includeWidth? 1 : 0;
    for( ; i < 4 ; i += 2 - includeWidth ) {
        which = cssExpand[ i ];
        attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
    }

    if ( includeWidth ) {
        attrs.opacity = attrs.width = type;
    }

    return attrs;
}

// Generate shortcuts for custom animations
jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: { opacity: "show" },
    fadeOut: { opacity: "hide" },
    fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
    jQuery.fn[ name ] = function( speed, easing, callback ) {
        return this.animate( props, speed, easing, callback );
    };
});

jQuery.speed = function( speed, easing, fn ) {
    var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
        complete: fn || !fn && easing ||
            jQuery.isFunction( speed ) && speed,
        duration: speed,
        easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
    };

    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
        opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

    // normalize opt.queue - true/undefined/null -> "fx"
    if ( opt.queue == null || opt.queue === true ) {
        opt.queue = "fx";
    }

    // Queueing
    opt.old = opt.complete;

    opt.complete = function() {
        if ( jQuery.isFunction( opt.old ) ) {
            opt.old.call( this );
        }

        if ( opt.queue ) {
            jQuery.dequeue( this, opt.queue );
        }
    };

    return opt;
};

jQuery.easing = {
    linear: function( p ) {
        return p;
    },
    swing: function( p ) {
        return 0.5 - Math.cos( p*Math.PI ) / 2;
    }
};

jQuery.timers = [];
jQuery.fx = Tween.prototype.init;
jQuery.fx.tick = function() {
    var timer,
        timers = jQuery.timers,
        i = 0;

    fxNow = jQuery.now();

    for ( ; i < timers.length; i++ ) {
        timer = timers[ i ];
        // Checks the timer has not already been removed
        if ( !timer() && timers[ i ] === timer ) {
            timers.splice( i--, 1 );
        }
    }

    if ( !timers.length ) {
        jQuery.fx.stop();
    }
    fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
    if ( timer() && jQuery.timers.push( timer ) && !timerId ) {
        timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
    }
};

jQuery.fx.interval = 13;

jQuery.fx.stop = function() {
    clearInterval( timerId );
    timerId = null;
};

jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
};

// Back Compat <1.8 extension point
jQuery.fx.step = {};

if ( jQuery.expr && jQuery.expr.filters ) {
    jQuery.expr.filters.animated = function( elem ) {
        return jQuery.grep(jQuery.timers, function( fn ) {
            return elem === fn.elem;
        }).length;
    };
}
var rroot = /^(?:body|html)$/i;

jQuery.fn.offset = function( options ) {
    if ( arguments.length ) {
        return options === undefined ?
            this :
            this.each(function( i ) {
                jQuery.offset.setOffset( this, options, i );
            });
    }

    var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft,
        box = { top: 0, left: 0 },
        elem = this[ 0 ],
        doc = elem && elem.ownerDocument;

    if ( !doc ) {
        return;
    }

    if ( (body = doc.body) === elem ) {
        return jQuery.offset.bodyOffset( elem );
    }

    docElem = doc.documentElement;

    // Make sure it's not a disconnected DOM node
    if ( !jQuery.contains( docElem, elem ) ) {
        return box;
    }

    // If we don't have gBCR, just use 0,0 rather than error
    // BlackBerry 5, iOS 3 (original iPhone)
    if ( typeof elem.getBoundingClientRect !== "undefined" ) {
        box = elem.getBoundingClientRect();
    }
    win = getWindow( doc );
    clientTop  = docElem.clientTop  || body.clientTop  || 0;
    clientLeft = docElem.clientLeft || body.clientLeft || 0;
    scrollTop  = win.pageYOffset || docElem.scrollTop;
    scrollLeft = win.pageXOffset || docElem.scrollLeft;
    return {
        top: box.top  + scrollTop  - clientTop,
        left: box.left + scrollLeft - clientLeft
    };
};

jQuery.offset = {

    bodyOffset: function( body ) {
        var top = body.offsetTop,
            left = body.offsetLeft;

        if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
            top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
            left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
        }

        return { top: top, left: left };
    },

    setOffset: function( elem, options, i ) {
        var position = jQuery.css( elem, "position" );

        // set position first, in-case top/left are set even on static elem
        if ( position === "static" ) {
            elem.style.position = "relative";
        }

        var curElem = jQuery( elem ),
            curOffset = curElem.offset(),
            curCSSTop = jQuery.css( elem, "top" ),
            curCSSLeft = jQuery.css( elem, "left" ),
            calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
            props = {}, curPosition = {}, curTop, curLeft;

        // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
        if ( calculatePosition ) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;
        } else {
            curTop = parseFloat( curCSSTop ) || 0;
            curLeft = parseFloat( curCSSLeft ) || 0;
        }

        if ( jQuery.isFunction( options ) ) {
            options = options.call( elem, i, curOffset );
        }

        if ( options.top != null ) {
            props.top = ( options.top - curOffset.top ) + curTop;
        }
        if ( options.left != null ) {
            props.left = ( options.left - curOffset.left ) + curLeft;
        }

        if ( "using" in options ) {
            options.using.call( elem, props );
        } else {
            curElem.css( props );
        }
    }
};


jQuery.fn.extend({

    position: function() {
        if ( !this[0] ) {
            return;
        }

        var elem = this[0],

        // Get *real* offsetParent
        offsetParent = this.offsetParent(),

        // Get correct offsets
        offset       = this.offset(),
        parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

        // Subtract element margins
        // note: when an element has margin: auto the offsetLeft and marginLeft
        // are the same in Safari causing offset.left to incorrectly be 0
        offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
        offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

        // Add offsetParent borders
        parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
        parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

        // Subtract the two offsets
        return {
            top:  offset.top  - parentOffset.top,
            left: offset.left - parentOffset.left
        };
    },

    offsetParent: function() {
        return this.map(function() {
            var offsetParent = this.offsetParent || document.body;
            while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
                offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || document.body;
        });
    }
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
    var top = /Y/.test( prop );

    jQuery.fn[ method ] = function( val ) {
        return jQuery.access( this, function( elem, method, val ) {
            var win = getWindow( elem );

            if ( val === undefined ) {
                return win ? (prop in win) ? win[ prop ] :
                    win.document.documentElement[ method ] :
                    elem[ method ];
            }

            if ( win ) {
                win.scrollTo(
                    !top ? val : jQuery( win ).scrollLeft(),
                     top ? val : jQuery( win ).scrollTop()
                );

            } else {
                elem[ method ] = val;
            }
        }, method, val, arguments.length, null );
    };
});

function getWindow( elem ) {
    return jQuery.isWindow( elem ) ?
        elem :
        elem.nodeType === 9 ?
            elem.defaultView || elem.parentWindow :
            false;
}
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
    jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
        // margin is only for outerHeight, outerWidth
        jQuery.fn[ funcName ] = function( margin, value ) {
            var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

            return jQuery.access( this, function( elem, type, value ) {
                var doc;

                if ( jQuery.isWindow( elem ) ) {
                    // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                    // isn't a whole lot we can do. See pull request at this URL for discussion:
                    // https://github.com/jquery/jquery/pull/764
                    return elem.document.documentElement[ "client" + name ];
                }

                // Get document width or height
                if ( elem.nodeType === 9 ) {
                    doc = elem.documentElement;

                    // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
                    // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
                    return Math.max(
                        elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                        elem.body[ "offset" + name ], doc[ "offset" + name ],
                        doc[ "client" + name ]
                    );
                }

                return value === undefined ?
                    // Get width or height on the element, requesting but not forcing parseFloat
                    jQuery.css( elem, type, value, extra ) :

                    // Set width or height on the element
                    jQuery.style( elem, type, value, extra );
            }, type, chainable ? margin : undefined, chainable, null );
        };
    });
});
// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
    define( "jquery", [], function () { return jQuery; } );
}

})( window );

define('lib/clone',['require'],function(require){
  var clone = function (json) {
    return JSON.parse(JSON.stringify(json));
  };
  return clone;
});

// There are a few ways we can define the configuration.
define('config',['require','lib/clone'],function(require) {
  var clone = require('lib/clone');
  var config = {};

  // Parse query parameters from the url search.
  //
  // config options here have 2 purposes:
  //  * desktop-calc specific options (testing, preview, maintenance, language menu)
  //  * testing api options (nofolders, etc)
  var query = location.search;
  if (query[0] === '?') query = query.slice(1);
  var paramStrings = query.split('&'), params = {};

  for (var i = 0; i < paramStrings.length; i++) {
    var pair = paramStrings[i].split('=');
    params[pair[0]] = (pair.length === 2) ? pair[1] : true;
  }

  var checkOption = function(option) {
    return params.hasOwnProperty(option);
  };
  var addOption = function(option) {
    if (checkOption(option)) config[option] = true;
  };

  //starts "no", i.e. "nographpaper" => graphpaper: false
  var addInverseOption = function(option) {
    if (checkOption("no" + option)) config[option] = false;
  };

  //desktop specific options
  addOption('testing');
  addOption('maintenance');
  addOption('disablelocale');
  addOption('detectlocale');
  addOption('nativeOnscreenKeypad');
  if (params.lang) config.lang = params.lang;

  // Disable navigation warning -- Eric likes not having this in noconcat. Eli likes it in startlivecss
  if (checkOption('noconcat')) config.no_navigation_warning = true;

  //previewMode rules:
  config.previewMessage = "You're previewing regressions.";
  config.previewFeedbackUrl = "https://docs.google.com/forms/d/1-TJNpusDOTmxuI44Pt8cNTPEtuc2zh5U_izPTPM2Glg/viewform";
  var hostIsPreview = location && location.hostname === 'preview.desmos.com';
  config.previewMode = (checkOption('previewMode') || hostIsPreview);

  //API options for testing
  addOption('lockViewport');
  addOption('resizeLoop');

  //note: on desktop, this won't work when you open a blank graph because we add focus
  //and that automatically uncollapses. Need to test on a non-blank state or in ?embed
  addOption('expressionsCollapsed');
  addInverseOption('images');
  addInverseOption('folders');
  addInverseOption('menus');
  addInverseOption('zoomButtons');
  addInverseOption('keypad');
  addInverseOption('graphpaper');
  addInverseOption('expressions');
  addInverseOption('expressionsTopbar');
  addInverseOption('settingsMenu');
  addInverseOption('branding');

  return {
    get: function (prop) {
      return config[prop];
    },
    all: function () {
      return clone(config);
    }
  };
});

// Do things this way to avoid script injection, and to have the LOAD_DATA
// var available to all our other javascript written out below. Using
// jQuery, which lives in vendor (above).
define('main/load_data',['require','jquery'],function(require){
  var $ = require('jquery');
  var load_data = $('body').data('load-data');
  return load_data;
});

define('pjs',[], function() {
var P = (function(prototype, ownProperty, undefined) {
  // helper functions that also help minification
  function isObject(o) { return typeof o === 'object'; }
  function isFunction(f) { return typeof f === 'function'; }

  // used to extend the prototypes of superclasses (which might not
  // have `.Bare`s)
  function SuperclassBare() {}

  function P(_superclass /* = Object */, definition) {
    // handle the case where no superclass is given
    if (definition === undefined) {
      definition = _superclass;
      _superclass = Object;
    }

    // C is the class to be returned.
    //
    // It delegates to instantiating an instance of `Bare`, so that it
    // will always return a new instance regardless of the calling
    // context.
    //
    //  TODO: the Chrome inspector shows all created objects as `C`
    //        rather than `Object`.  Setting the .name property seems to
    //        have no effect.  Is there a way to override this behavior?
    function C() {
      var self = new Bare;
      if (isFunction(self.init)) self.init.apply(self, arguments);
      return self;
    }

    // C.Bare is a class with a noop constructor.  Its prototype is the
    // same as C, so that instances of C.Bare are also instances of C.
    // New objects can be allocated without initialization by calling
    // `new MyClass.Bare`.
    function Bare() {}
    C.Bare = Bare;

    // Set up the prototype of the new class.
    var _super = SuperclassBare[prototype] = _superclass[prototype];
    var proto = Bare[prototype] = C[prototype] = new SuperclassBare;

    // other variables, as a minifier optimization
    var extensions;


    // set the constructor property on the prototype, for convenience
    proto.constructor = C;

    C.mixin = function(def) {
      Bare[prototype] = C[prototype] = P(C, def)[prototype];
      return C;
    }

    return (C.open = function(def) {
      extensions = {};

      if (isFunction(def)) {
        // call the defining function with all the arguments you need
        // extensions captures the return value.
        extensions = def.call(C, proto, _super, C, _superclass);
      }
      else if (isObject(def)) {
        // if you passed an object instead, we'll take it
        extensions = def;
      }

      // ...and extend it
      if (isObject(extensions)) {
        for (var ext in extensions) {
          if (ownProperty.call(extensions, ext)) {
            proto[ext] = extensions[ext];
          }
        }
      }

      // if there's no init, we assume we're inheriting a non-pjs class, so
      // we default to applying the superclass's constructor.
      if (!isFunction(proto.init)) {
        proto.init = _superclass;
      }

      return C;
    })(definition);
  }

  // ship it
  return P;

  // as a minifier optimization, we've closured in a few helper functions
  // and the string 'prototype' (C[p] is much shorter than C.prototype)
})('prototype', ({}).hasOwnProperty);
return P;
});

//     Underscore.js 1.3.3
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var slice            = ArrayProto.slice,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) { return new wrapper(obj); };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root['_'] = _;
  }

  // Current version.
  _.VERSION = '1.3.3';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    if (obj.length === +obj.length) results.length = obj.length;
    return results;
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError('Reduce of empty array with no initial value');
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var reversed = _.toArray(obj).reverse();
    if (context && !initial) iterator = _.bind(iterator, context);
    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    each(obj, function(value, index, list) {
      if (!iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if a given value is included in the array or object using `===`.
  // Aliased as `contains`.
  _.include = _.contains = function(obj, target) {
    var found = false;
    if (obj == null) return found;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    found = any(obj, function(value) {
      return value === target;
    });
    return found;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Return the maximum element or (element-based computation).
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var shuffled = [], rand;
    each(obj, function(value, index, list) {
      rand = Math.floor(Math.random() * (index + 1));
      shuffled[index] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, val, context) {
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      if (a === void 0) return 1;
      if (b === void 0) return -1;
      return a < b ? -1 : a > b ? 1 : 0;
    }), 'value');
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, val) {
    var result = {};
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    each(obj, function(value, index) {
      var key = iterator(value, index);
      (result[key] || (result[key] = [])).push(value);
    });
    return result;
  };

  // Use a comparator function to figure out at what index an object should
  // be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator) {
    iterator || (iterator = _.identity);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >> 1;
      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj)                                     return [];
    if (_.isArray(obj))                           return slice.call(obj);
    if (_.isArguments(obj))                       return slice.call(obj);
    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    return _.isArray(obj) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especcialy useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail`.
  // Especially useful on the arguments object. Passing an **index** will return
  // the rest of the values in the array from that index onward. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = function(array, index, guard) {
    return slice.call(array, (index == null) || guard ? 1 : index);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return _.reduce(array, function(memo, value) {
      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));
      memo[memo.length] = value;
      return memo;
    }, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator) {
    var initial = iterator ? _.map(array, iterator) : array;
    var results = [];
    // The `isSorted` flag is irrelevant if the array only contains two elements.
    if (array.length < 3) isSorted = true;
    _.reduce(initial, function (memo, value, index) {
      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {
        memo.push(value);
        results.push(array[index]);
      }
      return memo;
    }, []);
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays. (Aliased as "intersect" for back-compat.)
  _.intersection = _.intersect = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = _.flatten(slice.call(arguments, 1), true);
    return _.filter(array, function(value){ return !_.include(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
    return results;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i, l;
    if (isSorted) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item) {
    if (array == null) return -1;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
    var i = array.length;
    while (i--) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function bind(func, context) {
    var bound, args;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, throttling, more, result;
    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);
    return function() {
      context = this; args = arguments;
      var later = function() {
        timeout = null;
        if (more) func.apply(context, args);
        whenDone();
      };
      if (!timeout) timeout = setTimeout(later, wait);
      if (throttling) {
        more = true;
      } else {
        result = func.apply(context, args);
      }
      whenDone();
      throttling = true;
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      if (immediate && !timeout) func.apply(context, args);
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      return memo = func.apply(this, arguments);
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func].concat(slice.call(arguments, 0));
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) { return func.apply(this, arguments); }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    return _.map(obj, _.identity);
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var result = {};
    each(_.flatten(slice.call(arguments, 1)), function(key) {
      if (key in obj) result[key] = obj[key];
    });
    return result;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] == null) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function.
  function eq(a, b, stack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a._chain) a = a._wrapped;
    if (b._chain) b = b._wrapped;
    // Invoke a custom `isEqual` method if one is provided.
    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = stack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (stack[length] == a) return true;
    }
    // Add the first object to the stack of traversed objects.
    stack.push(a);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          // Ensure commutative equality for sparse arrays.
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent.
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    stack.pop();
    return result;
  }

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType == 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Is a given variable an arguments object?
  _.isArguments = function(obj) {
    return toString.call(obj) == '[object Arguments]';
  };
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Is a given value a function?
  _.isFunction = function(obj) {
    return toString.call(obj) == '[object Function]';
  };

  // Is a given value a string?
  _.isString = function(obj) {
    return toString.call(obj) == '[object String]';
  };

  // Is a given value a number?
  _.isNumber = function(obj) {
    return toString.call(obj) == '[object Number]';
  };

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return _.isNumber(obj) && isFinite(obj);
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    // `NaN` is the only value for which `===` is not reflexive.
    return obj !== obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value a date?
  _.isDate = function(obj) {
    return toString.call(obj) == '[object Date]';
  };

  // Is the given value a regular expression?
  _.isRegExp = function(obj) {
    return toString.call(obj) == '[object RegExp]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Has own property?
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function (n, iterator, context) {
    for (var i = 0; i < n; i++) iterator.call(context, i);
  };

  // Escape a string for HTML interpolation.
  _.escape = function(string) {
    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g,'&#x2F;');
  };

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object, ensuring that
  // they're correctly added to the OOP wrapper as well.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      addToWrapper(name, _[name] = obj[name]);
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /.^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    '\\': '\\',
    "'": "'",
    'r': '\r',
    'n': '\n',
    't': '\t',
    'u2028': '\u2028',
    'u2029': '\u2029'
  };

  for (var p in escapes) escapes[escapes[p]] = p;
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  var unescaper = /\\(\\|'|r|n|t|u2028|u2029)/g;

  // Within an interpolation, evaluation, or escaping, remove HTML escaping
  // that had been previously added.
  var unescape = function(code) {
    return code.replace(unescaper, function(match, escape) {
      return escapes[escape];
    });
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults(settings || {}, _.templateSettings);

    // Compile the template source, taking care to escape characters that
    // cannot be included in a string literal and then unescape them in code
    // blocks.
    var source = "__p+='" + text
      .replace(escaper, function(match) {
        return '\\' + escapes[match];
      })
      .replace(settings.escape || noMatch, function(match, code) {
        return "'+\n_.escape(" + unescape(code) + ")+\n'";
      })
      .replace(settings.interpolate || noMatch, function(match, code) {
        return "'+\n(" + unescape(code) + ")+\n'";
      })
      .replace(settings.evaluate || noMatch, function(match, code) {
        return "';\n" + unescape(code) + "\n;__p+='";
      }) + "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __p='';" +
      "var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n" +
      source + "return __p;\n";

    var render = new Function(settings.variable || 'obj', '_', source);
    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for build time
    // precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' +
      source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // The OOP Wrapper
  // ---------------

  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  var wrapper = function(obj) { this._wrapped = obj; };

  // Expose `wrapper.prototype` as `_.prototype`
  _.prototype = wrapper.prototype;

  // Helper function to continue chaining intermediate results.
  var result = function(obj, chain) {
    return chain ? _(obj).chain() : obj;
  };

  // A method to easily add functions to the OOP wrapper.
  var addToWrapper = function(name, func) {
    wrapper.prototype[name] = function() {
      var args = slice.call(arguments);
      unshift.call(args, this._wrapped);
      return result(func.apply(_, args), this._chain);
    };
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      var wrapped = this._wrapped;
      method.apply(wrapped, arguments);
      var length = wrapped.length;
      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];
      return result(wrapped, this._chain);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      return result(method.apply(this._wrapped, arguments), this._chain);
    };
  });

  // Start chaining a wrapped Underscore object.
  wrapper.prototype.chain = function() {
    this._chain = true;
    return this;
  };

  // Extracts the result from a wrapped and chained object.
  wrapper.prototype.value = function() {
    return this._wrapped;
  };

}).call(this);
define("underscore", (function (global) {
    return function () {
        var ret, fn;
        return ret || global._;
    };
}(this)));

//Copied from MDN reference
//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind

;(function () {
  if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
      if (typeof this !== "function") {
        // closest thing possible to the ECMAScript 5 internal IsCallable function
        throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
      }

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP = function () {},
          fBound = function () {
            return fToBind.apply(this instanceof fNOP && oThis ? this : oThis,
                                 aArgs.concat(Array.prototype.slice.call(arguments)));
          };

      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();

      return fBound;
    };
  }
})();

define("function.bind", function(){});

define('underscore_model',['require','underscore','pjs','function.bind'],function(require){
var _ = require('underscore');
var P = require('pjs');
require('function.bind');

var UnderscoreModel = P(function (model) {

  // each model gets a guid that is unique even across different
  // versions of this file running within the same window
  var guid_count = 0;
  var guid_prefix = 'guid_' + Math.round(Math.random()*1000000) + "_" + (new Date().getTime()) + "_";

  model.init = function () {
    this.__observers = {};
    this.__eventObservers = {};
    this.__oldProperties = {};
    this.__propertyComparators = {};
    this.guid = guid_prefix + (++guid_count);
  };

  model.unobserveAll = function () {
    this.__observers = {};
    this.__eventObservers = {};
  };

  model.getProperty = function (property) {
    return this[property];
  };

  model.getOldProperty = function (property) {
    return this.__oldProperties[property];
  };

  model.setProperty = function (property, newValue) {
    var oldValue = this[property];
    var comparator = this.__propertyComparators[property];
    if (comparator) {
      if (comparator(oldValue, newValue)) {
        return;
      }
    } else if (_.isEqual(oldValue, newValue)) {
      return;
    }

    this.__oldProperties[property] = oldValue;
    this[property] = newValue;
    this.notifyPropertyChange(property);
  };

  model.setProperties = function (obj) {
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) this.setProperty(k, obj[k]);
    }
  };

  model.setPropertyComparator = function (property, comparator) {
    this.__propertyComparators[property] = comparator;
  };

  // for properties
  model.notifyPropertyChange = function (property) {
    this.__callObservers(this.__observers, property, this);
  };
  model.observe = function (property_string, callback) {
    this.__addObservers(this.__observers, property_string, callback);
  };
  model.unobserve = function (property_string) {
    this.__removeObservers(this.__observers, property_string);
  };
  model.observeAndSync = function (property_string, callback) {
    this.observe(property_string, callback);
    var props = property_string.split(" ");
    for(var i = 0; i < props.length; i++){
      var prop_parts = props[i].split(".");
      var prop = prop_parts[0];
      if(this.hasOwnProperty(prop)){
        //Observer will fire for each observed property that exists
        //With the same args that an observed change would cause
        callback(prop, this);
      }
    }
  };

  // for events
  model.triggerEvent = function (event, param) {
    this.__callObservers(this.__eventObservers, event, param);
  };
  model.observeEvent = function (event_string, callback) {
    this.__addObservers(this.__eventObservers, event_string, callback);
  };
  model.unobserveEvent = function (event_string) {
    this.__removeObservers(this.__eventObservers, event_string);
  };

  // generic implementation of trigger, add, remove observers
  model.__callObservers = function (list, prop, arg) {
    var observers = list[prop];
    if (observers) {
     for (var i=0; i<observers.length; i++) {
       observers[i].callback(prop, arg);
     }
    }
  };
  model.__removeObservers = function (list, prop_string) {
    var props = prop_string.split(" ");
    for (var i=0; i<props.length; i++) {
      var prop_parts = props[i].split(".");
      var prop = prop_parts[0];
      var namespace = prop_parts[1];

      // only keep the ones with a different namespace
      if (prop && namespace) {
        var original = list[prop];
        var filtered = [];
        if (!original) continue;
        for (var j=0; j<original.length; j++) {
          var observer = original[j];
          if (observer.namespace !== namespace) {
            filtered.push(observer);
          }
        }
        list[prop] = filtered;

      // get rid of all of observers for this property since no namespace given
      } else if (prop) {
        delete list[prop];

      // we aren't given a property, only a namespace. run through each
      // property that has observers and call .unobserve(property.namespace)
      } else if (namespace) {
        for (prop in list) {
          if (list.hasOwnProperty(prop)) {
            this.__removeObservers(list, prop + "." + namespace);
          }
        }
      }
    }
  };
  model.__addObservers = function (list, prop_string, callback) {
    var props = prop_string.split(" ");
    for (var i=0; i<props.length; i++) {
      var prop_parts = props[i].split(".");
      var prop = prop_parts[0];
      if (!prop) throw 'Must supply a property to observe';

      var namespace = prop_parts[1];
      var observer = {
        namespace: namespace,
        callback: callback
      };

      var observers = list[prop];
      if (!observers) {
        list[prop] = [observer];
      } else {
        observers.push(observer);
      }
    }
  };

});

return UnderscoreModel;
});

define('main/url_prefix',['require'],function(require){
  var URL_PREFIX = '/';
  // if we're on the file:// protocol we don't want to look at pathname. It'll
  // be a really ugly path listing all the directories we need to go through to
  // get to the index.html file. Just pretend like we're on a live server.
  return URL_PREFIX;
});


//from http://www.w3schools.com/js/js_cookies.asp
define('main/cookie',[],function () {
  function getCookie(c_name) {

    var encoded_c_name = encodeURIComponent(c_name);
    var i,x,y,ARRcookies=document.cookie.split(";");
    for (i=0;i<ARRcookies.length;i++)
    {
      x=ARRcookies[i].substr(0,ARRcookies[i].indexOf("="));
      y=ARRcookies[i].substr(ARRcookies[i].indexOf("=")+1);
      x=x.replace(/^\s+|\s+$/g,"");
      if (x==encoded_c_name) {
        return decodeURIComponent(y);
      }
    }
  }

  function setCookie(c_name, value, duration) {
    //set a javascript cookie
    var expires = new Date();
    expires.setDate(expires.getDate() + (duration || 30));
    document.cookie = (
      encodeURIComponent(c_name) +
      "=" + encodeURIComponent(value) +
      "; expires=" + expires.toUTCString() +
      "; path=/"
    );
  }

  return {
    getCookie: getCookie,
    setCookie: setCookie
  };
});

define('i18n',['require','config','main/cookie','underscore'],function (require) {
  var Config = require('config');
  var Cookie = require('main/cookie');
  var _ = require('underscore');
  var default_lang = '';
  var language_dict = {};

  //this is a list of enabled languages -- i.e. ones that show up in the language dropdown
  //languages not on this list can still be accessed through the query parameter, but not
  //through the cookie or the browser preferences
  var enabled_languages = {
    'en': {
      displayName: 'English (US)',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
    },
    'es-ES': {
      displayName: 'Espaol (Espaa)',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_ES-ES.pdf',
      useAsRoot: true
    },
    'ru': {
      displayName: ' ',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_RU.pdf'
    },
    'de': {
      displayName: 'Deutsch',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_DE.pdf'
    },
    'pt-BR': {
      displayName: 'Portugus (Brasil)',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
    },
    'pt-PT': {
      displayName: 'Portugus (Portugal)',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
    },
    'fr': {
      displayName: 'Franais',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_FR.pdf'
    },
    'it': {
      displayName: 'Italiano',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_IT.pdf'
    },
    'nl': {
      displayName: 'Nederlands',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
    },
    'no': {
      displayName: 'Norsk',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
    },
    'sv-SE': {
      displayName: 'Svenska',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
    },
    'cs': {
      displayName: 'etina',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
    },
    'tr': {
      displayName: 'Trke',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_TR.pdf'
    },
    'sl': {
      displayName: 'Slovenina',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_SL.pdf'
    },
    'lt': {
      displayName: 'Lietuvi',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
    },
    'pl': {
      displayName: 'Polski',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_PL.pdf'
    },
    'ro': {
      displayName: 'Romn',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
    },
    'id': {
      displayName: 'Bahasa Indonesia',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
    },
    'vi': {
      displayName: 'Ting Vit',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_VI.pdf'
    },
    'el': {
      displayName: '',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_EL.pdf'
    },
    'sr-CS': {
      displayName: 'SRPSKI',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
    },
    'bg': {
      displayName: '',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_BG.pdf'
    },
    'mk': {
      displayName: '',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
    },
    'th': {
      displayName: ' ',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
    },
    'zh-CN': {
      displayName: '',
      useAsRoot: true,
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_ZH-CN.pdf'
    },
    'zh-TW': {
      displayName: '',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_ZH-TW.pdf'
    },
    'ko': {
      displayName: '',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
    },
    'ja': {
      displayName: '',
      userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
    }
  };

  function init (lang, dict) {
    default_lang = lang || '';
    language_dict = dict || {};
  }

  function translateString (message, variables) {
    var translation = language_dict[default_lang] && language_dict[default_lang][message] || message || '';

    for (var variable in variables) {
      if (variables.hasOwnProperty(variable)) {
        translation = translation.split('__' + variable + '__').join(variables[variable]);
      }
    }

    return translation;
  }

  //this function looks through users preferences to determine what language to show
  //order is:
  //  Config (i.e. query parameter): this doesn't require the lanague to be enabled
  //  Cookie: this *does* require that the language is enabled
  //  Browser settings: does require enabled
  //  Truncated version of browser setting: does require enabled
  //
  //If none of those works, we fall back to 'en' (which is actually ignored by our i18n_dict)
  function detectLanguage() {
    if (Config.get('lang')) {
      return Config.get('lang');
    }

    var preferences = [Cookie.getCookie('lang')];

    //auto detect locales
    if(!Config.get('disablelocale')){
      var browserLocale;
      if (navigator.userLanguage) {
        browserLocale = navigator.userLanguage;
      } else {
        browserLocale = navigator.language;
      }

      var baseLocale = browserLocale.split('-')[0];
      //first choice: exact dialect
      preferences.push(browserLocale);
      //second choice: root level locale
      preferences.push(baseLocale);
      //third choice: dialect that shares the root and has useAsRoot: true
      _.each(enabled_languages, function(lang, code) {
        if (
          code.split('-')[0] === baseLocale &&
          lang.useAsRoot
        ) preferences.push(code);
      });
    }

    for (var i = 0 ; i < preferences.length ; i++) {
      var lang = preferences[i];
      if (enabled_languages.hasOwnProperty(lang)) return lang;
    }
    return 'en';
  }

  function currentLanguage() {
    return default_lang;
  }

  //when we want to send translatable strings out from the worker, we JSON.stringify
  //{msg: message, vars: variables}.
  //unpack that all here.
  var unpack = function(str) {
    //numbers are JSON.parse-able, so catch this situation and return early.
    //can arise when this is called recursively from an unpack
    if (typeof(str) === 'number') return str;

    var returnVal;
    try {
      var data = JSON.parse(str);
      //elements of data.vars could also be i18n strings. recursively unpack.
      for (var key in data.vars) {
        data.vars[key] = unpack(data.vars[key]);
      }
      returnVal = translateString(data.msg, data.vars);
    } catch (ex) {
      //we sometimes just send back non-json-encoded strings (i.e. if we don't need to interpolate)
      returnVal = translateString(str);
    }
    return returnVal;
  };

  return {
    init: init,
    t: translateString,
    detectLanguage: detectLanguage,
    currentLanguage: currentLanguage,
    enabled_languages: enabled_languages,
    unpack: unpack
  };
});

define('main/graph',['require','pjs','underscore_model','main/url_prefix','i18n'],function(require){
  var P = require('pjs');
  var UnderscoreModel = require('underscore_model');
  var URL_PREFIX = require('main/url_prefix');
  var i18n = require('i18n');

  var Graph = P(UnderscoreModel, function (proto, _super) {

    var properties = [
      'title', 'thumbURL', 'hash', 'parentHash', 'graphData', 'access', 'created'
    ];

    proto.init = function (obj) {
      _super.init.call(this);
      var self = this;
      this.observe('title', function () {
        self.displayTitle = self.title || '['+i18n.t('Untitled Graph')+']';
      });
      this.observe('created', this.updateDisplayDate.bind(this));
      this.observe('hash', function () {
        self.setProperty(
          'path',
          URL_PREFIX + (self.hash ? '/' + self.hash : '')
        );
      });

      if (obj) {
        properties.forEach(function (p) {
          if (obj.hasOwnProperty(p)) self.setProperty(p, obj[p]);
        });
      }
      if (!this.access) this.setProperty('access', 'all');
      if (!this.path) this.setProperty('path', URL_PREFIX);
      this.now = new Date();
    };

    proto.copy = function () {
      return Graph(this);
    };

    function computeDisplayDate (created) {
      var now = Date.now();
      var seconds = (now - created)/1000;
      var minutes = seconds/60;
      var hours = minutes/60;
      var days = hours/24;
      var weeks = days/7;
      var monthNames = [
        i18n.t('Jan'),
        i18n.t('Feb'),
        i18n.t('Mar'),
        i18n.t('Apr'),
        i18n.t('May'),
        i18n.t('Jun'),
        i18n.t('Jul'),
        i18n.t('Aug'),
        i18n.t('Sep'),
        i18n.t('Oct'),
        i18n.t('Nov'),
        i18n.t('Dec')
      ];

      if (weeks >= 5) {
        return i18n.t('on __month__ __day__, __year__', {
          month: monthNames[created.getMonth()],
          day: created.getDate(),
          year: created.getFullYear()
        });
      }
      if (weeks >= 2) return i18n.t('__number__ weeks ago', {number: String(Math.floor(weeks))});
      if (days >= 7) return i18n.t('last week');
      if (days >= 2) return i18n.t('__number__ days ago', {number: String(Math.floor(days))});
      if (hours >= 24) return i18n.t('yesterday');
      if (hours >= 2) return i18n.t('__number__ hours ago', {number: String(Math.floor(hours))});
      if (minutes >= 60) return i18n.t('one hour ago');
      if (minutes >= 2) return i18n.t('__number__ minutes ago', {number: String(Math.floor(minutes))});
      if (seconds >= 60) return i18n.t('one minute ago');
      return i18n.t('just now');
    }

    proto.updateDisplayDate = function () {
      this.displayDate = computeDisplayDate(this.created);
    };

    proto.plainObject = function () {
      var out = {};
      var self = this;
      properties.forEach(function (p) {
        out[p] = self[p];
      });
      return out;
    };
  });

  Graph.fromAjax = function(obj) {
    return Graph({
      title: obj.title,
      thumbURL: obj.thumbUrl,
      graphData: JSON.stringify(obj.state),
      hash: obj.hash,
      parentHash: obj.parent_hash,
      access: obj.access,
      created: new Date(obj.created)
    });
  };

  Graph.updateFromSync = function (obj, resp) {
    obj.setProperty('title', resp.title);
    obj.setProperty('hash', resp.hash);
    obj.setProperty('parentHash', resp.parent_hash);
    obj.setProperty('graphData', obj.graphData);
    obj.setProperty('thumbURL', resp.thumbUrl);
    obj.setProperty('created', new Date(resp.created));
  };

  return Graph;
});

define('main/calculator_backend',['require','jquery','main/graph'],function(require){
  var $ = require('jquery');
  var Graph = require('main/graph');

  var calculatorBackend = {
    apiPath: function(path) {
      return ['/api/v1/calculator', path].join('/');
    },

    // Helper for saveGraph and shareGraph that lets them make different
    // decision about whether to add the graph to the list of the user's graphs.
    _saveGraph: function (graph, my_graphs) {
      //detect if we should push to drive
      var push_to_drive = ($('input[name="push_to_drive"]').attr("checked")? "push_to_drive" : undefined);
      var access = ($('input[name="access"]').attr("checked")? "all" : "link");
      var formData = {
        parent_hash: graph.parentHash,
        thumb_data: graph.thumbURL,
        calc_state: graph.graphData,
        graph_hash: graph.hash,
        version: 'h3',
        access: access,
        my_graphs: my_graphs,
        // Use all these undefineds so that the data doesn't go to the server
        // if it is blank or null.
        title: graph.title || undefined,
        push_to_drive: push_to_drive
      };

      return $.post(this.apiPath('save'), formData).pipe(function(resp) {
        Graph.updateFromSync(graph, resp);
        return graph;
      });
    },

    saveGraph: function (graph) {
      return this._saveGraph(graph, true);
    },

    shareGraph: function (graph) {
      return this._saveGraph(graph, false);
    },

    emailGraph: function (data) {
      return $.post(this.apiPath('email_graph'), data);
    },

    emailFeedback: function (data) {
      return $.post(this.apiPath('email_feedback'), data);
    },

    allowFeature: function (data) {
      return $.post(this.apiPath('allow_feature'), data);
    },

    getGraphs: function () {
      return $.getJSON(this.apiPath('my_graphs'));
    },

    removeGraph: function (graph) {
      return $.post(this.apiPath('my_graphs/remove'), {
        hash: graph.hash
      });
    },
  };

  return calculatorBackend;
});

define('main/parse_json_errors',['require','jquery'],function(require){
  var $ = require('jquery');
  var parseJSONErrors = function(jqXHR) {
    try {
      return $.parseJSON(jqXHR.responseText).errors;
    } catch(err) {
      return [{message: 'Internal Server Error.'}];
    }
  };
  return parseJSONErrors;
});
// RandomHashFactory takes a seed, and constructs an object with a .next()
// method that returns random 10 character alphanumeric strings. The seed is
// designed to be a hex string representing a 128 bit random UUID, but is
// allowed to be any non-empty string.
//
// Usage:
// > randomHashFactory = new Desmos.RandomHashFactory('570a95d1f9a6455ab4b9c76bbd2509b6')
// > randomHashFactory.next()
// 'medjqzoa4t'
// > randomHashFactory.next()
// 'phgn5qzrm0'
//
// Implementation Notes:
// Behind the scenes, uses an ARC4 implementation by David Bau.
// http://davidbau.com/archives/2010/01/30/random_seeds_coded_hints_and_quintillions.html
// http://davidbau.com/encode/seedrandom.js

define('lib/random_hash',['require','exports','module'],function(require, exports){
  /* jshint bitwise: false */

  // ARC4 wraps BauARC4 (taken from seedrandom.js) to make an object that
  // takes a string seed instead of a key as a constructor, and returns an
  // array of integers between 0 and 255 instead of a large integer.
  //
  // The seed is designed to be the hex representation of a 128 bit random
  // UUID, but is allowed to be any string.
  //
  // Usage:
  // var arc4 = new ARC4('this is a seed')
  // arc4.g(4) // returns an array of 4 integers between 0 and 256
  function ARC4(seed) {
    this.bauArc4 = new BauARC4(toKey(seed));
  }

  ARC4.prototype.g = function(count) {
    var digits = Array(count);
    for (var i = 0; i < count; i++) {
      digits[i] = this.bauArc4.g(1);
    }
    return digits;
  };

  // Helpers used by ARC4
  var width = 256;
  function lowbits(n) { return n & (width - 1); }

  //
  // tokey()
  // Converts a string seed into a key that is an array of integers
  function toKey(seed) {
    var stringSeed = seed + ''; // Ensure the seed is a string
    var key = [];
    var smear = 0;
    var j;
    for (j = 0; j < stringSeed.length; j++) {
      key[lowbits(j)] =
        lowbits((smear ^= key[lowbits(j)] * 19) + stringSeed.charCodeAt(j));
    }
    return key;
  }

  // BauARC4, cribbed from http://davidbau.com/encode/seedrandom.js
  //
  // An ARC4 implementation.  The constructor takes a key in the form of
  // an array of at most (width) integers that should be 0 <= x < (width).
  //
  // The g(count) method returns a pseudorandom integer that concatenates
  // the next (count) outputs from ARC4.  Its return value is a number x
  // that is in the range 0 <= x < (width ^ count).
  //
  /** @constructor */
  function BauARC4(key) {
    var t, u, me = this, keylen = key.length;
    var i = 0, j = me.i = me.j = me.m = 0;
    me.S = [];
    me.c = [];

    // The empty key [] is treated as [0].
    if (!keylen) { key = [keylen++]; }

    // Set up S using the standard key scheduling algorithm.
    while (i < width) { me.S[i] = i++; }
    for (i = 0; i < width; i++) {
      t = me.S[i];
      j = lowbits(j + t + key[i % keylen]);
      u = me.S[j];
      me.S[i] = u;
      me.S[j] = t;
    }

    // The "g" method returns the next (count) outputs as one number.
    me.g = function getnext(count) {
      var s = me.S;
      var i = lowbits(me.i + 1); var t = s[i];
      var j = lowbits(me.j + t); var u = s[j];
      s[i] = u;
      s[j] = t;
      var r = s[lowbits(t + u)];
      while (--count) {
        i = lowbits(i + 1); t = s[i];
        j = lowbits(j + t); u = s[j];
        s[i] = u;
        s[j] = t;
        r = r * width + s[lowbits(t + u)];
      }
      me.i = i;
      me.j = j;
      return r;
    };
    // For robust unpredictability discard an initial batch of values.
    // See http://www.rsa.com/rsalabs/node.asp?id=2009
    me.g(width);
  }

  // We're using a somewhat odd distribution of random hashes, but this
  // follows existing server side behavior. Draw characters from downcased
  // alphanumeric set. Weights each alphabetical character twice as heavily as
  // each digit.
  var upperLowerDigits =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  var codex = upperLowerDigits.toLowerCase();
  // Hardcoded because the below algorithm relies on this number not changing.
  var codexLength = 62;

  var nchars = 10;
  var RandomHashFactory = function(seed) {
    if (!seed) throw 'You must supply a seed to RandomHashFactory. It should have at least 128 bits of entropy.';

    var arc4 = new ARC4(seed);

    this.next = function () {
      var chars = Array(nchars);
      var n = 0;
      var trialIndex;

      // Rejection sampling. Want uniform samples between 0 and 61, the
      // valid indices into our codex. arc4 returns integers between 0 and
      // 255, so we shift two bits off them to get integers between 0 and 63,
      // and then reject the samples larger than 61.
      while (n < nchars) {
        trialIndex = arc4.g(1)[0] >> 2;
        if (trialIndex < codexLength) {
          chars[n] = codex[trialIndex];
          n++;
        }
      }
      return chars.join("");
    };

    // Return a new random 128-bit hex value
    this.nextSeed = function () {
      var nbytes = 16;
      var bytes = arc4.g(nbytes);
      var hexCodes = Array(nbytes);
      for (var i=0; i < nbytes; i++) {
        hexCodes[i] = bytes[i].toString(16);
        // Pad each byte representation to 2 hex characters
        if (hexCodes[i].length === 1) {
          hexCodes[i] = "0" + hexCodes[i];
        }
      }
      return hexCodes.join("");
    };
  };

  var factory;

  exports.next = function(){
    if(!factory) throw "Random Hash Factory not initialized";
    return factory.next();
  };

  exports.nextSeed = function(){
    if(!factory) throw "Random Hash Factory not initialized";
    return factory.nextSeed();
  };

  exports.init = function(seed){
    factory = new RandomHashFactory(seed);
  };

  return exports;
});

define('main/graphs_controller',['require','underscore','pjs','main/graph','main/calculator_backend','main/parse_json_errors','underscore_model','i18n','lib/random_hash'],function(require){
  var _ = require('underscore');
  var P = require('pjs');
  var Graph = require('main/graph');
  var calculatorBackend = require('main/calculator_backend');
  var parseJSONErrors = require('main/parse_json_errors');
  var UnderscoreModel = require('underscore_model');
  var i18n = require('i18n');
  var randomHash = require('lib/random_hash');

  var GraphsController = P(UnderscoreModel, function (proto, _super) {

    proto.init = function (Calc, randomSeed) {
      _super.init.call(this);

      this.observe('currentGraph', this.onCurrentGraphChange.bind(this));

      this.Calc = Calc;
      this.content = [];
      this.undoRedo = Calc._calc.undoRedo;

      this.startSavingCallbacks = [];
      this.saveSuccessCallbacks = [];
      this.saveErrorCallbacks = [];
      this.driveAccessErrorCallbacks = [];
      this.startUpdatingGraphsCallbacks = [];
      this.updateGraphsSuccessCallbacks = [];
      this.updateGraphsErrorCallbacks = [];
      this.graphAddedCallbacks = [];
      this.clearCallbacks = [];
      this.graphRemovedCallbacks = [];
      this.randomHash = randomHash;
      this.seedRandom(randomSeed);
    };

    proto.seedRandom = function (seed) {
      if (!seed) {
        alert(i18n.t(
          "Something went wrong, please report this to desmos.com support. (Error __error_num__)",
          {error_num: '77361'}
        ));
        return;
      }

      var d = new Date();
      var augmentedSeed = '' + seed + d.getTime() + d.getMilliseconds();
      this.randomHash.init(augmentedSeed);
    };

    proto.remove = function (graph) {
      var index = this.getIndexFromGraph(graph);
      this.content.splice(index, 1);
      this.triggerRemove(index);
      calculatorBackend.removeGraph(graph);
    };

    proto.clear = function () {
      this.content = [];
      this.triggerClear();
    };

    proto.triggerStartSaving = function () {
      _.each(this.startSavingCallbacks, function (cb) { cb() });
    };

    proto.triggerSaveSuccess = function () {
      _.each(this.saveSuccessCallbacks, function (cb) { cb() });
    };

    proto.triggerSaveError = function () {
      _.each(this.saveErrorCallbacks, function (cb) { cb() });
    };

    proto.triggerDriveAccessError = function () {
      _.each(this.driveAccessErrorCallbacks, function (cb) { cb() });
    };

    proto.triggerStartUpdatingGraphs = function () {
      _.each(this.startUpdatingGraphsCallbacks, function (cb) { cb() });
    };

    proto.triggerUpdateGraphsSuccess = function () {
      _.each(this.updateGraphsSuccessCallbacks, function (cb) { cb() });
    };

    proto.triggerupdateGraphsError = function () {
      _.each(this.updateGraphsErrorCallbacks, function (cb) { cb() });
    };

    proto.triggerAdd = function (index) {
      _.each(this.graphAddedCallbacks, function (cb) { cb(index); });
    };

    proto.triggerClear = function () {
      _.each(this.clearCallbacks, function (cb) { cb(); });
    };

    proto.triggerRemove = function (index) {
      _.each(this.graphRemovedCallbacks, function (cb) { cb(index); });
    };

    // Update state and screenshot
    proto.updateGraphData = function (graph) {
      var state = JSON.stringify(this.Calc.getState());
      graph.setProperty('graphData', state);
      graph.setProperty('parentHash', graph.hash);
      graph.setProperty('hash', this.randomHash.next());

      var thumbURL = this.Calc.screenshot({width: 200, height: 200});
      graph.setProperty('thumbURL', thumbURL);
    };

    proto.saveAs = function (graph) {
      this.save(graph, true);
    };

    //do_not_overwrite flag -- only exposed to proto.saveAs
    proto.save = function (graph, do_not_overwrite) {

      var oldGraph = this.currentGraph;
      var self = this;

      self.triggerStartSaving();

      // about to modify the graph, so we make sure we modify the copy, not the original
      graph = graph.copy();
      self.updateGraphData(graph);

      calculatorBackend.saveGraph(graph).done(function(graph) {

        // Don't call loadGraph here because we don't want to trigger a
        // setState on save.

        // copy graph so that what goes into my_graphs list isn't the exact
        // same object as what's stored in currentGraph.
        self.setProperty('currentGraph', graph.copy());
        self.content.unshift(graph);
        self.triggerAdd(0);
        self.triggerSaveSuccess();

        if (!do_not_overwrite && oldGraph) {
          self.remove(oldGraph);
        }

        //_kmq.push(['record', 'saved graph']);
      }).fail(function(jqXHR) {
        var error = parseJSONErrors(jqXHR)[0];
        if (error.key === 'drive_access_error') self.triggerDriveAccessError();
        self.triggerSaveError();
        //_kmq.push(['record', 'failed to save graph']);
      });
    };

    //is this the stablest way to do this?
    proto.getIndexFromGraph = function (graph) {
      for (var index = 0 ; index < this.content.length ; index++) {
        if (graph.hash === this.content[index].hash) return index;
      }
      return -1;
    };

    proto.updateGraphs = function () {
      var self = this;
      self.triggerStartUpdatingGraphs();
      calculatorBackend.getGraphs().done(function (msg) {
        var graphs;
        if (msg.myGraphs) graphs = msg.myGraphs.map(Graph.fromAjax);
        self.content = graphs;
        self.triggerUpdateGraphsSuccess();
      }).fail(function () {
        self.triggerupdateGraphsError();
      });
    };

    proto.loadGraph = function (graph) {
      var self = this;

      // combine the setState undo/redo along with the currentGraph undo/redo into
      // a single atomic undo/redo transaction.
      this.undoRedo.oneTransaction(function () {

        // set the sate. this itself is going to add to undo/redo stream to
        self.Calc.setState(graph.graphData);

        // set the currentGraph. This will add to undo/redo as well.
        self.setProperty('currentGraph', graph);
      });
    };

    proto.clearGraph = function () {
      this.loadGraph(Graph());
      this.Calc._calc.addFocus();
    };

    proto.onCurrentGraphChange = function () {
      var currentGraph = this.currentGraph;
      var oldCurrentGraph = this.getOldProperty('currentGraph');

      // only undo currentGraph if there is an oldCurrentGraph. Basically, this makes it so
      // that we skip the first time we set a Graph(), whether the first Graph()
      if (oldCurrentGraph) {
        var self = this;

        // make copies of these from the start in case they ever get modified in the future
        var undoGraph = oldCurrentGraph.copy();
        var redoGraph = currentGraph.copy();

        // this makes it so undo/redo changes title and hash
        this.undoRedo.addTransaction({
          type: this.undoRedo.RESPONSE_TO_CHANGE,
          redo: function(){
            self.setProperty('currentGraph', redoGraph.copy());
          },
          undo: function(){
            self.setProperty('currentGraph', undoGraph.copy());
          }
        });
      }

      document.title = currentGraph.title || i18n.t('Desmos Graphing Calculator');

      if (!(window.history && history.pushState)) return;

      var path = currentGraph.path;
      if (!path) return;
      if (window.location.search) path += window.location.search;
      if (path !== window.location.href) {
        history.pushState(
          currentGraph.plainObject(),
          currentGraph.title,
          path
        );
      }
    };
  });

  return GraphsController;
});

// From http://stackoverflow.com/questions/7742781/why-javascript-only-works-after-opening-developer-tools-in-ie-once
// Avoid `console` errors in browsers that lack a console.
define('console',['require'],function(require){
  var noop = function () {};
  var methods = [
    'assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error',
    'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log',
    'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd',
    'timeStamp', 'trace', 'warn'
  ];
  var console = {};

  var addMethod = function(method) {
    if((typeof window !== 'undefined') && window.console && window.console[method]) {
      console[method] = function(){window.console[method].apply(window.console, arguments)};
    } else {
      console[method] = noop;
    }
  };

  methods.forEach(addMethod);
  return console;
});

define('underscore_view',['require','jquery','underscore','./underscore_model','pjs','i18n'],function(require){
var $ = require('jquery');
var _ = require('underscore');
var UnderscoreModel = require('./underscore_model');
var P = require('pjs');
var i18n = require('i18n');

var insertionQueue = [];

var UnderscoreView = P(UnderscoreModel, function (view, _super, _class) {

  // Class method for generating more efficient templates in the case
  // that the template takes no parameters
  _class.staticTemplate = function (str) {
    var node = $(str)[0];
    return function () { return node.cloneNode(true); };
  };

  view.$ = function (selector) {
    var $node = $(this.__domNode);
    if (!selector) {
     return $node;
    } else {
      return $node.filter(selector).add($node.find(selector));
    }
  };

  // methods to adding view to dom. these call .didInsertElement()
  // automatically
  var makeInsertFn = function (methodName) {
    return function (selector) {
      var isTopmostInsert = (insertionQueue.length === 0);
      insertionQueue.push(this);
      if (!this.__domNode) _render.call(this);

      $(selector)[methodName](this.$());
      if (isTopmostInsert) {
        while (insertionQueue.length) {
          insertionQueue.pop().didInsertElement();
        }
      }
      return this.$();
    };
  };

  view.appendTo = makeInsertFn('append');
  view.replace = makeInsertFn('replaceWith');
  view.prependTo = makeInsertFn('prepend');
  view.insertAfter = makeInsertFn('after');
  view.insertBefore = makeInsertFn('before');

  view.remove = function () {
    this.$().remove();
    this.destruct();
  };

  // should be overriden and used to cleanup any resources this view has
  // aquired. Most often, that means remove any observers set and any child
  // views created.
  view.destruct = function () {};

  // Called when the view has been rendered, but before its DOM node has been
  // inserted into the document. This is a good time to attach child views and
  // event listeners.
  view.didCreateElement = function () {};

  // for this to be called, must insert this.$() into dom using one of the
  // methods above. If not, you must call .didInsertElement() yourself.
  view.didInsertElement = function () {};

  // this is the information that will be made available to the underscore template
  view.getTemplateParams = function () {return {};};

  // tap into these if you want deep control of how a complete rerender happens.
  // one thing these are useful for are saving/restoring temporary data within
  // the view that will get wiped out when the html is regenerated.
  view.beforeRerender = function () {};
  view.afterRerender = function () {};

  // will render only if something has changed
  view.rerender = function () {
    var oldDomNode = this.__domNode;
    var newParams = this.getTemplateParams();
    if (_.isEqual(newParams, this.__lastRenderParams)) return;

    this.beforeRerender();

    _render.call(this);

    if (oldDomNode && $.contains(document, oldDomNode)) {
      this.replace(oldDomNode);
    }

    this.afterRerender();
  };

  view.setDomNode = function (node) {
    this.__domNode = node[0] ? node[0] : node;
    this.didInsertElement();
  };

  // private
  var _render = function () {
    var params = this.getTemplateParams();
    var helpers = {
      t: function(key, args){ return i18n.t(key, args);}
    };
    var combined = _.extend({}, params, helpers);
    var html = this.template(combined);
    var $node = $(html);
    this.__domNode = $node[0];
    this.__lastRenderParams = params;
    this.didCreateElement();
  };

});
return UnderscoreView;
});

define('keys',['require'],function (require) {

  var Keys = function () {

    // based on http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#fixed-virtual-key-codes
    var table = {
      8:  this.BACKSPACE = 'Backspace',
      9:  this.TAB = 'Tab',
      13: this.ENTER = 'Enter',
      16: this.SHIFT = 'Shift',
      17: this.CONTROL = 'Control',
      18: this.ALT = 'Alt',
      20: this.CAPSLOCK = 'CapsLock',
      27: this.ESCAPE = 'Esc',
      32: this.SPACEBAR = 'Space',
      33: this.PAGEUP = 'PageUp',
      34: this.PAGEDOWN = 'PageDown',
      35: this.END = 'End',
      36: this.HOME = 'Home',
      37: this.LEFT = 'Left',
      38: this.UP = 'Up',
      39: this.RIGHT = 'Right',
      40: this.DOWN = 'Down',
      46: this.DELETE = 'Del'
    };

    this.lookup = function (evt) {
      return table[evt.which];
    };
  };

  return new Keys();
});
define('conditional_blur',['require','jquery'],function (require) {
  var $ = require('jquery');

  return function () {
    if (document.activeElement === document.body) return;
    $(document.activeElement).blur();
  };
});
// Shim HTML5 placeholder element.
//
// https://github.com/parndt/jquery-html5-placeholder-shim

(function($) {
  // @todo Document this.
  $.extend($,{ placeholder: {
      browser_supported: function() {
        return this._supported !== undefined ?
          this._supported :
          ( this._supported = !!('placeholder' in $('<input type="text">')[0]) );
      },
      shim: function(opts) {
        var config = {
          color: '#888',
          cls: 'placeholder',
          selector: 'input[placeholder], textarea[placeholder]'
        };
        $.extend(config,opts);
        if (!this.browser_supported()) {
          $(config.selector)._placeholder_shim(config);
        }
      }
  }});

  $.extend($.fn,{
    _placeholder_shim: function(config) {
      function calcPositionCss(target)
      {
        var op = $(target).offsetParent().offset();
        var ot = $(target).offset();

        return {
          top: ot.top - op.top,
          left: ot.left - op.left,
          width: $(target).width()
        };
      }
      return this.each(function() {
        var $this = $(this);

        if( $this.data('placeholder') ) {
          var $ol = $this.data('placeholder');
          $ol.css(calcPositionCss($this));
          return true;
        }

        var possible_line_height = {};
        if( !$this.is('textarea') && $this.css('height') != 'auto') {
          possible_line_height = { lineHeight: $this.css('height'), whiteSpace: 'nowrap' };
        }

        var ol = $('<label />')
          .text($this.attr('placeholder'))
          .addClass(config.cls)
          .css($.extend({
            position:'absolute',
            display: 'inline',
            float:'none',
            overflow:'hidden',
            textAlign: 'left',
            color: config.color,
            cursor: 'text',
            paddingTop: $this.css('padding-top'),
            paddingLeft: $this.css('padding-left'),
            paddingRight: $this.css('padding-right'),
            paddingBottom: $this.css('padding-bottom'),
            fontSize: $this.css('font-size'),
            fontFamily: $this.css('font-family'),
            fontStyle: $this.css('font-style'),
            fontWeight: $this.css('font-weight'),
            textTransform: $this.css('text-transform'),
            backgroundColor: 'transparent',
            zIndex: 99
          }, possible_line_height))
          .css(calcPositionCss(this))
          .attr('for', this.id)
          .data('target',$this)
          .click(function(){
            $(this).data('target').focus();
          })
          .insertBefore(this);
        $this
          .data('placeholder',ol)
          .focus(function(){
            ol.hide();
          }).blur(function() {
            ol[$this.val().length ? 'hide' : 'show']();
          }).triggerHandler('blur');
        $(window)
          .resize(function() {
            var $target = ol.data('target');
            ol.css(calcPositionCss($target));
          });
      });
    }
  });
})(jQuery);
define("vendor/jquery.html5-placeholder-shim", function(){});

/**
 * @license RequireJS text 2.0.7 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('text',['module'], function (module) {


    var text, fs, Cc, Ci,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.7',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.indexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1, name.length);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node)) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file.indexOf('\uFEFF') === 0) {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                errback(e);
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        errback(err);
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
            typeof Components !== 'undefined' && Components.classes &&
            Components.interfaces)) {
        //Avert your gaze!
        Cc = Components.classes,
        Ci = Components.interfaces;
        Components.utils['import']('resource://gre/modules/FileUtils.jsm');

        text.get = function (url, callback) {
            var inStream, convertStream,
                readData = {},
                fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                           .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                                .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});

/* global console */
define('template',['underscore', 'text'], function(_, text){
  var buildMap = {};

  return {
    load: function(name, req, onLoad, config){
      var text_name = "template_src/" + name + ".underscore";
      text.get(req.toUrl(text_name), function(template_source){
        var template = _.template(template_source);
        if(config.isBuild){
          buildMap[name] = template.source;
        }
        onLoad(template);
      });
    },

    write: function(pluginName, moduleName, write){
      if (moduleName in buildMap) {
        var template = (buildMap[moduleName]);
        write(
          "define('" +
            pluginName + '!' + moduleName + "', " +
            "['underscore'], " +
            "function(_) {return " + template + ";}" +
          ");"
        );
      }
      else{
        console.log("ERROR - failed to find template " + moduleName + " in buildMap");
      }
    }
  };
});

define('template!unsupported_browser', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div id="unsupported-browser" class="modal_section">\n  <div style=\'color:black; font-size:150%;\'>'+
( t('Unsupported Browser') )+
'</div>\n  <div style=\'padding:20px 0px; color:#666\'>\n      '+
( t('Desmos works best on your version of Android if you use the Chrome Browser.') )+
'\n      <br><br>\n      <a href=\'https://play.google.com/store/apps/details?id=com.android.chrome\'>\n        '+
( t('Click here to download Google Chrome.') )+
'<br><br>\n      </a>\n\n          <div style="text-align: center; margin-top: 25px; margin-bottom:-16px">\n              <a class=\'dcg-btn dcg-action-hide dcg-do-not-blur\'>'+
( t('Hide this warning.') )+
'</a>\n          </div>\n  </div>\n</div>\n';
}
return __p;
};});
define('template!login_dialog', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div id="login-dialog" class="modal_section">\n  <h1>\n    '+
( t('Sign In') )+
'\n  </h1>\n  \n  <div class=\'bg-line\'>\n    <span>'+
( t('Sign In with Google') )+
'</span>\n  </div>\n    <div class=\'google-login-btn\'>\n      <span class=\'dcg-btn dcg-btn-large dcg-action-googlelogin\'><img src=\'/img/google_32.png\' width=\'24px\' height=\'24px\' /> '+
( t('Sign In with Your Google Account') )+
'</span>\n    </div>\n    \n  <div class=\'bg-line\'>\n    <span>'+
( t('Sign In with Desmos') )+
'</span>\n  </div>\n  \n  ';
 _.each(errors, function(error) {
;__p+='\n  <div class="errors">\n      <span>'+
( error.message )+
'</span>\n  </div>\n  ';
 })
;__p+='\n  \n  <form class="desmos-login dcg-action-submit">\n    <div class="form_content_interior">\n      <label for="email">\n        <span>'+
( t('Email:') )+
'</span>\n        <input type="email"\n          name="email"\n          class="input"\n          autofocus="autofocus"\n          required="required"\n          id="top_email"\n        />\n      </label>\n  \n      <label>\n        <span>'+
( t('Password:') )+
'</span>\n        <input type="password"\n          name="password"\n          class="input"\n          required="required"\n          id="top_password"\n        />\n      </label>\n  \n      <span style="float: left; margin-top: 10px; margin-bottom: 10px">\n        <a class="dcg-action-recoverpassword">'+
( t('Forgot your password?') )+
'</a>\n        <div style=\'height:10px\'></div>\n        <a class="dcg-action-createaccount">'+
( t("Don't have an account?") )+
'</a>\n      </span>\n  \n      <div style="float:right; margin-right: 30px">\n        ';
 if (spinning) {
;__p+='\n          <div class="progress_indicator progress"></div>\n        ';
 } else {
;__p+='\n          <button type="submit" class="dcg-btn dcg-btn-green">'+
( t('Sign In') )+
'</button> \n        ';
 }
;__p+='\n      </div>\n  \n    </div>\n  </form>\n</div>\n';
}
return __p;
};});
define('template!create_account_dialog', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div id="create-account-dialog" class="modal_section ';
 if (saveNext) {
;__p+=' save-first';
 }
;__p+='">\n  <h1>\n    ';
 if (saveNext) {
;__p+='\n      '+
( t('Create an account to save your work!') )+
'\n    ';
 } else {
;__p+='\n      '+
( t('Create Account') )+
'\n    ';
 }
;__p+='\n  </h1>\n  ';
 if (saveNext) {
;__p+='\n    <h4 style="margin-bottom: 30px">'+
( t('Already have an account?') )+
' <span class="dcg-action-login-then-save">'+
( t('Sign in') )+
'</span></h4>\n  ';
 }
;__p+='\n  <div class=\'bg-line\'>\n    <span>'+
( t('Link to Google') )+
'</span>\n  </div>\n    <div class=\'google-login-btn\'>\n      <span class=\'dcg-btn dcg-btn-large dcg-action-googlelogin\'>\n        <img src=\'/img/google_32.png\' width=\'24px\' height=\'24px\' />\n        '+
( t("Link to your Google Account") )+
'\n      </span>\n    </div>\n    <div class=\'bg-line\'><span>\n      '+
( t("Use your Email Address") )+
'\n    </span></div>\n  \n  ';
 _.each(errors, function(error) {
;__p+='\n  <div class="errors">\n      <span>'+
( error.message )+
'</span>\n  </div>\n  ';
 })
;__p+='\n  \n  <form class="dcg-action-submit">\n    <label>\n      <span>'+
( t('Name:') )+
'</span>\n      <input type="text"\n        name="name"\n        class="input"\n        required="required"\n        autofocus="autofocus"\n      />\n    </label>\n  \n    <div class="dcg-description">\n      '+
( t("This is the name we'll use if we feature one of your graphs.") )+
'\n    </div>\n  \n    <label>\n      <span>'+
( t('Email:') )+
'</span>\n      <input type="email"\n        name="email"\n        class="input"\n        required="required"\n      />\n    </label>\n  \n    <div class="dcg-description">\n      '+
( t("We'll never share or sell your email address.") )+
'\n    </div>\n  \n    <label>\n      <span>'+
( t('Password:') )+
'</span>\n      <input type="password"\n        class="input"\n        name="password"\n        required="required"\n      />\n    </label>\n  \n    <span style="float: left; margin-top: 10px; margin-bottom: 10px">\n      <a class="dcg-action-login">'+
( t('Already have an account?') )+
'</a>\n    </span>\n  \n    ';
 if (spinning) {
;__p+='\n      <div class="progress_indicator progress"></div>\n    ';
 } else {
;__p+='\n      <button type="submit" class="dcg-btn dcg-btn-green" style="float:right; margin-right: 30px">'+
( t('Create Account') )+
'</button>\n    ';
 }
;__p+='\n      \n  </form>\n  <div class=\'notice\' style="margin-top: 30px">\n    '+
( t("By clicking \"__btn__,\" you acknowledge that you've read and accept our __terms_of_use_link__.",
      {
        terms_of_use_link : "<a href='/terms' target='_blank'>" + t("Terms of Use") + "</a>",
        btn: t("Create Account")
      }
    ) )+
'\n  </div>\n';
}
return __p;
};});
define('template!edit_account_dialog', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div id="edit-account-dialog" class="modal_section">\n  \n  ';
 _.each(errors, function(error) {
;__p+='\n    <div class="errors">\n      <span>'+
( error.message )+
'</span>\n    </div>\n  ';
 })
;__p+='\n  \n  <form class="dcg-action-submit">\n    ';
 if (user) {
;__p+='\n      <h1>'+
( t('Edit Account') )+
'</h1>\n      <label>\n        <span>'+
( t('Name:') )+
'</span>\n        <input type="text"\n          name="name"\n          class="input"\n          id="edit_name"\n          autofocus="autofocus"\n          required="required"\n          value="'+
( user.name )+
'"\n        />\n      </label>\n      <div class="dcg-description">\n        '+
( t("This is the name we'll use if we feature one of your graphs.") )+
'\n      </div>\n  \n      ';
 if(!user.isEdmodoUser && !user.isDriveUser) {
;__p+='\n        <h1>'+
( t('Update Password') )+
'</h1>\n        <div id="update-password-fields">\n          <label>\n            <span>'+
( t('Current Password:') )+
'</span>\n            <input type="password"\n              name="old_pass"\n              class="input"\n            />\n          </label>\n  \n          <label>\n            <span>'+
( t('New Password:') )+
'</span>\n            <input type="password"\n              name="new_pass"\n              class="input"\n            />\n          </label>\n  \n          <label>\n            <span>'+
( t('Repeat Password:') )+
'</span>\n            <input type="password"\n              name="repeat_new_pass"\n              class="input"\n            />\n          </label>\n        </div>\n      ';
 }
;__p+='\n      <br />\n      \n      ';
 if (spinning) {
;__p+='\n        <div class="progress_indicator progress"></div>\n      ';
 } else {
;__p+='\n        <button type="submit" class=\'dcg-btn dcg-btn-green\' id=\'save_graph_btn\' style="float:right; margin-right: 45px">\n          '+
( t('Update Account') )+
'\n        </button>\n      ';
 }
;__p+='\n    ';
 }
;__p+='\n  </form>\n</div>';
}
return __p;
};});
define('template!save_dialog', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div id="save-dialog" class="modal_section">\n    <h1>\n      '+
( t('Save This Graph!') )+
'\n    </h1>\n\n    <label class=\'input-label\'>\n      <div class=\'graph-title-title\'>'+
( t('Title:') )+
' &nbsp; </div>\n      <input class="title-input"\n             name="title"\n             placeholder="['+
( t('Untitled Graph') )+
']"\n             value="'+
( title )+
'"\n      >\n    </label>\n\n    ';
 if (user.isDriveUser) {
;__p+='\n    <div>\n      <label class="send-to-drive">\n        <input type="checkbox" name="push_to_drive" />\n        '+
( t('Send a Copy to Google Drive') )+
'\n      </label>\n    </div>\n    ';
 }
;__p+='\n    <br><br>\n\n    <div>\n    ';
 if (title) {
;__p+='\n\n      <button type="submit" class="dcg-btn dcg-btn-green pull-right dcg-action-save-as">'+
( t('Save a New Copy') )+
'</button>\n      <button type="submit" class="dcg-btn dcg-btn-gray pull-right dcg-action-save">'+
( t('Rename Graph') )+
'</button>\n\n\n    ';
 } else {
;__p+='\n\n    <button type="submit" class="dcg-btn dcg-btn-green pull-right dcg-action-save-as">'+
( t('Save Graph') )+
'</button>\n\n    ';
 }
;__p+='\n    </div>\n</div>';
}
return __p;
};});
define('template!recover_password_dialog', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div id="recover-password-dialog" class="modal_section">\n  <h1>'+
( t('Recover Password') )+
'</h1>\n  \n  ';
 _.each(errors, function(error) {
;__p+='\n  <div class="errors">\n      <span>'+
( error.message )+
'</span>\n  </div>\n  ';
 })
;__p+='\n  \n  ';
 if (sentMessage) {
;__p+='\n    <p>'+
( t("Message sent. Please check your email for a password recovery link.") + " (<a href='#' class='dcg-action-tryagain'>" + t("Didn't work? Try again!") + '</a>)' )+
'</p>\n  ';
 } else {
;__p+='\n  \n    <form class="dcg-action-submit">\n      <p>'+
( t('Please enter your email address. We will send a password recovery link to you.') )+
'</p>\n  \n      <label>\n        <span>'+
( t('Email:') )+
'</span>\n        <input type="email"\n        name="email"\n        class="input"\n        id="recover_email"\n        required="required"\n        autofocus="autofocus"\n        />\n      </label>\n\n      <br />\n\n      ';
 if (spinning) {
;__p+='\n        <div class="progress_indicator progress"></div>\n      ';
 } else {
;__p+='\n        <button type="submit" class="dcg-btn dcg-btn-green" style="float: right; margin-right: 30px">'+
( t('Recover Password') )+
'</button>\n      ';
 }
;__p+='\n\n    </form>\n    <br />\n  ';
 }
;__p+='\n  <p class="dcg-remembered-password">'+
( t('Remembered your password?') )+
' <a class="dcg-action-login">'+
( t('Sign In') )+
'</a></p>\n</div>';
}
return __p;
};});
define('main/modals_controller',['require','console','jquery','pjs','underscore_view','main/parse_json_errors','keys','i18n','conditional_blur','vendor/jquery.html5-placeholder-shim','template!unsupported_browser','template!login_dialog','template!create_account_dialog','template!edit_account_dialog','template!save_dialog','template!recover_password_dialog'],function (require) {
  var console = require('console');
  var $ = require('jquery');
  var P = require('pjs');
  var UnderscoreView = require('underscore_view');
  var parseJSONErrors = require('main/parse_json_errors');
  var Keys = require('keys');
  var i18n = require('i18n');
  var conditionalBlur = require('conditional_blur');

  require('vendor/jquery.html5-placeholder-shim');

  var templates = {};
  templates.unsupported_browser = require('template!unsupported_browser');
  templates.login_dialog = require('template!login_dialog');
  templates.create_account_dialog = require('template!create_account_dialog');
  templates.edit_account_dialog = require('template!edit_account_dialog');
  templates.save_dialog = require('template!save_dialog');
  templates.recover_password_dialog = require('template!recover_password_dialog');

  var popupDriveLogin = function() {
    var popup_window = window.open(
      '/drive_api/calculator/login',
      'drive_window',
      'width=650, height=530'
    );
    if (!popup_window) {
      alert(i18n.t('Login window blocked. Please allow popups from desmos.com to sign in with Google.'));
    }
  };

var ModalsController = P(function (c) {

  c.init = function (graphsController) {
    this.modals = {
      unsupportedBrowserDialog: UnsupportedBrowserDialog(
        graphsController,
        this
      )
    };
  };

  c.ready = function () {
    this.modalElement = $('#state-modals');
    this.modalBackground = $('#modal_background');
    this.modalElement
      .find('.close-modal')
      .add(this.modalBackground)
      .on('tap', this.hide.bind(this))
    ;
  };

  c.hide = function (el) {
    try{
      //only blur if we're disappearing the focused element
      //one relevant example: feels weird to have the active mathquill blur
      //when we dismiss the "unsupported browser" modal.
      //
      //I think this is here just so that we don't end up in a weird
      //state on iPad where a focused textbox in a modal becomes hidden, but retains focus
      if ($(document.activeElement).closest(this.modalElement).length > 0) conditionalBlur();
    } catch (e){}

    $("input[type='password']").attr("value", "");
    //this gets called right at the beginning (complete login) before modalBackground exists
    if (this.modalBackground) {
      this.modalBackground.hide();
      this.modalElement.hide();
    }
    $(el).off('keydown');
  };

  c.show = function (el) {
    $(el).siblings('.modal_section').hide();
    $(el).show();
    this.modalBackground.show();
    this.modalElement.show();
    $(el).on('keydown', this.handleKeydown.bind(this));
  };
  c.handleKeydown = function (evt) {
    if (Keys.lookup(evt) === Keys.ESCAPE) {
      this.hide($(evt.currentTarget));
    }
  };
  c.$ = function () {
    return this.modalElement;
  };

});

var ModalDialogView = P(UnderscoreView, function (view, _super) {

  view.init = function (graphsController, modalsController) {
    _super.init.call(this);
    this.errors = [];
    this.spinning = false;
    this.saved_inputs = {};
    this.initialized = false;
    this.graphsController = graphsController;
    this.modalsController = modalsController;
  };

  view.getTemplateParams = function () {
    return {
      errors: this.errors,
      spinning: this.spinning
    };
  };

  view.show = function() {
    if(!this.initialized){
      this.appendTo(this.modalsController.$());
      this.initialized = true;
    }
    this.errors = [];
    this.rerender();
    this.modalsController.show(this.$());
    // Focus first visible input
    this.$('input:visible, textarea:visible').first().focus();
    // Update position of placeholder shims.
    if ($.placeholder) $.placeholder.shim();
  };

  view.beforeRerender = function () {
    // save what the display value was for the .modal_section
    this.__$display = this.$().css('display');

    // save input values
    var self = this;
    this.$('input,textarea').each(function(){
      var name = $(this).attr('name');
      var value = $(this).val();

      self.saved_inputs[name] = value;
    });
  };

  view.afterRerender = function () {
    // must restore this if we want the modal to display. They are display:none
    // by default and that's how it'll get rerendered.
    this.$().css('display', this.__$display);

    // restore input values
    for (var name in this.saved_inputs) {
      this.$('[name="'+name+'"]').val(this.saved_inputs[name]);
    }
  };

  view.hide = function() {
    this.modalsController.hide();
  };

  view.processJSONErrors = function(jqXHR) {
    this.errors = parseJSONErrors(jqXHR);
  };

  view.startProcessingForm = function() {
    this.spinning = true;
    this.errors = [];
    this.rerender();
  };

  view.stopProcessingForm = function() {
    this.spinning = false;
    this.rerender();
  };

  view.successAnimation = function () {
    //reaches into header
    $('.dcg-edit-acct-success').show();
    setTimeout(function() {
      $('.dcg-edit-acct-success').fadeOut('fast');
    }, 800);
  };
});

/*
* here are the actual modal states
*/
var UnsupportedBrowserDialog = P(ModalDialogView, function(view){
  view.template = templates.unsupported_browser;
  view.didCreateElement = function() {
    this.$('.dcg-action-hide').on('tap', this.hide.bind(this));
  };
});

return ModalsController;
});

/*global console*/
define('loadcss',['text'], function(text){
  var buildMap = {};

  function inject_css_file(href) {
    var head = document.getElementsByTagName('head')[0];
    var link = document.createElement('link');
    link.href = href;
    link.rel = 'stylesheet';
    link.type = 'text/css';
    head.appendChild(link);
  }

  return {
    load: function(name, req, onLoad, config){
      var filename = req.toUrl(name) + ".css";

      // it's a build, so we grab the source directly
      if (config.isBuild) {
        text.get(filename, function(css_source){
          buildMap[name] = css_source;
          onLoad();
        });
      }

      // not a build, so add a <link> element to load the css file
      else {
        inject_css_file(filename);
        onLoad();
      }
    },

    onLayerEnd: function (write, data) {
      var complete_css = '';
      for (var moduleName in buildMap) {
        complete_css += buildMap[moduleName];
      }

      // save a css file in the same folder as the .js that will be saved. Could possibly
      // integrate this better with optimize.js in order to have more control over where the css
      // file goes. For now, it's fine within the generated/js/ dir.
      var fs = require.nodeRequire('fs');
      var css_file = data.path.replace(/\.js/g, '.required.css');
      fs.writeFileSync(css_file, complete_css, 'utf8');
    },

    write: function(pluginName, moduleName, write){
      if(moduleName in buildMap){
        write("define('" + pluginName + '!' + moduleName + "', function(){});");
      } else{
        console.log("ERROR - failed to find css " + moduleName + " in buildMap");
      }
    }
  };
});

define('loadcss!css/header_desktop', function(){});
define('browser',['require','jquery'],function (require) {
  var $ = require('jquery');

  var Browser = {
    IS_IE8: navigator.userAgent.match(/MSIE 8.0/i) !== null,
    IS_IE9: navigator.userAgent.match(/MSIE 9.0/i) !== null,
    IS_IE: navigator.userAgent.match(/MSIE/i) !== null,
    IS_IPAD: navigator.userAgent.match(/iPad/i) !== null,
    IS_MOBILE: navigator.userAgent.match(/Mobile|Android/i) !== null,
    IS_ANDROID: navigator.userAgent.match(/Android/i) !== null,
    IS_CHROME: navigator.userAgent.match(/Chrome/i) !== null,
    IS_KINDLE: navigator.userAgent.match(/Kindle/i) !== null || navigator.userAgent.match(/Silk/i) !== null,
    IS_IN_IFRAME: window.parent !== window
  };
  Browser.IS_TABLET = (Browser.IS_IPAD || Browser.IS_ANDROID || Browser.IS_KINDLE);

  Browser.IOS_VERSION = (function() {
    //http://stackoverflow.com/questions/8348139/detect-ios-version-less-than-5-with-javascript
    var v = (navigator.appVersion).match(/OS (\d+)_(\d+)_?(\d+)?/);
    if (v) {
      return [parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)];
    }
    return null;
  })();

  // Returns translate3d if supported, translate otherwise
  // from http://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support
  //
  // Needs document.body to be defined before it can run (so that we can put
  // an element into it). In supported browsers, the value will be set to
  // true on $(document).ready();
  Browser.SUPPORTS_TRANSLATE3D = false;

  $(document).ready(function() {

    var el = document.createElement('p');
    var has3d;
    var computedStyle;
    var transforms = {
      'webkitTransform':'-webkit-transform',
      'OTransform':'-o-transform',
      'msTransform':'-ms-transform',
      'MozTransform':'-moz-transform',
      'transform':'transform'
    };
    // Add it to the body to get the computed style.
    document.body.insertBefore(el, null);
    for (var t in transforms) {
      if (el.style[t] !== undefined) {
        el.style[t] = "translate3d(1px,1px,1px)";
        computedStyle = window.getComputedStyle(el);
        if (!computedStyle) return;
        has3d = computedStyle.getPropertyValue(transforms[t]);
      }
    }
    document.body.removeChild(el);
    Browser.SUPPORTS_TRANSLATE3D = (
      has3d !== undefined &&
      has3d.length > 0 &&
      has3d !== "none"
    );
  });

  //return a generated rule for an x-y translation. use translate3d where supported
  Browser.translateRule = function(x, y) {
    if (Browser.SUPPORTS_TRANSLATE3D) {
      return "translate3d(" + x + (x ? "px" : "") + "," + y + (y ? "px" : "") + ",0)";
    }
    return "translate(" + x + (x ? "px" : "") + "," + y + (y ? "px" : "") + ")";
  };

  Browser.SUPPORTS_CANVAS = (function () {
    var elem = document.createElement('canvas');
    var supports_canvas = !!(elem.getContext && elem.getContext('2d'));
    return supports_canvas;
  })();

  return Browser;
});

define('loadcss!tipsycss', function(){});
// tipsy, facebook style tooltips for jquery
// version 1.0.0a
// (c) 2008-2010 jason frame [jason@onehackoranother.com]
// released under the MIT license
//
// Modified by Mike Haverstock to work with touchtracking.js to decide when
// to show tooltips and when not to. Problem is that this library doesn't
// allow you to manually hide/show tooltips that are set with the 'live'
// option. That's because the 'live' option postpones tipsy instantiation for
// a specific node until an event bubbles up for that node. So, when you call
// .tipsy('show') for a live node, it sees that there is no .data('tipsy') set
// for the node and ignores the request. The solution is to not listen for
// mouseenter and mouseleave. Instead of those, you listen for 'tipsyshow' and
// 'tipsyhide'. Then, you manually hide/show tooltips by triggering 'tipsyshow'
// and 'tipsyhide' on that node. Then, the live code works perfectly fine. Now
// the only way to trigger tipsy is by manually triggering those events.
define('tipsy',['require','loadcss!tipsycss','jquery'],function(require) {
  //note: the path to tipsycss needs to be configured in your requirejs config
  //for example: `'tipsycss': '../vendor_manual/albany/tipsy'`

  require('loadcss!tipsycss');
  var $ = require('jquery');

  var openSticky = null;
  var ignoreStickyOpen = false;

  $(document).on('tap', '.tipsy-sticky', function (evnt) {

    // don't do anything. let the code that hides stickies close it.
    if (ignoreStickyOpen) {
      ignoreStickyOpen = false;
      return;
    }

    var opener = evnt.currentTarget;
    var $target = $(opener);

    // if the target doesn't have a tooltip, check if a child does
    if (!$target.attr('tooltip')) {
      $target = $target.find('[tooltip]').filter(':not([tooltip=""])');
    }

    // there should be exactly 1 tooltip to show
    if ($target.length !== 1) return;

    // ensure that the target is not display:none and no parent is display:none
    if ($target.css('display') === 'none') return;
    if ($target.parents().filter(function(){return $(this).css('display') === 'none'}).length) return;

    var options = $.extend({}, $.fn.tipsy.defaults);
    options.title = 'tooltip';
    options.gravity = 'nw';

    openSticky = new Tipsy($target[0], options);
    openSticky.show();
    openSticky.opener = opener;
  });

  $(document).on('tapstart keydown', function (evnt) {
    if (openSticky) {
      openSticky.hide();

      var opener = openSticky.opener;
      if (evnt.type === 'tapstart' && $(evnt.target).closest(opener).length ) {
        $(document).one('tapend', function (evnt2) {
          if ($(evnt2.target).closest(opener).length) {
            ignoreStickyOpen = true;
          }
        });
      }

      openSticky=null;
    }
  });

  function maybeCall(thing, ctx) {
    return (typeof thing == 'function') ? (thing.call(ctx)) : thing;
  }

  function Tipsy(element, options) {
    this.$element = $(element);
    this.options = options;
    this.fixTitle();
  }

  Tipsy.prototype = {
    show: function() {
      var title = this.getTitle();
      if (title && !isTipsyDisabled()) {
        var $tip = this.tip();
        var $arrow = $tip.find('.tipsy-arrow');

        $tip.find('.tipsy-inner')[this.options.html ? 'html' : 'text'](title);
        $tip[0].className = 'tipsy'; // reset classname in case of dynamic gravity
        $tip.remove().css({top: 0, left: 0, visibility: 'hidden', display: 'block'}).prependTo(document.body);

        var pos = $.extend({}, this.$element.offset(), {
          width: this.$element[0].offsetWidth,
          height: this.$element[0].offsetHeight
        });

        var tp, actualWidth = $tip[0].offsetWidth,
            actualHeight = $tip[0].offsetHeight,
            gravity = maybeCall(this.options.gravity, this.$element[0]);

        switch (gravity.charAt(0)) {
          case 'n':
            tp = {top: pos.top + pos.height + this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2};
            break;
          case 's':
            tp = {top: pos.top - actualHeight - this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2};
            break;
          case 'e':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth - this.options.offset};
            break;
          case 'w':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width + this.options.offset};
            break;
        }

        if (gravity.length == 2) {
          if (gravity.charAt(1) == 'w') {
            tp.left = pos.left + pos.width / 2 - 15;
          } else {
            tp.left = pos.left + pos.width / 2 - actualWidth + 15;
          }
        }
        var arrowMarginLeft = 0;

        if (tp.left < 0) {
          arrowMarginLeft = tp.left;
          tp.left = 0;
        } else if (tp.left + actualWidth > window.innerWidth) {
          arrowMarginLeft = tp.left + actualWidth - window.innerWidth;
          tp.left = window.innerWidth - actualWidth;
        }

        //we want to center it, so add -5px margin because the tipsy arrow is 10px wide
        if (gravity === 'n' || gravity === 's') {
          arrowMarginLeft -= 5;
        }
        $arrow.css('marginLeft', arrowMarginLeft);

        $tip.css(tp).addClass('tipsy-' + gravity);

        $arrow[0].className = 'tipsy-arrow tipsy-arrow-' + gravity.charAt(0);
        if (this.options.className) {
          $tip.addClass(maybeCall(this.options.className, this.$element[0]));
        }

        if (this.options.fadeIn) {
          $tip.stop().css({opacity: 0, display: 'block', visibility: 'visible'})
                     .animate({opacity: this.options.opacity}, this.options.fadeIn);
        } else {
          $tip.css({visibility: 'visible', opacity: this.options.opacity});
        }

        if (this.options.sticky) {
          $tip.addClass('tipsy-sticky');
        }

        var self = this;
        var validateLoop = function () {
          self.validate();
          self.validateTimeout = setTimeout(validateLoop, 100);
        };
        validateLoop();
      }
    },

    hide: function() {
      clearTimeout(this.validateTimeout);

      if (this.options.fadeOut) {
        this.tip().stop().fadeOut(this.options.fadeOut, function() { $(this).remove(); });
      } else {
        this.tip().remove();
      }
    },

    fixTitle: function() {
      var $e = this.$element;
      if ($e.attr('title') || typeof($e.attr('original-title')) != 'string') {
        $e.attr('original-title', $e.attr('title') || '').removeAttr('title');
      }
    },

    getTitle: function() {
      var title, $e = this.$element, o = this.options;
      this.fixTitle();
      o = this.options;
      if (typeof o.title == 'string') {
        title = $e.attr(o.title == 'title' ? 'original-title' : o.title);
      } else if (typeof o.title == 'function') {
        title = o.title.call($e[0]);
      }

      if (title) title = ('' + title).replace(/(^\s*|\s*$)/, "");
      return title || o.fallback;
    },

    tip: function() {
      if (!this.$tip) {
        this.$tip = $('<div class="tipsy"><div class="tipsy-arrow"></div><div class="tipsy-inner"></div></div>');
      }
      return this.$tip;
    },

    validate: function() {
      var hasTitle = !!this.getTitle();
      var inDom = false;

      if (hasTitle) {
        try {
          var node = this.$element[0];

          while (node) {
            if (node === document) {
              inDom = true;
              break;
            } else {
              node = node.parentNode;
            }
          }
        } catch (e) {}
      }

      if (!inDom) {
        this.hide();
      }
    }
  };

  $.fn.tipsy = function(options) {

    if (options === true) {
      return this.data('tipsy');
    } else if (typeof options == 'string') {
      var tipsy = this.data('tipsy');
      if (tipsy) tipsy[options]();
      return this;
    }

    options = $.extend({}, $.fn.tipsy.defaults, options);

    options.fadeIn = options.fadeIn || options.fade;
    options.fadeOut = options.fadeOut || options.fade;

    function get(ele) {
      var tipsy = $.data(ele, 'tipsy');
      if (!tipsy) {
        tipsy = new Tipsy(ele, $.fn.tipsy.elementOptions(ele, options));
        $.data(ele, 'tipsy', tipsy);
      }
      return tipsy;
    }

    function enter(evnt) {
      // the tipsyshow event bubbles up the dom, so we only want to
      // listen to the event if the target is the same as the element
      // that is responding to the event. If this wasn't here then when
      // you move your mouse from a tipsy-enabled parent to a child, the
      // tipsyshow event would be fired from the child, bubble through
      // the parent, and get caught higher up. That would cause the
      // already opened tooltip to close and fade in again. With this
      // code, we ignore the tipsyshow event because the target is the
      // the child that isn't tipsy-enabled.
      if (evnt.type === 'tipsyshow' && evnt.target !== this) return;

      // this element has a sticky open already
      if (openSticky === this) return;

      var tipsy = get(this);
      tipsy.hoverState = 'in';

      if (options.delayIn === 0) {
        tipsy.show();
      } else {
        tipsy.fixTitle();
        setTimeout(function() { if (tipsy.hoverState == 'in') tipsy.show(); }, options.delayIn);
      }
    }

    function leave(evnt) {
      // we do this for the same reason we do it for the tipsyshow event.
      // look at the comment a few lines above for more information.
      if (evnt.type === 'tipsyhide' && evnt.target !== this) return;

      var tipsy = get(this);

      // if this is a sticky tooltip, don't close it on tapStart. If we
      // closed it now, it would flicker back on when we mouse up and
      // make it permanent. We'd like it to stay on the whole time.
      if (evnt.type === 'tapstart' && tipsy.options.sticky) return;

      tipsy.hoverState = 'out';
      if (options.delayOut === 0) {
        tipsy.hide();
      } else {
        setTimeout(function() { if (tipsy.hoverState == 'out') tipsy.hide(); }, options.delayOut);
      }
    }

    if (!options.live) this.each(function() { get(this); });

    if (options.trigger != 'manual') {
      var eventIn  = options.trigger == 'hover' ? 'tipsyshow' : 'focus';
      var eventOut = options.trigger == 'hover' ? 'tipsyhide tapstart tapend tapcancel' : 'blur';

      if (options.live && options.delegate) {
        this.on(eventIn, options.delegate, enter).on(eventOut, options.delegate, leave);
      } else {
        var binder   = options.live ? 'on' : 'bind';
        this[binder](eventIn, enter)[binder](eventOut, leave);
      }
    }

    return this;
  };

  $.fn.tipsy.defaults = {
    className: null,
    delayIn: 0,
    delayOut: 0,
    fade: false,
    fadeIn: false,
    fadeOut: false,
    fallback: '',
    gravity: 'n',
    html: false,
    live: true,
    offset: 0,
    opacity: 1,
    title: 'title',
    trigger: 'hover'
  };

  // Overwrite this method to provide options on a per-element basis.
  // (remember - do not modify 'options' in place!)
  $.fn.tipsy.elementOptions = function(ele, options) {
    options = $.extend({}, options);

    var gravity = $(ele).attr('tipsy-gravity');
    if (gravity) {
      options.gravity = gravity;
    }

    var offset = parseInt($(ele).attr('tipsy-offset'), 10);
    if (!isNaN(offset)) {
      options.offset = offset;
    }

    return options;
  };

  $.fn.tipsy.autoNS = function() {
    return $(this).offset().top > ($(document).scrollTop() + $(window).height() / 2) ? 's' : 'n';
  };

  $.fn.tipsy.autoWE = function() {
    return $(this).offset().left > ($(document).scrollLeft() + $(window).width() / 2) ? 'e' : 'w';
  };

  /**
   * yields a closure of the supplied parameters, producing a function that takes
   * no arguments and is suitable for use as an autogravity function like so:
   *
   * @param margin (int) - distance from the viewable region edge that an
   *        element should be before setting its tooltip's gravity to be away
   *        from that edge.
   * @param prefer (string, e.g. 'n', 'sw', 'w') - the direction to prefer
   *        if there are no viewable region edges effecting the tooltip's
   *        gravity. It will try to vary from this minimally, for example,
   *        if 'sw' is preferred and an element is near the right viewable
   *        region edge, but not the top edge, it will set the gravity for
   *        that element's tooltip to be 'se', preserving the southern
   *        component.
  */
  $.fn.tipsy.autoBounds = function(margin, prefer) {
    return function() {
      var dir = {ns: prefer[0], ew: (prefer.length > 1 ? prefer[1] : false)},
          boundTop = $(document).scrollTop() + margin,
          boundLeft = $(document).scrollLeft() + margin,
          $this = $(this);

      if ($this.offset().top < boundTop) dir.ns = 'n';
      if ($this.offset().left < boundLeft) dir.ew = 'w';
      if ($(window).width() + $(document).scrollLeft() - $this.offset().left < margin) dir.ew = 'e';
      if ($(window).height() + $(document).scrollTop() - $this.offset().top < margin) dir.ns = 's';

      return dir.ns + (dir.ew ? dir.ew : '');
    };
  };

  // automatically instantiate tipsy for .tipsy-sticky classes
  $(document).tipsy({
    title: 'tooltip',
    wait: 0,
    live: true,
    delegate: '.tipsy-sticky',
    gravity: 'nw',
    sticky: true,
    fade: false
  });

  var disableLocks = 0;
  function isTipsyDisabled () {
    return disableLocks !== 0;
  }

  function removeDisableLock() {
    disableLocks--;
  }

  function addDisableLock() {
    disableLocks++;
  }

  return {
    isDisabled: isTipsyDisabled,
    removeDisableLock: removeDisableLock,
    addDisableLock: addDisableLock
  };
});

define('loadcss!css/share_options', function(){});
define('main/popover_view',['require','jquery','pjs','underscore_view','conditional_blur'],function(require){
  var $ = require('jquery');
  var P = require('pjs');
  var UnderscoreView = require('underscore_view');
  var conditionalBlur = require('conditional_blur');

  var allPopovers = [];

  function handleIsVisibleChange (changedPopover) {
     // hide all other popovers when this one becomes visible
    if (changedPopover.isVisible) {
      allPopovers.forEach(function (popover) {
        if (popover !== changedPopover) {
          popover.closePopover();
        }
      });

      $(document).on('tapstart.popover-' + changedPopover.popoverNumber, function (evt) {
        changedPopover.setProperty('isVisible', !changedPopover.eventShouldClosePopover(evt));
      });
    } else {
      $(document).off('tapstart.popover-' + changedPopover.popoverNumber);
    }
  }

  var PopoverView = P(UnderscoreView, function(view, _super){

    view.init = function () {
      _super.init.call(this);
      this.isVisible = false;

      allPopovers.push(this);

      this.popoverNumber = allPopovers.length;

      this.observe('isVisible', function () {
        handleIsVisibleChange(this);
        this.renderIsVisible();
      }.bind(this));
    };

    //jquery selector for where the arrow head should point
    view.setPointTo = function (el) {
      this.pointTo = el;
    };

    view.alignArrow = function () {
      if (!this.isVisible) return;
      var cont = this.$();
      if (!this.pointTo.length || !cont.length) return;

      var offset = this.pointTo.offset().left + 0.5 * this.pointTo.width() - cont.offset().left;

      this.$('.dcg-arrow').css('left', offset);
    };

    view.setupOpenButton = function (openButton, on) {
      this.openButton = openButton;
      this.openButton.on(on, this.onBtnPressed.bind(this));
    };

    view.didInsertElement = function () {
      this.renderIsVisible();
    };

    view.renderIsVisible = function () {
      this.$().toggle(this.isVisible);
      if (this.openButton) this.openButton.toggleClass('dcg-active', this.isVisible);
      if (this.pointTo) this.alignArrow();
    };

    // don't do anything if we're inside the popover or if we're inside the openButton
    view.eventShouldClosePopover = function (evt) {
      return !this.eventIsWithinPopover(evt);
    };

    view.eventIsWithinPopover = function (evt) {
      var $target = $(evt.target);
      return $target.closest(this.$()).length || $target.closest(this.openButton).length;
    };

    view.onBtnPressed = function (evt) {
      //for touch devices
      conditionalBlur();

      var $target = $(evt.target);

      // this is a popover whose built inside of the button. act like we didn't
      // press the button
      if ($target.closest('.dcg-popover').length) {
        return;
      }

      // pressed the open/close button
      if ($target.closest(this.openButton).length) {
        this.togglePopover();
        return;
      }
    };

    view.togglePopover = function () {
      this.setProperty('isVisible', !this.isVisible);
    };

    view.closePopover = function () {
      this.setProperty('isVisible', false);
    };
  });

  return PopoverView;
});

define('template!share_options', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="dcg-share-container dcg-popover dcg-bottom dcg-constrained-height-popover">\n    <div class="dcg-popover-interior">\n\n    <!-- have a graph hash -->\n\n    <div class=\'dcg-popover-title\'>\n      '+
( t('Share your graph with the world!') )+
'\n    </div>\n    <div class="dcg-popover-content">\n\n      <div class=\'dcg-loading\'>\n          <img src="/img/spinner_dark.gif" width="16px" height="16px" />\n          '+
( t('loading...') )+
'\n      </div>\n\n      <div class=\'dcg-loaded\'>\n        <br>\n        &nbsp; '+
( t('Share this link:') )+
'\n        <input class="dcg-permalink select-all dcg-variable-permalink"></input>\n\n        <form class="dcg-action-screenshoturl" target=\'_blank\' method=\'post\'>\n          <div class="dcg-btn-group dcg-options-btns">\n            <span class="dcg-btn dcg-action-togglesection" section="email">'+
( t('Email') )+
'</span>\n            <span class="dcg-btn dcg-action-togglesection" section="embed">'+
( t('Embed') )+
'</span>\n            <input type=\'hidden\' name=\'img\' class=\'dcg-imgData\'>\n            <button type=\'submit\' class="dcg-btn image-btn" section="image">'+
( t('Image') )+
'</button>\n          </div>\n        </form>\n\n        <div class="dcg-email-div share-div">\n          <div class="template-emailerrors"></div>\n          <form class="dcg-action-emailgraph">\n            <label>'+
( t('Send to:') )+
'\n            <input type="email" multiple="multiple" name="recipients" required="required" class="first-input" />\n            </label>\n\n            <label>'+
( t('Your Name:') )+
'\n            <input type="text" name="name" required="required" class="dcg-variable-username" />\n            </label>\n\n            <label>'+
( t('Message: <i>(optional)</i>') )+
'\n            <textarea name="message" rows="3" class=\'dcg-share-message\'></textarea>\n            </label>\n\n            <input type="hidden" name="hash" class="dcg-variable-graphhash" />\n            <button type="submit" class="dcg-btn dcg-btn-green" name="submit">'+
( t('Send') )+
'</button>\n\n            <span class=\'email-status-notifications\'>\n              <span class="template-ifprocessing">\n                <img src="/img/spinner_dark.gif" width="16px" height="16px" />\n                '+
( t('sending...') )+
'\n              </span>\n            </span>\n          </form>\n        </div>\n        <div class=\'dcg-email-sent\'>\n          '+
( t('message sent') )+
'\n        </div>\n\n        <div class="dcg-embed-div share-div">\n          <label>\n            '+
( t('HTML Embed Code') )+
'\n            <a href="http://support.desmos.com/entries/22449752-embedding-graphs-with-html" target="_blank">'+
( t("what's this?") )+
'</a>\n            <textarea rows="4" class="select-all first-input dcg-variable-htmlembedcode"></textarea>\n          </label>\n  \n          <label>\n            '+
( t('BBCode') )+
'\n            <a href="http://support.desmos.com/entries/22449762-embedding-graphs-in-forums-with-bbcode" target="_blank">'+
( t("what's this?") )+
'</a>\n\n            <input rows="4" class="select-all dcg-variable-htmlembedcodebb" />\n\n          </label>\n        </div>\n\n        <div class="template-iffeatureable">\n          <div class=\'alert dcg-allow-feature\'>\n            <a type="button" class="close dcg-action-cancelfeature">&times;</a>\n              <div class=\'content\'>\n                <div class=\'dcg-title\'>\n                  <b>'+
( t('Nice Graph!') )+
'</b> <br> '+
( t('Want us to consider featuring it?') )+
'\n                </div>\n                \n                <div class=\'dcg-btn-group\'>\n                  <span class="dcg-allowFeature dcg-btn dcg-action-togglefeature">'+
( t('yeah!') )+
'</span>\n                  <span class="dcg-disallowFeature dcg-btn dcg-action-togglefeature"> '+
( t('no, thanks') )+
'</span>\n                </div>\n                \n              </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  \n    <div class="dcg-arrow"></div>\n</div>\n';
}
return __p;
};});
define('main/share_options',['require','loadcss!css/share_options','jquery','underscore','pjs','main/popover_view','main/calculator_backend','main/parse_json_errors','template!share_options'],function(require){
  require('loadcss!css/share_options');

  var $ = require('jquery');
  var _ = require('underscore');
  var P = require('pjs');
  var PopoverView = require('main/popover_view');
  var calculatorBackend = require('main/calculator_backend');
  var parseJSONErrors = require('main/parse_json_errors');
  var template = require('template!share_options');

  /*
  * view for the settings bar
  */

  var ShareView = P(PopoverView, function (view, _super) {
    view.template = template;
    view.pointToSelector = '.dcg-action-share i';

    view.init = function (graphsController, Calc) {
      _super.init.call(this);
      this.graphsController = graphsController;
      this.Calc = Calc;
      this.sharePromise = $.Deferred().reject().promise();
      this.setProperty('isFeatureable', false);
    };

    view.renderIsVisible = function () {

      _super.renderIsVisible.call(this);
      var isVisible = this.isVisible;
      this.$().toggle(isVisible);

      if (this.isVisible) {
        this.onBecameVisible();
      } else {
        this.onBecameHidden();
      }
    };

    view.eventShouldClosePopover = function (evt) {
      var $target = $(evt.target);

      if (this.eventIsWithinPopover(evt)) {
        return false;
      }

      return !$target.closest("#state-modals").length &&
             $target.attr("id") != "modal_background";
    };

    view.didCreateElement = function () {
      _super.didCreateElement.call(this);

      this.$().on('tapstart', ".select-all", function () {
        $(this).on('tapend', function () {
          $(this).select();
        });
      });

      this.$().on('tapmove tapend', ".select-all", function () {
        $(this).off('tapend');
      });

      // event listeners
      this.$('.dcg-action-togglesection').on('tap', this.toggleSection.bind(this));
      this.$('.dcg-action-emailgraph').on('submit', this.emailGraph.bind(this));
      this.$('.dcg-action-cancelfeature').on('tap', this.cancelFeature.bind(this));
      this.$('.dcg-action-togglefeature').on('tapstart', this.toggleFeature.bind(this));

      var self = this;

      this.observeAndSync('isFeatureable', this.renderIsFeatureable.bind(this));
      this.observe('userAllowsFeature', this.renderUserAllowsFeature.bind(this));
      this.computeIsFeatureable();

      this.renderUser();
      this.renderGraph();
      this.renderIsProcessing();
      this.renderEmailErrors();
      this.renderOpenSection();
      this.setProperty('userAllowsFeature', true);
    };

    view.onBecameVisible = function() {
      var self = this;
      var graph = this.graphsController.currentGraph.copy();
      this.graphsController.updateGraphData(graph);
      this.sharePromise = calculatorBackend.shareGraph(graph).done(
        function (graph) {
          self.setGraph(graph);
          self.$('.dcg-loading').hide();
          self.$('.dcg-loaded').show();
          self.$('.dcg-imgData').attr(
            "value",
            self.Calc.screenshot()
          );
        }
      );
    };

    view.onBecameHidden = function() {
      this.$('.dcg-loaded').hide();
      this.$('.dcg-loading').show();
      var graph = this.graph;
      if (this.isFeatureable && this.userAllowsFeature) {
        this.sharePromise.done(function () {
          calculatorBackend.allowFeature({hash: graph.hash});
        });
      }
      this.minimizeSections();
      this.setIsProcessing(false);
      this.setEmailErrors(undefined);
    };

    view.getIsProcessing = function () {
      return this.isProcessing;
    };

    view.setIsProcessing = function (isProcessing) {
      if (isProcessing === this.isProcessing) return;
      this.isProcessing = isProcessing;
      this.renderIsProcessing();
    };

    view.renderIsProcessing = function () {
      this.$('.template-ifprocessing').toggle(this.getIsProcessing());
    };

    view.getEmailErrors = function () {
      return this.emailErrors;
    };

    view.setEmailErrors = function (emailErrors) {
      if (_.isEqual(emailErrors, this.emailErrors)) return;
      this.emailErrors = emailErrors;
      this.renderEmailErrors();
    };

    view.renderEmailErrors = function () {
      var errors = this.$('.template-emailerrors');
          errors.children().remove();
      _.each(this.emailErrors, function (error) {
        errors.append('<div class="dcg-errors">'+error.message+'</div>');
      });
    };

    view.computeIsFeatureable = function () {
      var graph = this.graphsController.currentGraph;

      //we don't want Clever users to be able to accidentally mark graphs as public
      //since we get their name through the API and until we have explicit permission we
      //don't want to use that kind of user-identifiable information.
      var isFeatureable = (graph && graph.title);
      this.setProperty('isFeatureable', isFeatureable);
    };

    view.renderIsFeatureable = function () {
      this.$('.template-iffeatureable').toggle(!!this.isFeatureable);
    };

    view.renderUserAllowsFeature = function () {
      this.$('.dcg-allowFeature').toggleClass(
        "dcg-active",
        !!this.userAllowsFeature
      );
      this.$('.dcg-disallowFeature').toggleClass(
        "dcg-active",
        !this.userAllowsFeature
      );
    };

    view.setGraph = function (graph) {
      if (this.graph && _.isEqual(graph, this.graph)) return;
      this.graph = graph;
      this.renderGraph();
      this.computeIsFeatureable();
    };

    view.renderGraph = function () {
      var graph = this.graph;
      if (!graph) graph = {};
      if (!graph.hash) graph.hash = '';
      if (!graph.path) graph.path = '';

      this.$('.dcg-action-screenshoturl').attr('action', this.getScreenshotUrl(graph));
      this.$('.dcg-variable-facebook').attr('href', this.getFacebookURL(graph));
      this.$('.dcg-variable-twitter').attr('href', this.getTwitterURL(graph));
      this.$('.dcg-variable-google').attr('href', this.getGooglePlusURL(graph));
      this.$('.dcg-permalink').val(graph.path);
      this.$('.dcg-variable-graphhash').val(graph.hash);
      this.$('.dcg-variable-htmlembedcode').val(this.getHtmlEmbedCode(graph));
      this.$('.dcg-variable-htmlembedcodebb').val(this.getHtmlEmbedCodeBB(graph));
    };

    view.setUser = function (user) {
      if (_.isEqual(user, this.user)) return;
      this.user = user;

      this.renderUser();
      this.computeIsFeatureable();
    };

    view.renderUser = function () {
      var user = this.user;

      this.$('.dcg-variable-username').val(user ? user.name : '');
    };

    view.minimizeSections = function() {
      this.setOpenSection(null);
      $('.share-div').hide();
    };

    view.getOpenSection = function () {
      return this.openSection;
    };

    view.setOpenSection = function (section) {
      if (section === this.openSection) return;
      this.openSection = section;

      this.renderOpenSection();
    };

    view.renderOpenSection = function () {
      var section = this.getOpenSection();
      this.$('[section=email]').toggleClass('dcg-active', section === 'email');
      this.$('[section=embed]').toggleClass('dcg-active', section === 'embed');
      this.$('[section=image]').toggleClass('dcg-active', section === 'image');
    };

    view.toggleSection = function(e) {
      var section = $(e.target).attr("section");
      var isOpen = this.getOpenSection() === section;
      this.minimizeSections();

      if (!isOpen) {
        this.$('.dcg-allow-feature').hide();
        this.$('.dcg-' + section + '-div').show();
        this.$('.dcg-' + section + '-div .first-input').focus().select();

        if (section === 'email') {
          this.$('.dcg-share-message').attr('value','');
          this.$('.dcg-email-div .first-input').attr('value', '');
        }

      } else {
        this.$('.dcg-allow-feature').show();
        section = null;
      }

      this.setOpenSection(section);
    };

    view.toggleFeature = function() {
      this.setProperty('userAllowsFeature', !this.userAllowsFeature);
    };

    view.cancelFeature = function() {
      this.setProperty('userAllowsFeature', false);
      this.$('.template-iffeatureable').slideUp('fast');
    };

    view.getFacebookURL = function(graph) {
      return 'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(graph.path);
    };

    view.getTwitterURL = function(graph) {
      var message, path;
      if (graph.hash) {
        message = 'Look what I made with the Desmos Graphing Calculator: ';
        path = graph.path;
      } else {
        message = 'Check out the Desmos Graphing Calculator: beautiful, free math!';
        path = 'https://www.desmos.com';
      }
      return (
        'https://twitter.com/intent/tweet?' +
        'url=' + encodeURIComponent(path) +
        '&text=' + encodeURIComponent(message) +
        '&via=desmos'
      );
    };

    view.getGooglePlusURL = function(graph) {
      return 'https://plus.google.com/share?url='+encodeURIComponent(graph.path);
    };

    view.getHtmlEmbedCode = function(graph) {
      return (
        '<a title="View with the Desmos Graphing Calculator" href="' + graph.path + '">' +
        '  <img src="' + graph.thumbURL + '" width="200px" height="200px"' +
        '     style="border:1px solid #ccc; border-radius:5px"' +
        '  />' +
        '</a>'
      );
    };

    view.getHtmlEmbedCodeBB = function(graph) {
      return '[GRAPH]' + graph.hash + '[/GRAPH]';
    };

    view.emailGraph = function (evt) {
      //don't submit the form
      evt.preventDefault();
      //don't repeat send
      if (this.getIsProcessing()) return;

      this.setIsProcessing(true);
      var self = this;
      var formData = $(evt.target).serialize();
      calculatorBackend.emailGraph(formData).done(function (msg) {
        self.setEmailErrors(undefined);
        self.$('.dcg-email-div').hide();
        self.$('.dcg-email-sent').show();
        setTimeout(function() {
          self.$('.dcg-email-sent').slideUp(400);
          self.minimizeSections();
        }, 1000);
      }).fail(function (jqXHR) {
        self.setEmailErrors(parseJSONErrors(jqXHR));
      }).always(function () {
        self.setIsProcessing(false);
      });
    };

    view.getScreenshotUrl = function(graph) {
      return "/screenshot/" + graph.hash;
    };

  });

  return ShareView;
});

define('loadcss!css/help', function(){});
define('template!help_desktop', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="dcg-help-container dcg-popover dcg-bottom dcg-constrained-height-popover">\n  <div class="dcg-popover-interior">\n\n\n    <div class=\'dcg-popover-title\'>'+
( t('Tours') )+
'</div>\n    <div class=\'dcg-popover-content dcg-tours-content\'>\n      <!-- tours get inserted here -->\n    </div>\n\n    <div class=\'dcg-popover-title\'>'+
( t('Resources') )+
'</div>\n    <div class=\'dcg-popover-content dcg-resources-content\'>\n      <div>\n        <a href=\''+
( userGuideURL )+
'\' target=\'_blank\'>\n          <i class=\'dcg-icon-book\'></i>\n          <span>'+
( t('Desmos User Guide') )+
'</span>\n        </a>\n      </div>\n\n      <div>\n        <a href=\'http://support.desmos.com/categories/20081717-using-the-desmos-graphing-calculator\' target=\'_blank\'>\n          <i class=\'dcg-icon-comments\'></i>\n          <span>'+
( t('Knowledge Base') )+
'</span>\n        </a>\n      </div>\n    </div>\n\n    <div class=\'dcg-popover-title dcg-interior-title\'>'+
( t('Feedback') )+
'</div>\n    <div class=\'dcg-popover-content\'>\n      <div class=\'dcg-resources-content dcg-feedback-content\'>\n\n\n      <span class="dcg-feedback-twitter">\n        <a href="https://twitter.com/intent/tweet?text=Hey%2C%20%40desmos:%20I\'ve%20got%20a%20question!&via=desmos" target=\'_blank\'>\n          <i class=\'dcg-icon-twitter\'></i>\n          <span>'+
( t('Tweet @desmos') )+
'</span>\n        </a>\n       </span>\n       <span class="dcg-feedback-facebook">\n        <a href="https://www.facebook.com/desmosinc" target=\'_blank\'>\n          <i class=\'dcg-icon-facebook\'></i>\n          <span>'+
( t('Tell us on Facebook') )+
'</span>\n        </a>\n      </span>\n\n\n      </div>\n\n      ';
 if (previewMode) {
;__p+='\n\n        <div class=\'dcg-previewMode\'>\n          '+
( previewMessage )+
'<br>\n          <a class=\'dcg-btn-green dcg-btn\' href=\''+
(previewFeedbackUrl)+
'\' target=\'_blank\'>\n            '+
( t("Share your thoughts!") )+
'\n          </a>\n        </div>\n\n      ';
 }
;__p+='\n\n      ';
 if (!maintenance && !previewMode) {
;__p+='\n        <div class="dcg-suggestions">\n          <div class="template-errors"></div>\n          <div class="dcg-feedback-email-sent">\n            '+
( t("Thanks for the feedback &ndash; you'll hear from us soon!") )+
'\n          </div>\n\n          <form class="dcg-action-submit">\n\n            <textarea placeholder="'+
( t('type your question or suggestion...') )+
'" name="message"></textarea>\n            <div class="dcg-suggestions-expansion">\n              <div class="template-unlessuser">\n                <div class=\'dcg-feedback-email-label\'>\n                  '+
( t('Please provide an email so that we can write back.') )+
'\n                  <i>('+
( t('optional') )+
')</i></div>\n                <input name="anonymous-email" class="dcg-anonymous-email" placeholder="your.name@test.com" type="email" />\n              </div>\n              <span class="dcg-feedback-btns">\n                <a class="dcg-btn dcg-action-closesuggestion">\n                  '+
( t('Cancel') )+
'\n                </a>\n                <button class="dcg-btn dcg-btn-green" name="submit" type="submit">\n                  '+
( t('Send Feedback') )+
'\n                </button>\n                </span>\n\n              <div class="template-processing" style="display:none">\n                <img src="/img/spinner_dark.gif" width="16px" height="16px" /> '+
( t('sending...') )+
'\n              </div>\n            </div>\n          </form>\n        </div>\n      ';
 }
;__p+='\n    </div>\n  </div>\n  <div class=\'dcg-arrow\'></div>\n</div>\n';
}
return __p;
};});

define('main/help_desktop',['require','loadcss!css/help','jquery','underscore','pjs','main/popover_view','main/parse_json_errors','main/calculator_backend','template!help_desktop','i18n','config','vendor/jquery.html5-placeholder-shim'],function(require){
  require('loadcss!css/help');

  var $ = require('jquery');
  var _ = require('underscore');
  var P = require('pjs');
  var PopoverView = require('main/popover_view');
  var parseJSONErrors = require('main/parse_json_errors');
  var calculatorBackend = require('main/calculator_backend');
  var template = require('template!help_desktop');
  var i18n = require('i18n');
  var Config = require('config');
  require('vendor/jquery.html5-placeholder-shim');

  /*
  * view for the help popover
  */

  var HelpView = P(PopoverView, function (view, _super) {
    view.template = template;
    view.pointToSelector = '.dcg-action-help i';

    view.init = function (
      graphsController,
      Calc,
      modals
    ) {
      _super.init.call(this);
      this.graphsController = graphsController;
      this.Calc = Calc;
      this.modals = modals;
    };

    view.renderIsVisible = function () {
      _super.renderIsVisible.call(this);
      if (this.isVisible) {
        if ($.placeholder) $.placeholder.shim();

      // becomes hidden
      } else {
        this.setErrors([]);
      }
    };

    view.getTemplateParams = function () {
      var userGuideURL = (i18n.enabled_languages[i18n.detectLanguage()] ?
        i18n.enabled_languages[i18n.detectLanguage()].userGuideURL :
        i18n.enabled_languages.en.userGuideURL
      );
      return {
        maintenance: Config.get('maintenance'),
        previewMode: Config.get('previewMode'),
        previewFeedbackUrl: Config.get('previewFeedbackUrl'),
        previewMessage: Config.get('previewMessage'),
        userGuideURL: userGuideURL
      };
    };

    view.eventShouldClosePopover = function (evt) {
      var $target = $(evt.target);
      if (this.eventIsWithinPopover(evt)) {
        return false;
      }

      return !$target.closest("#state-modals").length &&
             $target.attr("id") != "modal_background";
    };

    view.setErrors = function (errors) {
      if (_.isEqual(errors, this.errors)) return;
      this.errors = errors;

      var div = this.$('.template-errors');
      div.children().remove();
      for (var i=0; i<errors.length; i++) {
        div.append('<div class="dcg-errors">' + errors[i].message + '</div>');
      }
    };

    view.setProcessing = function (processing) {
      if (processing === this.processing) return;
      this.processing = processing;

      this.$('.template-processing').toggle(processing);
    };

    view.setLoggedIn = function (loggedIn) {
      if (loggedIn === this.loggedIn) return;
      this.loggedIn = loggedIn;

      this.$('.template-unlessuser').toggle(!loggedIn);
    };

    view.didCreateElement = function () {
      _super.didCreateElement.call(this);
      var self = this;
      this.$('.dcg-suggestions textarea').on("focus", function() {
        $(this).animate({"height": "80px"}, {
          duration: 200,
          complete: function () {
            if ($.placeholder) $.placeholder.shim();
          }
        });
        self.$('.dcg-suggestions-expansion').show();
      });

      this.$('.dcg-action-submit').on('submit', this.sendFeedback.bind(this));
      this.$('.dcg-action-closesuggestion').on('tap', this.closeSuggestion.bind(this));

      var closeModal = function() { this.setProperty('isVisible', false); };

      this.setErrors([]);
      this.setProcessing(false);
      this.setLoggedIn(false);
    };

    view.closeSuggestion = function() {
      this.$('.dcg-suggestions textarea').animate({"height":"33px"}, 200).attr("value", "");
      this.$('.dcg-suggestions-expansion').fadeOut(200);
      this.setProcessing(false);
      this.setErrors([]);
    };

    //whether the feedback email is being sent
    view.sendFeedback = function(evt) {
      //don't submit the form
      evt.preventDefault();
      //don't repeat send
      if (this.processing) return;

      var message = $.trim(this.$('textarea[name="message"]').attr("value"));
      if (!message) {
        this.setErrors([{
          message: i18n.t('Please enter your feedback.')
        }]);
        this.$('.dcg-suggestions').focus();
        return;
      }

      var feedbackData = {
        message: message,
        state: JSON.stringify(this.Calc.getState()),
        userAgent: navigator.userAgent,
        'anonymous-email': this.$('input[name="anonymous-email"]').attr("value")
      };

      // send feedback off
      var self = this;
      this.setProcessing(true);
      calculatorBackend.emailFeedback(feedbackData).done(function (msg) {
        self.$('.dcg-feedback-email-sent').show();
        self.setErrors([]);
        self.closeSuggestion();
        setTimeout(function() {
          self.$('.dcg-feedback-email-sent').slideUp();
        },2000);
      }).fail(function(jqXHR) {
        self.setErrors(parseJSONErrors(jqXHR));
      }).always(function(msg) {
        self.setProcessing(false);
      });
    };

    view.openFeedback = function () {
      this.setProperty('isVisible', true);
      this.$('.dcg-suggestions textarea').focus();
    };
  });

  return HelpView;
});

define('loadcss!css/language', function(){});
define('template!language', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="dcg-language-container dcg-popover dcg-bottom dcg-constrained-height-popover">\n\n  <div class=\'dcg-popover-interior\'>\n    <div class=\'dcg-popover-title\'>\n      '+
( t('Language') )+
'\n    </div>\n    <div class=\'dcg-popover-content\'>\n      <table>\n        <tr>\n      ';
 var i = 0; _.each(enabled_languages, function(language, locale) {
;__p+='\n       <td>\n        <div lang=\''+
( locale )+
'\' class=\'dcg-language-option'+
((locale === selected_language ? ' dcg-selected' : ''))+
'\'>\n            '+
(language.displayName)+
'\n\n        </div>\n        </td>\n        '+
( ((++i)%2 === 0 ? '</tr><tr>' : '') )+
'\n\n      ';
 })
;__p+='\n        </tr>\n      </table>\n\n      <div class=\'dcg-translate-invite\'>\n        Don\'t see your language?\n        <a\n          target=\'_blank\'\n          href=\'http://support.desmos.com/entries/28346817-Help-us-translate-Desmos-\'\n        >\n          Help us translate\n        </a>\n      </div>\n    </div>\n  </div>\n  <div class=\'dcg-arrow\'></div>\n</div>';
}
return __p;
};});
define('main/preserved_state',['require'],function (require) {
  var pushState = function(stateInfo) {
    sessionStorage.preservedState = JSON.stringify(stateInfo);
  };

  var popState = function() {
    var state_str = sessionStorage.preservedState;
    sessionStorage.preservedState = '';
    if (!state_str) return;

    return JSON.parse(state_str);
  };

  var hasState = function () {
    return !!sessionStorage.preservedState;
  };

  return {
    pushState: pushState,
    popState: popState,
    hasState: hasState
  };
});
define('main/language',['require','loadcss!css/language','jquery','pjs','underscore','main/popover_view','template!language','i18n','main/cookie','main/preserved_state'],function(require){
  require('loadcss!css/language');
  var $ = require('jquery');
  var P = require('pjs');
  var _ = require('underscore');

  var PopoverView = require('main/popover_view');
  var template = require('template!language');
  var i18n = require('i18n');
  var Cookie = require('main/cookie');
  //for page reloads when, for example, you switch language
  var preservedState = require('main/preserved_state');

  var LanguageView = P(PopoverView, function (view, _super) {
    view.template = template;
    view.pointToSelector = '.dcg-action-language i';

    view.init = function (Calc) {
      _super.init.call(this);
      this.Calc = Calc;
    };

    view.getTemplateParams = function () {
      return {
        enabled_languages: i18n.enabled_languages,
        selected_language: i18n.detectLanguage()
      };
    };

    view.didCreateElement = function () {
      _super.didCreateElement.call(this);

      this.$('.dcg-language-option').on('tap', this.selectLanguage.bind(this));
    };

    view.selectLanguage = function (evt) {
      var $el = $(evt.target);
      if ($el.hasClass('dcg-selected')) return;

      this.closePopover();

      var unsavedState = this.Calc.getState();
      var savedState = this.Calc.graphChangeMonitor.getSavedState();

      var isStateEmpty = _.filter(unsavedState.expressions.list, function(expr) {
        return (!expr.hasOwnProperty('latex') || expr.latex);
      }).length === 0;

      //TODO - with the extra information we have here I feel like
      //we can do better than this.
      //don't preserve an empty state
      if (!isStateEmpty) {
        preservedState.pushState({
          unsavedState: unsavedState,
          savedState: savedState
        });
      }

      Cookie.setCookie('lang', $el.attr('lang'));
      location.reload();
    };
  });

  return LanguageView;
});

define('template!account_dropdown', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="dcg-logout-options dcg-popover dcg-bottom">\n  <div class="dcg-popover-interior">\n    <div class="dcg-popover-content">\n      <div class=\'user-info\'>\n        <span class=\'account-name\'>'+
( name )+
'</span>\n        <span class=\'account-email\'>'+
( email )+
'</span>\n        <a class="dcg-action-editaccount">'+
( t('Edit Account') )+
'</a>\n      </div>\n      <a class="dcg-action-feedback">'+
( t('Send Feedback') )+
'</a>\n      <a class="dcg-action-logout">'+
( t('Sign Out') )+
'</a> \n    </div>\n  </div>\n  <div class=\'dcg-arrow\'></div>\n</div>';
}
return __p;
};});
define('main/account_dropdown',['require','loadcss!css/help','jquery','pjs','main/popover_view','template!account_dropdown'],function(require){
  require('loadcss!css/help');

  var $ = require('jquery');
  var P = require('pjs');
  var PopoverView = require('main/popover_view');
  var template = require('template!account_dropdown');

  /*
  * view for the account menu
  */

  var AccountView = P(PopoverView, function (view, _super) {
    view.template = template;
    view.pointToSelector = '.dcg-account-link .email i';

    view.init = function (helpView, modals) {
      _super.init.call(this);

      this.helpView = helpView;
      this.modals = modals;
    };

    view.getTemplateParams = function (){
      return {
        name: null,
        email: null
      };
    };

    view.editAccount = function () {
      this.modals.editAccountDialog.show();
      this.closePopover();
    };

    view.logout = function () {
      this.closePopover();
    };

    view.feedback = function () {
      this.closePopover();
      this.helpView.openFeedback();
    };

    view.eventShouldClosePopover = function (evt) {
      var $target = $(evt.target);

      if (this.eventIsWithinPopover(evt)) {
        return false;
      }

      return !$target.closest("#state-modals").length &&
             $target.attr("id") != "modal_background";
    };

    view.didCreateElement = function () {
      _super.didCreateElement.call(this);

      this.$('.dcg-action-logout').on('tap', this.logout.bind(this));
      this.$('.dcg-action-feedback').on('tap', this.feedback.bind(this));
      this.$('.dcg-action-editaccount').on('tap', this.editAccount.bind(this));
    };

  });

  return AccountView;
});

define('text!data/resources_examples.json',[],function () { return '[{\n  "section": "Lines",\n  "examples": [\n    {\n      "title": "Slope Intercept Form",\n      "graphHash": "59qdbtnlzy",\n      "state": {"graph": {"squareAxes": true, "showLabels": true, "showGrid": true, "showAxes": true, "labelXMode": "", "degreeMode": false, "labelYMode": "", "viewport": {"xmin": -10, "ymin": -5.537, "ymax": 5.537, "xmax": 10}}, "expressions": {"list": [{"color": "#C0504D", "latex": "y=mx+b", "domain": {"max": 10, "min": 0}, "id": 1, "hidden":false}, {"latex": "m=1", "domain": {"max": 10, "min": 0}, "color": "#F79646", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 3}, {"latex": "b=1", "domain": {"max": 10, "min": 0}, "color": "#8064A2", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 2}]}}\n    },\n    {\n      "title": "Point Slope Form",\n      "graphHash": "vphpgabluz",\n      "state": {"graph": {"squareAxes": true, "showLabels": true, "showGrid": true, "showAxes": true, "labelXMode": "", "degreeMode": false, "labelYMode": "", "viewport": {"xmin": -10, "ymin": -5.537, "ymax": 5.537, "xmax": 10}}, "expressions": {"list": [{"color": "#C0504D", "latex": "y-y_1=m\\\\left(x-x_1\\\\right)", "domain": {"max": 10, "min": 0}, "id": 1, "hidden":false}, {"color": "#8064A2", "latex": "\\\\left(x_1,y_1\\\\right)", "domain": {"max": 10, "min": 0}, "id": 8, "hidden":false}, {"latex": "x_1=1", "domain": {"max": 10, "min": 0}, "color": "#4F81BD", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 5}, {"latex": "y_1=1", "domain": {"max": 10, "min": 0}, "color": "#C0504D", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 7}, {"latex": "m=1", "domain": {"max": 10, "min": 0}, "color": "#9BBB59", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 6}]}}\n    },\n    {\n      "title": "Two Point Form",\n      "graphHash": "slkjzmm3ly",\n      "state": {"graph":{"viewport":{"xmin":-7.023,"ymin":-4.187,"xmax":7.024,"ymax":4.186},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"y-y_1=m\\\\left(x-x_1\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":12,"latex":"m=\\\\frac{y_2-y_1}{x_2-x_1}","domain":{"min":0,"max":10},"hidden":false,"color":"#9BBB59"},{"id":5,"latex":"x_1=-1","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":-10,"sliderMax":10},{"id":7,"latex":"y_1=1","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D","sliderMin":-10,"sliderMax":10},{"id":8,"latex":"\\\\left(x_1,y_1\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":9,"latex":"x_2=3","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":-10,"sliderMax":10},{"id":10,"latex":"y_2=2","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":-10,"sliderMax":10},{"id":11,"latex":"\\\\left(x_2,y_2\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"}]}}\n    },\n    {\n      "title": "Intercept Form",\n      "graphHash": "cmz3dawdji",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.961,"xmax":10,"ymax":5.961},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"\\\\frac{y}{a}+\\\\frac{x}{b}=1","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":14,"latex":"a=2","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":-10,"sliderMax":10},{"id":13,"latex":"b=1","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D","sliderMin":-10,"sliderMax":10},{"id":15,"latex":"\\\\left(0,a\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"},{"id":16,"latex":"\\\\left(b,0\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"}]}}\n    },\n    {\n      "title": "General Form",\n      "graphHash": "4acfppghta",\n      "state": {"graph": {"squareAxes": true, "showLabels": true, "showGrid": true, "showAxes": true, "labelXMode": "", "degreeMode": false, "labelYMode": "", "viewport": {"xmin": -10, "ymin": -5.537, "ymax": 5.537, "xmax": 10}}, "expressions": {"list": [{"color": "#C0504D", "latex": "ax+by=c", "domain": {"max": 10, "min": 0}, "id": 1, "hidden":false}, {"latex": "a=1", "domain": {"max": 10, "min": 0}, "color": "#F79646", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 2}, {"latex": "b=1", "domain": {"max": 10, "min": 0}, "color": "#8064A2", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 3}, {"latex": "c=1", "domain": {"max": 10, "min": 0}, "color": "#000000", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 4}]}}\n    },\n    {\n      "title": "Visualizing Slope",\n      "graphHash": "h4kwopbouh",\n      "state": {"graph":{"viewport":{"xmin":-3,"ymin":-10,"xmax":3,"ymax":10},"showLabels":true,"degreeMode":false,"showGrid":true,"polarMode":false,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"\\\\left(1,m\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#000"},{"id":509,"latex":"m=1.82","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D","sliderMin":-10,"sliderMax":10},{"id":487,"latex":"\\\\floor\\\\left(x\\\\right)\\\\cdot m\\\\le y\\\\le mx","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":508,"latex":"mx\\\\le y\\\\le\\\\floor\\\\left(x\\\\right)\\\\cdot m","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"}]}}\n    }\n  ]\n},\n{\n  "section": "Parabolas",\n  "examples": [\n    {\n      "title": "Standard Form",\n      "graphHash": "3ltwect0mc",\n      "state": {"graph": {"squareAxes": true, "showLabels": true, "showGrid": true, "showAxes": true, "labelXMode": "", "degreeMode": false, "labelYMode": "", "viewport": {"xmin": -10, "ymin": -5.537, "ymax": 5.537, "xmax": 10}}, "expressions": {"list": [{"color": "#C0504D", "latex": "y=ax^2+bx+c", "domain": {"max": 10, "min": 0}, "id": 1, "hidden":false}, {"latex": "a=1", "domain": {"max": 10, "min": 0}, "color": "#C0504D", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 19}, {"latex": "b=0", "domain": {"max": 10, "min": 0}, "color": "#9BBB59", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 18}, {"latex": "c=1", "domain": {"max": 10, "min": 0}, "color": "#4F81BD", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 17}]}}\n    },\n    {\n      "title": "Vertex Form",\n      "graphHash": "mey71rif1d",\n      "state": {"graph": {"squareAxes": true, "showLabels": true, "showGrid": true, "showAxes": true, "labelXMode": "", "degreeMode": false, "labelYMode": "", "viewport": {"xmin": -10, "ymin": -5.537, "ymax": 5.537, "xmax": 10}}, "expressions": {"list": [{"color": "#C0504D", "latex": "y=a\\\\left(x-h\\\\right)^2+k", "domain": {"max": 10, "min": 0}, "id": 1, "hidden":false}, {"latex": "a=1", "domain": {"max": 10, "min": 0}, "color": "#C0504D", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 25}, {"latex": "h=1", "domain": {"max": 10, "min": 0}, "color": "#9BBB59", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 24}, {"latex": "k=0", "domain": {"max": 10, "min": 0}, "color": "#4F81BD", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 23}, {"color": "#8064A2", "latex": "\\\\left(h,\\\\space k\\\\right)", "domain": {"max": 10, "min": 0}, "id": 26, "hidden":false}]}}\n    },\n    {\n      "title": "Factored Form",\n      "graphHash": "qgxlpjyebd",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.942,"xmax":10,"ymax":5.98},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"y=a\\\\left(x-x_1\\\\right)\\\\left(x-x_2\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":22,"latex":"a=1","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":-10,"sliderMax":10},{"id":21,"latex":"x_1=-2","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":-10,"sliderMax":10},{"id":20,"latex":"x_2=1","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":-10,"sliderMax":10},{"id":23,"latex":"\\\\left(x_1,0\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646"},{"id":24,"latex":"\\\\left(x_2,0\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646"}]}}\n    },\n    {\n      "title": "Standard Form with Tangent",\n      "graphHash": "bqr4ko6wi9",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.961,"xmax":10,"ymax":5.961},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"y\\\\ge ax^2+bx+c","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":19,"latex":"a=1","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D","sliderMin":-10,"sliderMax":10},{"id":18,"latex":"b=1","domain":{"min":0,"max":10},"hidden":false,"color":"#9BBB59","sliderMin":-10,"sliderMax":10},{"id":17,"latex":"c=1","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":-10,"sliderMax":10},{"id":21,"latex":"y\\\\space=\\\\space bx+c","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"}]}}\n    }\n  ]\n},\n{\n  "section": "Trigonometry",\n  "examples": [\n    {\n      "title": "Period and Amplitude",\n      "graphHash": "pjtapprsyt",\n      "state": {"graph": {"squareAxes": true, "showLabels": true, "showGrid": true, "showAxes": true, "labelXMode": "", "degreeMode": false, "labelYMode": "", "viewport": {"xmin": -10.056, "ymin": -7.352, "ymax": 7.352, "xmax": 9.944}}, "expressions": {"list": [{"text": "Sinusoid with amplitude \\"a\\" and period \\"b\\"", "id": 10}, {"color": "#C0504D", "latex": "a\\\\space\\\\cos\\\\left(\\\\frac{2\\\\pi x}{b}\\\\right)", "domain": {"max": 10, "min": 0}, "id": 1, "hidden":false}, {"latex": "a=2.58", "domain": {"max": 10, "min": 0}, "color": "#F79646", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 3}, {"latex": "b=4.65", "domain": {"max": 10, "min": 0}, "color": "#8064A2", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 2}, {"color": "#8064A2", "latex": "\\\\left(b,\\\\space at\\\\right)", "domain": {"max": 1, "min": 0}, "id": 4, "hidden":false}, {"color": "#4F81BD", "latex": "\\\\left(bt,\\\\space a\\\\right)", "domain": {"max": 1, "min": 0}, "id": 5, "hidden":false}]}}\n    },\n    {\n      "title": "Phase",\n      "graphHash": "rfo6v7r5vg",\n      "state": {"graph":{"viewport":{"xmin":-10.949,"ymin":-3,"xmax":11,"ymax":2},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":false,"labelXMode":"pi","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"\\\\cos\\\\left(x\\\\space-\\\\space p\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":13,"latex":"p=1.64","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":-10,"sliderMax":10},{"id":14,"latex":"\\\\cos\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":17,"latex":"\\\\left(pt,\\\\space1\\\\right)","domain":{"min":0,"max":1},"hidden":false,"color":"#C0504D"}]}}\n    },\n    {\n      "title": "All the Trig Functions",\n      "graphHash": "v3hgzjtpo5",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-6.095,"xmax":10,"ymax":6.095},"showLabels":true,"degreeMode":false,"showGrid":true,"polarMode":false,"showAxes":true,"squareAxes":true,"labelXMode":"pi","labelYMode":""},"expressions":{"list":[{"id":28,"text":"Click on the icon next to each trig function to turn it on or off:"},{"id":27,"latex":"\\\\sin\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":22,"latex":"\\\\cos\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2"},{"id":23,"latex":"\\\\tan\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#F79646"},{"id":24,"latex":"\\\\csc\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":25,"latex":"\\\\sec\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":26,"latex":"\\\\cot\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59"}]}}\n    },\n    {\n      "title": "Wave Interference",\n      "graphHash": "ae1kce4fwm",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.961,"xmax":10,"ymax":5.961},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":140,"latex":"a=-1.17","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":-10,"sliderMax":10},{"id":1,"latex":"f\\\\left(x\\\\right)=\\\\sin\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646"},{"id":2,"latex":"g\\\\left(x\\\\right)=\\\\sin\\\\left(x+a\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646"},{"id":5,"latex":"f\\\\left(x\\\\right)+g\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"}]}}\n    },\n    {\n      "title": "Unit Circle",\n      "graphHash": "aer4wpiiad",\n      "state": {"graph":{"viewport":{"xmin":-2.5,"ymin":-1.49,"xmax":2.5,"ymax":1.4905},"showLabels":true,"degreeMode":true,"showGrid":false,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"x^2+y^2=1","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":19,"latex":"\\\\left(\\\\cos a,\\\\space\\\\sin a\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":20,"latex":"a=30","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":0,"sliderMax":360},{"id":22,"latex":"y=\\\\left(\\\\tan a\\\\right)\\\\cdot x\\\\left\\\\{0<x<\\\\cos a\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":26,"latex":"y=\\\\left(\\\\tan a\\\\right)\\\\cdot x\\\\left\\\\{\\\\cos a<x<0\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":23,"latex":"x=\\\\cos(a)\\\\left\\\\{0<y<\\\\sin(a)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":27,"latex":"x=\\\\cos(a)\\\\left\\\\{\\\\sin(a)<y<0\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"}]}}\n    }\n  ]\n},\n{\n  "section": "Conic Sections",\n  "examples": [\n    {\n      "title": "Circle",\n      "graphHash": "bkmtndf38y",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.961,"xmax":10,"ymax":5.961},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"\\\\left(x-a\\\\right)^2+\\\\left(y-b\\\\right)^2<r^2","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":6,"latex":"r\\\\space=\\\\space2.5","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59","sliderMin":-10,"sliderMax":10},{"id":5,"latex":"a=0","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD","sliderMin":-10,"sliderMax":10},{"id":4,"latex":"b=0","domain":{"min":0,"max":10},"hidden":true,"color":"#000000","sliderMin":-10,"sliderMax":10}]}}\n      } ,\n      {\n        "title": "Parabola and Focus",\n        "graphHash": "naug1puabq",\n        "state": {"graph":{"viewport":{"xmin":-6.122,"ymin":-3.492,"xmax":6.364,"ymax":5.114},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":false,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"y=\\\\frac{x^2}{4p}","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":64,"latex":"p=1","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":0.5,"sliderMax":5},{"id":65,"latex":"\\\\left(0,\\\\space p\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":81,"latex":"y\\\\space=\\\\space-p","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"}]}}\n      },\n      {\n        "title": "Ellipse with Foci",\n        "graphHash": "fwn45vpf2z",\n        "state": {"graph":{"viewport":{"xmin":-8.918,"ymin":-5.215,"xmax":8.86,"ymax":5.324},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"\\\\frac{x^2}{a^2}+\\\\frac{y^2}{b^2}\\\\ge1","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":4,"latex":"a=5","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":3,"sliderMax":6},{"id":2,"latex":"b=3","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":1,"sliderMax":3},{"id":5,"latex":"c=\\\\sqrt{\\\\left(a^2-b^2\\\\right)}","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":6,"latex":"\\\\left(c,0\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":7,"latex":"\\\\left(-c,0\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"}]}}\n      },\n      {\n        "title": "Hyperbola",\n        "graphHash": "321ynqvpjh",\n        "state": {"graph":{"viewport":{"xmin":-9.594,"ymin":-4.136,"xmax":10.406,"ymax":7.786},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":23,"latex":"\\\\frac{y^2}{b^{2\\\\space}}-\\\\frac{x^2}{a^2}=1","domain":{"min":0,"max":10},"hidden":false,"color":"#9BBB59"},{"id":17,"latex":"\\\\frac{x^2}{a^2}-\\\\frac{y^2}{b^2}=1","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":24,"latex":"a=1","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59","sliderMin":0.01,"sliderMax":5},{"id":25,"latex":"b=1","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D","sliderMin":0.01,"sliderMax":5,"sliderInterval":""}]}}\n      }\n    ]\n  },\n{\n  "section": "Polar Graphing",\n  "examples": [\n    {\n      "title": "Polar Rose",\n      "graphHash": "zg6mokdc9e",\n      "state": {"graph":{"viewport":{"xmin":-2.1,"ymin":-2,"xmax":2.1,"ymax":2},"showLabels":true,"degreeMode":false,"showGrid":true,"polarMode":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"r\\\\space\\\\le\\\\space\\\\sin\\\\left(\\\\frac{a}{b}\\\\theta\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":82,"latex":"a=5","domain":{"min":0,"max":10},"hidden":true,"color":"#F79646","sliderMin":1,"sliderMax":10,"sliderInterval":1},{"id":81,"latex":"b=6","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2","sliderMin":1,"sliderMax":10,"sliderInterval":1}]}}\n    },\n    {\n      "title": "Logarithmic Spiral",\n      "graphHash": "ucm7smj9fz",\n      "state": {"graph":{"viewport":{"xmin":-1200,"ymin":-1000,"xmax":1200,"ymax":1000},"showLabels":true,"degreeMode":false,"showGrid":true,"polarMode":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":83,"latex":"r\\\\space=\\\\space a^{\\\\theta}","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":84,"latex":"a=1.25","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD","sliderMin":1.1,"sliderMax":5}]}}\n    },\n    {\n      "title": "Limacon",\n      "graphHash": "ie57pljxzm",\n      "state": {"graph":{"viewport":{"xmin":-8,"ymin":-10,"xmax":8,"ymax":10},"showLabels":true,"degreeMode":false,"showGrid":true,"polarMode":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":83,"latex":"r\\\\space=\\\\space a+b\\\\cdot\\\\cos\\\\left(\\\\theta\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":84,"latex":"a=2","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD","sliderMin":0,"sliderMax":5},{"id":85,"latex":"b=3","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59","sliderMin":0,"sliderMax":5}]}}\n    },\n    {\n      "title": "Polar Conic Sections",\n      "graphHash": "kk3axf8oon",\n      "state": {"graph":{"viewport":{"xmin":-11,"ymin":-5,"xmax":11,"ymax":5},"showLabels":true,"degreeMode":false,"showGrid":true,"polarMode":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"r\\\\space=\\\\space\\\\frac{1}{1-a\\\\cdot\\\\cos\\\\left(\\\\theta-b\\\\right)}","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":3,"latex":"a=1","domain":{"min":0,"max":10},"hidden":true,"color":"#F79646","sliderMin":-10,"sliderMax":10},{"id":2,"latex":"b=0","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2","sliderMin":-10,"sliderMax":10}]}}\n    }\n  ]\n},\n{\n  "section": "Transformations",\n  "examples": [\n    {\n      "title": "Translating Any Function",\n      "graphHash": "0ksctv1hm4",\n      "state": {"graph": {"squareAxes": true, "showLabels": true, "showGrid": true, "showAxes": true, "labelXMode": "", "degreeMode": false, "labelYMode": "", "viewport": {"xmin": -7.901, "ymin": -4.379, "ymax": 4.368, "xmax": 7.902}}, "expressions": {"list": [{"color": "#C0504D", "latex": "f\\\\left(x\\\\right)=x^2+\\\\sin\\\\left(3x\\\\right)", "domain": {"max": 10, "min": 0}, "id": 1, "hidden":false}, {"text": "Function g(x) is a transformed version of function f(x).", "id": 49}, {"color": "#F79646", "latex": "g\\\\left(x\\\\right)=f\\\\left(x-h\\\\right)+k", "domain": {"max": 10, "min": 0}, "id": 45, "hidden":false}, {"text": "What effect does k have on the function g(x)?", "id": 51}, {"latex": "h=2", "domain": {"max": 10, "min": 0}, "color": "#000000", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 46}, {"text": "What effect does h have on the function g(x)", "id": 53}, {"latex": "k=-1", "domain": {"max": 10, "min": 0}, "color": "#4F81BD", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 47}]}}\n    },\n    {\n      "title": "Scaling Any Function",\n      "graphHash": "doxva7ciht",\n      "state": {"graph": {"squareAxes": true, "showLabels": true, "showGrid": true, "showAxes": true, "labelXMode": "", "degreeMode": false, "labelYMode": "", "viewport": {"xmin": -7.901, "ymin": -4.379, "ymax": 4.368, "xmax": 7.902}}, "expressions": {"list": [{"color": "#C0504D", "latex": "f\\\\left(x\\\\right)=x^2+\\\\sin\\\\left(3x\\\\right)", "domain": {"max": 10, "min": 0}, "id": 1, "hidden":false}, {"text": "Function g(x) is a transformed version of function f(x).", "id": 49}, {"color": "#F79646", "latex": "g\\\\left(x\\\\right)=af\\\\left(\\\\frac{x}{b}\\\\right)", "domain": {"max": 10, "min": 0}, "id": 45, "hidden":false}, {"text": "What effect does a have on the function g(x)?", "id": 51}, {"latex": "a=0.5", "domain": {"max": 10, "min": 0}, "color": "#000000", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 46}, {"text": "What effect does b have on the function g(x)", "id": 53}, {"latex": "b=1", "domain": {"max": 10, "min": 0}, "color": "#4F81BD", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 47}]}}\n    },\n    {\n      "title": "Reflections of a Function",\n      "graphHash": "ynmlumjvz8",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.961,"xmax":10,"ymax":5.961},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"f\\\\left(x\\\\right)=\\\\left(x-3\\\\right)^3-x+5","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":92,"latex":"-f\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":96,"latex":"f\\\\left(-x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59"},{"id":97,"latex":"-f\\\\left(-x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"}]}}\n    },\n    {\n      "title": "Inverse of a Function",\n      "graphHash": "tif5liedlj",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.928,"xmax":10,"ymax":5.929},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"f\\\\left(x\\\\right)=.2x^3+.1x^5","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":155,"latex":"x=f\\\\left(y\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":156,"latex":"y=x","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"},{"id":158,"latex":"a=1.74","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":-10,"sliderMax":10},{"id":157,"latex":"\\\\left(a,f\\\\left(a\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":159,"latex":"\\\\left(f\\\\left(a\\\\right),a\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"}]}}\n    }\n  ]\n},\n{\n  "section": "Calculus",\n  "examples": [\n    {\n      "title": "Derivatives",\n      "graphHash": "aqgbwm3qfd",\n\n      "state": {"graph":{"viewport":{"xmin":-8.874,"ymin":-6.286,"xmax":11.127,"ymax":5.637},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"f\\\\left(x\\\\right)\\\\space=\\\\space ax^3+cx","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":150,"latex":"a=0.42","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59","sliderMin":-10,"sliderMax":10},{"id":148,"latex":"c=-1.64","domain":{"min":0,"max":10},"hidden":true,"color":"#000000","sliderMin":-10,"sliderMax":10},{"id":146,"latex":"g\\\\left(x\\\\right)\\\\space=\\\\space\\\\frac{d}{dx}f\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"}]}}\n    },\n    {\n      "title": "Secant Line",\n      "graphHash": "irip8pnpdf",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.961,"xmax":10,"ymax":5.961},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":3,"latex":"f\\\\left(x\\\\right)=\\\\sin\\\\left(x\\\\right)+.3x","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":7,"latex":"a=0.23","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":-10,"sliderMax":10},{"id":13,"latex":"h=2","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":0.1,"sliderMax":2},{"id":16,"latex":"m=\\\\frac{\\\\left(f\\\\left(a+h\\\\right)-f\\\\left(a\\\\right)\\\\right)}{h}","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":20,"latex":"y=m\\\\left(x-a\\\\right)+f\\\\left(a\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":23,"latex":"\\\\left(a,f\\\\left(a\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"},{"id":24,"latex":"\\\\left(a+h,f\\\\left(a+h\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"}]}}\n    },\n    {\n      "title": "Tangent Line",\n      "graphHash": "dlzhsldcgo",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.961,"xmax":10,"ymax":5.961},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":3,"latex":"f\\\\left(x\\\\right)=\\\\sin\\\\left(x\\\\right)+.3x","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":6,"latex":"g\\\\left(x\\\\right)=\\\\frac{d}{dx}f\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":7,"latex":"a=1.27","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":-10,"sliderMax":10},{"id":12,"latex":"y=g\\\\left(a\\\\right)\\\\left(x-a\\\\right)+f\\\\left(a\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":13,"latex":"\\\\left(a,\\\\space f\\\\left(a\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"}]}}\n    },\n    {\n      "title": "Taylor Expansion of sin(x)",\n      "graphHash": "gkjridbqfj",\n\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.961,"xmax":10,"ymax":5.961},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"y\\\\space=\\\\space\\\\sin\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":161,"latex":"y\\\\space=\\\\space\\\\sum_{n=0}^a\\\\frac{\\\\left(-1\\\\right)^nx^{\\\\left(2n+1\\\\right)}}{\\\\left(2n+1\\\\right)!}","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"},{"id":162,"latex":"a=1","domain":{"min":0,"max":10},"hidden":true,"color":"#F79646","sliderMin":0,"sliderMax":10,"sliderInterval":1}]}}\n    }\n  ]\n}]';});

define('mygraphs/examples',['require','underscore','main/graph','text!data/resources_examples.json'],function(require){
  var _ = require('underscore');
  var Graph = require('main/graph');
  var exampleGraphsString = require('text!data/resources_examples.json');

  // convert from sectioned examples to flat list
  var sectionedExamples = JSON.parse(exampleGraphsString);
  var flatExampleGraphs = [];
  _.each(sectionedExamples, function (section, i) {
    _.each(section.examples, function (example, j) {

      var exampleGraph = Graph({
        hash: example.graphHash,
        title: section.section + ": " + example.title,
        graphData: JSON.stringify(example.state),

        // TODO - we should inline the dataURL within the json
        thumbURL: 'https://s3.amazonaws.com/calc_thumbs/production/' + example.graphHash + '.png'
      });

      flatExampleGraphs.push(exampleGraph);
    });
  });


  return flatExampleGraphs;
});

define('loadcss!css/mygraphs', function(){});
define('mygraphs/item_model',['require','pjs','underscore_model'],function(require) {
  var P = require('pjs');
  var UnderscoreModel = require('underscore_model');

  var ItemModel = P(UnderscoreModel, function (model, _super) {
    model.init = function () {
      _super.init.call(this);

      // TODO - not sure this belongs in the model
      this.visible = true;
      this.selected = false;
      this.selectable = true;

      var self = this;
      this.observe('selectable', function () {
        if (!self.selectable && self.selected) {
          self.setProperty('selected', false);
        }
      });
    };
  });

  return ItemModel;
});


define('mygraphs/graphitem_model',['require','pjs','./item_model'],function(require) {
  var P = require('pjs');
  var ItemModel = require('./item_model');

  var GraphItemModel = P(ItemModel, function (model, _super) {
    model.isGraph = true;

    model.init = function (graph) {
      _super.init.call(this);
      this.graph = graph;
    };

    model.matchesQuery = function (query) {
      return this.graph.displayTitle.toLowerCase().indexOf(query.toLowerCase()) >= 0;
    };
  });

  return GraphItemModel;
});


define('mygraphs/examplegraphitem_model',['require','pjs','./graphitem_model'],function(require) {
  var P = require('pjs');
  var GraphItemModel = require('./graphitem_model');

  var ExampleGraphItemModel = P(GraphItemModel, function (model, _super) {
    model.isExampleGraph = true;
  });

  return ExampleGraphItemModel;
});

define('mygraphs/savedgraphitem_model',['require','pjs','./graphitem_model'],function(require) {
  var P = require('pjs');
  var GraphItemModel = require('./graphitem_model');

  var SavedGraphItemModel = P(GraphItemModel, function (model, _super) {
    model.isSavedGraph = true;
  });

  return SavedGraphItemModel;
});
define('mygraphs/model',['require','loadcss!css/mygraphs','pjs','underscore_model','./examplegraphitem_model','./savedgraphitem_model'],function(require) {
  require('loadcss!css/mygraphs');

  var P = require('pjs');
  var UnderscoreModel = require('underscore_model');
  var ExampleGraphItemModel = require('./examplegraphitem_model');
  var SavedGraphItemModel = require('./savedgraphitem_model');

  var MyGraphsModel = P(UnderscoreModel, function (model, _super) {

    model.init = function (exampleGraphs, graphsController) {
      _super.init.call(this);
      var self = this;

      this.graphsController = graphsController;
      this.__items = [];
      this.__selectedItem = null;
      this.filteredItemCount = 0;

      exampleGraphs.forEach(function (exampleGraph) {
        var item = ExampleGraphItemModel(exampleGraph);
        self.__addItemAt(item, self.__items.length); //add to end of __items
      });

      this.setProperty('isSpinning', false);

      this.observe('searchQuery', this.filterAllGraphs.bind(this));

      //note: on iPad, we'd expect that none of these triggers would be called
      //this is the less pretty way of doing this.graphsController.graphAddedCallbacks?.push ...
      if (!this.graphsController.hasOwnProperty('graphAddedCallbacks')) return;

      this.graphsController.graphAddedCallbacks.push(function (index) {
        var graph = self.graphsController.content[index];
        var graphItem = SavedGraphItemModel(graph);
        self.__addItemAt(graphItem, index);
      });

      this.graphsController.graphRemovedCallbacks.push(function (index) {
        self.__removeItemAt(index);
      });

      this.graphsController.startUpdatingGraphsCallbacks.push(function () {
        self.setProperty('isSpinning', true);
        self.__clearSavedGraphs();
      });
      this.graphsController.updateGraphsSuccessCallbacks.push(function () {
        self.setProperty('isSpinning', false);
        self.graphsController.content.forEach(function (savedGraph, i) {
          var savedGraphItem = SavedGraphItemModel(savedGraph);
          self.__addItemAt(savedGraphItem, i);
        });
      });
      this.graphsController.updateGraphsErrorCallbacks.push(function () {
        self.setProperty('isSpinning', false);
        // TODO error view not implemented. Might be nice to have a "try again"
        // button.
      });
      this.graphsController.clearCallbacks.push(function () {
        self.setProperty('isSpinning', true);
        self.__clearSavedGraphs();
      });
    };

    model.updateDisplayDates = function() {
      //note: on iPad, we'd expect that graphsController.content is an empty array
      this.graphsController.content.forEach(function (graph) {
        graph.updateDisplayDate();
      });
    };

    // TODO - optimize if need be to not call this when a single graph is deleted or
    // or added. But, I suspect that a single deletion or addition shouldn't be a bottleneck
    // as long as a complete refresh (login or logout) isn't a terrible bottleneck.
    model.filterAllGraphs = function () {
      var i;

      if (this.searchQuery) {
        var filteredItemCount = 0;
        for (i=0; i<this.__items.length; i++) {
          var item = this.__items[i];
          if (item.matchesQuery(this.searchQuery)) {
            filteredItemCount++;
            item.setProperty('visible', true);
          } else {
            item.setProperty('visible', false);
          }
        }
        this.setProperty('filteredItemCount', filteredItemCount);
      } else {
        for (i=0; i<this.__items.length; i++) {
          this.__items[i].setProperty('visible', true);
        }
        this.setProperty('filteredItemCount', this.__items.length);
      }
    };

    model.triggerItemAdded = function (item, index) {};
    model.__initItem = function (item) {
      item.mygraphs_list = this;
      item.observe('selected.' + this.guid, this.onSelectionChange.bind(this));
    };
    model.__addItemAt = function (item, index) {
      this.__items.splice(index, 0, item);
      this.__initItem(item);

      this.filterAllGraphs();
      this.triggerItemAdded(item, index);
    };

    model.triggerItemRemoved = function (item) {};
    model.__destructItem = function (item) {
      item.mygraphs_list = null;
      item.unobserve('.' + this.guid);
    };
    model.__removeItemAt = function (index) {
      var item = this.__items[index];
      this.__items.splice(index, 1);
      this.__destructItem(item);

      this.filterAllGraphs();
      this.triggerItemRemoved(item);
    };

    model.__clearSavedGraphs = function () {
      var oldItems = this.__items;
      this.__items = [];

      for (var i=0; i<oldItems.length; i++) {
        var item = oldItems[i];
        if (item.isSavedGraph) {
          // TODO - could save these up and remove all at once by adding a
          // "triggerItemsRemoved([item1, item2, etc]) method"
          this.__destructItem(item);
          this.triggerItemRemoved(item);
        } else {
          this.__items.push(item);
        }
      }

      this.filterAllGraphs();
    };

    model.getItems = function () {
      return this.__items;
    };

    model.getSelectedIndex = function () {
      if (!this.selectedItem) return -1;

      return this.__items.indexOf(this.selectedItem);
    };

    model.onSelectionChange = function (property, item) {

      if (item.selected) {
        // only 1 item can be selected at a time
        var cachedItem = this.selectedItem;
        this.setProperty('selectedItem', item);
        if (cachedItem) cachedItem.setProperty('selected', false);
      } else if (this.selectedItem === item) {
        this.setProperty('selectedItem', null);
      }
    };

    model.selectPrev = function () {
      var selectedIndex = this.getSelectedIndex();
      if (selectedIndex === -1) return;

      for (var i = selectedIndex - 1; i>=0; i--) {
        var item = this.__items[i];
        if (item.selectable) {
          item.setProperty('selected', true);
          return true;
        }
      }

      return false;
    };

    model.selectNext = function (evt) {
      var selectedIndex = this.getSelectedIndex();
      var i, item;
      // nothing is selected, so select the first item that is selectable and has a graph. This
      // skips over the "new blank graph" option
      if (selectedIndex === -1) {
        for (i = 0; i < this.__items.length; i++) {
          item = this.__items[i];
          if (item.selectable && item.graph) {
            item.setProperty('selected', true);
            return true;
          }
        }
      }

      for (i = selectedIndex + 1; i < this.__items.length ; i++) {
        item = this.__items[i];
        if (item.selectable) {
          item.setProperty('selected', true);
          return true;
        }
      }

      return false;
    };
  });

  return MyGraphsModel;
});

define('mygraphs/item_view',['require','pjs','underscore_view'],function(require) {
  var P = require('pjs');
  var UnderscoreView = require('underscore_view');

  var ItemView = P(UnderscoreView, function (view, _super) {

    view.init = function (model) {
      _super.init.call(this);
      this.model = model;
      this.model.observe('visible.' + this.guid, this.renderVisible.bind(this));
      this.model.observe('selected.' + this.guid, this.renderSelected.bind(this));
    };

    view.destruct = function () {
      this.model.unobserve('.' + this.guid);
    };

    view.renderSelected = function () {
      this.$().toggleClass('dcg-selected', this.model.selected);
    };

    view.renderVisible = function () {
      this.$().toggle(this.model.visible);
    };

    view.didCreateElement = function () {
      this.renderSelected();
      this.renderVisible();
    };
  });

  return ItemView;
});


/*
 * A handled event is one that should act like propagation was
 *  stopped, yet it's allowed to still bubble because other
 *  code might expect to see an event higher up on the dom.
 *
 * So the solution is to call 'handle()' when you don't
 *  want the event to be handled by any other other listeners.
 *  The listeners will still get called, but they can check
 *  that evt.wasHandled() == false to make sure that it
 *  should handle the event.
 *
 * You can namespace your event handlings so that two
 *  completely different parts of code can both use this
 *  utility. When you call 'wasHandled()', just pass in a
 *  string, and it will check that namespace. And when you
 *  call 'handle()', pass in a namespace string.
 *
 * For convienience, you can set the handleEvent attribute
 *  for any dom element and the 'wasHandled()' method will
 *  check if the event has passed through any dom element
 *  that should have handled the event.
 */

/* global jQuery */
;(function($) {
  var GLOBAL_NAMESPACE = "_*_";

  $.Event.prototype.wasHandled = function (namespace) {

    namespace = namespace ? namespace : GLOBAL_NAMESPACE;
    var oe = this.originalEvent;
    var hb = oe && oe.handledBy;

    //check if it was explicitly handled in code
    if (hb && hb[namespace]) return true;

    // namespace wasn't handled
    if (namespace !== GLOBAL_NAMESPACE) return false;

    //Now, check if it was implicitly handled through
    //the dom attribute 'handleEvent'
    var dom = $(this.target).closest('[handleEvent]');
    //TEMPORARY: just return true instead of deeply parsing
    if (dom.length && dom[0] !== this.currentTarget) {
      return dom.attr('handleEvent') !== "false";
    }

    //must not have been handled
    return false;
  };

  $.Event.prototype.handle = function (namespace) {
    namespace = namespace ? namespace : GLOBAL_NAMESPACE;
    var oe = this.originalEvent;
    if (!oe) return; //can't handle this properly

    var hb = oe.handledBy;
    if (!hb) hb = oe.handledBy = {};

    hb[namespace] = true;
  };

})(jQuery);


define("jquery.handleevent", function(){});

define('mygraphs/graphitem_view',['require','pjs','./item_view','jquery.handleevent'],function(require) {
  var P = require('pjs');
  var ItemView = require('./item_view');
  require('jquery.handleevent');

  var GraphItemView = P(ItemView, function (view, _super) {
    view.isGraphView = true;

    view.getTemplateParams = function () {
      return JSON.parse(JSON.stringify(this.model.graph));
    };

    view.didCreateElement = function () {
      _super.didCreateElement.call(this);

      var self = this;
      this.$().on('tap', function (evt) {
        if (evt.wasHandled()) return;

        if (self.model.selected) {
          self.model.setProperty('selected', false);
        } else if (self.model.selectable) {
          self.model.setProperty('selected', true);
        }
      });
    };
  });

  return GraphItemView;
});
define('template!mygraphs_examplegraph', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<li class="dcg-action-preview-graph graph-link-container example-graph">\n  <span class="dcg-example-ribbon"></span>\n  <span class="dcg-thumb" style="background-image: url('+
( thumbURL )+
')"></span>\n  <span class="dcg-title">'+
( displayTitle )+
'</span>\n  <span class="date">'+
( t('example'))+
'</span>\n</li>\n';
}
return __p;
};});
define('mygraphs/examplegraphitem_view',['require','pjs','./graphitem_view','template!mygraphs_examplegraph'],function(require) {
  var P = require('pjs');
  var GraphItemView = require('./graphitem_view');
  var template = require('template!mygraphs_examplegraph');

  var ExampleGraphItemView = P(GraphItemView, function (view, _super) {
    view.template = template;
    view.isExampleGraphView = true;

    view.init = function (model) {
      _super.init.call(this, model);

      this.model.observe('visible', this.computeSelectable.bind(this));
      this.computeSelectable();
    };

    view.computeSelectable = function () {
      this.model.setProperty('selectable', this.model.visible);
    };
  });

  return ExampleGraphItemView;
});
define('template!mygraphs_savedgraph', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<li class="saved-graph graph-link-container">\n  <div class="graph-link dcg-action-preview-graph">\n    <span class="dcg-thumb" style="background-image: url('+
( thumbURL )+
')"></span>\n    <span class="dcg-title">'+
( displayTitle )+
'</span>\n    <span class="date dcg-variable-date">'+
( displayDate )+
'</span>\n    <span class="actions" handleEvent="true">\n      <span class="dcg-icon-remove dcg-action-removegraph"></span>\n    </span>\n  </div>\n  <div class=\'deleted\' handleEvent="true">\n\t  '+
( t('This graph has been deleted.') )+
' <a class=\'dcg-action-cancelremovegraph\'>'+
( t('Undo') )+
'</a>\n  </div>\n</li>';
}
return __p;
};});
define('mygraphs/savedgraphitem_view',['require','pjs','./graphitem_view','template!mygraphs_savedgraph'],function(require) {
  var P = require('pjs');
  var GraphItemView = require('./graphitem_view');
  var template = require('template!mygraphs_savedgraph');

  var SavedGraphItemView = P(GraphItemView, function (view, _super) {
    view.template = template;
    view.isSavedGraphView = true;

    view.init = function (model) {
      _super.init.call(this, model);
      this.deleting = false;

      this.model.graph.observe('displayDate', this.renderDisplayDate.bind(this));
      this.model.observe('visible', this.computeSelectable.bind(this));
      this.observe('deleting', this.computeSelectable.bind(this));
      this.observe('deleting', this.renderDeleting.bind(this));

      this.computeSelectable();
    };

    view.computeSelectable = function () {
      this.model.setProperty('selectable', !this.deleting && this.model.visible);
    };

    view.didCreateElement = function () {
      _super.didCreateElement.call(this);
      this.renderDisplayDate();
      this.renderDeleting();

      this.$('.dcg-action-removegraph').on('tap', this.startDeleting.bind(this));
      this.$('.dcg-action-cancelremovegraph').on('tap', this.cancelDelete.bind(this));
    };

    view.destruct = function () {
      this.cancelDelete();
    };

    view.startDeleting = function () {
      this.setProperty('deleting', true);

      var self = this;
      this.deleteTimeout = setTimeout(function () {
        self.$('a').addClass('inactive');
        self.$().slideUp('fast');

        //rerender the preview arrow
        setTimeout(function() {
          self.model.mygraphs_list.graphsController.remove(self.model.graph);
        }, 300);

      }, 3000);
    };

    view.cancelDelete = function () {
      this.setProperty('deleting', false);
      clearTimeout(this.deleteTimeout);
    };

    view.renderDeleting = function () {
      this.$().toggleClass('deleting', !!this.deleting);
    };

    view.renderDisplayDate = function () {
      var displayDate = this.model.graph.displayDate;
      if (displayDate !== this.lastDisplayDate) {
        this.lastDisplayDate = displayDate;
        this.$('.dcg-variable-date').text(displayDate);
      }
    };
  });

  return SavedGraphItemView;
});
define('template!mygraphs', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div>\n  <div id="resources-container" class="hidden">\n    <div class="search-container">\n      <input id="search-mygraphs" type="text" placeholder="'+
( t('search by title...') )+
'" />\n      <span class="dcg-icon-search search-icon"></span>\n    </div>\n    <div class="scrollable">\n\n      ';
 if (maintenance) {
;__p+='\n        <div class=\'maintenance-mode\'>\n          '+
( t("Desmos is temporarily in maintenance mode. You can open example graphs, but won't be able to sign in, open your graphs, or save any changes. We're so sorry for the inconvenience.") )+
'\n        </div>\n\n      ';
 } else if (previewMode) {
;__p+='\n        <div class=\'maintenance-mode\'>\n          '+
( previewMessage )+
'\n          <br>\n          <a class=\'dcg-btn dcg-btn-green\' href=\''+
(previewFeedbackUrl)+
'\' target=\'_blank\'>\n            '+
( t("Share your thoughts!") )+
'\n          </a>\n        </div>\n\n\n      ';
 } else {
;__p+='\n\n        ';
 if (accountsEnabled) {
;__p+='\n          <div class="login-reminder">\n            <a class=\'dcg-btn dcg-action-createaccount\'>\n              '+
( t('Create Account') )+
'\n            </a>\n            '+
( t('or') )+
'\n            <a class=\'dcg-action-login\'>\n              '+
( t('Sign In') )+
'\n            </a>\n            <div>\n              '+
( t('to save and share your graphs!') )+
'\n            </div>\n          </div>\n        ';
 }
;__p+='\n\n        <div class="new-blank-graph dcg-action-newblankgraph">\n          <div class="new-blank-graph-inner">\n            <span>+</span> '+
( t('New Blank Graph') )+
'\n          </div>\n        </div>\n\n        ';
 if (accountsEnabled) {
;__p+='\n          <div class="template-spinning">\n            <img src="/img/spinner.gif" width="16px" height="16px" /> '+
( t('loading graphs...') )+
'\n          </div>\n        ';
 }
;__p+='\n\n      ';
 }
;__p+='\n\n      <ul class="template-list">\n\n      </ul>\n      <div class=\'no-matches\'>\n        '+
( t("Sorry, we didn't find any graphs with that title.") )+
'\n      </div>\n      <div class="dcg-mygraphs-branding">\n        <i class="dcg-icon-desmos"></i>\n      </div>\n    </div>\n\n\n    <div class="graph-preview">\n      <span class="dcg-btn dcg-pull-right dcg-btn-medium dcg-btn-gray dcg-action-cancel">\n        '+
( t('Cancel') )+
'\n      </span>\n      <h4 class="dcg-title"></h4>\n      <div class="screenshot-container">\n        <div id="preview-calculator"></div>\n        <div class="screenshot-clickjack dcg-action-open-graph">\n          <span class="dcg-btn dcg-action-open-graph dcg-open-graph-btn dcg-btn-medium dcg-btn-blue">\n            '+
( t('Open Graph') )+
'\n          </span>\n        </div>\n        <div class="dcg-loading-container">\n          loading...\n        </div>\n      </div>\n      <div class="active-arrow"><div class="dcg-graphic"></div></div>\n    </div>\n  </div>\n\n  <div id="resources-cover" class="dcg-action-close-resources"></div>\n</div>\n';
}
return __p;
};});
//Definition of built-in functions and variables

define('math/builtin',['require'],function(require){

var BuiltIn = {};

BuiltIn.mod = function(a, b){
  return a - b * Math.floor(a/b);
};

BuiltIn.sign = function(x){
  if(x === 0) return 0;
  if(x > 0) return 1;
  if(x < 0) return -1;
  return NaN;
};

BuiltIn.lcm = function(a, b){
  a = Math.round(a);
  b = Math.round(b);
  var gcd = BuiltIn.getGCD(a, b);
  return Math.abs(a * b / gcd);
};

BuiltIn.gcd = function(a, b){
  return BuiltIn.getGCD(a, b);
};

BuiltIn.nCr = function(n, r){
  n = Math.round(n);
  r = Math.round(r);

  //Error conditions
  if(r > n || n < 0 || r < 0){
    return 0;
  }

  var total = 1;
  for(var i = 0; i < r; i++)
  {
    total *= (n - i) / (i + 1);
  }
  return total;
};

BuiltIn.nPr = function(n, r){
  n = Math.round(n);
  r = Math.round(r);

  //Error conditions
  if(r > n || n < 0 || r < 0){
    return 0;
  }

  var total = 1;
  for(var i = 0; i < r; i++){
    total *= (n-i);
  }
  return total;
};

BuiltIn.factorial = function (x) {
  return BuiltIn.gamma(x + 1);
};

BuiltIn._integerFactorial = function (n) {
  if (n !== Math.floor(n)) return NaN;
  if (n < 0) return NaN;
  if (n > 170) return NaN; // Overflows double point floats
  if (n === 0 || n === 1) return 1;

  var output = 1;
  for (var i = 2; i <= n; i++) output *= i;

  return output;
};

BuiltIn.gamma = function (x) {
  if (x === Math.floor(x)) return BuiltIn._integerFactorial(x - 1);
  // Euler's reflection formula
  if (x < 0) return Math.PI/(Math.sin(Math.PI*x)*BuiltIn.gamma(1-x));
  return Math.exp(BuiltIn.lnGamma(x));
};

BuiltIn.lnGamma = function (x) {
  if (x < 0) return NaN; // Alternates between real and complex on integers.

  // 15 term rational approximation of lnGamma, valid for positive numbers.
  // Original source not known, but verified by JM using Mathematica to give
  // at least 14 correct digits of gamma = Math.exp(Math.lnGamma(x)) for
  // integers and half integers between 0 and 60, and at least 12 correct
  // digits up to 170.
  var cof = [
    57.1562356658629235,
    -59.5979603554754912,
    14.1360979747417471,
    -0.491913816097620199,
    0.339946499848118887e-4,
    0.465236289270485756e-4,
    -0.983744753048795646e-4,
    0.158088703224912494e-3,
    -0.210264441724104883e-3,
    0.217439618115212643e-3,
    -0.164318106536763890e-3,
    0.844182239838527433e-4,
    -0.261908384015814087e-4,
    0.368991826595316234e-5
  ];

  var s = 0.999999999999997092;
  for (var i=0; i < 14; i++) s += cof[i]/(x + i + 1);

  var t = x + 5.24218750000000000;

  return (x + 0.5)*Math.log(t) - t + Math.log(2.5066282746310005*s/x);
};

// BernoulliB_{2k} for k=1..14
BuiltIn.bernoulliTable = [
  1/6, -1/30, 1/42, -1/30, 5/66, -691/2730, 7/6, -3617/510,
  43867/798, -174611/330, 854513/138, -236364091/2730, 8553103/6,
  -23749461029/870
];

// mth derivative of cot(x)
//
// Used in evaluating reflection formula for polygamma
//
// Uses fact that (d/dx)^m cot(x) = p_m(cos(x))/sin(x)^{m+1} where p_m(x) is a
// polynomial with coefficents that obey the following recursion relation:
//
// a_{m+1, n} = -((m - n + 2) a_{m, n-1} + (n+1) a_{m, n+1})
//            = -(            t1         +        t2       )
// a_{0, 0} = 0, a_{0, 1} = 1
//
// Could improve performance by taking advantage of fact that p is even/odd
// when m is odd/even. Didn't feel worth the added trickiness.
BuiltIn.cotDerivative = function(m, x) {
  /* jshint maxcomplexity:11 */
  if (m !== Math.floor(m)) return NaN;
  if (m < 0) return NaN;

  if (m === 0) return 1/BuiltIn.tan(x);

  var sinx = BuiltIn.sin(x);
  if (m === 1) return -1/(sinx*sinx);

  var cosx = BuiltIn.cos(x);
  if (m === 2) return 2*cosx/(sinx*sinx*sinx);

  var aprev = [0, 2];
  var a;
  var mp, n;
  var t1, t2;
  for (mp = 3; mp <= m; mp++) {
    a = [];
    for (n = 0; n < mp; n++) {
      t1 = 0;
      t2 = 0;
      if (n > 0) t1 = (mp - n + 1)*aprev[n - 1];
      if (n + 2 < mp) t2 = (n + 1)*aprev[n + 1];
      a.push(-(t1 + t2));
    }
    aprev = a;
  }

  var s = 0;
  // Horner's method for polynomial evaluation
  for (n = m - 1; n >= 0; n--) s = a[n] + cosx*s;

  return s/Math.pow(sinx, m + 1);
};

// polyGamma(m, n) is the (m+1)th derivative of lnGamma(n)
//
// Implemented by differentiating Stirling's approximation:
//
// d/dn ln(Gamma(n)) = -\left(
//         ln(n) + 1/2n + \sum_{k=1}^{\infty} B_{2k}/(2k n^{2k})
//       /right)
//
// d^{m+1}/dn^{m+1} ln(Gamma(n)) =
//      m! (-1)^{m + 1} \left(
//        1/(m n^m) - 1/(2 n^{1+m}) +
//        \sum_{k=1}^{\infty} B_{2k} (2k + m - 1)!/(m!(2k)!n^{2k+m})
//      \right)
//
// B_{2k} are the Bernoulli numbers.
//
// Uses recurrence relation to bring arguments above 10, and reflection
// formula for negative n. In this case, 14 term sum gives results accurate to
// machine precision for values of m between 0 and at least 8.
//
// Only get 8 digits for polyGamma(100, 30)
//
// Recurrence relation:
//
// polyGamma(m, n) = polyGamma(m, n + 1) + (-1)^m m!/n^{m+1}
//
// Reflection formula:
//
// polyGamma(m, n) = (-1)^{m}polyGamma(m, 1 - n) - pi d^m/dn^m cot(pi*n)
//
// Can lose some accuracy in reflection formula for large m because of large
// powers of trig functions.
BuiltIn.polyGamma = function (m, n) {
  if (m < 0) return NaN;
  if (m !== Math.floor(m)) return NaN;
  var sign = (m % 2 === 0) ? -1 : 1;
  // Use reflection formula for negative n
  if (n < 0) {
    return -sign*BuiltIn.polyGamma(m, 1 - n) -
      Math.pow(Math.PI, m + 1)*BuiltIn.cotDerivative(m, Math.PI*n);
  }

  var mfac = BuiltIn.factorial(m);

  // Use recurrence relation to bring n above 10
  var s = 0;
  var npmm = Math.pow(n, -(m + 1));
  while (n < 10) {
    s += npmm;
    n++;
    npmm = Math.pow(n, -(m + 1));
  }

  s += (m === 0) ? -Math.log(n) : npmm*n/m;
  s += 0.5*npmm;

  var bt = BuiltIn.bernoulliTable;
  var num = m + 1;
  var denom = 2;
  var pre = npmm*n*num/denom;
  var nsqinv = 1/(n*n);
  for (var k = 1; k <= 14; k++) {
    pre *= nsqinv;
    s += pre*bt[k-1];
    num++; denom++;
    pre *= num/denom;
    num++; denom++;
    pre *= num/denom;
  }
  return mfac*sign*s;
};

BuiltIn.getGCD = function(x,y)
{
    //Only defined over integers
    var a = Math.round(x);
    var b = Math.round(y);

    // Positive values only
    if (a < 0)
        a = -a;
    if (b < 0)
        b = -b;

    // Reverse order if necessary.
    // b should be smaller than a
    if (b > a)
    {
        var temp = b;
        b = a;
        a = temp;
    }

    //GCD(0, x) = x
    if(b === 0){
      return a;
    }

    var m = a % b;

    while (m > 0)
    {
        a = b;
        b = m;
        m = a % b;
    }

    return b;
};

// Returns a reduced fraction approximation of x with denominator less than
// maxDenominator. maxDenominator defaults to 1e6.
BuiltIn.toFraction = function (x, maxDenominator) {

  if (x === Infinity) return { n: Infinity, d: 1 };
  if (x === -Infinity) return { n: -Infinity, d: 1};
  if (!isFinite(x)) return { n: NaN, d: 1};

  var whole, n0 = 0, n1 = 1, d0 = 1, d1 = 0, n, d;
  if (!maxDenominator) maxDenominator = 1e6;
  while (true) {
    whole = Math.floor(x);
    n = whole*n1 + n0;
    d = whole*d1 + d0;
    if (d > maxDenominator) break;
    n0 = n1;
    d0 = d1;
    n1 = n;
    d1 = d;
    if (x === whole) break;
    x = 1/(x - whole);
  }
  return { n: n1, d: d1 };
};

// Check if two values are equal to within the given number of bits of
// precision. For numbers smaller than one, compares the difference in the
// numbers to 1 instead of the larger of the numbers. This makes calculations like
// BuiltIn.approx(Math.sin(Math.Pi), 0) work out.
BuiltIn.approx = function (x1, x2, bits) {
  var m = Math.max(Math.max(Math.abs(x1), Math.abs(x2)), 1);
  var d = (bits === undefined) ? 0.5 : Math.pow(0.5, bits);
  return m === m + d*Math.abs(x2 - x1);
};

BuiltIn.log_base = function(n, base){return Math.log(n) / Math.log(base)};

BuiltIn.pow = function (x, n) {
  if (x >= 0 || n === Math.floor(n)) return Math.pow(x, n);
  var frac = BuiltIn.toFraction(n, 100);
  if (BuiltIn.approx(frac.n/frac.d, n, 2) && frac.d % 2 === 1) return (frac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, n);
  return NaN;
};
BuiltIn.nthroot = function(x, n) { return BuiltIn.pow(x, 1/n) };

var PI_INV = 1/Math.PI;

//Trig functions
// We do some work to make integer and half integer multiples of pi equal to 0 when they should be.
BuiltIn.sin = function (x) {
  var absx = Math.abs(x);
  if (0.5*(absx*PI_INV*2 % 2) + absx === absx) return 0;
  return Math.sin(x);
};

BuiltIn.cos = function (x) {
  var absx = Math.abs(x);
  if (0.5*((absx*PI_INV*2 + 1) % 2) + absx === absx) return 0;
  return Math.cos(x);
};

BuiltIn.tan = function (x) {
  var absx = Math.abs(x);
  if (0.5*(absx*PI_INV*2 % 2) + absx === absx) return 0;
  if (0.5*((absx*PI_INV*2 + 1) % 2) + absx === absx) return Infinity;
  return Math.tan(x);
};

BuiltIn.sec = function (x) {
  var absx = Math.abs(x);
  if (0.5*((absx*PI_INV*2 + 1) % 2) + absx === absx) return Infinity;
  return 1/Math.cos(x);
};

BuiltIn.csc = function(x) {
  var absx = Math.abs(x);
  if (0.5*(absx*PI_INV*2 % 2) + absx === absx) return Infinity;
  return 1/Math.sin(x);
};

BuiltIn.cot = function(x) {
  var absx = Math.abs(x);
  if (0.5*(absx*PI_INV*2 % 2) + absx === absx) return Infinity;
  if (0.5*((absx*PI_INV*2 + 1) % 2) + absx === absx) return 0;
  return 1/Math.tan(x);
};

//Inverse trig functions
BuiltIn.acot = function(x){return Math.PI / 2 - Math.atan(x)};
BuiltIn.acsc = function(x){return Math.asin(1/x)};
BuiltIn.asec = function(x){return Math.acos(1/x)};

//Hyperbolic trig functions
BuiltIn.sinh = function(x){return (Math.exp(x) - Math.exp(-x)) / 2};
BuiltIn.cosh = function(x){return (Math.exp(x) + Math.exp(-x)) / 2};
BuiltIn.tanh = function(x) {
  // This definition avoids overflow of sinh and cosh for large x
  if (x > 0) {
    return (1 - Math.exp(-2*x))/(1 + Math.exp(-2*x));
  } else {
    return (Math.exp(2*x) - 1)/(Math.exp(2*x) + 1);
  }
};

BuiltIn.sech = function(x){return 1 / BuiltIn.cosh(x)};
BuiltIn.csch = function(x){return 1 / BuiltIn.sinh(x)};
BuiltIn.coth = function(x){return 1 / BuiltIn.tanh(x)};

//Inverse hyperbolic trig functions
BuiltIn.asinh = function(x){return Math.log(x+Math.sqrt(x*x+1))};
BuiltIn.acosh = function(x){return Math.log(x+Math.sqrt(x+1)*Math.sqrt(x-1))};
BuiltIn.atanh = function(x){return 0.5 * Math.log((1+x)/(1-x))};

BuiltIn.asech = function(x){return Math.log(1/x + Math.sqrt((1/x + 1)) * Math.sqrt((1/x - 1)))};
BuiltIn.acsch = function(x){return Math.log(1/x + Math.sqrt((1/(x*x)+1)))};
BuiltIn.acoth = function(x){return 0.5 * Math.log((x+1)/(x-1))};

BuiltIn.mean = function(list){
  var total = 0;
  for(var i = 0; i < list.length; i++){
    total += list[i];
  }
  return total / list.length;
};

BuiltIn.total = function(list){
  var total = 0;
  for(var i = 0; i < list.length; i++){
    total += list[i];
  }
  return total;
};

BuiltIn.length = function(list){
  return list.length;
};

BuiltIn.listMin = function (list) {
  if (list.length < 1) return NaN;
  var min = list[0];
  if (isNaN(min)) return NaN;
  for (var i = 1; i < list.length; i++) {
    if (isNaN(list[i])) return NaN;
    if (list[i] < min) min = list[i];
  }
  return min;
};

BuiltIn.listMax = function (list) {
  if (list.length < 1) return NaN;
  var max = list[0];
  if (isNaN(max)) return NaN;
  for (var i = 1; i < list.length; i++) {
    if (isNaN(list[i])) return NaN;
    if (list[i] >= max) max = list[i];
  }
  return max;
};

BuiltIn.argMin = function (list) {
  // Our lists start indexing from 1, so returning 0 represents
  // no element of the list.
  if (list.length < 1) return 0;
  var min = list[0];
  if (isNaN(min)) return 0;
  var argMin = 0;
  for (var i = 1; i < list.length; i++) {
    if (isNaN(list[i])) return 0;
    if (list[i] < min) {
      argMin = i;
      min = list[i];
    }
  }
  return argMin + 1; // Convert between js and Desmos indexing conventions
};

BuiltIn.argMax = function (list) {
  if (list.length < 1) return 0;
  var max = list[0];
  if (isNaN(max)) return 0;
  var argMax = 0;
  for (var i = 1; i < list.length; i++) {
    if (list[i] >= max) {
      if (isNaN(list[i])) return 0;
      argMax = i;
      max = list[i];
    }
  }
  return argMax + 1; // Convert between js and Desmos indexing conventions
};

BuiltIn.var = function (list) {
  var m = BuiltIn.mean(list);
  var total = 0;
  for (var i = 0; i < list.length; i++) {
    var delta = list[i] - m;
    total += delta*delta;
  }
  return total/list.length;
};

// Pearson correlation coefficient
BuiltIn.corr = function (l1, l2) {
  if (l1.length !== l2.length) return NaN;
  var len = l1.length;
  var m1 = BuiltIn.mean(l1);
  var m2 = BuiltIn.mean(l2);
  var d1, d2;
  var t1 = 0, t2 = 0, tc = 0;
  for (var i = 0; i < len; i++) {
    d1 = l1[i] - m1;
    d2 = l2[i] - m2;
    t1 += d1*d1;
    t2 += d2*d2;
    tc += d1*d2;
  }
  return tc/Math.sqrt(t1*t2);
};

BuiltIn.stdev = function (list) {
  var l = list.length;
  return Math.sqrt(BuiltIn.var(list)*l/(l-1));
};

BuiltIn.stdevp = function (list) {
  return Math.sqrt(BuiltIn.var(list));
};

return BuiltIn;
});

// Utility for serializing/deserializing functions.
define('math/functions',['require','math/builtin'],function (require) {
  var BuiltIn = require('math/builtin');

  function dehydrateGraphData (data) {
    for (var i = 0; i < data.length; i++) {
      if (data[i].compiled) {
        delete data[i].compiled.fn;
      }
    }
  }

  function rehydrateGraphData (data) {
    /* jshint evil: true */
    for (var i = 0; i < data.length; i++) {
      var compiled = data[i].compiled;
      if (compiled) {
        compiled.fn = closureFunctionWithBuiltIn(compiled.args, compiled.source);
      }
    }
  }

  //Helper function to auto-generate evaluateOnce calls from evaluation strings
  function createEvaluateFunction (evalExpressionFn, n) {
    /*jshint evil:true*/
    var argList = [];
    for(var i = 0; i < n; i++){
      argList.push('values['+i+']');
    }
    return closureFunctionWithBuiltIn(['values'], 'return ' + evalExpressionFn(argList));
  }

  function closureFunctionWithBuiltIn (args, body) {
    /*jshint evil:true*/
    var argList = args.join(',');
    var functionString = "return (function("+argList+"){"+body+"})";
    var compilerFunction = new Function(['BuiltIn'], functionString);
    return compilerFunction(BuiltIn);
  }

  return {
    dehydrateGraphData: dehydrateGraphData,
    rehydrateGraphData: rehydrateGraphData,
    closureFunctionWithBuiltIn: closureFunctionWithBuiltIn,
    createEvaluateFunction: createEvaluateFunction
  };
});

define('api/cross_origin_worker',['require'],function(require) {

  return function (workerURL) {

    // IE workers fail if you put ?desmos_config= after the url.
    // They fail absolutely silently. The browsers doesn't make a request for the
    // javascript and no errors are thrown. This is my best attempt at feature-detecting
    // all versions of IE. Starting with IE11 microsoft wants to make it hard to sniff IE.
    // we aren't putting ?desmos_config= after the url, but we've hit too many snags with
    // IE workers to allow them. Disabling them outright until Microsoft gets its act together
    if (window.MSBlobBuilder) {
      return null;
    }

    var location = window.location;
    var a = document.createElement('a');
    a.href = workerURL;

    // IE doesn't correctly parse the relative URL we give it which results in .protocol being
    // returned as ':'. So we update the elements href with its own, now fully-qualified href.
    a.href = a.href;
    // Go home Internet Explorer - you're drunk.

    if (a.protocol === location.protocol && a.host === location.host) {
      return workerURL;
    }

    var codeString = 'importScripts(\'' + workerURL + '\');';

    var blob;
    try {
      blob = new Blob([codeString], {type : 'application/javascript'});
    } catch (e1) {
      try {
        var BlobBuilder = window.BlobBuilder ||
                          window.WebKitBlobBuilder ||
                          window.MozBlobBuilder;

        var blobBuilder = new BlobBuilder();
        blobBuilder.append(codeString);
        blob = blobBuilder.getBlob('application/javascript');
      } catch (e2) {
        return null; // can't create a blob, abort
      }
    }

    var URL = window.URL || window.webkitURL;
    return URL.createObjectURL(blob);
  };
});

define('numeric',[],function () {


var numeric = (typeof exports === "undefined")?(function numeric() {}):(exports);
if(typeof global !== "undefined") { global.numeric = numeric; }

numeric.version = "1.2.6";

// 1. Utility functions
numeric.bench = function bench (f,interval) {
    var t1,t2,n,i;
    if(typeof interval === "undefined") { interval = 15; }
    n = 0.5;
    t1 = new Date();
    while(1) {
        n*=2;
        for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
        while(i>0) { f(); i--; }
        t2 = new Date();
        if(t2-t1 > interval) break;
    }
    for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
    while(i>0) { f(); i--; }
    t2 = new Date();
    return 1000*(3*n-1)/(t2-t1);
}

numeric._myIndexOf = (function _myIndexOf(w) {
    var n = this.length,k;
    for(k=0;k<n;++k) if(this[k]===w) return k;
    return -1;
});
numeric.myIndexOf = (Array.prototype.indexOf)?Array.prototype.indexOf:numeric._myIndexOf;

numeric.precision = 4;
numeric.largeArray = 50;

// Wrapper around `new Function` that closures in the `numeric` object.
numeric.compile = function () {
  var args = Array.prototype.slice.call(arguments);
  var body = args.pop();
  body = 'return function (' + args.join(',') + ') {' + body + ';}';
  return (new Function(['numeric'], body))(numeric);
}

numeric.prettyPrint = function prettyPrint(x) {
    function fmtnum(x) {
        if(x === 0) { return '0'; }
        if(isNaN(x)) { return 'NaN'; }
        if(x<0) { return '-'+fmtnum(-x); }
        if(isFinite(x)) {
            var scale = Math.floor(Math.log(x) / Math.log(10));
            var normalized = x / Math.pow(10,scale);
            var basic = normalized.toPrecision(numeric.precision);
            if(parseFloat(basic) === 10) { scale++; normalized = 1; basic = normalized.toPrecision(numeric.precision); }
            return parseFloat(basic).toString()+'e'+scale.toString();
        }
        return 'Infinity';
    }
    var ret = [];
    function foo(x) {
        var k;
        if(typeof x === "undefined") { ret.push(Array(numeric.precision+8).join(' ')); return false; }
        if(typeof x === "string") { ret.push('"'+x+'"'); return false; }
        if(typeof x === "boolean") { ret.push(x.toString()); return false; }
        if(typeof x === "number") {
            var a = fmtnum(x);
            var b = x.toPrecision(numeric.precision);
            var c = parseFloat(x.toString()).toString();
            var d = [a,b,c,parseFloat(b).toString(),parseFloat(c).toString()];
            for(k=1;k<d.length;k++) { if(d[k].length < a.length) a = d[k]; }
            ret.push(Array(numeric.precision+8-a.length).join(' ')+a);
            return false;
        }
        if(x === null) { ret.push("null"); return false; }
        if(typeof x === "function") {
            ret.push(x.toString());
            var flag = false;
            for(k in x) { if(x.hasOwnProperty(k)) {
                if(flag) ret.push(',\n');
                else ret.push('\n{');
                flag = true;
                ret.push(k);
                ret.push(': \n');
                foo(x[k]);
            } }
            if(flag) ret.push('}\n');
            return true;
        }
        if(x instanceof Array) {
            if(x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }
            var flag = false;
            ret.push('[');
            for(k=0;k<x.length;k++) { if(k>0) { ret.push(','); if(flag) ret.push('\n '); } flag = foo(x[k]); }
            ret.push(']');
            return true;
        }
        ret.push('{');
        var flag = false;
        for(k in x) { if(x.hasOwnProperty(k)) { if(flag) ret.push(',\n'); flag = true; ret.push(k); ret.push(': \n'); foo(x[k]); } }
        ret.push('}');
        return true;
    }
    foo(x);
    return ret.join('');
}

numeric.parseDate = function parseDate(d) {
    function foo(d) {
        if(typeof d === 'string') { return Date.parse(d.replace(/-/g,'/')); }
        if(!(d instanceof Array)) { throw new Error("parseDate: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseFloat = function parseFloat_(d) {
    function foo(d) {
        if(typeof d === 'string') { return parseFloat(d); }
        if(!(d instanceof Array)) { throw new Error("parseFloat: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseCSV = function parseCSV(t) {
    var foo = t.split('\n');
    var j,k;
    var ret = [];
    var pat = /(([^'",]*)|('[^']*')|("[^"]*")),/g;
    var patnum = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/;
    var stripper = function(n) { return n.substr(0,n.length-1); }
    var count = 0;
    for(k=0;k<foo.length;k++) {
      var bar = (foo[k]+",").match(pat),baz;
      if(bar.length>0) {
          ret[count] = [];
          for(j=0;j<bar.length;j++) {
              baz = stripper(bar[j]);
              if(patnum.test(baz)) { ret[count][j] = parseFloat(baz); }
              else ret[count][j] = baz;
          }
          count++;
      }
    }
    return ret;
}

numeric.toCSV = function toCSV(A) {
    var s = numeric.dim(A);
    var i,j,m,n,row,ret;
    m = s[0];
    n = s[1];
    ret = [];
    for(i=0;i<m;i++) {
        row = [];
        for(j=0;j<m;j++) { row[j] = A[i][j].toString(); }
        ret[i] = row.join(', ');
    }
    return ret.join('\n')+'\n';
}

numeric.getURL = function getURL(url) {
    var client = new XMLHttpRequest();
    client.open("GET",url,false);
    client.send();
    return client;
}

numeric.imageURL = function imageURL(img) {
    function base64(A) {
        var n = A.length, i,x,y,z,p,q,r,s;
        var key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var ret = "";
        for(i=0;i<n;i+=3) {
            x = A[i];
            y = A[i+1];
            z = A[i+2];
            p = x >> 2;
            q = ((x & 3) << 4) + (y >> 4);
            r = ((y & 15) << 2) + (z >> 6);
            s = z & 63;
            if(i+1>=n) { r = s = 64; }
            else if(i+2>=n) { s = 64; }
            ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);
            }
        return ret;
    }
    function crc32Array (a,from,to) {
        if(typeof from === "undefined") { from = 0; }
        if(typeof to === "undefined") { to = a.length; }
        var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
                     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
                     0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
                     0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
                     0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
                     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
                     0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
                     0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
                     0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
                     0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
                     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
                     0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
                     0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
                     0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
                     0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
                     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
                     0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
                     0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
                     0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
                     0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
                     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
                     0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
                     0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
                     0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
                     0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
                     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
                     0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
                     0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
                     0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
                     0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
                     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
                     0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];

        var crc = -1, y = 0, n = a.length,i;

        for (i = from; i < to; i++) {
            y = (crc ^ a[i]) & 0xFF;
            crc = (crc >>> 8) ^ table[y];
        }

        return crc ^ (-1);
    }

    var h = img[0].length, w = img[0][0].length, s1, s2, next,k,length,a,b,i,j,adler32,crc32;
    var stream = [
                  137, 80, 78, 71, 13, 10, 26, 10,                           //  0: PNG signature
                  0,0,0,13,                                                  //  8: IHDR Chunk length
                  73, 72, 68, 82,                                            // 12: "IHDR"
                  (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w&255,   // 16: Width
                  (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h&255,   // 20: Height
                  8,                                                         // 24: bit depth
                  2,                                                         // 25: RGB
                  0,                                                         // 26: deflate
                  0,                                                         // 27: no filter
                  0,                                                         // 28: no interlace
                  -1,-2,-3,-4,                                               // 29: CRC
                  -5,-6,-7,-8,                                               // 33: IDAT Chunk length
                  73, 68, 65, 84,                                            // 37: "IDAT"
                  // RFC 1950 header starts here
                  8,                                                         // 41: RFC1950 CMF
                  29                                                         // 42: RFC1950 FLG
                  ];
    crc32 = crc32Array(stream,12,29);
    stream[29] = (crc32>>24)&255;
    stream[30] = (crc32>>16)&255;
    stream[31] = (crc32>>8)&255;
    stream[32] = (crc32)&255;
    s1 = 1;
    s2 = 0;
    for(i=0;i<h;i++) {
        if(i<h-1) { stream.push(0); }
        else { stream.push(1); }
        a = (3*w+1+(i===0))&255; b = ((3*w+1+(i===0))>>8)&255;
        stream.push(a); stream.push(b);
        stream.push((~a)&255); stream.push((~b)&255);
        if(i===0) stream.push(0);
        for(j=0;j<w;j++) {
            for(k=0;k<3;k++) {
                a = img[k][i][j];
                if(a>255) a = 255;
                else if(a<0) a=0;
                else a = Math.round(a);
                s1 = (s1 + a )%65521;
                s2 = (s2 + s1)%65521;
                stream.push(a);
            }
        }
        stream.push(0);
    }
    adler32 = (s2<<16)+s1;
    stream.push((adler32>>24)&255);
    stream.push((adler32>>16)&255);
    stream.push((adler32>>8)&255);
    stream.push((adler32)&255);
    length = stream.length - 41;
    stream[33] = (length>>24)&255;
    stream[34] = (length>>16)&255;
    stream[35] = (length>>8)&255;
    stream[36] = (length)&255;
    crc32 = crc32Array(stream,37);
    stream.push((crc32>>24)&255);
    stream.push((crc32>>16)&255);
    stream.push((crc32>>8)&255);
    stream.push((crc32)&255);
    stream.push(0);
    stream.push(0);
    stream.push(0);
    stream.push(0);
//    a = stream.length;
    stream.push(73);  // I
    stream.push(69);  // E
    stream.push(78);  // N
    stream.push(68);  // D
    stream.push(174); // CRC1
    stream.push(66);  // CRC2
    stream.push(96);  // CRC3
    stream.push(130); // CRC4
    return 'data:image/png;base64,'+base64(stream);
}

// 2. Linear algebra with Arrays.
numeric._dim = function _dim(x) {
    var ret = [];
    while(typeof x === "object") { ret.push(x.length); x = x[0]; }
    return ret;
}

numeric.dim = function dim(x) {
    var y,z;
    if(typeof x === "object") {
        y = x[0];
        if(typeof y === "object") {
            z = y[0];
            if(typeof z === "object") {
                return numeric._dim(x);
            }
            return [x.length,y.length];
        }
        return [x.length];
    }
    return [];
}

numeric.mapreduce = function mapreduce(body,init) {
    return numeric.compile('x','accum','_s','_k',
            'if(typeof accum === "undefined") accum = '+init+';\n'+
            'if(typeof x === "number") { var xi = x; '+body+'; return accum; }\n'+
            'if(typeof _s === "undefined") _s = numeric.dim(x);\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i,xi;\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) {\n'+
            '        accum = arguments.callee(x[i],accum,_s,_k+1);\n'+
            '    }'+
            '    return accum;\n'+
            '}\n'+
            'for(i=_n-1;i>=1;i-=2) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '    xi = x[i-1];\n'+
            '    '+body+';\n'+
            '}\n'+
            'if(i === 0) {\n'+
            '    xi = x[i];\n'+
            '    '+body+'\n'+
            '}\n'+
            'return accum;'
            );
}
numeric.mapreduce2 = function mapreduce2(body,setup) {
    return numeric.compile('x',
            'var n = x.length;\n'+
            'var i,xi;\n'+setup+';\n'+
            'for(i=n-1;i!==-1;--i) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '}\n'+
            'return accum;'
            );
}


numeric.same = function same(x,y) {
    var i,n;
    if(!(x instanceof Array) || !(y instanceof Array)) { return false; }
    n = x.length;
    if(n !== y.length) { return false; }
    for(i=0;i<n;i++) {
        if(x[i] === y[i]) { continue; }
        if(typeof x[i] === "object") { if(!same(x[i],y[i])) return false; }
        else { return false; }
    }
    return true;
}

numeric.rep = function rep(s,v,k) {
    if(typeof k === "undefined") { k=0; }
    var n = s[k], ret = Array(n), i;
    if(k === s.length-1) {
        for(i=n-2;i>=0;i-=2) { ret[i+1] = v; ret[i] = v; }
        if(i===-1) { ret[0] = v; }
        return ret;
    }
    for(i=n-1;i>=0;i--) { ret[i] = numeric.rep(s,v,k+1); }
    return ret;
}


numeric.dotMMsmall = function dotMMsmall(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0;
    p = x.length; q = y.length; r = y[0].length;
    ret = Array(p);
    for(i=p-1;i>=0;i--) {
        foo = Array(r);
        bar = x[i];
        for(k=r-1;k>=0;k--) {
            woo = bar[q-1]*y[q-1][k];
            for(j=q-2;j>=1;j-=2) {
                i0 = j-1;
                woo += bar[j]*y[j][k] + bar[i0]*y[i0][k];
            }
            if(j===0) { woo += bar[0]*y[0][k]; }
            foo[k] = woo;
        }
        ret[i] = foo;
    }
    return ret;
}
numeric._getCol = function _getCol(A,j,x) {
    var n = A.length, i;
    for(i=n-1;i>0;--i) {
        x[i] = A[i][j];
        --i;
        x[i] = A[i][j];
    }
    if(i===0) x[0] = A[0][j];
}
numeric.dotMMbig = function dotMMbig(x,y){
    var gc = numeric._getCol, p = y.length, v = Array(p);
    var m = x.length, n = y[0].length, A = new Array(m), xj;
    var VV = numeric.dotVV;
    var i,j,k,z;
    --p;
    --m;
    for(i=m;i!==-1;--i) A[i] = Array(n);
    --n;
    for(i=n;i!==-1;--i) {
        gc(y,i,v);
        for(j=m;j!==-1;--j) {
            z=0;
            xj = x[j];
            A[j][i] = VV(xj,v);
        }
    }
    return A;
}

numeric.dotMV = function dotMV(x,y) {
    var p = x.length, q = y.length,i;
    var ret = Array(p), dotVV = numeric.dotVV;
    for(i=p-1;i>=0;i--) { ret[i] = dotVV(x[i],y); }
    return ret;
}

numeric.dotVM = function dotVM(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0,s1,s2,s3,baz,accum;
    p = x.length; q = y[0].length;
    ret = Array(q);
    for(k=q-1;k>=0;k--) {
        woo = x[p-1]*y[p-1][k];
        for(j=p-2;j>=1;j-=2) {
            i0 = j-1;
            woo += x[j]*y[j][k] + x[i0]*y[i0][k];
        }
        if(j===0) { woo += x[0]*y[0][k]; }
        ret[k] = woo;
    }
    return ret;
}

numeric.dotVV = function dotVV(x,y) {
    var i,n=x.length,i1,ret = x[n-1]*y[n-1];
    for(i=n-2;i>=1;i-=2) {
        i1 = i-1;
        ret += x[i]*y[i] + x[i1]*y[i1];
    }
    if(i===0) { ret += x[0]*y[0]; }
    return ret;
}

numeric.dot = function dot(x,y) {
    var d = numeric.dim;
    switch(d(x).length*1000+d(y).length) {
    case 2002:
        if(y.length < 10) return numeric.dotMMsmall(x,y);
        else return numeric.dotMMbig(x,y);
    case 2001: return numeric.dotMV(x,y);
    case 1002: return numeric.dotVM(x,y);
    case 1001: return numeric.dotVV(x,y);
    case 1000: return numeric.mulVS(x,y);
    case 1: return numeric.mulSV(x,y);
    case 0: return x*y;
    default: throw new Error('numeric.dot only works on vectors and matrices');
    }
}

numeric.diag = function diag(d) {
    var i,i1,j,n = d.length, A = Array(n), Ai;
    for(i=n-1;i>=0;i--) {
        Ai = Array(n);
        i1 = i+2;
        for(j=n-1;j>=i1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j>i) { Ai[j] = 0; }
        Ai[i] = d[i];
        for(j=i-1;j>=1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j===0) { Ai[0] = 0; }
        A[i] = Ai;
    }
    return A;
}
numeric.getDiag = function(A) {
    var n = Math.min(A.length,A[0].length),i,ret = Array(n);
    for(i=n-1;i>=1;--i) {
        ret[i] = A[i][i];
        --i;
        ret[i] = A[i][i];
    }
    if(i===0) {
        ret[0] = A[0][0];
    }
    return ret;
}

numeric.identity = function identity(n) { return numeric.diag(numeric.rep([n],1)); }
numeric.pointwise = function pointwise(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = '_s';
    fun[params.length+1] = '_k';
    fun[params.length+2] = (
            'if(typeof _s === "undefined") _s = numeric.dim('+thevec+');\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee('+params.join(',')+',_s,_k+1);\n'+
            '    return ret;\n'+
            '}\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            '    '+body+'\n'+
            '}\n'+
            'return ret;'
            );
    return numeric.compile.apply(null,fun);
}
numeric.pointwise2 = function pointwise2(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = (
            'var _n = '+thevec+'.length;\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            body+'\n'+
            '}\n'+
            'return ret;'
            );
    return numeric.compile.apply(null,fun);
}
numeric._biforeach = (function _biforeach(x,y,s,k,f) {
    if(k === s.length-1) { f(x,y); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _biforeach(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
});
numeric._biforeach2 = (function _biforeach2(x,y,s,k,f) {
    if(k === s.length-1) { return f(x,y); }
    var i,n=s[k],ret = Array(n);
    for(i=n-1;i>=0;--i) { ret[i] = _biforeach2(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
    return ret;
});
numeric._foreach = (function _foreach(x,s,k,f) {
    if(k === s.length-1) { f(x); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _foreach(x[i],s,k+1,f); }
});
numeric._foreach2 = (function _foreach2(x,s,k,f) {
    if(k === s.length-1) { return f(x); }
    var i,n=s[k], ret = Array(n);
    for(i=n-1;i>=0;i--) { ret[i] = _foreach2(x[i],s,k+1,f); }
    return ret;
});

/*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');
numeric.allV = numeric.mapreduce('if(!xi) return false;','true');
numeric.any = function(x) { if(typeof x.length === "undefined") return x; return numeric.anyV(x); }
numeric.all = function(x) { if(typeof x.length === "undefined") return x; return numeric.allV(x); }*/

numeric.ops2 = {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%',
        and: '&&',
        or:  '||',
        eq:  '===',
        neq: '!==',
        lt:  '<',
        gt:  '>',
        leq: '<=',
        geq: '>=',
        band: '&',
        bor: '|',
        bxor: '^',
        lshift: '<<',
        rshift: '>>',
        rrshift: '>>>'
};
numeric.opseq = {
        addeq: '+=',
        subeq: '-=',
        muleq: '*=',
        diveq: '/=',
        modeq: '%=',
        lshifteq: '<<=',
        rshifteq: '>>=',
        rrshifteq: '>>>=',
        bandeq: '&=',
        boreq: '|=',
        bxoreq: '^='
};
numeric.mathfuns = ['abs','acos','asin','atan','ceil','cos',
                    'exp','floor','log','round','sin','sqrt','tan',
                    'isNaN','isFinite'];
numeric.mathfuns2 = ['atan2','pow','max','min'];
numeric.ops1 = {
        neg: '-',
        not: '!',
        bnot: '~',
        clone: ''
};
numeric.mapreducers = {
        any: ['if(xi) return true;','var accum = false;'],
        all: ['if(!xi) return false;','var accum = true;'],
        sum: ['accum += xi;','var accum = 0;'],
        prod: ['accum *= xi;','var accum = 1;'],
        norm2Squared: ['accum += xi*xi;','var accum = 0;'],
        norminf: ['accum = max(accum,abs(xi));','var accum = 0, max = Math.max, abs = Math.abs;'],
        norm1: ['accum += abs(xi)','var accum = 0, abs = Math.abs;'],
        sup: ['accum = max(accum,xi);','var accum = -Infinity, max = Math.max;'],
        inf: ['accum = min(accum,xi);','var accum = Infinity, min = Math.min;']
};

(function () {
    var i,o;
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        numeric.ops2[o] = o;
    }
    for(i in numeric.ops2) {
        if(numeric.ops2.hasOwnProperty(i)) {
            o = numeric.ops2[i];
            var code, codeeq, setup = '';
            if(numeric.myIndexOf.call(numeric.mathfuns2,i)!==-1) {
                setup = 'var '+o+' = Math.'+o+';\n';
                code = function(r,x,y) { return r+' = '+o+'('+x+','+y+')'; };
                codeeq = function(x,y) { return x+' = '+o+'('+x+','+y+')'; };
            } else {
                code = function(r,x,y) { return r+' = '+x+' '+o+' '+y; };
                if(numeric.opseq.hasOwnProperty(i+'eq')) {
                    codeeq = function(x,y) { return x+' '+o+'= '+y; };
                } else {
                    codeeq = function(x,y) { return x+' = '+x+' '+o+' '+y; };
                }
            }
            numeric[i+'VV'] = numeric.pointwise2(['x[i]','y[i]'],code('ret[i]','x[i]','y[i]'),setup);
            numeric[i+'SV'] = numeric.pointwise2(['x','y[i]'],code('ret[i]','x','y[i]'),setup);
            numeric[i+'VS'] = numeric.pointwise2(['x[i]','y'],code('ret[i]','x[i]','y'),setup);
            numeric[i] = numeric.compile(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var VV = numeric.'+i+'VV, VS = numeric.'+i+'VS, SV = numeric.'+i+'SV;\n'+
                    'var dim = numeric.dim;\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof x === "object") {\n'+
                    '      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n'+
                    '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n'+
                    '  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n'+
                    '  else '+codeeq('x','y')+'\n'+
                    '}\nreturn x;\n');
            numeric[o] = numeric[i];
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]','x[i]'], codeeq('ret[i]','x[i]'),setup);
            numeric[i+'eqS'] = numeric.pointwise2(['ret[i]','x'], codeeq('ret[i]','x'),setup);
            numeric[i+'eq'] = numeric.compile(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var V = numeric.'+i+'eqV, S = numeric.'+i+'eqS\n'+
                    'var s = numeric.dim(x);\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n'+
                    '  else numeric._biforeach(x,y,s,0,S);\n'+
                    '}\nreturn x;\n');
        }
    }
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        delete numeric.ops2[o];
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        numeric.ops1[o] = o;
    }
    for(i in numeric.ops1) {
        if(numeric.ops1.hasOwnProperty(i)) {
            setup = '';
            o = numeric.ops1[i];
            if(numeric.myIndexOf.call(numeric.mathfuns,i)!==-1) {
                if(Math.hasOwnProperty(o)) setup = 'var '+o+' = Math.'+o+';\n';
            }
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]'],'ret[i] = '+o+'(ret[i]);',setup);
            numeric[i+'eq'] = numeric.compile('x',
                    'if(typeof x !== "object") return '+o+'x\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'eqV;\n'+
                    'var s = numeric.dim(x);\n'+
                    'numeric._foreach(x,s,0,V);\n'+
                    'return x;\n');
            numeric[i+'V'] = numeric.pointwise2(['x[i]'],'ret[i] = '+o+'(x[i]);',setup);
            numeric[i] = numeric.compile('x',
                    'if(typeof x !== "object") return '+o+'(x)\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'V;\n'+
                    'var s = numeric.dim(x);\n'+
                    'return numeric._foreach2(x,s,0,V);\n');
        }
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        delete numeric.ops1[o];
    }
    for(i in numeric.mapreducers) {
        if(numeric.mapreducers.hasOwnProperty(i)) {
            o = numeric.mapreducers[i];
            numeric[i+'V'] = numeric.mapreduce2(o[0],o[1]);
            numeric[i] = numeric.compile('x','s','k',
                    o[1]+
                    'if(typeof x !== "object") {'+
                    '    xi = x;\n'+
                    o[0]+';\n'+
                    '    return accum;\n'+
                    '}'+
                    'if(typeof s === "undefined") s = numeric.dim(x);\n'+
                    'if(typeof k === "undefined") k = 0;\n'+
                    'if(k === s.length-1) return numeric.'+i+'V(x);\n'+
                    'var xi;\n'+
                    'var n = x.length, i;\n'+
                    'for(i=n-1;i!==-1;--i) {\n'+
                    '   xi = arguments.callee(x[i]);\n'+
                    o[0]+';\n'+
                    '}\n'+
                    'return accum;\n');
        }
    }
}());

numeric.truncVV = numeric.pointwise(['x[i]','y[i]'],'ret[i] = round(x[i]/y[i])*y[i];','var round = Math.round;');
numeric.truncVS = numeric.pointwise(['x[i]','y'],'ret[i] = round(x[i]/y)*y;','var round = Math.round;');
numeric.truncSV = numeric.pointwise(['x','y[i]'],'ret[i] = round(x/y[i])*y[i];','var round = Math.round;');
numeric.trunc = function trunc(x,y) {
    if(typeof x === "object") {
        if(typeof y === "object") return numeric.truncVV(x,y);
        return numeric.truncVS(x,y);
    }
    if (typeof y === "object") return numeric.truncSV(x,y);
    return Math.round(x/y)*y;
}

numeric.inv = function inv(x) {
    var s = numeric.dim(x), abs = Math.abs, m = s[0], n = s[1];
    var A = numeric.clone(x), Ai, Aj;
    var I = numeric.identity(m), Ii, Ij;
    var i,j,k,x;
    for(j=0;j<n;++j) {
        var i0 = -1;
        var v0 = -1;
        for(i=j;i!==m;++i) { k = abs(A[i][j]); if(k>v0) { i0 = i; v0 = k; } }
        Aj = A[i0]; A[i0] = A[j]; A[j] = Aj;
        Ij = I[i0]; I[i0] = I[j]; I[j] = Ij;
        x = Aj[j];
        for(k=j;k!==n;++k)    Aj[k] /= x;
        for(k=n-1;k!==-1;--k) Ij[k] /= x;
        for(i=m-1;i!==-1;--i) {
            if(i!==j) {
                Ai = A[i];
                Ii = I[i];
                x = Ai[j];
                for(k=j+1;k!==n;++k)  Ai[k] -= Aj[k]*x;
                for(k=n-1;k>0;--k) { Ii[k] -= Ij[k]*x; --k; Ii[k] -= Ij[k]*x; }
                if(k===0) Ii[0] -= Ij[0]*x;
            }
        }
    }
    return I;
}

numeric.det = function det(x) {
    var s = numeric.dim(x);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }
    var n = s[0], ret = 1,i,j,k,A = numeric.clone(x),Aj,Ai,alpha,temp,k1,k2,k3;
    for(j=0;j<n-1;j++) {
        k=j;
        for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
        if(k !== j) {
            temp = A[k]; A[k] = A[j]; A[j] = temp;
            ret *= -1;
        }
        Aj = A[j];
        for(i=j+1;i<n;i++) {
            Ai = A[i];
            alpha = Ai[j]/Aj[j];
            for(k=j+1;k<n-1;k+=2) {
                k1 = k+1;
                Ai[k] -= Aj[k]*alpha;
                Ai[k1] -= Aj[k1]*alpha;
            }
            if(k!==n) { Ai[k] -= Aj[k]*alpha; }
        }
        if(Aj[j] === 0) { return 0; }
        ret *= Aj[j];
    }
    return ret*A[j][j];
}

numeric.transpose = function transpose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
            --j;
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = A1[0]; Bj[i-1] = A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = A0[j];
            --j;
            ret[j][0] = A0[j];
        }
        if(j===0) { ret[0][0] = A0[0]; }
    }
    return ret;
}
numeric.negtranspose = function negtranspose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
            --j;
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = -A1[0]; Bj[i-1] = -A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = -A0[j];
            --j;
            ret[j][0] = -A0[j];
        }
        if(j===0) { ret[0][0] = -A0[0]; }
    }
    return ret;
}

numeric._random = function _random(s,k) {
    var i,n=s[k],ret=Array(n), rnd;
    if(k === s.length-1) {
        rnd = Math.random;
        for(i=n-1;i>=1;i-=2) {
            ret[i] = rnd();
            ret[i-1] = rnd();
        }
        if(i===0) { ret[0] = rnd(); }
        return ret;
    }
    for(i=n-1;i>=0;i--) ret[i] = _random(s,k+1);
    return ret;
}
numeric.random = function random(s) { return numeric._random(s,0); }

numeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }

numeric.linspace = function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}

numeric.getBlock = function getBlock(x,from,to) {
    var s = numeric.dim(x);
    function foo(x,k) {
        var i,a = from[k], n = to[k]-a, ret = Array(n);
        if(k === s.length-1) {
            for(i=n;i>=0;i--) { ret[i] = x[i+a]; }
            return ret;
        }
        for(i=n;i>=0;i--) { ret[i] = foo(x[i+a],k+1); }
        return ret;
    }
    return foo(x,0);
}

numeric.setBlock = function setBlock(x,from,to,B) {
    var s = numeric.dim(x);
    function foo(x,y,k) {
        var i,a = from[k], n = to[k]-a;
        if(k === s.length-1) { for(i=n;i>=0;i--) { x[i+a] = y[i]; } }
        for(i=n;i>=0;i--) { foo(x[i+a],y[i],k+1); }
    }
    foo(x,B,0);
    return x;
}

numeric.getRange = function getRange(A,I,J) {
    var m = I.length, n = J.length;
    var i,j;
    var B = Array(m), Bi, AI;
    for(i=m-1;i!==-1;--i) {
        B[i] = Array(n);
        Bi = B[i];
        AI = A[I[i]];
        for(j=n-1;j!==-1;--j) Bi[j] = AI[J[j]];
    }
    return B;
}

numeric.blockMatrix = function blockMatrix(X) {
    var s = numeric.dim(X);
    if(s.length<4) return numeric.blockMatrix([X]);
    var m=s[0],n=s[1],M,N,i,j,Xij;
    M = 0; N = 0;
    for(i=0;i<m;++i) M+=X[i][0].length;
    for(j=0;j<n;++j) N+=X[0][j][0].length;
    var Z = Array(M);
    for(i=0;i<M;++i) Z[i] = Array(N);
    var I=0,J,ZI,k,l,Xijk;
    for(i=0;i<m;++i) {
        J=N;
        for(j=n-1;j!==-1;--j) {
            Xij = X[i][j];
            J -= Xij[0].length;
            for(k=Xij.length-1;k!==-1;--k) {
                Xijk = Xij[k];
                ZI = Z[I+k];
                for(l = Xijk.length-1;l!==-1;--l) ZI[J+l] = Xijk[l];
            }
        }
        I += X[i][0].length;
    }
    return Z;
}

numeric.tensor = function tensor(x,y) {
    if(typeof x === "number" || typeof y === "number") return numeric.mul(x,y);
    var s1 = numeric.dim(x), s2 = numeric.dim(y);
    if(s1.length !== 1 || s2.length !== 1) {
        throw new Error('numeric: tensor product is only defined for vectors');
    }
    var m = s1[0], n = s2[0], A = Array(m), Ai, i,j,xi;
    for(i=m-1;i>=0;i--) {
        Ai = Array(n);
        xi = x[i];
        for(j=n-1;j>=3;--j) {
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
        }
        while(j>=0) { Ai[j] = xi * y[j]; --j; }
        A[i] = Ai;
    }
    return A;
}

// 3. The Tensor type T
numeric.T = function T(x,y) { this.x = x; this.y = y; }
numeric.t = function t(x,y) { return new numeric.T(x,y); }

numeric.Tbinop = function Tbinop(rr,rc,cr,cc,setup) {
    var io = numeric.indexOf;
    if(typeof setup !== "string") {
        var k;
        setup = '';
        for(k in numeric) {
            if(numeric.hasOwnProperty(k) && (rr.indexOf(k)>=0 || rc.indexOf(k)>=0 || cr.indexOf(k)>=0 || cc.indexOf(k)>=0) && k.length>1) {
                setup += 'var '+k+' = numeric.'+k+';\n';
            }
        }
    }
    return numeric.compile(['y'],
            'var x = this;\n'+
            'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n'+
            setup+'\n'+
            'if(x.y) {'+
            '  if(y.y) {'+
            '    return new numeric.T('+cc+');\n'+
            '  }\n'+
            '  return new numeric.T('+cr+');\n'+
            '}\n'+
            'if(y.y) {\n'+
            '  return new numeric.T('+rc+');\n'+
            '}\n'+
            'return new numeric.T('+rr+');\n'
    );
}

numeric.T.prototype.add = numeric.Tbinop(
        'add(x.x,y.x)',
        'add(x.x,y.x),y.y',
        'add(x.x,y.x),x.y',
        'add(x.x,y.x),add(x.y,y.y)');
numeric.T.prototype.sub = numeric.Tbinop(
        'sub(x.x,y.x)',
        'sub(x.x,y.x),neg(y.y)',
        'sub(x.x,y.x),x.y',
        'sub(x.x,y.x),sub(x.y,y.y)');
numeric.T.prototype.mul = numeric.Tbinop(
        'mul(x.x,y.x)',
        'mul(x.x,y.x),mul(x.x,y.y)',
        'mul(x.x,y.x),mul(x.y,y.x)',
        'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');

numeric.T.prototype.reciprocal = function reciprocal() {
    var mul = numeric.mul, div = numeric.div;
    if(this.y) {
        var d = numeric.add(mul(this.x,this.x),mul(this.y,this.y));
        return new numeric.T(div(this.x,d),div(numeric.neg(this.y),d));
    }
    return new T(div(1,this.x));
}
numeric.T.prototype.div = function div(y) {
    if(!(y instanceof numeric.T)) y = new numeric.T(y);
    if(y.y) { return this.mul(y.reciprocal()); }
    var div = numeric.div;
    if(this.y) { return new numeric.T(div(this.x,y.x),div(this.y,y.x)); }
    return new numeric.T(div(this.x,y.x));
}
numeric.T.prototype.dot = numeric.Tbinop(
        'dot(x.x,y.x)',
        'dot(x.x,y.x),dot(x.x,y.y)',
        'dot(x.x,y.x),dot(x.y,y.x)',
        'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'
        );
numeric.T.prototype.transpose = function transpose() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),t(y)); }
    return new numeric.T(t(x));
}
numeric.T.prototype.transjugate = function transjugate() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),numeric.negtranspose(y)); }
    return new numeric.T(t(x));
}
numeric.Tunop = function Tunop(r,c,s) {
    if(typeof s !== "string") { s = ''; }
    return numeric.compile(
            'var x = this;\n'+
            s+'\n'+
            'if(x.y) {'+
            '  '+c+';\n'+
            '}\n'+
            r+';\n'
    );
}

numeric.T.prototype.exp = numeric.Tunop(
        'return new numeric.T(ex)',
        'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',
        'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');
numeric.T.prototype.conj = numeric.Tunop(
        'return new numeric.T(x.x);',
        'return new numeric.T(x.x,numeric.neg(x.y));');
numeric.T.prototype.neg = numeric.Tunop(
        'return new numeric.T(neg(x.x));',
        'return new numeric.T(neg(x.x),neg(x.y));',
        'var neg = numeric.neg;');
numeric.T.prototype.sin = numeric.Tunop(
        'return new numeric.T(numeric.sin(x.x))',
        'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');
numeric.T.prototype.cos = numeric.Tunop(
        'return new numeric.T(numeric.cos(x.x))',
        'return x.exp().add(x.neg().exp()).div(2);');
numeric.T.prototype.abs = numeric.Tunop(
        'return new numeric.T(numeric.abs(x.x));',
        'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',
        'var mul = numeric.mul;');
numeric.T.prototype.log = numeric.Tunop(
        'return new numeric.T(numeric.log(x.x));',
        'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\n'+
        'return new numeric.T(numeric.log(r.x),theta.x);');
numeric.T.prototype.norm2 = numeric.Tunop(
        'return numeric.norm2(x.x);',
        'var f = numeric.norm2Squared;\n'+
        'return Math.sqrt(f(x.x)+f(x.y));');
numeric.T.prototype.inv = function inv() {
    var A = this;
    if(typeof A.y === "undefined") { return new numeric.T(numeric.inv(A.x)); }
    var n = A.x.length, i, j, k;
    var Rx = numeric.identity(n),Ry = numeric.rep([n,n],0);
    var Ax = numeric.clone(A.x), Ay = numeric.clone(A.y);
    var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;
    var i,j,k,d,d1,ax,ay,bx,by,temp;
    for(i=0;i<n;i++) {
        ax = Ax[i][i]; ay = Ay[i][i];
        d = ax*ax+ay*ay;
        k = i;
        for(j=i+1;j<n;j++) {
            ax = Ax[j][i]; ay = Ay[j][i];
            d1 = ax*ax+ay*ay;
            if(d1 > d) { k=j; d = d1; }
        }
        if(k!==i) {
            temp = Ax[i]; Ax[i] = Ax[k]; Ax[k] = temp;
            temp = Ay[i]; Ay[i] = Ay[k]; Ay[k] = temp;
            temp = Rx[i]; Rx[i] = Rx[k]; Rx[k] = temp;
            temp = Ry[i]; Ry[i] = Ry[k]; Ry[k] = temp;
        }
        Aix = Ax[i]; Aiy = Ay[i];
        Rix = Rx[i]; Riy = Ry[i];
        ax = Aix[i]; ay = Aiy[i];
        for(j=i+1;j<n;j++) {
            bx = Aix[j]; by = Aiy[j];
            Aix[j] = (bx*ax+by*ay)/d;
            Aiy[j] = (by*ax-bx*ay)/d;
        }
        for(j=0;j<n;j++) {
            bx = Rix[j]; by = Riy[j];
            Rix[j] = (bx*ax+by*ay)/d;
            Riy[j] = (by*ax-bx*ay)/d;
        }
        for(j=i+1;j<n;j++) {
            Ajx = Ax[j]; Ajy = Ay[j];
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ajx[i]; ay = Ajy[i];
            for(k=i+1;k<n;k++) {
                bx = Aix[k]; by = Aiy[k];
                Ajx[k] -= bx*ax-by*ay;
                Ajy[k] -= by*ax+bx*ay;
            }
            for(k=0;k<n;k++) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= bx*ax-by*ay;
                Rjy[k] -= by*ax+bx*ay;
            }
        }
    }
    for(i=n-1;i>0;i--) {
        Rix = Rx[i]; Riy = Ry[i];
        for(j=i-1;j>=0;j--) {
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ax[j][i]; ay = Ay[j][i];
            for(k=n-1;k>=0;k--) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= ax*bx - ay*by;
                Rjy[k] -= ax*by + ay*bx;
            }
        }
    }
    return new numeric.T(Rx,Ry);
}
numeric.T.prototype.get = function get(i) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length;
    if(y) {
        while(k<n) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        return new numeric.T(x,y);
    }
    while(k<n) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    return new numeric.T(x);
}
numeric.T.prototype.set = function set(i,v) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length, vx = v.x, vy = v.y;
    if(n===0) {
        if(vy) { this.y = vy; }
        else if(y) { this.y = undefined; }
        this.x = x;
        return this;
    }
    if(vy) {
        if(y) { /* ok */ }
        else {
            y = numeric.rep(numeric.dim(x),0);
            this.y = y;
        }
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        y[ik] = vy;
        return this;
    }
    if(y) {
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        if(vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx),0);
        else y[ik] = 0;
        return this;
    }
    while(k<n-1) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    ik = i[k];
    x[ik] = vx;
    return this;
}
numeric.T.prototype.getRows = function getRows(i0,i1) {
    var n = i1-i0+1, j;
    var rx = Array(n), ry, x = this.x, y = this.y;
    for(j=i0;j<=i1;j++) { rx[j-i0] = x[j]; }
    if(y) {
        ry = Array(n);
        for(j=i0;j<=i1;j++) { ry[j-i0] = y[j]; }
        return new numeric.T(rx,ry);
    }
    return new numeric.T(rx);
}
numeric.T.prototype.setRows = function setRows(i0,i1,A) {
    var j;
    var rx = this.x, ry = this.y, x = A.x, y = A.y;
    for(j=i0;j<=i1;j++) { rx[j] = x[j-i0]; }
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        for(j=i0;j<=i1;j++) { ry[j] = y[j-i0]; }
    } else if(ry) {
        for(j=i0;j<=i1;j++) { ry[j] = numeric.rep([x[j-i0].length],0); }
    }
    return this;
}
numeric.T.prototype.getRow = function getRow(k) {
    var x = this.x, y = this.y;
    if(y) { return new numeric.T(x[k],y[k]); }
    return new numeric.T(x[k]);
}
numeric.T.prototype.setRow = function setRow(i,v) {
    var rx = this.x, ry = this.y, x = v.x, y = v.y;
    rx[i] = x;
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        ry[i] = y;
    } else if(ry) {
        ry = numeric.rep([x.length],0);
    }
    return this;
}

numeric.T.prototype.getBlock = function getBlock(from,to) {
    var x = this.x, y = this.y, b = numeric.getBlock;
    if(y) { return new numeric.T(b(x,from,to),b(y,from,to)); }
    return new numeric.T(b(x,from,to));
}
numeric.T.prototype.setBlock = function setBlock(from,to,A) {
    if(!(A instanceof numeric.T)) A = new numeric.T(A);
    var x = this.x, y = this.y, b = numeric.setBlock, Ax = A.x, Ay = A.y;
    if(Ay) {
        if(!y) { this.y = numeric.rep(numeric.dim(this),0); y = this.y; }
        b(x,from,to,Ax);
        b(y,from,to,Ay);
        return this;
    }
    b(x,from,to,Ax);
    if(y) b(y,from,to,numeric.rep(numeric.dim(Ax),0));
}
numeric.T.rep = function rep(s,v) {
    var T = numeric.T;
    if(!(v instanceof T)) v = new T(v);
    var x = v.x, y = v.y, r = numeric.rep;
    if(y) return new T(r(s,x),r(s,y));
    return new T(r(s,x));
}
numeric.T.diag = function diag(d) {
    if(!(d instanceof numeric.T)) d = new numeric.T(d);
    var x = d.x, y = d.y, diag = numeric.diag;
    if(y) return new numeric.T(diag(x),diag(y));
    return new numeric.T(diag(x));
}
numeric.T.eig = function eig() {
    if(this.y) { throw new Error('eig: not implemented for complex matrices.'); }
    return numeric.eig(this.x);
}
numeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }
numeric.T.prototype.getDiag = function getDiag() {
    var n = numeric;
    var x = this.x, y = this.y;
    if(y) { return new n.T(n.getDiag(x),n.getDiag(y)); }
    return new n.T(n.getDiag(x));
}

// 4. Eigenvalues of real matrices

numeric.house = function house(x) {
    var v = numeric.clone(x);
    var s = x[0] >= 0 ? 1 : -1;
    var alpha = s*numeric.norm2(x);
    v[0] += alpha;
    var foo = numeric.norm2(v);
    if(foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }
    return numeric.div(v,foo);
}

numeric.toUpperHessenberg = function toUpperHessenberg(me) {
    var s = numeric.dim(me);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }
    var m = s[0], i,j,k,x,v,A = numeric.clone(me),B,C,Ai,Ci,Q = numeric.identity(m),Qi;
    for(j=0;j<m-2;j++) {
        x = Array(m-j-1);
        for(i=j+1;i<m;i++) { x[i-j-1] = A[i][j]; }
        if(numeric.norm2(x)>0) {
            v = numeric.house(x);
            B = numeric.getBlock(A,[j+1,j],[m-1,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Ai = A[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Ai[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(A,[0,j+1],[m-1,m-1]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Ai = A[i]; Ci = C[i]; for(k=j+1;k<m;k++) Ai[k] -= 2*Ci[k-j-1]; }
            B = Array(m-j-1);
            for(i=j+1;i<m;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    return {H:A, Q:Q};
}

numeric.epsilon = 2.220446049250313e-16;

numeric.QRFrancis = function(H,maxiter) {
    if(typeof maxiter === "undefined") { maxiter = 10000; }
    H = numeric.clone(H);
    var H0 = numeric.clone(H);
    var s = numeric.dim(H),m=s[0],x,v,a,b,c,d,det,tr, Hloc, Q = numeric.identity(m), Qi, Hi, B, C, Ci,i,j,k,iter;
    if(m<3) { return {Q:Q, B:[ [0,m-1] ]}; }
    var epsilon = numeric.epsilon;
    for(iter=0;iter<maxiter;iter++) {
        for(j=0;j<m-1;j++) {
            if(Math.abs(H[j+1][j]) < epsilon*(Math.abs(H[j][j])+Math.abs(H[j+1][j+1]))) {
                var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[j,j]),maxiter);
                var QH2 = numeric.QRFrancis(numeric.getBlock(H,[j+1,j+1],[m-1,m-1]),maxiter);
                B = Array(j+1);
                for(i=0;i<=j;i++) { B[i] = Q[i]; }
                C = numeric.dot(QH1.Q,B);
                for(i=0;i<=j;i++) { Q[i] = C[i]; }
                B = Array(m-j-1);
                for(i=j+1;i<m;i++) { B[i-j-1] = Q[i]; }
                C = numeric.dot(QH2.Q,B);
                for(i=j+1;i<m;i++) { Q[i] = C[i-j-1]; }
                return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,j+1))};
            }
        }
        a = H[m-2][m-2]; b = H[m-2][m-1];
        c = H[m-1][m-2]; d = H[m-1][m-1];
        tr = a+d;
        det = (a*d-b*c);
        Hloc = numeric.getBlock(H, [0,0], [2,2]);
        if(tr*tr>=4*det) {
            var s1,s2;
            s1 = 0.5*(tr+Math.sqrt(tr*tr-4*det));
            s2 = 0.5*(tr-Math.sqrt(tr*tr-4*det));
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,s1+s2)),
                               numeric.diag(numeric.rep([3],s1*s2)));
        } else {
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,tr)),
                               numeric.diag(numeric.rep([3],det)));
        }
        x = [Hloc[0][0],Hloc[1][0],Hloc[2][0]];
        v = numeric.house(x);
        B = [H[0],H[1],H[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<m;k++) Hi[k] -= 2*Ci[k]; }
        B = numeric.getBlock(H, [0,0],[m-1,2]);
        C = numeric.tensor(numeric.dot(B,v),v);
        for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<3;k++) Hi[k] -= 2*Ci[k]; }
        B = [Q[0],Q[1],Q[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Qi = Q[i]; Ci = C[i]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        var J;
        for(j=0;j<m-2;j++) {
            for(k=j;k<=j+1;k++) {
                if(Math.abs(H[k+1][k]) < epsilon*(Math.abs(H[k][k])+Math.abs(H[k+1][k+1]))) {
                    var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[k,k]),maxiter);
                    var QH2 = numeric.QRFrancis(numeric.getBlock(H,[k+1,k+1],[m-1,m-1]),maxiter);
                    B = Array(k+1);
                    for(i=0;i<=k;i++) { B[i] = Q[i]; }
                    C = numeric.dot(QH1.Q,B);
                    for(i=0;i<=k;i++) { Q[i] = C[i]; }
                    B = Array(m-k-1);
                    for(i=k+1;i<m;i++) { B[i-k-1] = Q[i]; }
                    C = numeric.dot(QH2.Q,B);
                    for(i=k+1;i<m;i++) { Q[i] = C[i-k-1]; }
                    return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,k+1))};
                }
            }
            J = Math.min(m-1,j+3);
            x = Array(J-j);
            for(i=j+1;i<=J;i++) { x[i-j-1] = H[i][j]; }
            v = numeric.house(x);
            B = numeric.getBlock(H, [j+1,j],[J,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Hi = H[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Hi[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(H, [0,j+1],[m-1,J]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=j+1;k<=J;k++) Hi[k] -= 2*Ci[k-j-1]; }
            B = Array(J-j);
            for(i=j+1;i<=J;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');
}

numeric.eig = function eig(A,maxiter) {
    var QH = numeric.toUpperHessenberg(A);
    var QB = numeric.QRFrancis(QH.H,maxiter);
    var T = numeric.T;
    var n = A.length,i,k,flag = false,B = QB.B,H = numeric.dot(QB.Q,numeric.dot(QH.H,numeric.transpose(QB.Q)));
    var Q = new T(numeric.dot(QB.Q,QH.Q)),Q0;
    var m = B.length,j;
    var a,b,c,d,p1,p2,disc,x,y,p,q,n1,n2;
    var sqrt = Math.sqrt;
    for(k=0;k<m;k++) {
        i = B[k][0];
        if(i === B[k][1]) {
            // nothing
        } else {
            j = i+1;
            a = H[i][i];
            b = H[i][j];
            c = H[j][i];
            d = H[j][j];
            if(b === 0 && c === 0) continue;
            p1 = -a-d;
            p2 = a*d-b*c;
            disc = p1*p1-4*p2;
            if(disc>=0) {
                if(p1<0) x = -0.5*(p1-sqrt(disc));
                else     x = -0.5*(p1+sqrt(disc));
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1);
                    p = (a-x)/n1;
                    q = b/n1;
                } else {
                    n2 = sqrt(n2);
                    p = c/n2;
                    q = (d-x)/n2;
                }
                Q0 = new T([[q,-p],[p,q]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            } else {
                x = -0.5*p1;
                y = 0.5*sqrt(-disc);
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1+y*y);
                    p = (a-x)/n1;
                    q = b/n1;
                    x = 0;
                    y /= n1;
                } else {
                    n2 = sqrt(n2+y*y);
                    p = c/n2;
                    q = (d-x)/n2;
                    x = y/n2;
                    y = 0;
                }
                Q0 = new T([[q,-p],[p,q]],[[x,y],[y,-x]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            }
        }
    }
    var R = Q.dot(A).dot(Q.transjugate()), n = A.length, E = numeric.T.identity(n);
    for(j=0;j<n;j++) {
        if(j>0) {
            for(k=j-1;k>=0;k--) {
                var Rk = R.get([k,k]), Rj = R.get([j,j]);
                if(numeric.neq(Rk.x,Rj.x) || numeric.neq(Rk.y,Rj.y)) {
                    x = R.getRow(k).getBlock([k],[j-1]);
                    y = E.getRow(j).getBlock([k],[j-1]);
                    E.set([j,k],(R.get([k,j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));
                } else {
                    E.setRow(j,E.getRow(k));
                    continue;
                }
            }
        }
    }
    for(j=0;j<n;j++) {
        x = E.getRow(j);
        E.setRow(j,x.div(x.norm2()));
    }
    E = E.transpose();
    E = Q.transjugate().dot(E);
    return { lambda:R.getDiag(), E:E };
};

// 5. Compressed Column Storage matrices
numeric.ccsSparse = function ccsSparse(A) {
    var m = A.length,n,foo, i,j, counts = [];
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            j = parseInt(j);
            while(j>=counts.length) counts[counts.length] = 0;
            if(foo[j]!==0) counts[j]++;
        }
    }
    var n = counts.length;
    var Ai = Array(n+1);
    Ai[0] = 0;
    for(i=0;i<n;++i) Ai[i+1] = Ai[i] + counts[i];
    var Aj = Array(Ai[n]), Av = Array(Ai[n]);
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            if(foo[j]!==0) {
                counts[j]--;
                Aj[Ai[j]+counts[j]] = i;
                Av[Ai[j]+counts[j]] = foo[j];
            }
        }
    }
    return [Ai,Aj,Av];
}
numeric.ccsFull = function ccsFull(A) {
    var Ai = A[0], Aj = A[1], Av = A[2], s = numeric.ccsDim(A), m = s[0], n = s[1], i,j,j0,j1,k;
    var B = numeric.rep([m,n],0);
    for(i=0;i<n;i++) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j<j1;++j) { B[Aj[j]][i] = Av[j]; }
    }
    return B;
}
numeric.ccsTSolve = function ccsTSolve(A,b,x,bj,xj) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, max = Math.max,n=0;
    if(typeof bj === "undefined") x = numeric.rep([m],0);
    if(typeof bj === "undefined") bj = numeric.linspace(0,x.length-1);
    if(typeof xj === "undefined") xj = [];
    function dfs(j) {
        var k;
        if(x[j] !== 0) return;
        x[j] = 1;
        for(k=Ai[j];k<Ai[j+1];++k) dfs(Aj[k]);
        xj[n] = j;
        ++n;
    }
    var i,j,j0,j1,k,l,l0,l1,a;
    for(i=bj.length-1;i!==-1;--i) { dfs(bj[i]); }
    xj.length = n;
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=bj.length-1;i!==-1;--i) { j = bj[i]; x[j] = b[j]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = max(Ai[j+1],j0);
        for(k=j0;k!==j1;++k) { if(Aj[k] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k!==j1;++k) {
            l = Aj[k];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsDFS = function ccsDFS(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[J];
    k1[0] = k11 = Ai[J+1];
    while(1) {
        if(km >= k11) {
            xj[n] = j[m];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Pinv[Aj[km]];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve = function ccsLPSolve(A,B,x,xj,I,Pinv,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];

    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Pinv[Bj[i]],Ai,Aj,x,xj,Pinv); }
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=i0;i!==i1;++i) { j = Pinv[Bj[i]]; x[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k<j1;++k) {
            l = Pinv[Aj[k]];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsLUP1 = function ccsLUP1(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var x = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,x,xj,i,Pinv,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(x[k]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(x[i])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
            a = x[i]; x[i] = x[e]; x[e] = a;
        }
        a = Li[i];
        e = Ui[i];
        d = x[i];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = x[k];
            xj[j] = 0;
            x[k] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsDFS0 = function ccsDFS0(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS0.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv,P) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[Pinv[J]];
    k1[0] = k11 = Ai[Pinv[J]+1];
    while(1) {
        if(isNaN(km)) throw new Error("Ow!");
        if(km >= k11) {
            xj[n] = Pinv[j[m]];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Aj[km];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                foo = Pinv[foo];
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve0 = function ccsLPSolve0(A,B,y,xj,I,Pinv,P,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];

    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Bj[i],Ai,Aj,y,xj,Pinv,P); }
    for(i=xj.length-1;i!==-1;--i) { j = xj[i]; y[P[j]] = 0; }
    for(i=i0;i!==i1;++i) { j = Bj[i]; y[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        l = P[j];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Aj[k] === l) { y[l] /= Av[k]; break; } }
        a = y[l];
        for(k=j0;k<j1;++k) y[Aj[k]] -= a*Av[k];
        y[l] = a;
    }
}
numeric.ccsLUP0 = function ccsLUP0(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var y = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve0, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS0(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,y,xj,i,Pinv,P,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(y[P[k]]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(y[P[i]])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
        }
        a = Li[i];
        e = Ui[i];
        d = y[P[i]];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = y[P[k]];
            xj[j] = 0;
            y[P[k]] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsLUP = numeric.ccsLUP0;

numeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1])+1,A[0].length-1]; }
numeric.ccsGetBlock = function ccsGetBlock(A,i,j) {
    var s = numeric.ccsDim(A),m=s[0],n=s[1];
    if(typeof i === "undefined") { i = numeric.linspace(0,m-1); }
    else if(typeof i === "number") { i = [i]; }
    if(typeof j === "undefined") { j = numeric.linspace(0,n-1); }
    else if(typeof j === "number") { j = [j]; }
    var p,p0,p1,P = i.length,q,Q = j.length,r,jq,ip;
    var Bi = numeric.rep([n],0), Bj=[], Bv=[], B = [Bi,Bj,Bv];
    var Ai = A[0], Aj = A[1], Av = A[2];
    var x = numeric.rep([m],0),count=0,flags = numeric.rep([m],0);
    for(q=0;q<Q;++q) {
        jq = j[q];
        var q0 = Ai[jq];
        var q1 = Ai[jq+1];
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 1;
            x[r] = Av[p];
        }
        for(p=0;p<P;++p) {
            ip = i[p];
            if(flags[ip]) {
                Bj[count] = p;
                Bv[count] = x[i[p]];
                ++count;
            }
        }
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 0;
        }
        Bi[q+1] = count;
    }
    return B;
}

numeric.ccsDot = function ccsDot(A,B) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var Bi = B[0], Bj = B[1], Bv = B[2];
    var sA = numeric.ccsDim(A), sB = numeric.ccsDim(B);
    var m = sA[0], n = sA[1], o = sB[1];
    var x = numeric.rep([m],0), flags = numeric.rep([m],0), xj = Array(m);
    var Ci = numeric.rep([o],0), Cj = [], Cv = [], C = [Ci,Cj,Cv];
    var i,j,k,j0,j1,i0,i1,l,p,a,b;
    for(k=0;k!==o;++k) {
        j0 = Bi[k];
        j1 = Bi[k+1];
        p = 0;
        for(j=j0;j<j1;++j) {
            a = Bj[j];
            b = Bv[j];
            i0 = Ai[a];
            i1 = Ai[a+1];
            for(i=i0;i<i1;++i) {
                l = Aj[i];
                if(flags[l]===0) {
                    xj[p] = l;
                    flags[l] = 1;
                    p = p+1;
                }
                x[l] = x[l] + Av[i]*b;
            }
        }
        j0 = Ci[k];
        j1 = j0+p;
        Ci[k+1] = j1;
        for(j=p-1;j!==-1;--j) {
            b = j0+j;
            i = xj[j];
            Cj[b] = i;
            Cv[b] = x[i];
            flags[i] = 0;
            x[i] = 0;
        }
        Ci[k+1] = Ci[k]+p;
    }
    return C;
}

numeric.ccsLUPSolve = function ccsLUPSolve(LUP,B) {
    var L = LUP.L, U = LUP.U, P = LUP.P;
    var Bi = B[0];
    var flag = false;
    if(typeof Bi !== "object") { B = [[0,B.length],numeric.linspace(0,B.length-1),B]; Bi = B[0]; flag = true; }
    var Bj = B[1], Bv = B[2];
    var n = L[0].length-1, m = Bi.length-1;
    var x = numeric.rep([n],0), xj = Array(n);
    var b = numeric.rep([n],0), bj = Array(n);
    var Xi = numeric.rep([m+1],0), Xj = [], Xv = [];
    var sol = numeric.ccsTSolve;
    var i,j,j0,j1,k,J,N=0;
    for(i=0;i<m;++i) {
        k = 0;
        j0 = Bi[i];
        j1 = Bi[i+1];
        for(j=j0;j<j1;++j) {
            J = LUP.Pinv[Bj[j]];
            bj[k] = J;
            b[J] = Bv[j];
            ++k;
        }
        bj.length = k;
        sol(L,b,x,bj,xj);
        for(j=bj.length-1;j!==-1;--j) b[bj[j]] = 0;
        sol(U,x,b,xj,bj);
        if(flag) return b;
        for(j=xj.length-1;j!==-1;--j) x[xj[j]] = 0;
        for(j=bj.length-1;j!==-1;--j) {
            J = bj[j];
            Xj[N] = J;
            Xv[N] = b[J];
            b[J] = 0;
            ++N;
        }
        Xi[i+1] = N;
    }
    return [Xi,Xj,Xv];
}

numeric.ccsbinop = function ccsbinop(body,setup) {
    if(typeof setup === "undefined") setup='';
    return numeric.compile('X','Y',
            'var Xi = X[0], Xj = X[1], Xv = X[2];\n'+
            'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\n'+
            'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\n'+
            'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\n'+
            'var x = numeric.rep([m],0),y = numeric.rep([m],0);\n'+
            'var xk,yk,zk;\n'+
            'var i,j,j0,j1,k,p=0;\n'+
            setup+
            'for(i=0;i<n;++i) {\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Xj[j];\n'+
            '    x[k] = 1;\n'+
            '    Zj[p] = k;\n'+
            '    ++p;\n'+
            '  }\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Yj[j];\n'+
            '    y[k] = Yv[j];\n'+
            '    if(x[k] === 0) {\n'+
            '      Zj[p] = k;\n'+
            '      ++p;\n'+
            '    }\n'+
            '  }\n'+
            '  Zi[i+1] = p;\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n'+
            '  j0 = Zi[i]; j1 = Zi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Zj[j];\n'+
            '    xk = x[k];\n'+
            '    yk = y[k];\n'+
            body+'\n'+
            '    Zv[j] = zk;\n'+
            '  }\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n'+
            '}\n'+
            'return [Zi,Zj,Zv];'
            );
};

(function() {
    var k,A,B,C;
    for(k in numeric.ops2) {
        if(isFinite(eval('1'+numeric.ops2[k]+'0'))) A = '[Y[0],Y[1],numeric.'+k+'(X,Y[2])]';
        else A = 'NaN';
        if(isFinite(eval('0'+numeric.ops2[k]+'1'))) B = '[X[0],X[1],numeric.'+k+'(X[2],Y)]';
        else B = 'NaN';
        if(isFinite(eval('1'+numeric.ops2[k]+'0')) && isFinite(eval('0'+numeric.ops2[k]+'1'))) C = 'numeric.ccs'+k+'MM(X,Y)';
        else C = 'NaN';
        numeric['ccs'+k+'MM'] = numeric.ccsbinop('zk = xk '+numeric.ops2[k]+'yk;');
        numeric['ccs'+k] = numeric.compile('X','Y',
                'if(typeof X === "number") return '+A+';\n'+
                'if(typeof Y === "number") return '+B+';\n'+
                'return '+C+';\n'
                );
    }
}());

numeric.ccsScatter = function ccsScatter(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = numeric.sup(Aj)+1,m=Ai.length;
    var Ri = numeric.rep([n],0),Rj=Array(m), Rv = Array(m);
    var counts = numeric.rep([n],0),i;
    for(i=0;i<m;++i) counts[Aj[i]]++;
    for(i=0;i<n;++i) Ri[i+1] = Ri[i] + counts[i];
    var ptr = Ri.slice(0),k,Aii;
    for(i=0;i<m;++i) {
        Aii = Aj[i];
        k = ptr[Aii];
        Rj[k] = Ai[i];
        Rv[k] = Av[i];
        ptr[Aii]=ptr[Aii]+1;
    }
    return [Ri,Rj,Rv];
}

numeric.ccsGather = function ccsGather(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = Ai.length-1,m = Aj.length;
    var Ri = Array(m), Rj = Array(m), Rv = Array(m);
    var i,j,j0,j1,p;
    p=0;
    for(i=0;i<n;++i) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j!==j1;++j) {
            Rj[p] = i;
            Ri[p] = Aj[j];
            Rv[p] = Av[j];
            ++p;
        }
    }
    return [Ri,Rj,Rv];
}

// The following sparse linear algebra routines are deprecated.

numeric.sdim = function dim(A,ret,k) {
    if(typeof ret === "undefined") { ret = []; }
    if(typeof A !== "object") return ret;
    if(typeof k === "undefined") { k=0; }
    if(!(k in ret)) { ret[k] = 0; }
    if(A.length > ret[k]) ret[k] = A.length;
    var i;
    for(i in A) {
        if(A.hasOwnProperty(i)) dim(A[i],ret,k+1);
    }
    return ret;
};

numeric.sclone = function clone(A,k,n) {
    if(typeof k === "undefined") { k=0; }
    if(typeof n === "undefined") { n = numeric.sdim(A).length; }
    var i,ret = Array(A.length);
    if(k === n-1) {
        for(i in A) { if(A.hasOwnProperty(i)) ret[i] = A[i]; }
        return ret;
    }
    for(i in A) {
        if(A.hasOwnProperty(i)) ret[i] = clone(A[i],k+1,n);
    }
    return ret;
}

numeric.sdiag = function diag(d) {
    var n = d.length,i,ret = Array(n),i1,i2,i3;
    for(i=n-1;i>=1;i-=2) {
        i1 = i-1;
        ret[i] = []; ret[i][i] = d[i];
        ret[i1] = []; ret[i1][i1] = d[i1];
    }
    if(i===0) { ret[0] = []; ret[0][0] = d[i]; }
    return ret;
}

numeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n],1)); }

numeric.stranspose = function transpose(A) {
    var ret = [], n = A.length, i,j,Ai;
    for(i in A) {
        if(!(A.hasOwnProperty(i))) continue;
        Ai = A[i];
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(typeof ret[j] !== "object") { ret[j] = []; }
            ret[j][i] = Ai[j];
        }
    }
    return ret;
}

numeric.sLUP = function LUP(A,tol) {
    throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
};

numeric.sdotMM = function dotMM(A,B) {
    var p = A.length, q = B.length, BT = numeric.stranspose(B), r = BT.length, Ai, BTk;
    var i,j,k,accum;
    var ret = Array(p),reti;
    for(i=p-1;i>=0;i--) {
        reti = [];
        Ai = A[i];
        for(k=r-1;k>=0;k--) {
            accum = 0;
            BTk = BT[k];
            for(j in Ai) {
                if(!(Ai.hasOwnProperty(j))) continue;
                if(j in BTk) { accum += Ai[j]*BTk[j]; }
            }
            if(accum) reti[k] = accum;
        }
        ret[i] = reti;
    }
    return ret;
}

numeric.sdotMV = function dotMV(A,x) {
    var p = A.length, Ai, i,j;
    var ret = Array(p), accum;
    for(i=p-1;i>=0;i--) {
        Ai = A[i];
        accum = 0;
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(x[j]) accum += Ai[j]*x[j];
        }
        if(accum) ret[i] = accum;
    }
    return ret;
}

numeric.sdotVM = function dotMV(x,A) {
    var i,j,Ai,alpha;
    var ret = [], accum;
    for(i in x) {
        if(!x.hasOwnProperty(i)) continue;
        Ai = A[i];
        alpha = x[i];
        for(j in Ai) {
            if(!Ai.hasOwnProperty(j)) continue;
            if(!ret[j]) { ret[j] = 0; }
            ret[j] += alpha*Ai[j];
        }
    }
    return ret;
}

numeric.sdotVV = function dotVV(x,y) {
    var i,ret=0;
    for(i in x) { if(x[i] && y[i]) ret+= x[i]*y[i]; }
    return ret;
}

numeric.sdot = function dot(A,B) {
    var m = numeric.sdim(A).length, n = numeric.sdim(B).length;
    var k = m*1000+n;
    switch(k) {
    case 0: return A*B;
    case 1001: return numeric.sdotVV(A,B);
    case 2001: return numeric.sdotMV(A,B);
    case 1002: return numeric.sdotVM(A,B);
    case 2002: return numeric.sdotMM(A,B);
    default: throw new Error('numeric.sdot not implemented for tensors of order '+m+' and '+n);
    }
}

numeric.sscatter = function scatter(V) {
    var n = V[0].length, Vij, i, j, m = V.length, A = [], Aj;
    for(i=n-1;i>=0;--i) {
        if(!V[m-1][i]) continue;
        Aj = A;
        for(j=0;j<m-2;j++) {
            Vij = V[j][i];
            if(!Aj[Vij]) Aj[Vij] = [];
            Aj = Aj[Vij];
        }
        Aj[V[j][i]] = V[j+1][i];
    }
    return A;
}

numeric.sgather = function gather(A,ret,k) {
    if(typeof ret === "undefined") ret = [];
    if(typeof k === "undefined") k = [];
    var n,i,Ai;
    n = k.length;
    for(i in A) {
        if(A.hasOwnProperty(i)) {
            k[n] = parseInt(i);
            Ai = A[i];
            if(typeof Ai === "number") {
                if(Ai) {
                    if(ret.length === 0) {
                        for(i=n+1;i>=0;--i) ret[i] = [];
                    }
                    for(i=n;i>=0;--i) ret[i].push(k[i]);
                    ret[n+1].push(Ai);
                }
            } else gather(Ai,ret,k);
        }
    }
    if(k.length>n) k.pop();
    return ret;
}

// 6. Coordinate matrices
numeric.cLU = function LU(A) {
    var I = A[0], J = A[1], V = A[2];
    var p = I.length, m=0, i,j,k,a,b,c;
    for(i=0;i<p;i++) if(I[i]>m) m=I[i];
    m++;
    var L = Array(m), U = Array(m), left = numeric.rep([m],Infinity), right = numeric.rep([m],-Infinity);
    var Ui, Uj,alpha;
    for(k=0;k<p;k++) {
        i = I[k];
        j = J[k];
        if(j<left[i]) left[i] = j;
        if(j>right[i]) right[i] = j;
    }
    for(i=0;i<m-1;i++) { if(right[i] > right[i+1]) right[i+1] = right[i]; }
    for(i=m-1;i>=1;i--) { if(left[i]<left[i-1]) left[i-1] = left[i]; }
    var countL = 0, countU = 0;
    for(i=0;i<m;i++) {
        U[i] = numeric.rep([right[i]-left[i]+1],0);
        L[i] = numeric.rep([i-left[i]],0);
        countL += i-left[i]+1;
        countU += right[i]-i+1;
    }
    for(k=0;k<p;k++) { i = I[k]; U[i][J[k]-left[i]] = V[k]; }
    for(i=0;i<m-1;i++) {
        a = i-left[i];
        Ui = U[i];
        for(j=i+1;left[j]<=i && j<m;j++) {
            b = i-left[j];
            c = right[i]-i;
            Uj = U[j];
            alpha = Uj[b]/Ui[a];
            if(alpha) {
                for(k=1;k<=c;k++) { Uj[k+b] -= alpha*Ui[k+a]; }
                L[j][i-left[j]] = alpha;
            }
        }
    }
    var Ui = [], Uj = [], Uv = [], Li = [], Lj = [], Lv = [];
    var p,q,foo;
    p=0; q=0;
    for(i=0;i<m;i++) {
        a = left[i];
        b = right[i];
        foo = U[i];
        for(j=i;j<=b;j++) {
            if(foo[j-a]) {
                Ui[p] = i;
                Uj[p] = j;
                Uv[p] = foo[j-a];
                p++;
            }
        }
        foo = L[i];
        for(j=a;j<i;j++) {
            if(foo[j-a]) {
                Li[q] = i;
                Lj[q] = j;
                Lv[q] = foo[j-a];
                q++;
            }
        }
        Li[q] = i;
        Lj[q] = i;
        Lv[q] = 1;
        q++;
    }
    return {U:[Ui,Uj,Uv], L:[Li,Lj,Lv]};
};

numeric.cLUsolve = function LUsolve(lu,b) {
    var L = lu.L, U = lu.U, ret = numeric.clone(b);
    var Li = L[0], Lj = L[1], Lv = L[2];
    var Ui = U[0], Uj = U[1], Uv = U[2];
    var p = Ui.length, q = Li.length;
    var m = ret.length,i,j,k;
    k = 0;
    for(i=0;i<m;i++) {
        while(Lj[k] < i) {
            ret[i] -= Lv[k]*ret[Lj[k]];
            k++;
        }
        k++;
    }
    k = p-1;
    for(i=m-1;i>=0;i--) {
        while(Uj[k] > i) {
            ret[i] -= Uv[k]*ret[Uj[k]];
            k--;
        }
        ret[i] /= Uv[k];
        k--;
    }
    return ret;
};

numeric.cgrid = function grid(n,shape) {
    if(typeof n === "number") n = [n,n];
    var ret = numeric.rep(n,-1);
    var i,j,count;
    if(typeof shape !== "function") {
        switch(shape) {
        case 'L':
            shape = function(i,j) { return (i>=n[0]/2 || j<n[1]/2); }
            break;
        default:
            shape = function(i,j) { return true; };
            break;
        }
    }
    count=0;
    for(i=1;i<n[0]-1;i++) for(j=1;j<n[1]-1;j++)
        if(shape(i,j)) {
            ret[i][j] = count;
            count++;
        }
    return ret;
}

numeric.cdelsq = function delsq(g) {
    var dir = [[-1,0],[0,-1],[0,1],[1,0]];
    var s = numeric.dim(g), m = s[0], n = s[1], i,j,k,p,q;
    var Li = [], Lj = [], Lv = [];
    for(i=1;i<m-1;i++) for(j=1;j<n-1;j++) {
        if(g[i][j]<0) continue;
        for(k=0;k<4;k++) {
            p = i+dir[k][0];
            q = j+dir[k][1];
            if(g[p][q]<0) continue;
            Li.push(g[i][j]);
            Lj.push(g[p][q]);
            Lv.push(-1);
        }
        Li.push(g[i][j]);
        Lj.push(g[i][j]);
        Lv.push(4);
    }
    return [Li,Lj,Lv];
}

numeric.cdotMV = function dotMV(A,x) {
    var ret, Ai = A[0], Aj = A[1], Av = A[2],k,p=Ai.length,N;
    N=0;
    for(k=0;k<p;k++) { if(Ai[k]>N) N = Ai[k]; }
    N++;
    ret = numeric.rep([N],0);
    for(k=0;k<p;k++) { ret[Ai[k]]+=Av[k]*x[Aj[k]]; }
    return ret;
}

// 7. Splines

numeric.Spline = function Spline(x,yl,yr,kl,kr) { this.x = x; this.yl = yl; this.yr = yr; this.kl = kl; this.kr = kr; }
numeric.Spline.prototype._at = function _at(x1,p) {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var x1,a,b,t;
    var add = numeric.add, sub = numeric.sub, mul = numeric.mul;
    a = sub(mul(kl[p],x[p+1]-x[p]),sub(yr[p+1],yl[p]));
    b = add(mul(kr[p+1],x[p]-x[p+1]),sub(yr[p+1],yl[p]));
    t = (x1-x[p])/(x[p+1]-x[p]);
    var s = t*(1-t);
    return add(add(add(mul(1-t,yl[p]),mul(t,yr[p+1])),mul(a,s*(1-t))),mul(b,s*t));
}
numeric.Spline.prototype.at = function at(x0) {
    if(typeof x0 === "number") {
        var x = this.x;
        var n = x.length;
        var p,q,mid,floor = Math.floor,a,b,t;
        p = 0;
        q = n-1;
        while(q-p>1) {
            mid = floor((p+q)/2);
            if(x[mid] <= x0) p = mid;
            else q = mid;
        }
        return this._at(x0,p);
    }
    var n = x0.length, i, ret = Array(n);
    for(i=n-1;i!==-1;--i) ret[i] = this.at(x0[i]);
    return ret;
}
numeric.Spline.prototype.diff = function diff() {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var n = yl.length;
    var i,dx,dy;
    var zl = kl, zr = kr, pl = Array(n), pr = Array(n);
    var add = numeric.add, mul = numeric.mul, div = numeric.div, sub = numeric.sub;
    for(i=n-1;i!==-1;--i) {
        dx = x[i+1]-x[i];
        dy = sub(yr[i+1],yl[i]);
        pl[i] = div(add(mul(dy, 6),mul(kl[i],-4*dx),mul(kr[i+1],-2*dx)),dx*dx);
        pr[i+1] = div(add(mul(dy,-6),mul(kl[i], 2*dx),mul(kr[i+1], 4*dx)),dx*dx);
    }
    return new numeric.Spline(x,zl,zr,pl,pr);
}
numeric.Spline.prototype.roots = function roots() {
    function sqr(x) { return x*x; }
    function heval(y0,y1,k0,k1,x) {
        var A = k0*2-(y1-y0);
        var B = -k1*2+(y1-y0);
        var t = (x+1)*0.5;
        var s = t*(1-t);
        return (1-t)*y0+t*y1+A*s*(1-t)+B*s*t;
    }
    var ret = [];
    var x = this.x, yl = this.yl, yr = this.yr, kl = this.kl, kr = this.kr;
    if(typeof yl[0] === "number") {
        yl = [yl];
        yr = [yr];
        kl = [kl];
        kr = [kr];
    }
    var m = yl.length,n=x.length-1,i,j,k,y,s,t;
    var ai,bi,ci,di, ret = Array(m),ri,k0,k1,y0,y1,A,B,D,dx,cx,stops,z0,z1,zm,t0,t1,tm;
    var sqrt = Math.sqrt;
    for(i=0;i!==m;++i) {
        ai = yl[i];
        bi = yr[i];
        ci = kl[i];
        di = kr[i];
        ri = [];
        for(j=0;j!==n;j++) {
            if(j>0 && bi[j]*ai[j]<0) ri.push(x[j]);
            dx = (x[j+1]-x[j]);
            cx = x[j];
            y0 = ai[j];
            y1 = bi[j+1];
            k0 = ci[j]/dx;
            k1 = di[j+1]/dx;
            D = sqr(k0-k1+3*(y0-y1)) + 12*k1*y0;
            A = k1+3*y0+2*k0-3*y1;
            B = 3*(k1+k0+2*(y0-y1));
            if(D<=0) {
                z0 = A/B;
                if(z0>x[j] && z0<x[j+1]) stops = [x[j],z0,x[j+1]];
                else stops = [x[j],x[j+1]];
            } else {
                z0 = (A-sqrt(D))/B;
                z1 = (A+sqrt(D))/B;
                stops = [x[j]];
                if(z0>x[j] && z0<x[j+1]) stops.push(z0);
                if(z1>x[j] && z1<x[j+1]) stops.push(z1);
                stops.push(x[j+1]);
            }
            t0 = stops[0];
            z0 = this._at(t0,j);
            for(k=0;k<stops.length-1;k++) {
                t1 = stops[k+1];
                z1 = this._at(t1,j);
                if(z0 === 0) {
                    ri.push(t0);
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                if(z1 === 0 || z0*z1>0) {
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                var side = 0;
                while(1) {
                    tm = (z0*t1-z1*t0)/(z0-z1);
                    if(tm <= t0 || tm >= t1) { break; }
                    zm = this._at(tm,j);
                    if(zm*z1>0) {
                        t1 = tm;
                        z1 = zm;
                        if(side === -1) z0*=0.5;
                        side = -1;
                    } else if(zm*z0>0) {
                        t0 = tm;
                        z0 = zm;
                        if(side === 1) z1*=0.5;
                        side = 1;
                    } else break;
                }
                ri.push(tm);
                t0 = stops[k+1];
                z0 = this._at(t0, j);
            }
            if(z1 === 0) ri.push(t1);
        }
        ret[i] = ri;
    }
    if(typeof this.yl[0] === "number") return ret[0];
    return ret;
}
numeric.spline = function spline(x,y,k1,kn) {
    var n = x.length, b = [], dx = [], dy = [];
    var i;
    var sub = numeric.sub,mul = numeric.mul,add = numeric.add;
    for(i=n-2;i>=0;i--) { dx[i] = x[i+1]-x[i]; dy[i] = sub(y[i+1],y[i]); }
    if(typeof k1 === "string" || typeof kn === "string") {
        k1 = kn = "periodic";
    }
    // Build sparse tridiagonal system
    var T = [[],[],[]];
    switch(typeof k1) {
    case "undefined":
        b[0] = mul(3/(dx[0]*dx[0]),dy[0]);
        T[0].push(0,0);
        T[1].push(0,1);
        T[2].push(2/dx[0],1/dx[0]);
        break;
    case "string":
        b[0] = add(mul(3/(dx[n-2]*dx[n-2]),dy[n-2]),mul(3/(dx[0]*dx[0]),dy[0]));
        T[0].push(0,0,0);
        T[1].push(n-2,0,1);
        T[2].push(1/dx[n-2],2/dx[n-2]+2/dx[0],1/dx[0]);
        break;
    default:
        b[0] = k1;
        T[0].push(0);
        T[1].push(0);
        T[2].push(1);
        break;
    }
    for(i=1;i<n-1;i++) {
        b[i] = add(mul(3/(dx[i-1]*dx[i-1]),dy[i-1]),mul(3/(dx[i]*dx[i]),dy[i]));
        T[0].push(i,i,i);
        T[1].push(i-1,i,i+1);
        T[2].push(1/dx[i-1],2/dx[i-1]+2/dx[i],1/dx[i]);
    }
    switch(typeof kn) {
    case "undefined":
        b[n-1] = mul(3/(dx[n-2]*dx[n-2]),dy[n-2]);
        T[0].push(n-1,n-1);
        T[1].push(n-2,n-1);
        T[2].push(1/dx[n-2],2/dx[n-2]);
        break;
    case "string":
        T[1][T[1].length-1] = 0;
        break;
    default:
        b[n-1] = kn;
        T[0].push(n-1);
        T[1].push(n-1);
        T[2].push(1);
        break;
    }
    if(typeof b[0] !== "number") b = numeric.transpose(b);
    else b = [b];
    var k = Array(b.length);
    if(typeof k1 === "string") {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)),b[i]);
            k[i][n-1] = k[i][0];
        }
    } else {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.cLUsolve(numeric.cLU(T),b[i]);
        }
    }
    if(typeof y[0] === "number") k = k[0];
    else k = numeric.transpose(k);
    return new numeric.Spline(x,y,y,k,k);
}

// 8. FFT
numeric.fftpow2 = function fftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    fftpow2(xe,ye);
    fftpow2(xo,yo);
    j = n/2;
    var t,k = (-6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric._ifftpow2 = function _ifftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    _ifftpow2(xe,ye);
    _ifftpow2(xo,yo);
    j = n/2;
    var t,k = (6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric.ifftpow2 = function ifftpow2(x,y) {
    numeric._ifftpow2(x,y);
    numeric.diveq(x,x.length);
    numeric.diveq(y,y.length);
}
numeric.convpow2 = function convpow2(ax,ay,bx,by) {
    numeric.fftpow2(ax,ay);
    numeric.fftpow2(bx,by);
    var i,n = ax.length,axi,bxi,ayi,byi;
    for(i=n-1;i!==-1;--i) {
        axi = ax[i]; ayi = ay[i]; bxi = bx[i]; byi = by[i];
        ax[i] = axi*bxi-ayi*byi;
        ay[i] = axi*byi+ayi*bxi;
    }
    numeric.ifftpow2(ax,ay);
}
numeric.T.prototype.fft = function fft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (-3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X;
}
numeric.T.prototype.ifft = function ifft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X.div(n);
}

//9. Unconstrained optimization
numeric.gradient = function gradient(f,x) {
    var n = x.length;
    var f0 = f(x);
    if(isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');
    var max = Math.max;
    var i,x0 = numeric.clone(x),f1,f2, J = Array(n);
    var div = numeric.div, sub = numeric.sub,errest,roundoff,max = Math.max,eps = 1e-3,abs = Math.abs, min = Math.min;
    var t0,t1,t2,it=0,d1,d2,N;
    for(i=0;i<n;i++) {
        var h = max(1e-6*f0,1e-8);
        while(1) {
            ++it;
            if(it>20) { throw new Error("Numerical gradient fails"); }
            x0[i] = x[i]+h;
            f1 = f(x0);
            x0[i] = x[i]-h;
            f2 = f(x0);
            x0[i] = x[i];
            if(isNaN(f1) || isNaN(f2)) { h/=16; continue; }
            J[i] = (f1-f2)/(2*h);
            t0 = x[i]-h;
            t1 = x[i];
            t2 = x[i]+h;
            d1 = (f1-f0)/h;
            d2 = (f0-f2)/h;
            N = max(abs(J[i]),abs(f0),abs(f1),abs(f2),abs(t0),abs(t1),abs(t2),1e-8);
            errest = min(max(abs(d1-J[i]),abs(d2-J[i]),abs(d1-d2))/N,h/N);
            if(errest>eps) { h/=16; }
            else break;
            }
    }
    return J;
}

numeric.uncmin = function uncmin(f,x0,tol,gradient,maxit,callback,options) {
    var grad = numeric.gradient;
    if(typeof options === "undefined") { options = {}; }
    if(typeof tol === "undefined") { tol = 1e-8; }
    if(typeof gradient === "undefined") { gradient = function(x) { return grad(f,x); }; }
    if(typeof maxit === "undefined") maxit = 1000;
    x0 = numeric.clone(x0);
    var n = x0.length;
    var f0 = f(x0),f1,df0;
    if(isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
    var max = Math.max, norm2 = numeric.norm2;
    tol = max(tol,numeric.epsilon);
    var step,g0,g1,H1 = options.Hinv || numeric.identity(n);
    var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;
    var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;
    var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;
    var msg = "";
    g0 = gradient(x0);
    while(it<maxit) {
        if(typeof callback === "function") { if(callback(it,x0,f0,g0,H1)) { msg = "Callback returned true"; break; } }
        if(!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
        step = neg(dot(H1,g0));
        if(!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
        nstep = norm2(step);
        if(nstep < tol) { msg="Newton step smaller than tol"; break; }
        t = 1;
        df0 = dot(g0,step);
        // line search
        x1 = x0;
        while(it < maxit) {
            if(t*nstep < tol) { break; }
            s = mul(step,t);
            x1 = add(x0,s);
            f1 = f(x1);
            if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {
                t *= 0.5;
                ++it;
                continue;
            }
            break;
        }
        if(t*nstep < tol) { msg = "Line search step size smaller than tol"; break; }
        if(it === maxit) { msg = "maxit reached during line search"; break; }
        g1 = gradient(x1);
        y = sub(g1,g0);
        ys = dot(y,s);
        Hy = dot(H1,y);
        H1 = sub(add(H1,
                mul(
                        (ys+dot(y,Hy))/(ys*ys),
                        ten(s,s)    )),
                div(add(ten(Hy,s),ten(s,Hy)),ys));
        x0 = x1;
        f0 = f1;
        g0 = g1;
        ++it;
    }
    return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};
}

// 10. Ode solver (Dormand-Prince)
numeric.Dopri = function Dopri(x,y,f,ymid,iterations,msg,events) {
    this.x = x;
    this.y = y;
    this.f = f;
    this.ymid = ymid;
    this.iterations = iterations;
    this.events = events;
    this.message = msg;
}
numeric.Dopri.prototype._at = function _at(xi,j) {
    function sqr(x) { return x*x; }
    var sol = this;
    var xs = sol.x;
    var ys = sol.y;
    var k1 = sol.f;
    var ymid = sol.ymid;
    var n = xs.length;
    var x0,x1,xh,y0,y1,yh,xi;
    var floor = Math.floor,h;
    var c = 0.5;
    var add = numeric.add, mul = numeric.mul,sub = numeric.sub, p,q,w;
    x0 = xs[j];
    x1 = xs[j+1];
    y0 = ys[j];
    y1 = ys[j+1];
    h  = x1-x0;
    xh = x0+c*h;
    yh = ymid[j];
    p = sub(k1[j  ],mul(y0,1/(x0-xh)+2/(x0-x1)));
    q = sub(k1[j+1],mul(y1,1/(x1-xh)+2/(x1-x0)));
    w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
         sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),
         sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),
         (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0-x1) / (x0 - xh),
         (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0-x1) / (x1 - xh)];
    return add(add(add(add(mul(y0,w[0]),
                           mul(yh,w[1])),
                           mul(y1,w[2])),
                           mul( p,w[3])),
                           mul( q,w[4]));
}
numeric.Dopri.prototype.at = function at(x) {
    var i,j,k,floor = Math.floor;
    if(typeof x !== "number") {
        var n = x.length, ret = Array(n);
        for(i=n-1;i!==-1;--i) {
            ret[i] = this.at(x[i]);
        }
        return ret;
    }
    var x0 = this.x;
    i = 0; j = x0.length-1;
    while(j-i>1) {
        k = floor(0.5*(i+j));
        if(x0[k] <= x) i = k;
        else j = k;
    }
    return this._at(x,i);
}

numeric.dopri = function dopri(x0,x1,y0,f,tol,maxit,event) {
    if(typeof tol === "undefined") { tol = 1e-6; }
    if(typeof maxit === "undefined") { maxit = 1000; }
    var xs = [x0], ys = [y0], k1 = [f(x0,y0)], k2,k3,k4,k5,k6,k7, ymid = [];
    var A2 = 1/5;
    var A3 = [3/40,9/40];
    var A4 = [44/45,-56/15,32/9];
    var A5 = [19372/6561,-25360/2187,64448/6561,-212/729];
    var A6 = [9017/3168,-355/33,46732/5247,49/176,-5103/18656];
    var b = [35/384,0,500/1113,125/192,-2187/6784,11/84];
    var bm = [0.5*6025192743/30085553152,
              0,
              0.5*51252292925/65400821598,
              0.5*-2691868925/45128329728,
              0.5*187940372067/1594534317056,
              0.5*-1776094331/19743644256,
              0.5*11237099/235043384];
    var c = [1/5,3/10,4/5,8/9,1,1];
    var e = [-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40];
    var i = 0,er,j;
    var h = (x1-x0)/10;
    var it = 0;
    var add = numeric.add, mul = numeric.mul, y1,erinf;
    var max = Math.max, min = Math.min, abs = Math.abs, norminf = numeric.norminf,pow = Math.pow;
    var any = numeric.any, lt = numeric.lt, and = numeric.and, sub = numeric.sub;
    var e0, e1, ev;
    var ret = new numeric.Dopri(xs,ys,k1,ymid,-1,"");
    if(typeof event === "function") e0 = event(x0,y0);
    while(x0<x1 && it<maxit) {
        ++it;
        if(x0+h>x1) h = x1-x0;
        k2 = f(x0+c[0]*h,                add(y0,mul(   A2*h,k1[i])));
        k3 = f(x0+c[1]*h,            add(add(y0,mul(A3[0]*h,k1[i])),mul(A3[1]*h,k2)));
        k4 = f(x0+c[2]*h,        add(add(add(y0,mul(A4[0]*h,k1[i])),mul(A4[1]*h,k2)),mul(A4[2]*h,k3)));
        k5 = f(x0+c[3]*h,    add(add(add(add(y0,mul(A5[0]*h,k1[i])),mul(A5[1]*h,k2)),mul(A5[2]*h,k3)),mul(A5[3]*h,k4)));
        k6 = f(x0+c[4]*h,add(add(add(add(add(y0,mul(A6[0]*h,k1[i])),mul(A6[1]*h,k2)),mul(A6[2]*h,k3)),mul(A6[3]*h,k4)),mul(A6[4]*h,k5)));
        y1 = add(add(add(add(add(y0,mul(k1[i],h*b[0])),mul(k3,h*b[2])),mul(k4,h*b[3])),mul(k5,h*b[4])),mul(k6,h*b[5]));
        k7 = f(x0+h,y1);
        er = add(add(add(add(add(mul(k1[i],h*e[0]),mul(k3,h*e[2])),mul(k4,h*e[3])),mul(k5,h*e[4])),mul(k6,h*e[5])),mul(k7,h*e[6]));
        if(typeof er === "number") erinf = abs(er);
        else erinf = norminf(er);
        if(erinf > tol) { // reject
            h = 0.2*h*pow(tol/erinf,0.25);
            if(x0+h === x0) {
                ret.msg = "Step size became too small";
                break;
            }
            continue;
        }
        ymid[i] = add(add(add(add(add(add(y0,
                mul(k1[i],h*bm[0])),
                mul(k3   ,h*bm[2])),
                mul(k4   ,h*bm[3])),
                mul(k5   ,h*bm[4])),
                mul(k6   ,h*bm[5])),
                mul(k7   ,h*bm[6]));
        ++i;
        xs[i] = x0+h;
        ys[i] = y1;
        k1[i] = k7;
        if(typeof event === "function") {
            var yi,xl = x0,xr = x0+0.5*h,xi;
            e1 = event(xr,ymid[i-1]);
            ev = and(lt(e0,0),lt(0,e1));
            if(!any(ev)) { xl = xr; xr = x0+h; e0 = e1; e1 = event(xr,y1); ev = and(lt(e0,0),lt(0,e1)); }
            if(any(ev)) {
                var xc, yc, en,ei;
                var side=0, sl = 1.0, sr = 1.0;
                while(1) {
                    if(typeof e0 === "number") xi = (sr*e1*xl-sl*e0*xr)/(sr*e1-sl*e0);
                    else {
                        xi = xr;
                        for(j=e0.length-1;j!==-1;--j) {
                            if(e0[j]<0 && e1[j]>0) xi = min(xi,(sr*e1[j]*xl-sl*e0[j]*xr)/(sr*e1[j]-sl*e0[j]));
                        }
                    }
                    if(xi <= xl || xi >= xr) break;
                    yi = ret._at(xi, i-1);
                    ei = event(xi,yi);
                    en = and(lt(e0,0),lt(0,ei));
                    if(any(en)) {
                        xr = xi;
                        e1 = ei;
                        ev = en;
                        sr = 1.0;
                        if(side === -1) sl *= 0.5;
                        else sl = 1.0;
                        side = -1;
                    } else {
                        xl = xi;
                        e0 = ei;
                        sl = 1.0;
                        if(side === 1) sr *= 0.5;
                        else sr = 1.0;
                        side = 1;
                    }
                }
                y1 = ret._at(0.5*(x0+xi),i-1);
                ret.f[i] = f(xi,yi);
                ret.x[i] = xi;
                ret.y[i] = yi;
                ret.ymid[i-1] = y1;
                ret.events = ev;
                ret.iterations = it;
                return ret;
            }
        }
        x0 += h;
        y0 = y1;
        e0 = e1;
        h = min(0.8*h*pow(tol/erinf,0.25),4*h);
    }
    ret.iterations = it;
    return ret;
}

// 11. Ax = b
numeric.LU = function(A, fast) {
  fast = fast || false;

  var abs = Math.abs;
  var i, j, k, absAjk, Akk, Ak, Pk, Ai;
  var max;
  var n = A.length, n1 = n-1;
  var P = new Array(n);
  if(!fast) A = numeric.clone(A);

  for (k = 0; k < n; ++k) {
    Pk = k;
    Ak = A[k];
    max = abs(Ak[k]);
    for (j = k + 1; j < n; ++j) {
      absAjk = abs(A[j][k]);
      if (max < absAjk) {
        max = absAjk;
        Pk = j;
      }
    }
    P[k] = Pk;

    if (Pk != k) {
      A[k] = A[Pk];
      A[Pk] = Ak;
      Ak = A[k];
    }

    Akk = Ak[k];

    for (i = k + 1; i < n; ++i) {
      A[i][k] /= Akk;
    }

    for (i = k + 1; i < n; ++i) {
      Ai = A[i];
      for (j = k + 1; j < n1; ++j) {
        Ai[j] -= Ai[k] * Ak[j];
        ++j;
        Ai[j] -= Ai[k] * Ak[j];
      }
      if(j===n1) Ai[j] -= Ai[k] * Ak[j];
    }
  }

  return {
    LU: A,
    P:  P
  };
}

numeric.LUsolve = function LUsolve(LUP, b) {
  var i, j;
  var LU = LUP.LU;
  var n   = LU.length;
  var x = numeric.clone(b);
  var P   = LUP.P;
  var Pi, LUi, LUii, tmp;

  for (i=n-1;i!==-1;--i) x[i] = b[i];
  for (i = 0; i < n; ++i) {
    Pi = P[i];
    if (P[i] !== i) {
      tmp = x[i];
      x[i] = x[Pi];
      x[Pi] = tmp;
    }

    LUi = LU[i];
    for (j = 0; j < i; ++j) {
      x[i] -= x[j] * LUi[j];
    }
  }

  for (i = n - 1; i >= 0; --i) {
    LUi = LU[i];
    for (j = i + 1; j < n; ++j) {
      x[i] -= x[j] * LUi[j];
    }

    x[i] /= LUi[i];
  }

  return x;
}

numeric.solve = function solve(A,b,fast) { return numeric.LUsolve(numeric.LU(A,fast), b); }

// 12. Linear programming
numeric.echelonize = function echelonize(A) {
    var s = numeric.dim(A), m = s[0], n = s[1];
    var I = numeric.identity(m);
    var P = Array(m);
    var i,j,k,l,Ai,Ii,Z,a;
    var abs = Math.abs;
    var diveq = numeric.diveq;
    A = numeric.clone(A);
    for(i=0;i<m;++i) {
        k = 0;
        Ai = A[i];
        Ii = I[i];
        for(j=1;j<n;++j) if(abs(Ai[k])<abs(Ai[j])) k=j;
        P[i] = k;
        diveq(Ii,Ai[k]);
        diveq(Ai,Ai[k]);
        for(j=0;j<m;++j) if(j!==i) {
            Z = A[j]; a = Z[k];
            for(l=n-1;l!==-1;--l) Z[l] -= Ai[l]*a;
            Z = I[j];
            for(l=m-1;l!==-1;--l) Z[l] -= Ii[l]*a;
        }
    }
    return {I:I, A:A, P:P};
}

numeric.__solveLP = function __solveLP(c,A,b,tol,maxit,x,flag) {
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var m = c.length, n = b.length,y;
    var unbounded = false, cb,i0=0;
    var alpha = 1.0;
    var f0,df0,AT = numeric.transpose(A), svd = numeric.svd,transpose = numeric.transpose,leq = numeric.leq, sqrt = Math.sqrt, abs = Math.abs;
    var muleq = numeric.muleq;
    var norm = numeric.norminf, any = numeric.any,min = Math.min;
    var all = numeric.all, gt = numeric.gt;
    var p = Array(m), A0 = Array(n),e=numeric.rep([n],1), H;
    var solve = numeric.solve, z = sub(b,dot(A,x)),count;
    var dotcc = dot(c,c);
    var g;
    for(count=i0;count<maxit;++count) {
        var i,j,d;
        for(i=n-1;i!==-1;--i) A0[i] = div(A[i],z[i]);
        var A1 = transpose(A0);
        for(i=m-1;i!==-1;--i) p[i] = (/*x[i]+*/sum(A1[i]));
        alpha = 0.25*abs(dotcc/dot(c,p));
        var a1 = 100*sqrt(dotcc/dot(p,p));
        if(!isFinite(alpha) || alpha>a1) alpha = a1;
        g = add(c,mul(alpha,p));
        H = dot(A1,A0);
        for(i=m-1;i!==-1;--i) H[i][i] += 1;
        d = solve(H,div(g,alpha),true);
        var t0 = div(z,dot(A,d));
        var t = 1.0;
        for(i=n-1;i!==-1;--i) if(t0[i]<0) t = min(t,-0.999*t0[i]);
        y = sub(x,mul(d,t));
        z = sub(b,dot(A,y));
        if(!all(gt(z,0))) return { solution: x, message: "", iterations: count };
        x = y;
        if(alpha<tol) return { solution: y, message: "", iterations: count };
        if(flag) {
            var s = dot(c,g), Ag = dot(A,g);
            unbounded = true;
            for(i=n-1;i!==-1;--i) if(s*Ag[i]<0) { unbounded = false; break; }
        } else {
            if(x[m-1]>=0) unbounded = false;
            else unbounded = true;
        }
        if(unbounded) return { solution: y, message: "Unbounded", iterations: count };
    }
    return { solution: x, message: "maximum iteration count exceeded", iterations:count };
}

numeric._solveLP = function _solveLP(c,A,b,tol,maxit) {
    var m = c.length, n = b.length,y;
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var c0 = numeric.rep([m],0).concat([1]);
    var J = numeric.rep([n,1],-1);
    var A0 = numeric.blockMatrix([[A                   ,   J  ]]);
    var b0 = b;
    var y = numeric.rep([m],0).concat(Math.max(0,numeric.sup(numeric.neg(b)))+1);
    var x0 = numeric.__solveLP(c0,A0,b0,tol,maxit,y,false);
    var x = numeric.clone(x0.solution);
    x.length = m;
    var foo = numeric.inf(sub(b,dot(A,x)));
    if(foo<0) { return { solution: NaN, message: "Infeasible", iterations: x0.iterations }; }
    var ret = numeric.__solveLP(c, A, b, tol, maxit-x0.iterations, x, true);
    ret.iterations += x0.iterations;
    return ret;
};

numeric.solveLP = function solveLP(c,A,b,Aeq,beq,tol,maxit) {
    if(typeof maxit === "undefined") maxit = 1000;
    if(typeof tol === "undefined") tol = numeric.epsilon;
    if(typeof Aeq === "undefined") return numeric._solveLP(c,A,b,tol,maxit);
    var m = Aeq.length, n = Aeq[0].length, o = A.length;
    var B = numeric.echelonize(Aeq);
    var flags = numeric.rep([n],0);
    var P = B.P;
    var Q = [];
    var i;
    for(i=P.length-1;i!==-1;--i) flags[P[i]] = 1;
    for(i=n-1;i!==-1;--i) if(flags[i]===0) Q.push(i);
    var g = numeric.getRange;
    var I = numeric.linspace(0,m-1), J = numeric.linspace(0,o-1);
    var Aeq2 = g(Aeq,I,Q), A1 = g(A,J,P), A2 = g(A,J,Q), dot = numeric.dot, sub = numeric.sub;
    var A3 = dot(A1,B.I);
    var A4 = sub(A2,dot(A3,Aeq2)), b4 = sub(b,dot(A3,beq));
    var c1 = Array(P.length), c2 = Array(Q.length);
    for(i=P.length-1;i!==-1;--i) c1[i] = c[P[i]];
    for(i=Q.length-1;i!==-1;--i) c2[i] = c[Q[i]];
    var c4 = sub(c2,dot(c1,dot(B.I,Aeq2)));
    var S = numeric._solveLP(c4,A4,b4,tol,maxit);
    var x2 = S.solution;
    if(x2!==x2) return S;
    var x1 = dot(B.I,sub(beq,dot(Aeq2,x2)));
    var x = Array(c.length);
    for(i=P.length-1;i!==-1;--i) x[P[i]] = x1[i];
    for(i=Q.length-1;i!==-1;--i) x[Q[i]] = x2[i];
    return { solution: x, message:S.message, iterations: S.iterations };
}

numeric.MPStoLP = function MPStoLP(MPS) {
    if(MPS instanceof String) { MPS.split('\n'); }
    var state = 0;
    var states = ['Initial state','NAME','ROWS','COLUMNS','RHS','BOUNDS','ENDATA'];
    var n = MPS.length;
    var i,j,z,N=0,rows = {}, sign = [], rl = 0, vars = {}, nv = 0;
    var name;
    var c = [], A = [], b = [];
    function err(e) { throw new Error('MPStoLP: '+e+'\nLine '+i+': '+MPS[i]+'\nCurrent state: '+states[state]+'\n'); }
    for(i=0;i<n;++i) {
        z = MPS[i];
        var w0 = z.match(/\S*/g);
        var w = [];
        for(j=0;j<w0.length;++j) if(w0[j]!=="") w.push(w0[j]);
        if(w.length === 0) continue;
        for(j=0;j<states.length;++j) if(z.substr(0,states[j].length) === states[j]) break;
        if(j<states.length) {
            state = j;
            if(j===1) { name = w[1]; }
            if(j===6) return { name:name, c:c, A:numeric.transpose(A), b:b, rows:rows, vars:vars };
            continue;
        }
        switch(state) {
        case 0: case 1: err('Unexpected line');
        case 2:
            switch(w[0]) {
            case 'N': if(N===0) N = w[1]; else err('Two or more N rows'); break;
            case 'L': rows[w[1]] = rl; sign[rl] = 1; b[rl] = 0; ++rl; break;
            case 'G': rows[w[1]] = rl; sign[rl] = -1;b[rl] = 0; ++rl; break;
            case 'E': rows[w[1]] = rl; sign[rl] = 0;b[rl] = 0; ++rl; break;
            default: err('Parse error '+numeric.prettyPrint(w));
            }
            break;
        case 3:
            if(!vars.hasOwnProperty(w[0])) { vars[w[0]] = nv; c[nv] = 0; A[nv] = numeric.rep([rl],0); ++nv; }
            var p = vars[w[0]];
            for(j=1;j<w.length;j+=2) {
                if(w[j] === N) { c[p] = parseFloat(w[j+1]); continue; }
                var q = rows[w[j]];
                A[p][q] = (sign[q]<0?-1:1)*parseFloat(w[j+1]);
            }
            break;
        case 4:
            for(j=1;j<w.length;j+=2) b[rows[w[j]]] = (sign[rows[w[j]]]<0?-1:1)*parseFloat(w[j+1]);
            break;
        case 5: /*FIXME*/ break;
        case 6: err('Internal error');
        }
    }
    err('Reached end of file without ENDATA');
}
// seedrandom.js version 2.0.
// Author: David Bau 4/2/2011
//
// Defines a method Math.seedrandom() that, when called, substitutes
// an explicitly seeded RC4-based algorithm for Math.random().  Also
// supports automatic seeding from local or network sources of entropy.
//
// Usage:
//
//   <script src=http://davidbau.com/encode/seedrandom-min.js></script>
//
//   Math.seedrandom('yipee'); Sets Math.random to a function that is
//                             initialized using the given explicit seed.
//
//   Math.seedrandom();        Sets Math.random to a function that is
//                             seeded using the current time, dom state,
//                             and other accumulated local entropy.
//                             The generated seed string is returned.
//
//   Math.seedrandom('yowza', true);
//                             Seeds using the given explicit seed mixed
//                             together with accumulated entropy.
//
//   <script src="http://bit.ly/srandom-512"></script>
//                             Seeds using physical random bits downloaded
//                             from random.org.
//
//   <script src="https://jsonlib.appspot.com/urandom?callback=Math.seedrandom">
//   </script>                 Seeds using urandom bits from call.jsonlib.com,
//                             which is faster than random.org.
//
// Examples:
//
//   Math.seedrandom("hello");            // Use "hello" as the seed.
//   document.write(Math.random());       // Always 0.5463663768140734
//   document.write(Math.random());       // Always 0.43973793770592234
//   var rng1 = Math.random;              // Remember the current prng.
//
//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.
//   document.write(Math.random());       // Pretty much unpredictable.
//
//   Math.random = rng1;                  // Continue "hello" prng sequence.
//   document.write(Math.random());       // Always 0.554769432473455
//
//   Math.seedrandom(autoseed);           // Restart at the previous seed.
//   document.write(Math.random());       // Repeat the 'unpredictable' value.
//
// Notes:
//
// Each time seedrandom('arg') is called, entropy from the passed seed
// is accumulated in a pool to help generate future seeds for the
// zero-argument form of Math.seedrandom, so entropy can be injected over
// time by calling seedrandom with explicit data repeatedly.
//
// On speed - This javascript implementation of Math.random() is about
// 3-10x slower than the built-in Math.random() because it is not native
// code, but this is typically fast enough anyway.  Seeding is more expensive,
// especially if you use auto-seeding.  Some details (timings on Chrome 4):
//
// Our Math.random()            - avg less than 0.002 milliseconds per call
// seedrandom('explicit')       - avg less than 0.5 milliseconds per call
// seedrandom('explicit', true) - avg less than 2 milliseconds per call
// seedrandom()                 - avg about 38 milliseconds per call
//
// LICENSE (BSD):
//
// Copyright 2010 David Bau, all rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
//   3. Neither the name of this module nor the names of its contributors may
//      be used to endorse or promote products derived from this software
//      without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
/**
 * All code is in an anonymous closure to keep the global namespace clean.
 *
 * @param {number=} overflow
 * @param {number=} startdenom
 */

// Patched by Seb so that seedrandom.js does not pollute the Math object.
// My tests suggest that doing Math.trouble = 1 makes Math lookups about 5%
// slower.
numeric.seedrandom = { pow:Math.pow, random:Math.random };

(function (pool, math, width, chunks, significance, overflow, startdenom) {


//
// seedrandom()
// This is the seedrandom function described above.
//
math['seedrandom'] = function seedrandom(seed, use_entropy) {
  var key = [];
  var arc4;

  // Flatten the seed string or build one from local entropy if needed.
  seed = mixkey(flatten(
    use_entropy ? [seed, pool] :
    arguments.length ? seed :
    [new Date().getTime(), pool, window], 3), key);

  // Use the seed to initialize an ARC4 generator.
  arc4 = new ARC4(key);

  // Mix the randomness into accumulated entropy.
  mixkey(arc4.S, pool);

  // Override Math.random

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.

  math['random'] = function random() {  // Closure to return a random double:
    var n = arc4.g(chunks);             // Start with a numerator n < 2 ^ 48
    var d = startdenom;                 //   and denominator d = 2 ^ 48.
    var x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  // Return the seed that was used
  return seed;
};

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
/** @constructor */
function ARC4(key) {
  var t, u, me = this, keylen = key.length;
  var i = 0, j = me.i = me.j = me.m = 0;
  me.S = [];
  me.c = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) { me.S[i] = i++; }
  for (i = 0; i < width; i++) {
    t = me.S[i];
    j = lowbits(j + t + key[i % keylen]);
    u = me.S[j];
    me.S[i] = u;
    me.S[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  me.g = function getnext(count) {
    var s = me.S;
    var i = lowbits(me.i + 1); var t = s[i];
    var j = lowbits(me.j + t); var u = s[j];
    s[i] = u;
    s[j] = t;
    var r = s[lowbits(t + u)];
    while (--count) {
      i = lowbits(i + 1); t = s[i];
      j = lowbits(j + t); u = s[j];
      s[i] = u;
      s[j] = t;
      r = r * width + s[lowbits(t + u)];
    }
    me.i = i;
    me.j = j;
    return r;
  };
  // For robust unpredictability discard an initial batch of values.
  // See http://www.rsa.com/rsalabs/node.asp?id=2009
  me.g(width);
}

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
/** @param {Object=} result
  * @param {string=} prop
  * @param {string=} typ */
function flatten(obj, depth, result, prop, typ) {
  result = [];
  typ = typeof(obj);
  if (depth && typ == 'object') {
    for (prop in obj) {
      if (prop.indexOf('S') < 5) {    // Avoid FF3 bug (local/sessionStorage)
        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
      }
    }
  }
  return (result.length ? result : obj + (typ != 'string' ? '\0' : ''));
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
/** @param {number=} smear
  * @param {number=} j */
function mixkey(seed, key, smear, j) {
  seed += '';                         // Ensure the seed is a string
  smear = 0;
  for (j = 0; j < seed.length; j++) {
    key[lowbits(j)] =
      lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));
  }
  seed = '';
  for (j in key) { seed += String.fromCharCode(key[j]); }
  return seed;
}

//
// lowbits()
// A quick "n mod width" for width a power of 2.
//
function lowbits(n) { return n & (width - 1); }

//
// The following constants are related to IEEE 754 limits.
//
startdenom = math.pow(width, chunks);
significance = math.pow(2, significance);
overflow = significance * 2;

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to intefere with determinstic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

// End anonymous scope, and pass initial values.
}(
  [],   // pool: entropy pool starts empty
  numeric.seedrandom, // math: package containing random, pow, and seedrandom
  256,  // width: each RC4 output is 0 <= x < 256
  6,    // chunks: at least six RC4 outputs for each double
  52    // significance: there are 52 significant digits in a double
  ));
/* This file is a slightly modified version of quadprog.js from Alberto Santini.
 * It has been slightly modified by Sbastien Loisel to make sure that it handles
 * 0-based Arrays instead of 1-based Arrays.
 * License is in resources/LICENSE.quadprog */
(function(exports) {

function base0to1(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=0;i<n;i++) ret[i+1] = base0to1(A[i]);
    return ret;
}
function base1to0(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=1;i<n;i++) ret[i-1] = base1to0(A[i]);
    return ret;
}

function dpori(a, lda, n) {
    var i, j, k, kp1, t;

    for (k = 1; k <= n; k = k + 1) {
        a[k][k] = 1 / a[k][k];
        t = -a[k][k];
        //~ dscal(k - 1, t, a[1][k], 1);
        for (i = 1; i < k; i = i + 1) {
            a[i][k] = t * a[i][k];
        }

        kp1 = k + 1;
        if (n < kp1) {
            break;
        }
        for (j = kp1; j <= n; j = j + 1) {
            t = a[k][j];
            a[k][j] = 0;
            //~ daxpy(k, t, a[1][k], 1, a[1][j], 1);
            for (i = 1; i <= k; i = i + 1) {
                a[i][j] = a[i][j] + (t * a[i][k]);
            }
        }
    }

}

function dposl(a, lda, n, b) {
    var i, k, kb, t;

    for (k = 1; k <= n; k = k + 1) {
        //~ t = ddot(k - 1, a[1][k], 1, b[1], 1);
        t = 0;
        for (i = 1; i < k; i = i + 1) {
            t = t + (a[i][k] * b[i]);
        }

        b[k] = (b[k] - t) / a[k][k];
    }

    for (kb = 1; kb <= n; kb = kb + 1) {
        k = n + 1 - kb;
        b[k] = b[k] / a[k][k];
        t = -b[k];
        //~ daxpy(k - 1, t, a[1][k], 1, b[1], 1);
        for (i = 1; i < k; i = i + 1) {
            b[i] = b[i] + (t * a[i][k]);
        }
    }
}

function dpofa(a, lda, n, info) {
    var i, j, jm1, k, t, s;

    for (j = 1; j <= n; j = j + 1) {
        info[1] = j;
        s = 0;
        jm1 = j - 1;
        if (jm1 < 1) {
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        } else {
            for (k = 1; k <= jm1; k = k + 1) {
                //~ t = a[k][j] - ddot(k - 1, a[1][k], 1, a[1][j], 1);
                t = a[k][j];
                for (i = 1; i < k; i = i + 1) {
                    t = t - (a[i][j] * a[i][k]);
                }
                t = t / a[k][k];
                a[k][j] = t;
                s = s + t * t;
            }
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        }
        info[1] = 0;
    }
}

function qpgen2(dmat, dvec, fddmat, n, sol, crval, amat,
    bvec, fdamat, q, meq, iact, nact, iter, work, ierr) {

    var i, j, l, l1, info, it1, iwzv, iwrv, iwrm, iwsv, iwuv, nvl, r, iwnbv,
        temp, sum, t1, tt, gc, gs, nu,
        t1inf, t2min,
        vsmall, tmpa, tmpb,
        go;

    r = Math.min(n, q);
    l = 2 * n + (r * (r + 5)) / 2 + 2 * q + 1;

    vsmall = 1.0e-60;
    do {
        vsmall = vsmall + vsmall;
        tmpa = 1 + 0.1 * vsmall;
        tmpb = 1 + 0.2 * vsmall;
    } while (tmpa <= 1 || tmpb <= 1);

    for (i = 1; i <= n; i = i + 1) {
        work[i] = dvec[i];
    }
    for (i = n + 1; i <= l; i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }

    info = [];

    if (ierr[1] === 0) {
        dpofa(dmat, fddmat, n, info);
        if (info[1] !== 0) {
            ierr[1] = 2;
            return;
        }
        dposl(dmat, fddmat, n, dvec);
        dpori(dmat, fddmat, n);
    } else {
        for (j = 1; j <= n; j = j + 1) {
            sol[j] = 0;
            for (i = 1; i <= j; i = i + 1) {
                sol[j] = sol[j] + dmat[i][j] * dvec[i];
            }
        }
        for (j = 1; j <= n; j = j + 1) {
            dvec[j] = 0;
            for (i = j; i <= n; i = i + 1) {
                dvec[j] = dvec[j] + dmat[j][i] * sol[i];
            }
        }
    }

    crval[1] = 0;
    for (j = 1; j <= n; j = j + 1) {
        sol[j] = dvec[j];
        crval[1] = crval[1] + work[j] * sol[j];
        work[j] = 0;
        for (i = j + 1; i <= n; i = i + 1) {
            dmat[i][j] = 0;
        }
    }
    crval[1] = -crval[1] / 2;
    ierr[1] = 0;

    iwzv = n;
    iwrv = iwzv + n;
    iwuv = iwrv + r;
    iwrm = iwuv + r + 1;
    iwsv = iwrm + (r * (r + 1)) / 2;
    iwnbv = iwsv + q;

    for (i = 1; i <= q; i = i + 1) {
        sum = 0;
        for (j = 1; j <= n; j = j + 1) {
            sum = sum + amat[j][i] * amat[j][i];
        }
        work[iwnbv + i] = Math.sqrt(sum);
    }
    nact = 0;
    iter[1] = 0;
    iter[2] = 0;

    function fn_goto_50() {
        iter[1] = iter[1] + 1;

        l = iwsv;
        for (i = 1; i <= q; i = i + 1) {
            l = l + 1;
            sum = -bvec[i];
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + amat[j][i] * sol[j];
            }
            if (Math.abs(sum) < vsmall) {
                sum = 0;
            }
            if (i > meq) {
                work[l] = sum;
            } else {
                work[l] = -Math.abs(sum);
                if (sum > 0) {
                    for (j = 1; j <= n; j = j + 1) {
                        amat[j][i] = -amat[j][i];
                    }
                    bvec[i] = -bvec[i];
                }
            }
        }

        for (i = 1; i <= nact; i = i + 1) {
            work[iwsv + iact[i]] = 0;
        }

        nvl = 0;
        temp = 0;
        for (i = 1; i <= q; i = i + 1) {
            if (work[iwsv + i] < temp * work[iwnbv + i]) {
                nvl = i;
                temp = work[iwsv + i] / work[iwnbv + i];
            }
        }
        if (nvl === 0) {
            return 999;
        }

        return 0;
    }

    function fn_goto_55() {
        for (i = 1; i <= n; i = i + 1) {
            sum = 0;
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + dmat[j][i] * amat[j][nvl];
            }
            work[i] = sum;
        }

        l1 = iwzv;
        for (i = 1; i <= n; i = i + 1) {
            work[l1 + i] = 0;
        }
        for (j = nact + 1; j <= n; j = j + 1) {
            for (i = 1; i <= n; i = i + 1) {
                work[l1 + i] = work[l1 + i] + dmat[i][j] * work[j];
            }
        }

        t1inf = true;
        for (i = nact; i >= 1; i = i - 1) {
            sum = work[i];
            l = iwrm + (i * (i + 3)) / 2;
            l1 = l - i;
            for (j = i + 1; j <= nact; j = j + 1) {
                sum = sum - work[l] * work[iwrv + j];
                l = l + j;
            }
            sum = sum / work[l1];
            work[iwrv + i] = sum;
            if (iact[i] < meq) {
                // continue;
                break;
            }
            if (sum < 0) {
                // continue;
                break;
            }
            t1inf = false;
            it1 = i;
        }

        if (!t1inf) {
            t1 = work[iwuv + it1] / work[iwrv + it1];
            for (i = 1; i <= nact; i = i + 1) {
                if (iact[i] < meq) {
                    // continue;
                    break;
                }
                if (work[iwrv + i] < 0) {
                    // continue;
                    break;
                }
                temp = work[iwuv + i] / work[iwrv + i];
                if (temp < t1) {
                    t1 = temp;
                    it1 = i;
                }
            }
        }

        sum = 0;
        for (i = iwzv + 1; i <= iwzv + n; i = i + 1) {
            sum = sum + work[i] * work[i];
        }
        if (Math.abs(sum) <= vsmall) {
            if (t1inf) {
                ierr[1] = 1;
                // GOTO 999
                return 999;
            } else {
                for (i = 1; i <= nact; i = i + 1) {
                    work[iwuv + i] = work[iwuv + i] - t1 * work[iwrv + i];
                }
                work[iwuv + nact + 1] = work[iwuv + nact + 1] + t1;
                // GOTO 700
                return 700;
            }
        } else {
            sum = 0;
            for (i = 1; i <= n; i = i + 1) {
                sum = sum + work[iwzv + i] * amat[i][nvl];
            }
            tt = -work[iwsv + nvl] / sum;
            t2min = true;
            if (!t1inf) {
                if (t1 < tt) {
                    tt = t1;
                    t2min = false;
                }
            }

            for (i = 1; i <= n; i = i + 1) {
                sol[i] = sol[i] + tt * work[iwzv + i];
                if (Math.abs(sol[i]) < vsmall) {
                    sol[i] = 0;
                }
            }

            crval[1] = crval[1] + tt * sum * (tt / 2 + work[iwuv + nact + 1]);
            for (i = 1; i <= nact; i = i + 1) {
                work[iwuv + i] = work[iwuv + i] - tt * work[iwrv + i];
            }
            work[iwuv + nact + 1] = work[iwuv + nact + 1] + tt;

            if (t2min) {
                nact = nact + 1;
                iact[nact] = nvl;

                l = iwrm + ((nact - 1) * nact) / 2 + 1;
                for (i = 1; i <= nact - 1; i = i + 1) {
                    work[l] = work[i];
                    l = l + 1;
                }

                if (nact === n) {
                    work[l] = work[n];
                } else {
                    for (i = n; i >= nact + 1; i = i - 1) {
                        if (work[i] === 0) {
                            // continue;
                            break;
                        }
                        gc = Math.max(Math.abs(work[i - 1]), Math.abs(work[i]));
                        gs = Math.min(Math.abs(work[i - 1]), Math.abs(work[i]));
                        if (work[i - 1] >= 0) {
                            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        } else {
                            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        }
                        gc = work[i - 1] / temp;
                        gs = work[i] / temp;

                        if (gc === 1) {
                            // continue;
                            break;
                        }
                        if (gc === 0) {
                            work[i - 1] = gs * temp;
                            for (j = 1; j <= n; j = j + 1) {
                                temp = dmat[j][i - 1];
                                dmat[j][i - 1] = dmat[j][i];
                                dmat[j][i] = temp;
                            }
                        } else {
                            work[i - 1] = temp;
                            nu = gs / (1 + gc);
                            for (j = 1; j <= n; j = j + 1) {
                                temp = gc * dmat[j][i - 1] + gs * dmat[j][i];
                                dmat[j][i] = nu * (dmat[j][i - 1] + temp) - dmat[j][i];
                                dmat[j][i - 1] = temp;

                            }
                        }
                    }
                    work[l] = work[nact];
                }
            } else {
                sum = -bvec[nvl];
                for (j = 1; j <= n; j = j + 1) {
                    sum = sum + sol[j] * amat[j][nvl];
                }
                if (nvl > meq) {
                    work[iwsv + nvl] = sum;
                } else {
                    work[iwsv + nvl] = -Math.abs(sum);
                    if (sum > 0) {
                        for (j = 1; j <= n; j = j + 1) {
                            amat[j][nvl] = -amat[j][nvl];
                        }
                        bvec[nvl] = -bvec[nvl];
                    }
                }
                // GOTO 700
                return 700;
            }
        }

        return 0;
    }

    function fn_goto_797() {
        l = iwrm + (it1 * (it1 + 1)) / 2 + 1;
        l1 = l + it1;
        if (work[l1] === 0) {
            // GOTO 798
            return 798;
        }
        gc = Math.max(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        gs = Math.min(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        if (work[l1 - 1] >= 0) {
            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        } else {
            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        }
        gc = work[l1 - 1] / temp;
        gs = work[l1] / temp;

        if (gc === 1) {
            // GOTO 798
            return 798;
        }
        if (gc === 0) {
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = work[l1 - 1];
                work[l1 - 1] = work[l1];
                work[l1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = dmat[i][it1];
                dmat[i][it1] = dmat[i][it1 + 1];
                dmat[i][it1 + 1] = temp;
            }
        } else {
            nu = gs / (1 + gc);
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = gc * work[l1 - 1] + gs * work[l1];
                work[l1] = nu * (work[l1 - 1] + temp) - work[l1];
                work[l1 - 1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = gc * dmat[i][it1] + gs * dmat[i][it1 + 1];
                dmat[i][it1 + 1] = nu * (dmat[i][it1] + temp) - dmat[i][it1 + 1];
                dmat[i][it1] = temp;
            }
        }

        return 0;
    }

    function fn_goto_798() {
        l1 = l - it1;
        for (i = 1; i <= it1; i = i + 1) {
            work[l1] = work[l];
            l = l + 1;
            l1 = l1 + 1;
        }

        work[iwuv + it1] = work[iwuv + it1 + 1];
        iact[it1] = iact[it1 + 1];
        it1 = it1 + 1;
        if (it1 < nact) {
            // GOTO 797
            return 797;
        }

        return 0;
    }

    function fn_goto_799() {
        work[iwuv + nact] = work[iwuv + nact + 1];
        work[iwuv + nact + 1] = 0;
        iact[nact] = 0;
        nact = nact - 1;
        iter[2] = iter[2] + 1;

        return 0;
    }

    go = 0;
    while (true) {
        go = fn_goto_50();
        if (go === 999) {
            return;
        }
        while (true) {
            go = fn_goto_55();
            if (go === 0) {
                break;
            }
            if (go === 999) {
                return;
            }
            if (go === 700) {
                if (it1 === nact) {
                    fn_goto_799();
                } else {
                    while (true) {
                        fn_goto_797();
                        go = fn_goto_798();
                        if (go !== 797) {
                            break;
                        }
                    }
                    fn_goto_799();
                }
            }
        }
    }

}

function solveQP(Dmat, dvec, Amat, bvec, meq, factorized) {
    Dmat = base0to1(Dmat);
    dvec = base0to1(dvec);
    Amat = base0to1(Amat);
    var i, n, q,
        nact, r,
        crval = [], iact = [], sol = [], work = [], iter = [],
        message;

    meq = meq || 0;
    factorized = factorized ? base0to1(factorized) : [undefined, 0];
    bvec = bvec ? base0to1(bvec) : [];

    // In Fortran the array index starts from 1
    n = Dmat.length - 1;
    q = Amat[1].length - 1;

    if (!bvec) {
        for (i = 1; i <= q; i = i + 1) {
            bvec[i] = 0;
        }
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }
    nact = 0;
    r = Math.min(n, q);
    for (i = 1; i <= n; i = i + 1) {
        sol[i] = 0;
    }
    crval[1] = 0;
    for (i = 1; i <= (2 * n + (r * (r + 5)) / 2 + 2 * q + 1); i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= 2; i = i + 1) {
        iter[i] = 0;
    }

    qpgen2(Dmat, dvec, n, n, sol, crval, Amat,
        bvec, n, q, meq, iact, nact, iter, work, factorized);

    message = "";
    if (factorized[1] === 1) {
        message = "constraints are inconsistent, no solution!";
    }
    if (factorized[1] === 2) {
        message = "matrix D in quadratic function is not positive definite!";
    }

    return {
        solution: base1to0(sol),
        value: base1to0(crval),
        unconstrained_solution: base1to0(dvec),
        iterations: base1to0(iter),
        iact: base1to0(iact),
        message: message
    };
}
exports.solveQP = solveQP;
}(numeric));
/*
Shanti Rao sent me this routine by private email. I had to modify it
slightly to work on Arrays instead of using a Matrix object.
It is apparently translated from http://stitchpanorama.sourceforge.net/Python/svd.py
*/

numeric.svd= function svd(A) {
    var temp;
//Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)
    var prec= numeric.epsilon; //Math.pow(2,-52) // assumes double prec
    var tolerance= 1.e-64/prec;
    var itmax= 50;
    var c=0;
    var i=0;
    var j=0;
    var k=0;
    var l=0;

    var u= numeric.clone(A);
    var m= u.length;

    var n= u[0].length;

    if (m < n) throw "Need more rows than columns"

    var e = new Array(n);
    var q = new Array(n);
    for (i=0; i<n; i++) e[i] = q[i] = 0.0;
    var v = numeric.rep([n,n],0);
//  v.zero();

    function pythag(a,b)
    {
        a = Math.abs(a)
        b = Math.abs(b)
        if (a > b)
            return a*Math.sqrt(1.0+(b*b/a/a))
        else if (b == 0.0)
            return a
        return b*Math.sqrt(1.0+(a*a/b/b))
    }

    //Householder's reduction to bidiagonal form

    var f= 0.0;
    var g= 0.0;
    var h= 0.0;
    var x= 0.0;
    var y= 0.0;
    var z= 0.0;
    var s= 0.0;

    for (i=0; i < n; i++)
    {
        e[i]= g;
        s= 0.0;
        l= i+1;
        for (j=i; j < m; j++)
            s += (u[j][i]*u[j][i]);
        if (s <= tolerance)
            g= 0.0;
        else
        {
            f= u[i][i];
            g= Math.sqrt(s);
            if (f >= 0.0) g= -g;
            h= f*g-s
            u[i][i]=f-g;
            for (j=l; j < n; j++)
            {
                s= 0.0
                for (k=i; k < m; k++)
                    s += u[k][i]*u[k][j]
                f= s/h
                for (k=i; k < m; k++)
                    u[k][j]+=f*u[k][i]
            }
        }
        q[i]= g
        s= 0.0
        for (j=l; j < n; j++)
            s= s + u[i][j]*u[i][j]
        if (s <= tolerance)
            g= 0.0
        else
        {
            f= u[i][i+1]
            g= Math.sqrt(s)
            if (f >= 0.0) g= -g
            h= f*g - s
            u[i][i+1] = f-g;
            for (j=l; j < n; j++) e[j]= u[i][j]/h
            for (j=l; j < m; j++)
            {
                s=0.0
                for (k=l; k < n; k++)
                    s += (u[j][k]*u[i][k])
                for (k=l; k < n; k++)
                    u[j][k]+=s*e[k]
            }
        }
        y= Math.abs(q[i])+Math.abs(e[i])
        if (y>x)
            x=y
    }

    // accumulation of right hand gtransformations
    for (i=n-1; i != -1; i+= -1)
    {
        if (g != 0.0)
        {
            h= g*u[i][i+1]
            for (j=l; j < n; j++)
                v[j][i]=u[i][j]/h
            for (j=l; j < n; j++)
            {
                s=0.0
                for (k=l; k < n; k++)
                    s += u[i][k]*v[k][j]
                for (k=l; k < n; k++)
                    v[k][j]+=(s*v[k][i])
            }
        }
        for (j=l; j < n; j++)
        {
            v[i][j] = 0;
            v[j][i] = 0;
        }
        v[i][i] = 1;
        g= e[i]
        l= i
    }

    // accumulation of left hand transformations
    for (i=n-1; i != -1; i+= -1)
    {
        l= i+1
        g= q[i]
        for (j=l; j < n; j++)
            u[i][j] = 0;
        if (g != 0.0)
        {
            h= u[i][i]*g
            for (j=l; j < n; j++)
            {
                s=0.0
                for (k=l; k < m; k++) s += u[k][i]*u[k][j];
                f= s/h
                for (k=i; k < m; k++) u[k][j]+=f*u[k][i];
            }
            for (j=i; j < m; j++) u[j][i] = u[j][i]/g;
        }
        else
            for (j=i; j < m; j++) u[j][i] = 0;
        u[i][i] += 1;
    }

    // diagonalization of the bidiagonal form
    prec= prec*x
    for (k=n-1; k != -1; k+= -1)
    {
        for (var iteration=0; iteration < itmax; iteration++)
        {   // test f splitting
            var test_convergence = false
            for (l=k; l != -1; l+= -1)
            {
                if (Math.abs(e[l]) <= prec)
                {   test_convergence= true
                    break
                }
                if (Math.abs(q[l-1]) <= prec)
                    break
            }
            if (!test_convergence)
            {   // cancellation of e[l] if l>0
                c= 0.0
                s= 1.0
                var l1= l-1
                for (i =l; i<k+1; i++)
                {
                    f= s*e[i]
                    e[i]= c*e[i]
                    if (Math.abs(f) <= prec)
                        break
                    g= q[i]
                    h= pythag(f,g)
                    q[i]= h
                    c= g/h
                    s= -f/h
                    for (j=0; j < m; j++)
                    {
                        y= u[j][l1]
                        z= u[j][i]
                        u[j][l1] =  y*c+(z*s)
                        u[j][i] = -y*s+(z*c)
                    }
                }
            }
            // test f convergence
            z= q[k]
            if (l== k)
            {   //convergence
                if (z<0.0)
                {   //q[k] is made non-negative
                    q[k]= -z
                    for (j=0; j < n; j++)
                        v[j][k] = -v[j][k]
                }
                break  //break out of iteration loop and move on to next k value
            }
            if (iteration >= itmax-1)
                throw 'Error: no convergence.'
            // shift from bottom 2x2 minor
            x= q[l]
            y= q[k-1]
            g= e[k-1]
            h= e[k]
            f= ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y)
            g= pythag(f,1.0)
            if (f < 0.0)
                f= ((x-z)*(x+z)+h*(y/(f-g)-h))/x
            else
                f= ((x-z)*(x+z)+h*(y/(f+g)-h))/x
            // next QR transformation
            c= 1.0
            s= 1.0
            for (i=l+1; i< k+1; i++)
            {
                g= e[i]
                y= q[i]
                h= s*g
                g= c*g
                z= pythag(f,h)
                e[i-1]= z
                c= f/z
                s= h/z
                f= x*c+g*s
                g= -x*s+g*c
                h= y*s
                y= y*c
                for (j=0; j < n; j++)
                {
                    x= v[j][i-1]
                    z= v[j][i]
                    v[j][i-1] = x*c+z*s
                    v[j][i] = -x*s+z*c
                }
                z= pythag(f,h)
                q[i-1]= z
                c= f/z
                s= h/z
                f= c*g+s*y
                x= -s*g+c*y
                for (j=0; j < m; j++)
                {
                    y= u[j][i-1]
                    z= u[j][i]
                    u[j][i-1] = y*c+z*s
                    u[j][i] = -y*s+z*c
                }
            }
            e[l]= 0.0
            e[k]= f
            q[k]= x
        }
    }

    //vt= transpose(v)
    //return (u,q,vt)
    for (i=0;i<q.length; i++)
      if (q[i] < prec) q[i] = 0

    //sort eigenvalues
    for (i=0; i< n; i++)
    {
    //writeln(q)
     for (j=i-1; j >= 0; j--)
     {
      if (q[j] < q[i])
      {
    //  writeln(i,'-',j)
       c = q[j]
       q[j] = q[i]
       q[i] = c
       for(k=0;k<u.length;k++) { temp = u[k][i]; u[k][i] = u[k][j]; u[k][j] = temp; }
       for(k=0;k<v.length;k++) { temp = v[k][i]; v[k][i] = v[k][j]; v[k][j] = temp; }
//     u.swapCols(i,j)
//     v.swapCols(i,j)
       i = j
      }
     }
    }

    return {U:u,S:q,V:v}
};

return numeric;

});
// Helper functions for computing distance.
//
// The name of this should probably be changed, once we learn what other
// kinds of things we're including here.

define('math/distance',['require','math/builtin','numeric'],function (require) {
  var Builtin = require('math/builtin');
  var Numeric = require('numeric');

  var Distance = {
    // sqrt(x^2 + y^2), computed to avoid overflow and underflow.
    // http://en.wikipedia.org/wiki/Hypot
    hypot: function(x, y) {
      if(x === 0 && y === 0) {
        return 0;
      }
      if (Math.abs(x) > Math.abs(y)) {
        return Math.abs(x) * Math.sqrt((y/x) * (y/x) + 1);
      } else {
        return Math.abs(y) * Math.sqrt((x/y) * (x/y) + 1);
      }
    },

    // (x1 + x2)/2, computed to avoid overflow.
    mean: function (x1, x2) {
      return ((x1 > 0) === (x2 > 0)) ? x1 + 0.5*(x2 - x1) : 0.5*(x1 + x2);
    },

    dot: function(x1, y1, x2, y2) {
      return x1*x2 + y1*y2;
    },

    // Consider the line extending the segment, parameterized as
    // v1 + t (v2 - v1), where p, v1, and v2 are (xp, yp), (x1, y1), and
    // (x2, y2) respectively.
    //
    // Return the value of the parameter t for the projected point of p onto
    // the line through the segment.
    //
    // It falls where t = [(p-v) . (w-v)] / |w-v|^2
    //
    // Returns 0 in the degenerate case where v1 === v2.
    pointToSegmentParameter: function(xp, yp, x1, y1, x2, y2) {
      var line_length = this.hypot(x2 - x1, y2 - y1);

      // Degenerate case of a point to a point
      if (line_length === 0) return 0;

      var t = this.dot(
        (xp - x1)/line_length,
        (yp - y1)/line_length,
        (x2 - x1)/line_length,
        (y2 - y1)/line_length
      );

      return t;
    },

    closestPointOnSegment: function (xp, yp, x1, y1, x2, y2) {
      var t = this.pointToSegmentParameter(xp, yp, x1, y1, x2, y2);

      if (t <= 0) return [x1, y1];
      if (t >= 1) return [x2, y2];
      return [x1 + t*(x2 - x1), y1 + t*(y2 - y1)];
    },

    // Shortest distance from a point to a line segment
    // http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
    pointToSegment: function (xp, yp, x1, y1, x2, y2) {
      var p = this.closestPointOnSegment(xp, yp, x1, y1, x2, y2);
      return this.hypot(xp - p[0], yp - p[1]);
    },

    // (Near) 0 if x3, y3 lies on the line from x1, y1 to x2, y2.
    // Positive if x3, y3 is on the left of the line, so that the points form a
    // triangle with clockwise orientation.
    isLine: function (x1, y1, x2, y2, x3, y3) {
      var S = Numeric.svd([
        [x1, y1, 1],
        [x2, y2, 1],
        [x3, y3, 1]
      ]).S;
      return Builtin.approx(S[S.length - 1]/S[0], 0);
    },

    isCircle: function (x1, y1, x2, y2, x3, y3, x4, y4) {
      var S = Numeric.svd([
        [x1*x1 + y1*y1, x1, y1, 1],
        [x2*x2 + y2*y2, x2, y2, 1],
        [x3*x3 + y3*y3, x3, y3, 1],
        [x4*x4 + y4*y4, x4, y4, 1]
      ]).S;
      return Builtin.approx(S[S.length - 1]/S[0], 0);
    },

    // (Near) 0 if x6, y6 lies on the conic defined by the first five points.
    // I don't quite know how to interpret the sign for a general conic.
    isConic: function (x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6) {
      var S =  Numeric.svd([
        [x1*x1, y1*y1, 2*x1*y1, x1, y1, 1],
        [x2*x2, y2*y2, 2*x2*y2, x2, y2, 1],
        [x3*x3, y3*y3, 2*x3*y3, x3, y3, 1],
        [x4*x4, y4*y4, 2*x4*y4, x4, y4, 1],
        [x5*x5, y5*y5, 2*x5*y5, x5, y5, 1],
        [x6*x6, y6*y6, 2*x6*y6, x6, y6, 1]
      ]).S;
      return Builtin.approx(S[S.length - 1]/S[0], 0);
    },

    conicQuadraticParameters: function (x1, y1, x2, y2, x3, y3, x4, y4, x5, y5) {
      return {
        a: Numeric.det([
          [y1*y1, 2*x1*y1, x1, y1, 1],
          [y2*y2, 2*x2*y2, x2, y2, 1],
          [y3*y3, 2*x3*y3, x3, y3, 1],
          [y4*y4, 2*x4*y4, x4, y4, 1],
          [y5*y5, 2*x5*y5, x5, y5, 1]
        ]),

        b: Numeric.det([
          [x1*x1, y1*y1, x1, y1, 1],
          [x2*x2, y2*y2, x2, y2, 1],
          [x3*x3, y3*y3, x3, y3, 1],
          [x4*x4, y4*y4, x4, y4, 1],
          [x5*x5, y5*y5, x5, y5, 1]
        ]),

        c: -Numeric.det([
          [x1*x1, 2*x1*y1, x1, y1, 1],
          [x2*x2, 2*x2*y2, x2, y2, 1],
          [x3*x3, 2*x3*y3, x3, y3, 1],
          [x4*x4, 2*x4*y4, x4, y4, 1],
          [x5*x5, 2*x5*y5, x5, y5, 1]
        ])
      };
    },

    // Classify a set of 6 points as line, circle, parabola, hyperbola, ellipse, or none for not a conic.
    classifyConic: function (x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6) {
      if (Distance.isLine(x1, y1, x3, y3, x6, y6)) return 'line';
      if (Distance.isCircle(x1, y1, x2, y2, x5, y5, x6, y6)) return 'circle';
      if (!Distance.isConic(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6)) return 'none';

      var p = Distance.conicQuadraticParameters(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5);
      var S = Numeric.svd([[p.a, p.b], [p.b, p.c]]).S;

      if (Builtin.approx(S[S.length - 1]/S[0], 0, 20)) return 'parabola';
      return (p.b*p.b > p.a*p.c) ? 'hyperbola' : 'ellipse';

    }
  };

  return Distance;
});

// Utilites for finding and refining points of interest in samled functions.
//
// bisect* are low level functions take endpoints and a function, and return
// a single [x, f(x)] pair, where f is the function that was passed in, or
// null if a non-finite value of the function is encountered during
// evaluation. These methods have preconditions on the endpoints that callers
// are expected to enforce (because they are called recursively). They bisect
// to machine precision.
//
// find* are higher level. They take an array of segments and a function.
// Each segment is an array of points representing a polyline that
// approximates the function over a range where the function is expected to be
// continuous. No more than one zero and one extremum will be returned between
// individual point pairs in the segments list.
//
// findPOIs collects the results of all the find* methods together.


define('math/poi',['require','console','./builtin','./distance'],function(require){
  var console = require('console');
  var BuiltIn = require('./builtin');
  var Distance = require('./distance');

// floatMiddle is a helper function for bisecting floats. Necessary because
// floats are denser near 0 than they are elsewhere, so using a normal mean
// results in slow bisection to 0.
//
// This function returns the arithmetic mean if both numbers have
// magnitude larger than 1e-2, 0 if the numbers are small and have opposite
// signs, and the signed geometric mean if the numbers have the same sign. The
// geometric mean bisects the exponent instead of the mantissa, which is what
// we want near 0.

function floatMiddle(a, b) {
  var tmp;
  if (a > b) {
    tmp = a; a = b; b = tmp;
  }
  var aPos = a > 0;
  var bPos = b > 0;
  var aLarge = Math.abs(a) > 1e-2;
  var bLarge = Math.abs(b) > 1e-2;
  if (aLarge || bLarge) return Distance.mean(a, b);
  if (a === 0) return b*Math.abs(b);
  if (b === 0) return a*Math.abs(a);
  if (aPos !== bPos) return 0;
  var gMean = (aPos) ? Math.sqrt(a*b) : -Math.sqrt(a*b);
  // Check if the geometric mean actually lies between the numbers (it might
  // not because of floating point rounding). If it does not, return the
  // normal mean, which is computed in a way that guarantees it will be
  // between the inputs.
  return ((gMean >= a) && (b >= gMean)) ? gMean : Distance.mean(a, b);
}

function bisectZero(x0, y0, x2, y2, fn) {
  // Preconditions:
  // 1. y0 and y2 are finite and non-zero and have opposite sign
  if (!(isFinite(y0) && isFinite(y2) && (y0 < 0) !== (y2 < 0))) {
    console.log('bisectZero called with bad y values', [y0, y2]);
    return;
  }

  while (true) {
    var x1 = floatMiddle(x0, x2);
    var y1 = fn(x1);

    if (!isFinite(y1)) return null;

    // We can't bisect any further; return x for side with y closer to 0.
    if (x1 === x0 || x1 === x2) {
      return Math.abs(y0) <= Math.abs(y2) ? [x0, y0] : [x2, y2];
    }

    // Found a 0 early. Check if we're on a flat, and return the center of it.
    if (y1 === 0) return flatCenter(x0, y0, x1, y1, x2, y2, fn);

    // Bisect on side that brackets zero
    if ((y0 < 0) !== (y1 < 0)) {
      x2 = x1; y2 = y1;
    } else {
      x0 = x1; y0 = y1;
    }
  }
}

// Returns the center of a possibly flat region with constant value y1
function flatCenter(x0, y0, x1, y1, x2, y2, fn) {
  // Preconditions:
  // 1. x0 < x1 < x2

  var edge;
  if (!isFinite(y1)) return;

  if (!isFinite(y0)) {
    edge = bisectFinite(x0, y0, x1, y1, fn);
    x0 = edge[0];
    y0 = edge[1];
  }

  if (!isFinite(y2)) {
    edge = bisectFinite(x1, y1, x2, y2, fn);
    x2 = edge[0];
    y2 = edge[1];
  }

  var flatLeft, flatRight;

  if (y0 === y1) {
    flatLeft = [x0, y0];
  } else {
    flatLeft = bisectConstant(x0, y0, x1, y1, fn, y1);
  }

  if (y2 === y1) {
    flatRight = [x2, y2];
  } else {
    flatRight = bisectConstant(x1, y1, x2, y2, fn, y1);
  }

  var xc = floatMiddle(flatLeft[0], flatRight[0]);
  return [xc, fn(xc)];
}

function bisectFinite(x0, y0, x2, y2, fn) {
  // Preconditions:
  // 1. isFinite(y0) !== isFinite(y2)
  if (isFinite(y0) === isFinite(y2)) {
    console.log('bisectFinite called with bad y values', [y0, y2]);
    return;
  }

  while (true) {
    var x1 = floatMiddle(x0, x2);
    var y1 = fn(x1);

    // We can't bisect any further; return [x, y] pair for side that is finite.
    if (x1 === x0 || x1 === x2) return isFinite(y0) ? [x0, y0]: [x2, y2];

    // Bisect on side that brackets zero
    if (isFinite(y1) !== isFinite(y0)) {
      x2 = x1; y2 = y1;
    } else {
      x0 = x1; y0 = y1;
    }
  }
}

function bisectConstant(x0, y0, x2, y2, fn, constant) {
  // Preconditions:
  // 1. (y0 === constant) !== (y2 === constant)
  if ((y0 === constant) === (y2 === constant)) {
    console.log('bisectConstant called with bad y values', [y0, y2, constant]);
    return;
  }

  while (true) {
    var x1 = floatMiddle(x0, x2);
    var y1 = fn(x1);

    // We can't bisect any further; return [x, y] pair for side with
    // y === constant
    if (x1 === x0 || x1 === x2) return (y0 === constant) ? [x0, y0]: [x2, y2];

    if ((y1 === constant) !== (y0 === constant)) {
      x2 = x1; y2 = y1;
    } else {
      x0 = x1; y0 = y1;
    }
  }
}

function bisectExtremum(x0, y0, x2, y2, x4, y4, fn) {
  /* jshint maxcomplexity:11 */
  // Preconditions:
  // 1. x0 < x2 < x4
  // 2. y0, y2, and y4 are finite, non-equal, and y2 > y0 === y2 > y4.
  if (!(x0 < x2 && x2 < x4)) {
    console.log('bisectExtremum called with bad x values', [x0, x2, x4]);
    return;
  }
  if (!(
    (isFinite(y0) && isFinite(y2) && isFinite(y4)) &&
    (y0 !== y2 && y2 !== y4) &&
    (y2 > y0) === (y2 > y4)
  )) {
    console.log('bisectExtremum called with bad y values', [y0, y2, y4]);
    return;
  }

  while (true) {
    var x1 = floatMiddle(x0, x2);
    var y1 = fn(x1);
    var x3 = floatMiddle(x2, x4);
    var y3 = fn(x3);

    if (!isFinite(y1) || !isFinite(y3)) return null;

    // We can't bisect any further; return x and y for most extreme value
    if (x1 === x0 || x1 === x2 || x3 === x2 || x3 === x4) {
      if ((y1 > y2) === (y2 > y0)) return [x1, y1];
      if ((y3 > y2) === (y2 > y0)) return [x3, y3];
      return [x2, y2];
    }

    // We've hit a flat. Find its edges and return x and y for its center.
    if (y1 === y2 || y3 === y2) {
      return flatCenter(x0, y0, x2, y2, x4, y4, fn);
    }

    // Bisect on side that brackets zero
    if ((y1 > y0) === (y2 > y0) && (y1 > y0) === (y1 > y2)) {
      x4 = x2; y4 = y2; x2 = x1; y2 = y1;
    } else if ((y3 > y4) === (y2 > y4) && (y3 > y2) === (y3 > y4)) {
      x0 = x2; y0 = y2; x2 = x3; y2 = y3;
    } else {
      x0 = x1; y0 = y1; x4 = x3; y4 = y3;
    }
  }
}

// Returns larget jump among 4 points. Used in final step of bisectJump
function largestJump(x0, y0, x1, y1, x2, y2, x3, y3) {
  // Preconditions:
  // 1. y0, y1, y2, and y3 are all finite
  var d1 = Math.abs(y1 - y0);
  var d2 = Math.abs(y2 - y1);
  var d3 = Math.abs(y3 - y2);

  if (d1 > d2 && d1 > d3) return [[x0, y0], [x1, y1]];
  if (d3 > d2 && d3 > d1) return [[x2, y2], [x3, y3]];
  return [[x1, y1], [x2, y2]];
}

// Tries to find the largest jump in an interval. Returns left side and right
// side of jump as [[xl, yl], [xr, yr]], or null if no jump was found.
// Tolerance is allowed to be 0, and this works for some smooth functions,
// but returns false positives for others.
function bisectJump(x0, y0, x2, y2, x4, y4, fn, tolerance) {
  /* jshint maxcomplexity:15 */
  // Preconditions:
  // 1. x0 < x2 < x4
  // 2. y0, y2, and y4 are all finite.
  // Also expect x2 - x0 ~= x4 - x2
  if (!(x0 < x2 && x2 < x4)) {
    console.log('bisectJump called with bad x values', [x0, x2, x4]);
    return;
  }
  if (!isFinite(y0) || !isFinite(y4)) {
    console.log('bisectJump called with bad y values', [y0, y2, y4]);
    return;
  }

  if (!isFinite(y2)) {
    return [bisectFinite(x0, y0, x2, y2, fn), bisectFinite(x2, y2, x4, y4, fn)];
  }

  if (Math.abs(y2 - ((x4 - x2)*y0 + (x2 - x0)*y4)/(x4 - x0)) < tolerance) return null;

  while (true) {
    var x1 = floatMiddle(x0, x2);
    var y1 = fn(x1);
    var x3 = floatMiddle(x2, x4);
    var y3 = fn(x3);
    var dy1 = Math.abs(y1 - Distance.mean(y0, y2));
    var dy3 = Math.abs(y3 - Distance.mean(y2, y4));
    var left;
    var right;
    if (!tolerance) tolerance = 0;

    if (dy1 <= tolerance && dy3 <= tolerance) return null;

    // An undefined region counts as a jump.
    if (!isFinite(y1)) {
      left = bisectFinite(x0, y0, x1, y1, fn);
      right = bisectFinite(x1, y1, x4, y4, fn);
      return [left, right];
    }

    if (!isFinite(y3)) {
      left = bisectFinite(x0, y0, x3, y3, fn);
      right = bisectFinite(x3, y3, x4, y4, fn);
      return [left, right];
    }

    if ((x1 === x0 || x1 === x2) && (x3 === x2 || x3 === x4)) {
      if (Math.abs(y2 - y0) > Math.abs(y4 - y2)) {
        left = [x0, y0];
        right = [x2, y2];
      } else {
        left = [x2, y2];
        right = [x4, y4];
      }
      return [left, right];
    } else if (x1 === x0 || x1 === x2) {
      return largestJump(x0, y0, x2, y2, x3, y3, x4, y4);
    } else if (x3 === x2 || x3 === x4) {
      return largestJump(x0, y0, x1, y1, x2, y2, x4, y4);
    }

    if (dy1 > dy3) {
      x4 = x2; y4 = y2; x2 = x1; y2 = y1;
    } else {
      x0 = x2; y0 = y2; x2 = x3; y2 = y3;
    }
  }
}

function findZeros(segments, fn) {
  var segment;
  var accumulator = { x: [], y: [] };
  var x0;
  var y0;
  var x2;
  var y2;
  var zero;
  var flatLeft;
  for (var i=0, li=segments.length; i<li; i++) {
    segment = segments[i];
    flatLeft = undefined;
    if (segment[1] === 0) flatLeft = [segment[0], segment[1]];
    for (var j=0, lj=segment.length; j<lj-2; j = j+2) {
      x0 = segment[j];
      y0 = segment[j+1];
      x2 = segment[j+2];
      y2 = segment[j+3];

      if (!flatLeft) {
        if (y2 === 0) {
          // Entering left side of a potential flat. Save its position.
          flatLeft = [x0, y0];
        } else if ((y0 < 0) !== (y2 < 0)) {
          zero = bisectZero(x0, y0, x2, y2, fn);
          if (zero) {
            accumulator.x.push(zero[0]);
            accumulator.y.push(zero[1]);
          }
        }
      } else {
        if (y2 !== 0) {
          // Leaving right side of a flat. Add its center as a root.
          // Don't label zeros that start on segment boundaries.
          if (flatLeft[0] !== segment[0]) {
            zero = flatCenter(flatLeft[0], flatLeft[1], x0, y0, x2, y2, fn);
            accumulator.x.push(zero[0]);
            accumulator.y.push(zero[1]);
          }
          flatLeft = undefined;
        }
        // Otherwise we're in the middle of the flat; do nothing
      }
    }
    // Don't label zero that ends on a segment boundary.
  }

  return accumulator;
}

function findExtrema (segments, fn, derivative) {
  /* jshint maxcomplexity:13 */
  var segment;
  var accumulator = { x: [], y: [] };
  var x0;
  var y0;
  var x2;
  var y2;
  var x4;
  var y4;
  var extremum;
  var flatLeft;
  for (var i=0, li=segments.length; i<li; i++) {
    segment = segments[i];
    for (var j=0, lj=segment.length; j<lj - 4; j = j+2) {
      x0 = segment[j];
      y0 = segment[j+1];
      x2 = segment[j+2];
      y2 = segment[j+3];
      x4 = segment[j+4];
      y4 = segment[j+5];

      //TODO handle extremal endpoints.
      if (!(isFinite(y0) && isFinite(y2) && isFinite(y4))) continue;

      if (y0 !== y2 && y2 === y4) {
        // Entering left side of a flat. Save its position.
        flatLeft = [x0, y0];
      } else if (y0 === y2 && y2 !== y4 && flatLeft) {
        // Leaving right side of a flat.
        if ((y2 > flatLeft[1]) === (y2 > y4)) {
          // Flat is an extremum. Push it's center.
          extremum = flatCenter(flatLeft[0], flatLeft[1], x2, y2, x4, y4, fn);
          accumulator.x.push(extremum[0]);
          accumulator.y.push(extremum[1]);
        }
        flatLeft = undefined;
      } else if (y0 === y2 && y2 === y4) {
        // Middle of a flat, do nothing
      } else if ((y2 > y0) === (y2 > y4)) {
        if (derivative) {
          // If we have derivative information, find zeros of the derivative
          // to find extrema. This gives greater accuracy in the argmax/argmin
          // because the original function is flat at the extrema, but its
          // derivative is (usually) not.

          // Make sure we satisfy prereqs of bisectZero
          if ((derivative(x0) > 0) === (derivative(x4) > 0)) continue;
          extremum = bisectZero(
            x0, derivative(x0),
            x4, derivative(x4),
            derivative
          );
          // Currently treat maxima and minima the same
          if (extremum) {
            accumulator.x.push(extremum[0]);
            accumulator.y.push(fn(extremum[0]));
          }
        } else {
          extremum = bisectExtremum(x0, y0, x2, y2, x4, y4, fn);
          // Currently treat maxima and minima the same
          if (extremum) {
            accumulator.x.push(extremum[0]);
            accumulator.y.push(extremum[1]);
          }
        }
      }
    }
  }
  return accumulator;
}

function findIntercept(segments, fn) {
  var intercept = fn(0);
  if (!isFinite(intercept)) return { x: [], y: []};
  return { x: [ 0 ], y: [ fn(0) ] };
}

function findEdges(segments, fn) {
  var slen = segments.length;
  var accumulator = { x: [], y: [] };
  //TODO work out robust system for labeling holes so that we can label all
  // edges.
  //
  // For now, only label edges that are close to zero as zeros.

  for (var i = 0; i < slen; i++) {
    var segment = segments[i];
    if (parseFloat(segment[1].toFixed(7)) === 0) {
      accumulator.x.push(segment[0]);
      accumulator.y.push(segment[1]);
    }

    if (parseFloat(segment[segment.length - 1].toFixed(7)) === 0) {
      accumulator.x.push(segment[segment.length - 2]);
      accumulator.y.push(segment[segment.length -1]);
    }
  }
  return accumulator;
}

function findPOIs (segments, fn, derivative) {
  var zeros = findZeros(segments, fn);
  var edges = findEdges(segments, fn);

  // Not displaying edges right now; combine them with zeros.
  zeros.x.push.apply(zeros.x, edges.x);
  zeros.y.push.apply(zeros.y, edges.y);

  return {
    zeros: zeros,
    intercept: findIntercept(segments, fn),
    extrema: findExtrema(segments, fn, derivative)
  };
}

// indicatorFn is a function that is 0 where two curves intersect, and
// indicatorSamples is a series of samples of this function. For two
// y vs x curves, the indicator function is just the difference between
// the two curves. For intersecting a y vs x curve with an x vs y curve,
// e.g. y = f(x) and x = g(y), a suitable indicator function is
// x - g(f(x)). fn1 is used at the end to get y values from the x values
// that are roots of the indicator function.
function findIntersections (indicatorSamples, fn1, indicatorFn) {

  var zeros = findZeros(indicatorSamples, indicatorFn);
  var i, elen, zlen;

  // Find tangent intersections.
  var extrema = findExtrema(indicatorSamples, indicatorFn);
  for (i = 0, elen = extrema.x.length; i < elen; i++) {
    if (BuiltIn.approx(extrema.y[i], 0)) {
      zeros.x.push(extrema.x[i]);
      zeros.y.push(extrema.y[i]);
    }
  }

  // Find original function intersection y values.
  for (i = 0, zlen = zeros.x.length; i < zlen; i++) {
    zeros.y[i] = fn1(zeros.x[i]);
  }
  return zeros;
}

return {
  bisectJump: bisectJump,
  bisectExtremum: bisectExtremum,
  bisectFinite: bisectFinite,
  bisectZero: bisectZero,
  findExtrema: findExtrema,
  findZeros: findZeros,
  findPOIs: findPOIs,
  findIntersections: findIntersections,

  //Enums for POI type
  INTERSECTION: 1001,
  ZERO: 1002,
  INTERCEPT: 1003,
  EXTREMUM: 1004,
  EDGE: 1005,
  DEFINITION: 1006
};

});

define('graphing/graphmode',{
  X: 1,
  Y: 2,
  XYPOINT: 3,
  XYPOINT_MOVABLE: 4,
  PARAMETRIC: 5,
  POLAR: 6,
  POLYGONFILL: 7,
  IMPLICIT: 8,
  NONE: 10
});

define('math/plotter',['require','pjs','./distance','./poi','graphing/graphmode'],function(require) {
  var P = require('pjs');
  var Distance = require('./distance');
  var POI = require('./poi');
  var GRAPHMODE = require('graphing/graphmode');

  var Accumulator = P(function (proto) {
    proto.init = function (domain) {
      this.domain = domain;
      if (domain) {
        this.xtolerance = domain.xtolerance || domain.tolerance || 0;
        this.ytolerance = domain.ytolerance || domain.tolerance || 0;
        this.map = domain.map;
      } else {
        this.xtolerance = this.ytolerance = 0;
      }
      this.segments = [];
      this.segment = null;
      // Second point added to colinear set; defines line direction
      this.pivotPoint = null;
      // Most recent point in colinear set
      this.pendingPoint = null;
    };

    proto.colinear = function (p0, p1, p2) {
      if (this.map) {
        p0 = this.map(p0);
        p1 = this.map(p1);
        p2 = this.map(p2);
      }

      var t = Distance.pointToSegmentParameter(
        p2[0], p2[1],
        p0[0], p0[1],
        p1[0], p1[1]
      );

      if (t < 1) return false;

      var closestPoint = [
        p0[0] + t*(p1[0] - p0[0]),
        p0[1] + t*(p1[1] - p0[1])
      ];

      return (
        Math.abs(p2[0] - closestPoint[0]) <= this.xtolerance &&
        Math.abs(p2[1] - closestPoint[1]) <= this.ytolerance
      );
    };

    proto.addPoint = function (p) {
      this.n+=1;

      if (!this.segment) {
        this.segment = [p[0], p[1]];  //First point of the segment
        return;
      }

      if (this.xtolerance < 0 && this.ytolerance < 0) {
        this.segment.push(p[0], p[1]);
        return;
      }

      if (!this.pivotPoint) {
        this.pivotPoint = p;
        this.pendingPoint = p;
        return;
      }

      // Check if the new point lies on the line segment defined by the
      // last flushed point and the pivot point. If not, flush the pending
      // point and start a new linear section.
      var lastPoint = [
        this.segment[this.segment.length - 2],
        this.segment[this.segment.length - 1]
      ];

      if (!this.colinear(lastPoint, this.pivotPoint, p)) {
        this.flushPending();
        this.pivotPoint = p;
      }

      this.pendingPoint = p;
    };

    proto.flushPending = function () {
      if (this.pendingPoint) { //Only happens when we have a segment
        this.segment.push(this.pendingPoint[0], this.pendingPoint[1]);
        this.pivotPoint = null;
        this.pendingPoint = null;
      }
    };

    proto.breakSegment = function () {
      this.flushPending();

      if (this.segment) {
        if (this.segment.length > 2) {
          this.segments.push(this.segment);
        }
        this.segment = null;
      }
    };

    proto.getSegments = function () {
      this.breakSegment();
      return this.segments;
    };

    proto.finish = function () {
      return {
        segments: this.getSegments(),
        resolved: true
      };
    };

    proto.exhaust = function () {};
  });

  //Simple sampling of a [x(t), y(t)] function.
  //Domain is provided in terms of the independent variable
  //PARAMETERS
  //fn(int) => [x, y]
  //domain = {min, max, step}
  //RETURNS
  //Unclipped list of segments which can be passed directly into onGraph
  function sampleParametricNaive (fn, domain) {
    var accumulator = new Accumulator();
    var point;
    for (var independent = domain.min; independent <= domain.max + domain.step/2; independent += domain.step) {
      point = fn(independent);
      if (isFinite(point[0]) && isFinite(point[1])) {
        accumulator.addPoint(point);
      }
      else {
        accumulator.breakSegment();
      }
    }
    return accumulator.finish();
  }

  //Simple sampling of a y(x) function.
  //PARAMETERS
  //fn(int) => y
  //domain = {min, max, step}
  //RETURNS
  //Unclipped list of segments which can be passed directly into onGraph
  function sampleXYNaive (fn, domain) {
    var accumulator = new Accumulator(domain);
    var y;
    for (var x = domain.min; x <= domain.max + domain.step/2; x += domain.step) {
      y = fn(x);
      if (isFinite(y)) {
        accumulator.addPoint([x, y]);
      } else {
        accumulator.breakSegment();
      }
    }
    return accumulator.finish();
  }

  function sampleLinear (linearCoefficients, domain) {
    var accumulator = new Accumulator(domain);
    accumulator.addPoint([domain.min, linearCoefficients[0] + domain.min*linearCoefficients[1]]);
    accumulator.addPoint([domain.max, linearCoefficients[0] + domain.max*linearCoefficients[1]]);
    return accumulator.finish();
  }

  // Only returns a jump if we also find a jump when previousPoint and point are
  // perturbed by stepPerturbation.
  function _bisectJumpRobust (previousPoint, point, params) {
    var x0, y0, x1, y1, x2, y2;
    var fn = params.fn;
    var jumpTolerance = params.jumpTolerance;
    var stepPerturbation = params.stepPerturbation;

    x0 = previousPoint[0];
    y0 = previousPoint[1];
    x2 = point[0];
    y2 = point[1];
    x1 = Distance.mean(x0, x2);
    y1 = fn(x1);

    var jump = POI.bisectJump(x0, y0, x1, y1, x2, y2, fn, jumpTolerance);

    if (!jump) return;

    // If we found a jump, check whether we still find one with a small perturbation
    // to the left or the right.
    var perturbations = [-stepPerturbation, stepPerturbation];
    for (var i = 0; i < perturbations.length; i++) {
      x0 = previousPoint[0] + perturbations[i];
      y0 = fn(x0);
      if (!isFinite(y0)) {
        x0 = previousPoint[0];
        y0 = previousPoint[1];
      }
      x2 = point[0] + perturbations[i];
      y2 = fn(x2);
      if (!isFinite(y2)) {
        x2 = point[0];
        y2 = point[1];
      }
      x1 = Distance.mean(x0, x2);
      y1 = fn(x1);

      if (POI.bisectJump(x0, y0, x1, y1, x2, y2, fn, jumpTolerance)) return jump;
    }

    // If we made it here, we didn't find a jump under either perturbation, so just
    // conclude that the jump was not robust and return nothing.
  }

  var _handleJump = function (previousPoint, point, params) {
    if (!isFinite(params.jumpTolerance) || (params.jumpTolerance <= 0)) return;
    var jump = _bisectJumpRobust(previousPoint, point, params);
    if (jump) {
      params.accumulator.addPoint(jump[0]);
      params.accumulator.breakSegment();
      params.accumulator.addPoint(jump[1]);
    }
  };

  // Thre are a few pieces of state and configuration that need to get passed to
  // subroutines in sampleXY. This is just a simple container to keep track of
  // them.
  //
  // _handleJump used to be defined inside samlpeXY to close over all of these
  // variables, but it gets called a ton, so it's worth a bit of bureaucracy to
  // avoid paying the runtime cost of closures.
  var SampleXYParameters = function (fn, domain) {
    this.accumulator = new Accumulator(domain);
    this.fn = fn;
    this.jumpTolerance = domain.ytolerance || domain.tolerance;
    this.stepPerturbation = domain.step/10;
  };

  function sampleXY (fn, domain) {

    var params = new SampleXYParameters(fn, domain);
    var edge;
    var x = domain.min;
    var y = fn(x);
    var previousPoint = [x, y];

    if (isFinite(y)) params.accumulator.addPoint([x, y]);
    for (x += domain.step; x <= domain.max + domain.step/2; x += domain.step) {
      var xp = x;
      y = fn(xp);

      // If y isn't finite, try two nearby values to see if we can find an x with a finite y.
      // Policy is to try to avoid numerically spurious jumps and holes by ignoring them if
      // they have no influence outside a region that we could have missed by sampling with
      // a small offset.
      // https://github.com/desmosinc/knox/issues/2230
      // https://github.com/desmosinc/knox/issues/4151
      if (!isFinite(y)) {
        xp = x + params.stepPerturbation;
        y = fn(xp);
      }
      if (!isFinite(y)) {
        xp = x - params.stepPerturbation;
        y = fn(xp);
      }

      if (isFinite(y) && isFinite(previousPoint[1])) {
        _handleJump(previousPoint, [xp, y], params);
        params.accumulator.addPoint([xp, y]);
      } else if (isFinite(y) && !isFinite(previousPoint[1])) {
        edge = POI.bisectFinite(previousPoint[0], previousPoint[1], xp, y, fn);
        if (edge[0] !== xp) params.accumulator.addPoint(edge);
        _handleJump(edge, [xp, y], params);
        params.accumulator.addPoint([xp, y]);
      } else if (!isFinite(y) && isFinite(previousPoint[1])) {
        edge = POI.bisectFinite(previousPoint[0], previousPoint[1], xp, y, fn);
        _handleJump(previousPoint, edge, params);
        if (edge[0] !== previousPoint[0]) params.accumulator.addPoint(edge);
        params.accumulator.breakSegment();
      }
      previousPoint = [xp, y];
    }
    return params.accumulator.finish();
  }

  function findPiPeriod (fn, domain, trigAngleMultiplier, allowAntiperiods) {
    // If the function is periodic by a multiple of 2*pi, or antiperiodic by
    // a multiple of pi within the domain, return the period.
    //
    // Can optionally pass true to find antiperiods if they exist.
    var min = domain.min;
    var range = domain.max - domain.min;
    var tolerance = (domain.xtolerance && domain.ytolerance) ?
      Math.min(domain.xtolerance, domain.ytolerance) :
      domain.tolerance;
    var piRange = Math.floor(range/(Math.PI/trigAngleMultiplier));
    var n, m, period;

    function isPeriod(fn, n) {
      var sign = (n % 2 === 0) ? 1 : -1;
      if (!allowAntiperiods && sign === -1) return false;
      var nPI = n*(Math.PI/trigAngleMultiplier);
      var vals = [ min, min + 1, min + 2, min + 3];

      for (var i = 0, ilen = vals.length; i < ilen; i++) {
        if (
          isFinite(fn(vals[i])) !== isFinite(fn(vals[i] + nPI)) ||
          Math.abs(fn(vals[i]) - sign*fn(vals[i] + nPI)) > tolerance
        ) {
          return false;
        }
      }

      return true;
    }

    for (n = 1; n <= piRange; n++) {
      if (isPeriod(fn, n)) {
        period = n;
        // Check if integer multiples of the period are also periods
        for (m = 2; m*n <= piRange; m++) {
          if (!isPeriod(fn, m*n)) period = undefined;
        }
        if (period) break;
      }
    }

    if (!period) return null;

    return period*(Math.PI/trigAngleMultiplier);
  }

  function mapPolar (p) {
    return [ p[1]*Math.cos(p[0]), p[1]*Math.sin(p[0]) ];
  }

  function samplePolar (fn, domain) {
    // Don't allow line coallescing, since linear segments of a polar
    // equation don't map to lines on the graph paper.
    domain.map = mapPolar;
    return sampleXY(fn, domain);
  }

  // Helper for calling a function at steps along a range that makes sure we
  // hit start and endpoints exactly.
  //
  // TODO, use this in sampling xy also. Not
  // doing that for now because I don't want to step on Eric's toes with
  // extrema interleaving system that is being concurrently developed.
  function eachStep (domain, fn) {
    var min = domain.min;
    var max = domain.max;
    var step = domain.step;
    var range = max - min;
    var nsteps = Math.ceil(range/step);
    var newStep = range/nsteps;
    for (var n = 0; n < nsteps; n++) {
      fn(min + n*newStep);
    }
    fn(max);
  }

  function sampleParametricRecursive (fn, domain) {
    if (domain.max < domain.min) { return [] }

    var accumulator = new Accumulator(domain);

    //Sampling parameters
    var subdivision_levels = 10;

    //Initialize for first pass through loop
    var t0 = domain.min;
    var p0 = fn(t0);
    if (isFinite(p0[0]) && isFinite(p0[1])) {
      accumulator.addPoint(p0);
    }

    var p1;
    // Note, processes first point twice; but that's okay.
    eachStep(domain, function (t1) {
      p1 = fn(t1);
      subsampleParametricRecursive(fn, t0, p0, t1, p1, subdivision_levels, accumulator);
      t0 = t1;
      p0 = p1;
    });

    return accumulator.finish();
  }

  function subsampleParametricRecursive (fn, t0, p0, t1, p1, subdivision_levels_left, accumulator) {
    /* jshint maxcomplexity:13 */
    if (t1 === t0) return; // Nothing new to add, but don't need to break;

    var xtolerance = accumulator.xtolerance, ytolerance = accumulator.ytolerance;
    var t_mid = Distance.mean(t0, t1);
    var p_mid = fn(t_mid, true);

    var p0_valid = isFinite(p0[0]) && isFinite(p0[1]);
    var p1_valid = isFinite(p1[0]) && isFinite(p1[1]);
    var p_mid_valid = isFinite(p_mid[0]) && isFinite(p_mid[1]);

    if (subdivision_levels_left === 0 || t_mid === t0 || t_mid === t1) {
      accumulator.breakSegment(); //Didn't converge.
      if (p1_valid) accumulator.addPoint(p1);
      return;
    }

    // Don't need to break segment, since p0 should already have been processed.
    if (!p0_valid && !p1_valid) return;

    if (p0_valid !== p1_valid) {
      // We're at the edge of where the function is defined.
      // Subdivide until we find where edge point to machine precision.
      var original_t0 = t0;
      var original_t1 = t1;
      var original_p0 = p0;
      var original_p1 = p1;

      while (t0 !== t_mid && t_mid !== t1) {

        if (p_mid_valid == p0_valid) {
          t0 = t_mid;
          p0 = p_mid;
          p0_valid = p_mid_valid;
        }
        else {
          t1 = t_mid;
          p1 = p_mid;
          p1_valid = p_mid_valid;
        }

        t_mid = t0 + (t1-t0)/2;
        p_mid = fn(t_mid, true);
        p_mid_valid = isFinite(p_mid[0]) && isFinite(p_mid[1]);
      } //When this loop terminates, t_mid equals either t0 or t1

      if (p0_valid) {
        subsampleParametricRecursive(fn, original_t0, original_p0, t0, p0, subdivision_levels_left-1, accumulator);
        accumulator.breakSegment();
      }
      else {
        accumulator.breakSegment();
        accumulator.addPoint(p1);
        subsampleParametricRecursive(fn, t1, p1, original_t1, original_p1, subdivision_levels_left-1, accumulator);
      }
      return;
    }

    if (p0_valid && p_mid_valid && p1_valid) {

      var t = Distance.pointToSegmentParameter(
        p_mid[0],
        p_mid[1],
        p0[0],
        p0[1],
        p1[0],
        p1[1]
      );

      // If the new point lies betwen 20 % and 80 % of the way between the
      // outer points, and the distance from the segment to the new point is
      // less than tolerance, add the rightmost point, and stop recursing.
      if (
        t > 0.2 &&
        t < 0.8 &&
        Math.abs(p_mid[0] - (p0[0] + t*(p1[0] - p0[0]))) <= xtolerance &&
        Math.abs(p_mid[1] - (p0[1] + t*(p1[1] - p0[1]))) <= ytolerance
      ) {
        accumulator.addPoint(p1);
        return;
      }
    }

    // If we didn't stop, recurse. Don't recurse between two points that are
    // equal, since this will make us do a lot of work if our point becomes
    // independent of t over some range.
    if (!(p0[0] === p_mid[0] && p0[1] === p_mid[1])) {
      subsampleParametricRecursive(fn, t0, p0, t_mid, p_mid, subdivision_levels_left - 1, accumulator);
    }
    if (!(p1[0] === p_mid[0] && p1[1] === p_mid[1])) {
      subsampleParametricRecursive(fn, t_mid, p_mid, t1, p1, subdivision_levels_left - 1, accumulator);
    }
  }

  function sampleImplicitRecursive (fn, domain) {
    var xmin = domain.xmin;
    var ymin = domain.ymin;
    var xmax = domain.xmax;
    var ymax = domain.ymax;

    var a = 6; // Devide the grid at least a times
    var b = 0; // Allow up to b extra subdivisions locally

    var maxSegments = 10000;
    // Perform an iterative deepening depth first search on how many segments we will produce.
    // This allows us to go to very high precision locally for mostly simple functions that have a few kinks,
    // while still limiting the total number of line segments that we'll ever return to the draw routine.
    var opts;
    var pointCount;
    var lastPointCount = -1;
    var exhaustedCount;
    var incrementPointCount = function () { pointCount++; };
    var incrementExhuastedCount = function () { exhaustedCount++; };

    var maxDepth = 12;

    while (true) {
      pointCount = 0;
      exhaustedCount = 0;

      opts = {
        fn: fn,
        mindepth: b,
        accumulator: {push: incrementPointCount, exhaust: incrementExhuastedCount},
        xtolerance: domain.xtolerance,
        ytolerance: domain.ytolerance
      };

      subsampleImplicitRecursive(
        opts, a + b,
        xmin, ymax, fn(xmin, ymax),
        xmax, ymax, fn(xmax, ymax),
        xmax, ymin, fn(xmax, ymin),
        xmin, ymin, fn(xmin, ymin)
      );

      if (pointCount === lastPointCount || pointCount > maxSegments) {
        b--;
        break;
      }

      if (exhaustedCount === 0) {
        break;
      } else {
        b += Math.max(1, Math.floor(Math.log((maxSegments - pointCount)/exhaustedCount)/Math.log(4)));
        if (b > maxDepth) {
          b = maxDepth;
          break;
        }
      }

      lastPointCount = pointCount;
    }

    var resolved = pointCount < maxSegments;

    var accumulator = [];
    var noop = function () {};

    opts = {
      fn: fn,
      mindepth: b,
      accumulator: {
        push: function() {Array.prototype.push.apply(accumulator, arguments);}, //Avoiding bind for phantomjs
        exhaust: noop
      },
      xtolerance: domain.xtolerance,
      ytolerance: domain.ytolerance
    };

    subsampleImplicitRecursive(
      opts, a + b,
      xmin, ymax, fn(xmin, ymax),
      xmax, ymax, fn(xmax, ymax),
      xmax, ymin, fn(xmax, ymin),
      xmin, ymin, fn(xmin, ymin)
    );

    return {
      segments: accumulator,
      resolved: resolved
    };
  }

  function subsampleImplicitRecursive (
    opts, depth,
    xtl, ytl, ftl,
    xtr, ytr, ftr,
    xbr, ybr, fbr,
    xbl, ybl, fbl
  ) {
    /* jshint maxcomplexity:19 */
    var fn = opts.fn;
    var mindepth = opts.mindepth;
    var accumulator = opts.accumulator;
    var xtolerance = opts.xtolerance;
    var ytolerance = opts.ytolerance;

    if (!depth) depth = 0;
    if (depth < 0) {
      accumulator.exhaust();
      return;
    }

    // No point in continuing to divide once the grid edges are
    // smaller than the tolerances.
    if (Math.abs(xtl - xtr) < 2*xtolerance && Math.abs(ytl - ybl) < 2*ytolerance) {
      depth = 0;
    }

    depth--;

    // Calculate midpoints of 4 edges, and the midpoint of the box.
    var xtm = 0.5*(xtl + xtr);
    var ytm = 0.5*(ytl + ytr);
    var ftm = fn(xtm, ytm);

    var xml = 0.5*(xtl + xbl);
    var yml = 0.5*(ytl + ybl);
    var fml = fn(xml, yml);

    var xmr = 0.5*(xtr + xbr);
    var ymr = 0.5*(ytr + ybr);
    var fmr = fn(xmr, ymr);

    var xbm = 0.5*(xbl + xbr);
    var ybm = 0.5*(ybl + ybr);
    var fbm = fn(xbm, ybm);

    var xmm = 0.5*(xml + xmr);
    var ymm = 0.5*(ytm + ybm);
    var fmm = fn(xmm, ymm);

    // Descend recursively into each of the 4 subboxes of the current box.
    var descend = function () {
      subsampleImplicitRecursive(
        opts, depth,
        xtl, ytl, ftl,
        xtm, ytm, ftm,
        xmm, ymm, fmm,
        xml, yml, fml
      );
      subsampleImplicitRecursive(
        opts, depth,
        xtm, ytm, ftm,
        xtr, ytr, ftr,
        xmr, ymr, fmr,
        xmm, ymm, fmm
      );
      subsampleImplicitRecursive(
        opts, depth,
        xmm, ymm, fmm,
        xmr, ymr, fmr,
        xbr, ybr, fbr,
        xbm, ybm, fbm
      );
      subsampleImplicitRecursive(
        opts, depth,
        xml, yml, fml,
        xmm, ymm, fmm,
        xbm, ybm, fbm,
        xbl, ybl, fbl
      );
    };

    if (depth > mindepth) return descend();

    // If box contains both finite and non-finite vertices, descend
    if (
      isFinite(ftl) !== isFinite(ftr) ||
      isFinite(ftl) !== isFinite(fbr) ||
      isFinite(ftl) !== isFinite(fbl)
    ) return descend();

    // Check for oxo or xox edges and descend.
    if (ftl > 0 === ftr > 0 && ftm > 0 !== ftl > 0) {
      return descend();
    }
    if (ftr > 0 === fbr > 0 && fmr > 0 !== ftr > 0) {
      return descend();
    }
    if (fbr > 0 === fbl > 0 && fbm > 0 !== fbr > 0) {
      return descend();
    }
    if (fbl > 0 === ftl > 0 && fml > 0 !== fbl > 0) {
      return descend();
    }

    // Check for xo/ox or ox/xo boxes and descend.
    if (ftl > 0 !== ftr > 0 && ftr > 0 !== fbr > 0 && fbr > 0 !== fbl > 0) {
      return descend();
    }

    // Check for oo/oo or xx/xx boxes and do nothing
    if (ftl > 0 === ftr > 0 && ftr > 0 === fbr > 0 && fbr > 0 === fbl > 0) {
      return;
    }

    // At this point, we know there are exactly two xo or ox edges in the box.
    // Interpolate is called with a 3-point edge (corner, midpoint, corner),
    // and if the signs of the function values are appropriate, pushes an edge
    // intersection onto the intersections accumulator.
    var intersections = [];
    var interpolate = function (x0, y0, f0, x1, y1, f1, x2, y2, f2) {
      /* jshint maxcomplexity:11 */
      var code = 1*(f0 > 0) + 2*(f1 > 0) + 4*(f2 > 0);

      var a, xm0, xm1, ym0, ym1;
      switch (code) {
        case 0: return false; // ooo
        case 7: return false; // xxx

        case 2: return true; // oxo
        case 5: return true; // xox

        case 1: // xoo
          a = f0/(f0 - f2);
          xm0 = (1 - a)*x0 + a*x2;
          ym0 = (1 - a)*y0 + a*y2;
          a = f0/(f0 - f1);
          xm1 = (1 - a)*x0 + a*x1;
          ym1 = (1 - a)*y0 + a*y1;
          break;

        case 4: // oox
          a = f2/(f2 - f0);
          xm0 = (1 - a)*x2 + a*x0;
          ym0 = (1 - a)*y2 + a*y0;
          a = f2/(f2 - f1);
          xm1 = (1 - a)*x2 + a*x1;
          ym1 = (1 - a)*y2 + a*y1;
          break;

        case 3: // xxo
          a = f0/(f0 - f2);
          xm0 = (1 - a)*x0 + a*x2;
          ym0 = (1 - a)*y0 + a*y2;
          a = f1/(f1 - f2);
          xm1 = (1 - a)*x1 + a*x2;
          ym1 = (1 - a)*y1 + a*y2;
          break;

        case 6: // oxx
          a = f2/(f2 - f0);
          xm0 = (1 - a)*x2 + a*x0;
          ym0 = (1 - a)*y2 + a*y0;
          a = f1/(f1 - f0);
          xm1 = (1 - a)*x1 + a*x0;
          ym1 = (1 - a)*y1 + a*y0;
          break;
      }

      if (Math.abs(xm1 - xm0) > xtolerance || Math.abs(ym1 - ym0) > ytolerance) {
        if (depth >= 0) {
          return true; // At recursion bottom, just draw the line.
        } else {
          accumulator.exhaust();
        }
      }
      intersections.push(xm1, ym1);
      return false;
    };

    // Interpolate each of the 4 edges, and descend if the interpolate routine
    // indicates further precision is necessary.
    if (interpolate(xtl, ytl, ftl, xtm, ytm, ftm, xtr, ytr, ftr)) {
      return descend();
    }
    if (interpolate(xtr, ytr, ftr, xmr, ymr, fmr, xbr, ybr, fbr)) {
      return descend();
    }
    if (interpolate(xbr, ybr, fbr, xbm, ybm, fbm, xbl, ybl, fbl)) {
      return descend();
    }
    if (interpolate(xbl, ybl, fbl, xml, yml, fml, xtl, ytl, ftl)) {
      return descend();
    }

    // Check for differing signs on either side of intersection midpoint
    var x1 = intersections[0];
    var y1 = intersections[1];
    var x2 = intersections[2];
    var y2 = intersections[3];

    var xm = Distance.mean(x1, x2);
    var ym = Distance.mean(y1, y2);

    var dx = x2 - x1;
    var dy = y2 - y1;

    var length = Distance.hypot(dx, dy);

    var fm = fn(xm, ym);
    var f1 = fn(xm + dy/length*ytolerance, ym - dx/length*xtolerance);
    var f2 = fn(xm - dy/length*ytolerance, ym + dx/length*xtolerance);

    if (f1 > fm === f2 > fm) return descend(); // Looks like an asymptote, not a 0 crossing.
    if (f1 > 0 === f2 > 0) {
      if (depth >= 0) {
        return descend();
      } else {
        accumulator.exhaust();
      }
    }

    accumulator.push(intersections);
  }

  function validateViewState (viewState) {
    if (!viewState) return false;
    var xmin = viewState.viewport.xmin;
    var xmax = viewState.viewport.xmax;
    var ymin = viewState.viewport.ymin;
    var ymax = viewState.viewport.ymax;
    if (!isFinite(xmin) || !isFinite(xmax) || xmax <= xmin) return false;
    if (!isFinite(ymin) || !isFinite(ymax) || ymax <= ymin) return false;
    if (!isFinite(viewState.screen.width) || viewState.screen.width <= 0) return false;
    if (!isFinite(viewState.screen.height) || viewState.screen.height <= 0) return false;
    return true;
  }

  // May return false to indicate either an unrecoginzed GRAPHMODE,
  // or function with a domain that doesn't overlap the viewport.
  function computeDomain (viewState, graphInfo, fn) {
    var xmin = viewState.viewport.xmin;
    var xmax = viewState.viewport.xmax;
    var ymin = viewState.viewport.ymin;
    var ymax = viewState.viewport.ymax;
    var trigAngleMultiplier = viewState.trigAngleMultiplier || 1.0;

    var oversample = viewState.oversample || 4;
    var xtolerance = 1/oversample*(xmax - xmin)/viewState.screen.width;
    var ytolerance = 1/oversample*(ymax - ymin)/viewState.screen.height;
    var domainBound = graphInfo.domainBound;

    var domain;
    switch(graphInfo.graphMode) {
      case GRAPHMODE.X:
        ymin = Math.max(ymin, domainBound[0]);
        ymax = Math.min(ymax, domainBound[1]);
        if (!isFinite(ymax) || !isFinite(ymin) || ymax <= ymin) return false;
        domain = {
          min: ymin,
          max: ymax,
          xtolerance: ytolerance, // Note, switched
          ytolerance: xtolerance,
          step: ytolerance
        };
        break;
      case GRAPHMODE.Y:
        xmin = Math.max(xmin, domainBound[0]);
        xmax = Math.min(xmax, domainBound[1]);
        if (!isFinite(xmax) || !isFinite(xmin) || xmax <= xmin) return false;
        domain = {
         min: xmin,
         max: xmax,
         xtolerance: xtolerance,
         ytolerance: ytolerance,
         step: xtolerance
        };
        break;
      case GRAPHMODE.POLAR:
        domain = {
          min :0,
          max: 2*Math.PI/trigAngleMultiplier*6,
          step: (2*Math.PI/trigAngleMultiplier)/1000,
          tolerance: Math.min(xtolerance, ytolerance)
        };
        var period = findPiPeriod(fn, domain, trigAngleMultiplier, graphInfo.operator === '=');
        if (period) domain.max = domain.min + period;
        break;
      case GRAPHMODE.PARAMETRIC:
        //this catch fixes a bug where center coordinate of image
        //with free variables of t would crash
        if (graphInfo.domain) domain = {
          min: graphInfo.domain.min,
          max: graphInfo.domain.max,
          step: graphInfo.domain.step,
          xtolerance: xtolerance,
          ytolerance: ytolerance
        };
        break;
      case GRAPHMODE.IMPLICIT:
        domain = {
          xmin: xmin,
          xmax: xmax,
          ymin: ymin,
          ymax: ymax,
          xtolerance: xtolerance,
          ytolerance: ytolerance
        };
        break;
      default:
        return false;
    }
    return domain;
  }

  function classifyBranchConic (segments) {
    var conic, segmentConic;
    if (segments.length === 1 && segments[0].length === 4) return 'line';
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      var len = segment.length;
      if (len < 12) return 'unknown';
      try {
        segmentConic = Distance.classifyConic(
          segment[0], segment[1],
          segment[2*Math.floor(1*len/12)], segment[2*Math.floor(1*len/12) + 1],
          segment[2*Math.floor(2*len/12)], segment[2*Math.floor(2*len/12) + 1],
          segment[2*Math.floor(3*len/12)], segment[2*Math.floor(3*len/12) + 1],
          segment[2*Math.floor(4*len/12)], segment[2*Math.floor(4*len/12) + 1],
          segment[len - 2], segment[len - 1]
        );
      } catch (e) {
        // numeric.js's SVD routine can fail to converge and throw an error.
        return 'unknown';
      }

      if (segmentConic === 'none') return 'none';
      if (conic && segmentConic !== conic) return 'none';
      conic = segmentConic;
    }
    return conic;
  }

  //Computes domain, decides what function to use, and returns answer
  function computeGraphData (viewState, graphInfo, fn, derivative) {
    /* jshint maxcomplexity:12 */
    var domain = computeDomain(viewState, graphInfo, fn);
    var segmentData;
    var segments;
    var tmp;
    if (!domain) {
      segments = [];
      segmentData = {resolved: true};
    } else {
      switch(graphInfo.graphMode) {
        case GRAPHMODE.X:
        case GRAPHMODE.Y:
          segmentData = graphInfo.isLinear ? sampleLinear(graphInfo.linearCoefficients, domain) : sampleXY(fn, domain);
        break;
        case GRAPHMODE.POLAR:
        segmentData = samplePolar(fn, domain);
        break;
        case GRAPHMODE.IMPLICIT:
        segmentData = sampleImplicitRecursive(fn, domain);
        break;
        case GRAPHMODE.PARAMETRIC:
        if (!domain.step) domain.step = (domain.max - domain.min) / 1000;
        segmentData = sampleParametricRecursive(fn, domain);
      }

      segments = segmentData.segments;
    }


    var poi = [];
    if (
      graphInfo.graphMode !== GRAPHMODE.PARAMETRIC &&
      graphInfo.graphMode !== GRAPHMODE.IMPLICIT
    ) {
      poi = POI.findPOIs(segments, fn, derivative);
      segments = interleaveExtrema(segments, poi);
    }

    // Flip POI representation if necessary
    if (graphInfo.graphMode === GRAPHMODE.X) {
      for (var type in poi) {
        if (!poi.hasOwnProperty(type)) continue;
        tmp = poi[type].y;
        poi[type].y = poi[type].x;
        poi[type].x = tmp;
      }
    }

    var datum = {
      segments: segments,
      resolved: segmentData.resolved,
      graphMode: graphInfo.graphMode,
      color: graphInfo.color,
      style: graphInfo.style,
      operator: graphInfo.operator,
      poi: poi,
      conic: (graphInfo.graphMode === GRAPHMODE.IMPLICIT) ? 'unknown' : classifyBranchConic(segments),
      expr: null //compiled.fn
    };
    return datum;
  }

  function interleaveExtrema (segments, poi) {
    var nsegments = segments.length;
    var segment;
    var newSegments = Array(nsegments);
    var newSegment;
    var slen;
    var extrema = poi.extrema;
    var j=0;
    var elen = extrema.x.length;

    for (var n = 0; n < nsegments; n++) {
      segment = segments[n];
      slen = segment.length;
      newSegment = [];
      for (var i=0; i < slen; i = i+2) {
        // push extrema between last point and current point onto
        // accumulator.
        while (j < elen && extrema.x[j] <= segment[i]) {
          // Don't push the same point twice
          if (extrema.x[j] !== segment[i]) {
            newSegment.push(extrema.x[j], extrema.y[j]);
          }
          j++;
        }
        // push current point onto accumulator.
        newSegment.push(segment[i], segment[i+1]);
      }
      newSegments[n] = newSegment;
    }
    return newSegments;
  }

  function polygonFromSegments (bottom_segments, top_segments, graphMode) {
    //TODO - respect graphMode (by pushing in proper order)
    var i, j, p, segment;
    var polygon = [];
    var map;
    switch (graphMode) {
      case GRAPHMODE.POLAR:
        map = this.mapPolar;
        break;
      case GRAPHMODE.X:
        map = function(p) {return [p[1], p[0]];};
        break;
    }
    for (i = 0; i < bottom_segments.length; i++) {
      segment = bottom_segments[i];
      for (j = 0; j < segment.length; j += 2) {
        p = [segment[j], segment[j+1]];
        if (map) p = map(p);
        polygon.push(p[0], p[1]);
      }
    }
    for (i = top_segments.length - 1; i>=0; i--) {
      segment = top_segments[i];
      for (j = segment.length - 2; j >= 0; j -= 2) {
        p = [segment[j], segment[j+1]];
        if (map) p = map(p);
        polygon.push(p[0], p[1]);
      }
    }
    return polygon;
  }


  function polygonsFromSegments (bottom_segments, top_segments, graphMode) {
    var last_x = function (segments) {
      var last_segment = segments[segments.length - 1];
      return last_segment[last_segment.length - 2];
    };

    var polygons = [];
    //Until we have pulled the last segment:
      //Continue to pull segments from the top and the bottom until we find two which end at the same point.
      //When that happens, close the polygon, and start another one.
    var i_top = 0;
    var i_bottom = 0;
    var current_bottom = [];
    var current_top = [];
    var top_x = -Infinity;
    var bottom_x = -Infinity;

    while (true) {

      if (top_x <= bottom_x) {
        if (i_top >= top_segments.length) break;
        current_top.push(top_segments[i_top++]);
      }
      if (bottom_x <= top_x) {
        if (i_bottom >= bottom_segments.length) break;
        current_bottom.push(bottom_segments[i_bottom++]);
      }
      top_x = last_x(current_top);
      bottom_x = last_x(current_bottom);

      if (top_x == bottom_x) {
        polygons.push(polygonFromSegments(current_bottom, current_top, graphMode));
        current_top = [];
        current_bottom = [];
      }
    }
    return polygons;
  }

  return {
    Accumulator: Accumulator,
    sampleParametricNaive: sampleParametricNaive,
    sampleXYNaive: sampleXYNaive,
    sampleLinear: sampleLinear,
    sampleXY: sampleXY,
    findPiPeriod: findPiPeriod,
    samplePolar: samplePolar,
    sampleParametricRecursive: sampleParametricRecursive,
    subsampleParametricRecursive: subsampleParametricRecursive,
    sampleImplicitRecursive: sampleImplicitRecursive,
    subsampleImplicitRecursive: subsampleImplicitRecursive,
    validateViewState: validateViewState,
    computeDomain: computeDomain,
    computeGraphData: computeGraphData,
    polygonsFromSegments: polygonsFromSegments
  };
});

define('jison',[], function(){
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"sentence":3,"expr":4,"EOF":5,"assignment":6,"equation":7,"function_declaration":8,"regression":9,"ordered_pair_list":10,"double_inequality":11,"boolean":12,"identifier":13,"=":14,"FUNCTION_PROTOTYPE":15,",":16,"~":17,"comparator":18,"IDENTIFIER_BASE":19,"ordered_pair_list_elements":20,"ordered_pair":21,"(":22,")":23,"list":24,"[":25,"list_elements":26,"]":27,"range":28,"optional_commas_ellipsis":29,"...":30,"list_element_access":31,"expr_atom":32,"expr_sum":33,"<":34,">":35,">=":36,"<=":37,"+":38,"expr_product":39,"-":40,"expr_atom_impmul":41,"*":42,"/":43,"exponent":44,"^N":45,"^I":46,"^":47,"{":48,"}":49,"function_call":50,"function_call_unary":51,"trig_function_call":52,"log_function_call":53,"ln_function_call":54,"left|":55,"right|":56,"FRAC":57,"SQRT":58,"!":59,"repeated_operator":60,"DERIVATIVE":61,"expr_piecewise":62,"constant":63,"NUMBER":64,"repeated_operator_symbol":65,"SUM":66,"PROD":67,"_":68,"{_visible":69,"piecewise_list":70,"}_visible":71,"incomplete_piecewise_list":72,"piecewise_element":73,":":74,"trig_function":75,"TRIG_FUNCTION":76,"log_prefix":77,"LOG":78,"LOG_BASE_N":79,"LN":80,"function_argument_list":81,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",14:"=",15:"FUNCTION_PROTOTYPE",16:",",17:"~",19:"IDENTIFIER_BASE",22:"(",23:")",25:"[",27:"]",30:"...",34:"<",35:">",36:">=",37:"<=",38:"+",40:"-",42:"*",43:"/",45:"^N",46:"^I",47:"^",48:"{",49:"}",55:"left|",56:"right|",57:"FRAC",58:"SQRT",59:"!",61:"DERIVATIVE",64:"NUMBER",66:"SUM",67:"PROD",68:"_",69:"{_visible",71:"}_visible",74:":",76:"TRIG_FUNCTION",78:"LOG",79:"LOG_BASE_N",80:"LN"},
productions_: [0,[3,2],[3,2],[3,2],[3,2],[3,2],[3,2],[3,2],[3,2],[3,3],[3,2],[3,4],[3,1],[6,3],[9,3],[7,3],[11,5],[13,1],[10,1],[20,1],[20,3],[21,5],[24,3],[28,5],[29,1],[29,2],[29,2],[29,3],[26,1],[26,3],[31,4],[4,1],[18,1],[18,1],[18,1],[18,1],[12,3],[12,3],[12,5],[33,3],[33,3],[33,1],[39,2],[39,3],[39,3],[39,1],[44,1],[44,1],[44,4],[41,1],[41,1],[41,1],[41,1],[41,1],[41,1],[41,3],[41,3],[41,3],[41,2],[41,7],[41,4],[41,7],[41,2],[41,1],[41,2],[41,1],[32,1],[32,3],[32,2],[32,2],[32,2],[32,1],[32,1],[32,1],[32,1],[65,1],[65,1],[60,9],[62,3],[62,2],[70,3],[70,1],[72,3],[72,1],[73,3],[73,1],[63,1],[63,2],[51,5],[51,4],[75,1],[52,4],[52,2],[52,7],[52,9],[52,3],[52,5],[77,1],[77,1],[77,3],[77,5],[53,4],[53,2],[53,5],[53,3],[54,4],[54,2],[54,5],[54,3],[50,4],[81,3],[81,3],[8,2]],
performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {

var $0 = $$.length - 1;
switch (yystate) {
case 1: return $$[$0-1];
break;
case 2: return $$[$0-1];
break;
case 3: return $$[$0-1];
break;
case 4: return $$[$0-1];
break;
case 5: return $$[$0-1];
break;
case 6: return $$[$0-1];
break;
case 7: return $$[$0-1];
break;
case 8: return $$[$0-1];
break;
case 9: return yy.ErrorMsg.missingRHS($$[$0-2]._symbol);
break;
case 10: var symbol = yy.parseFunctionDeclaration($$[$0-1]).identifier._symbol;
          return yy.ErrorMsg.missingRHS(symbol);

break;
case 11: return yy.ErrorMsg.malformedPoint();
break;
case 12: return yy.ErrorMsg.blankExpression();
break;
case 13:this.$ = yy.Assignment($$[$0-2], $$[$0]);
          yy.setInput(this.$, this._$);

break;
case 14:this.$ = yy.Regression($$[$0-2], $$[$0]);
        yy.setInput(this.$, this._$);

break;
case 15:this.$ = yy.Equation($$[$0-2], $$[$0]);
          yy.setInput(this.$, this._$);

break;
case 16:this.$ = yy.DoubleInequality([$$[$0-4], $$[$0-3], $$[$0-2], $$[$0-1], $$[$0]]);
        yy.setInput(this.$, this._$);

break;
case 17:this.$ = yy.Identifier(yytext);
        yy.setInput(this.$, this._$);

break;
case 18:this.$ = yy.OrderedPair.fromList($$[$0]);
      yy.setInput(this.$, this._$);

break;
case 19: this.$ = [($$[$0])];
break;
case 20: $$[$0-2].push($$[$0]); this.$ = $$[$0-2]
break;
case 21: this.$ = yy.OrderedPair([$$[$0-3], $$[$0-1]]);
break;
case 22:this.$ = yy.List($$[$0-1]);
      yy.setInput(this.$, this._$);

break;
case 23: this.$ = yy.Range([yy.List($$[$0-3]), yy.List($$[$0-1])]);
break;
case 28: this.$ = [$$[$0]]
break;
case 29: $$[$0-2].push($$[$0]); this.$ = $$[$0-2]
break;
case 30: this.$ = yy.ListAccess([$$[$0-3], $$[$0-1]])
break;
case 31:this.$ = $$[$0];
      yy.setInput(this.$, this._$);

break;
case 32:this.$ = '<'
break;
case 33:this.$ = '>'
break;
case 34:this.$ = '>='
break;
case 35:this.$ = '<='
break;
case 36:this.$ = yy.Comparator[$$[$0-1]]([$$[$0-2], $$[$0]]);
        yy.setInput(this.$, this._$);

break;
case 37:this.$ = yy.Comparator['=']([$$[$0-2], $$[$0]]);
        yy.setInput(this.$, this._$);

break;
case 38:
        var c1 = yy.Comparator[$$[$0-3]]([$$[$0-4], $$[$0-2]]);
        var c2 = yy.Comparator[$$[$0-1]]([$$[$0-2], $$[$0]]);
        this.$ = yy.And([c1, c2]);
        yy.setInput(this.$, this._$);

break;
case 39:this.$ = yy.Add([$$[$0-2], $$[$0]]);
break;
case 40:this.$ = yy.Subtract([$$[$0-2], $$[$0]]);
break;
case 41:this.$ = $$[$0]
break;
case 42:this.$ = yy.Multiply([$$[$0-1], $$[$0]]);
break;
case 43:this.$ = yy.Multiply([$$[$0-2], $$[$0]]);
break;
case 44:this.$ = yy.Divide([$$[$0-2], $$[$0]]);
break;
case 45:this.$ = $$[$0];
break;
case 46:this.$ = yy.Constant(Number($$[$0]));
break;
case 47:this.$ = yy.Identifier($$[$0]);
break;
case 48:this.$ = $$[$0-1];
break;
case 49:this.$ = $$[$0];
break;
case 50:this.$ = $$[$0];
break;
case 51:this.$ = $$[$0];
break;
case 52:this.$ = $$[$0];
break;
case 53:this.$ = $$[$0];
break;
case 54:this.$ = $$[$0];
break;
case 55:this.$ = $$[$0-1];
break;
case 56:this.$ = $$[$0-1];
break;
case 57:this.$ = yy.FunctionCall('\\abs', [$$[$0-1]]);
break;
case 58:this.$ = yy.Exponent([$$[$0-1], $$[$0]]);
break;
case 59:this.$ = yy.Divide([$$[$0-4], $$[$0-1]]);
break;
case 60:this.$ = yy.FunctionCall('\\sqrt', [$$[$0-1]]);
break;
case 61:this.$ = yy.FunctionCall('\\nthroot', [$$[$0-1], $$[$0-4]]);
break;
case 62:this.$ = yy.FunctionCall('\\factorial', [$$[$0-1]])
break;
case 63:this.$ = $$[$0];
break;
case 64:this.$ = yy.Derivative($$[$0-1], [$$[$0]]);
break;
case 65:this.$ = $$[$0]
break;
case 66:this.$ = $$[$0];
break;
case 67:this.$ = yy.Negative([yy.Exponent([yy.Constant(Number($$[$0-1])), $$[$0]])]);
break;
case 68:this.$ = yy.Exponent([$$[$0-1], $$[$0]]);
break;
case 69:this.$ = yy.FunctionCall('\\factorial', [$$[$0-1]])
break;
case 70:this.$ = yy.Negative([$$[$0]])
break;
case 71:this.$ = $$[$0]
break;
case 72:this.$ = $$[$0]
break;
case 73:this.$ = $$[$0]
break;
case 74:this.$ = $$[$0]
break;
case 75:this.$ = yy.Sum;
break;
case 76:this.$ =  yy.Product;
break;
case 77:this.$ = $$[$0-8]([$$[$0-5], $$[$0-3], $$[$0-1], $$[$0]]);
break;
case 78:this.$ = yy.Piecewise.chain($$[$0-1]);
break;
case 79:this.$ = yy.Constant(1);
break;
case 80:$$[$0-2].push({condition:yy.Constant(true), if_expr:$$[$0]}); this.$=$$[$0-2];
break;
case 81:this.$=$$[$0]
break;
case 82:$$[$0-2].push($$[$0]); this.$=$$[$0-2];
break;
case 83:this.$=[$$[$0]];
break;
case 84:this.$={condition: $$[$0-2], if_expr: $$[$0]};
break;
case 85:this.$={condition: $$[$0], if_expr: yy.Constant(1)};
break;
case 86:this.$ = yy.Constant(Number(yytext));
break;
case 87:this.$ = yy.Constant(-$$[$0])
break;
case 88:this.$ = yy.FunctionExponent([$$[$0-4], $$[$0-2], $$[$0]]);
break;
case 89:this.$ = yy.FunctionCall($$[$0-3], [$$[$0-1]]);
break;
case 90:this.$ = yy.Identifier(yytext);
break;
case 91:this.$ = yy.FunctionCall($$[$0-3], [$$[$0-1]]);
break;
case 92:
          if(!$$[$0].okForImplicitFunction()) {throw yy.ErrorMsg.badTrigImplicitMultiply();};
          this.$ = yy.FunctionCall($$[$0-1], [$$[$0]]);

break;
case 93:
          if(!$$[$0].okForImplicitFunction()) {throw yy.ErrorMsg.badTrigImplicitMultiply();};
          if($$[$0-2].constantValue != 1) {throw yy.ErrorMsg.badTrigExponent($$[$0-6]._symbol);};
          this.$ = yy.FunctionCall(yy.Identifier(yy.inverses[$$[$0-6]._symbol]), [$$[$0]]);

break;
case 94:
          if($$[$0-4].constantValue != 1) {throw yy.ErrorMsg.badTrigExponent($$[$0-8]._symbol);};
          this.$ = yy.FunctionCall(yy.Identifier(yy.inverses[$$[$0-8]._symbol]), [$$[$0-1]]);

break;
case 95:
          if(!$$[$0].okForImplicitFunction()) {throw yy.ErrorMsg.badTrigImplicitMultiply();};
          if($$[$0-1] != "2") {throw yy.ErrorMsg.badTrigExponent($$[$0-2]._symbol);};
          this.$ = yy.Exponent([yy.FunctionCall($$[$0-2], [$$[$0]]), yy.Constant(2)]);

break;
case 96:
          if($$[$0-3] != "2") {throw yy.ErrorMsg.badTrigExponent($$[$0-4]._symbol);};
          this.$ = yy.Exponent([yy.FunctionCall($$[$0-4], [$$[$0-1]]), yy.Constant(2)]);

break;
case 97: this.$ = yy.Constant(10)
break;
case 98: this.$ = yy.Constant(Number(yytext));
break;
case 99: this.$ = $$[$0]
break;
case 100: this.$ = $$[$0-1]
break;
case 101:this.$ = yy.FunctionCall(yy.Identifier('log'), [$$[$0-1], $$[$0-3]])
break;
case 102:
      if(!$$[$0].okForImplicitFunction()) {throw yy.ErrorMsg.badLogImplicitMultiply();};
      this.$ = yy.FunctionCall(yy.Identifier('log'), [$$[$0], $$[$0-1]])

break;
case 103:
      if($$[$0-3] != "2") {throw yy.ErrorMsg.badLogExponent('log');}
      this.$ = yy.Exponent([yy.FunctionCall(yy.Identifier('log'), [$$[$0-1], $$[$0-4]]), yy.Constant(2)])

break;
case 104:
      if(!$$[$0].okForImplicitFunction()) {throw yy.ErrorMsg.badLogImplicitMultiply();};
      if($$[$0-1] != "2") {throw yy.ErrorMsg.badLogExponent('log');}
      this.$ = yy.Exponent([yy.FunctionCall(yy.Identifier('log'), [$$[$0], $$[$0-2]]), yy.Constant(2)])

break;
case 105:this.$ = yy.FunctionCall(yy.Identifier('ln'), [$$[$0-1]])
break;
case 106:
      if(!$$[$0].okForImplicitFunction()) {throw yy.ErrorMsg.badLogImplicitMultiply();};
      this.$ = yy.FunctionCall(yy.Identifier('ln'), [$$[$0]])

break;
case 107:
      if($$[$0-3] != "2") {throw yy.ErrorMsg.badLogExponent('ln');}
      this.$ = yy.Exponent([yy.FunctionCall(yy.Identifier('ln'), [$$[$0-1]]), yy.Constant(2)])

break;
case 108:
      if(!$$[$0].okForImplicitFunction()) {throw yy.ErrorMsg.badLogImplicitMultiply();};
      if($$[$0-1] != "2") {throw yy.ErrorMsg.badLogExponent('ln');}
      this.$ = yy.Exponent([yy.FunctionCall(yy.Identifier('ln'), [$$[$0]]), yy.Constant(2)])

break;
case 109:this.$ = yy.FunctionCall($$[$0-3], $$[$0-1]);
break;
case 110:this.$ = $$[$0-2].concat([$$[$0]]);
break;
case 111:this.$ = [$$[$0-2], $$[$0]];
break;
case 112:var val = yy.parseFunctionDeclaration($$[$0-1]); this.$ = yy.FunctionDefinition(val.identifier, val.args, $$[$0]);
        yy.setInput(this.$, this._$);

break;
}
},
table: [{3:1,4:2,5:[1,12],6:3,7:4,8:5,9:6,10:7,11:8,12:9,13:10,15:[1,11],19:[1,15],20:14,21:17,22:[1,19],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{1:[3]},{5:[1,50],14:[1,52],16:[1,51],17:[1,53],18:54,34:[1,55],35:[1,56],36:[1,57],37:[1,58]},{5:[1,59]},{5:[1,60]},{5:[1,61]},{5:[1,62]},{5:[1,63]},{5:[1,64]},{5:[1,65]},{5:[2,49],14:[1,66],16:[2,49],17:[2,49],19:[2,49],22:[1,67],25:[2,49],34:[2,49],35:[2,49],36:[2,49],37:[2,49],38:[2,49],40:[2,49],42:[2,49],43:[2,49],45:[2,49],46:[2,49],47:[2,49],48:[2,49],55:[2,49],57:[2,49],58:[2,49],59:[2,49],61:[2,49],66:[2,49],67:[2,49],69:[2,49],76:[2,49],78:[2,49],79:[2,49],80:[2,49]},{4:69,5:[1,68],13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{1:[2,12]},{5:[2,31],14:[2,31],16:[2,31],17:[2,31],19:[2,31],22:[2,31],23:[2,31],25:[2,31],27:[2,31],30:[2,31],34:[2,31],35:[2,31],36:[2,31],37:[2,31],38:[1,72],40:[1,73],42:[2,31],43:[2,31],45:[2,31],46:[2,31],47:[2,31],48:[2,31],49:[2,31],55:[2,31],56:[2,31],57:[2,31],58:[2,31],59:[2,31],61:[2,31],66:[2,31],67:[2,31],69:[2,31],71:[2,31],74:[2,31],76:[2,31],78:[2,31],79:[2,31],80:[2,31]},{5:[2,18],16:[1,74]},{5:[2,17],14:[2,17],16:[2,17],17:[2,17],19:[2,17],22:[2,17],23:[2,17],25:[2,17],27:[2,17],30:[2,17],34:[2,17],35:[2,17],36:[2,17],37:[2,17],38:[2,17],40:[2,17],42:[2,17],43:[2,17],45:[2,17],46:[2,17],47:[2,17],48:[2,17],49:[2,17],55:[2,17],56:[2,17],57:[2,17],58:[2,17],59:[2,17],61:[2,17],64:[2,17],66:[2,17],67:[2,17],69:[2,17],71:[2,17],74:[2,17],76:[2,17],78:[2,17],79:[2,17],80:[2,17]},{5:[2,41],13:70,14:[2,41],16:[2,41],17:[2,41],19:[1,15],22:[1,71],23:[2,41],25:[2,41],27:[2,41],30:[2,41],34:[2,41],35:[2,41],36:[2,41],37:[2,41],38:[2,41],40:[2,41],41:75,42:[1,76],43:[1,77],45:[2,41],46:[2,41],47:[2,41],48:[1,33],49:[2,41],50:28,51:29,52:30,53:31,54:32,55:[1,34],56:[2,41],57:[1,35],58:[1,36],59:[2,41],60:37,61:[1,38],62:39,65:43,66:[1,48],67:[1,49],69:[1,44],71:[2,41],74:[2,41],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,19],16:[2,19]},{5:[2,45],14:[2,45],16:[2,45],17:[2,45],19:[2,45],22:[2,45],23:[2,45],25:[1,80],27:[2,45],30:[2,45],34:[2,45],35:[2,45],36:[2,45],37:[2,45],38:[2,45],40:[2,45],42:[2,45],43:[2,45],44:78,45:[1,81],46:[1,82],47:[1,83],48:[2,45],49:[2,45],55:[2,45],56:[2,45],57:[2,45],58:[2,45],59:[1,79],61:[2,45],66:[2,45],67:[2,45],69:[2,45],71:[2,45],74:[2,45],76:[2,45],78:[2,45],79:[2,45],80:[2,45]},{4:84,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,66],14:[2,66],16:[2,66],17:[2,66],19:[2,66],22:[2,66],23:[2,66],25:[2,66],27:[2,66],30:[2,66],34:[2,66],35:[2,66],36:[2,66],37:[2,66],38:[2,66],40:[2,66],42:[2,66],43:[2,66],45:[2,66],46:[2,66],47:[2,66],48:[2,66],49:[2,66],55:[2,66],56:[2,66],57:[2,66],58:[2,66],59:[2,66],61:[2,66],66:[2,66],67:[2,66],69:[2,66],71:[2,66],74:[2,66],76:[2,66],78:[2,66],79:[2,66],80:[2,66]},{13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:86,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,85],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,71],14:[2,71],16:[2,71],17:[2,71],19:[2,71],22:[2,71],23:[2,71],25:[2,71],27:[2,71],30:[2,71],34:[2,71],35:[2,71],36:[2,71],37:[2,71],38:[2,71],40:[2,71],42:[2,71],43:[2,71],45:[2,71],46:[2,71],47:[2,71],48:[2,71],49:[2,71],55:[2,71],56:[2,71],57:[2,71],58:[2,71],59:[2,71],61:[2,71],66:[2,71],67:[2,71],69:[2,71],71:[2,71],74:[2,71],76:[2,71],78:[2,71],79:[2,71],80:[2,71]},{5:[2,72],14:[2,72],16:[2,72],17:[2,72],19:[2,72],22:[2,72],23:[2,72],25:[2,72],27:[2,72],30:[2,72],34:[2,72],35:[2,72],36:[2,72],37:[2,72],38:[2,72],40:[2,72],42:[2,72],43:[2,72],45:[2,72],46:[2,72],47:[2,72],48:[2,72],49:[2,72],55:[2,72],56:[2,72],57:[2,72],58:[2,72],59:[2,72],61:[2,72],66:[2,72],67:[2,72],69:[2,72],71:[2,72],74:[2,72],76:[2,72],78:[2,72],79:[2,72],80:[2,72]},{5:[2,73],14:[2,73],16:[2,73],17:[2,73],19:[2,73],22:[2,73],23:[2,73],25:[2,73],27:[2,73],30:[2,73],34:[2,73],35:[2,73],36:[2,73],37:[2,73],38:[2,73],40:[2,73],42:[2,73],43:[2,73],45:[2,73],46:[2,73],47:[2,73],48:[2,73],49:[2,73],55:[2,73],56:[2,73],57:[2,73],58:[2,73],59:[2,73],61:[2,73],66:[2,73],67:[2,73],69:[2,73],71:[2,73],74:[2,73],76:[2,73],78:[2,73],79:[2,73],80:[2,73]},{5:[2,74],14:[2,74],16:[2,74],17:[2,74],19:[2,74],22:[2,74],23:[2,74],25:[2,74],27:[2,74],30:[2,74],34:[2,74],35:[2,74],36:[2,74],37:[2,74],38:[2,74],40:[2,74],42:[2,74],43:[2,74],44:87,45:[1,81],46:[1,82],47:[1,83],48:[2,74],49:[2,74],55:[2,74],56:[2,74],57:[2,74],58:[2,74],59:[1,88],61:[2,74],66:[2,74],67:[2,74],69:[2,74],71:[2,74],74:[2,74],76:[2,74],78:[2,74],79:[2,74],80:[2,74]},{5:[2,86],14:[2,86],16:[2,86],17:[2,86],19:[2,86],22:[2,86],23:[2,86],25:[2,86],27:[2,86],30:[2,86],34:[2,86],35:[2,86],36:[2,86],37:[2,86],38:[2,86],40:[2,86],42:[2,86],43:[2,86],45:[2,86],46:[2,86],47:[2,86],48:[2,86],49:[2,86],55:[2,86],56:[2,86],57:[2,86],58:[2,86],59:[2,86],61:[2,86],66:[2,86],67:[2,86],69:[2,86],71:[2,86],74:[2,86],76:[2,86],78:[2,86],79:[2,86],80:[2,86]},{4:90,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],26:89,28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,50],14:[2,50],16:[2,50],17:[2,50],19:[2,50],22:[2,50],23:[2,50],25:[2,50],27:[2,50],30:[2,50],34:[2,50],35:[2,50],36:[2,50],37:[2,50],38:[2,50],40:[2,50],42:[2,50],43:[2,50],45:[2,50],46:[2,50],47:[2,50],48:[2,50],49:[2,50],55:[2,50],56:[2,50],57:[2,50],58:[2,50],59:[2,50],61:[2,50],66:[2,50],67:[2,50],69:[2,50],71:[2,50],74:[2,50],76:[2,50],78:[2,50],79:[2,50],80:[2,50]},{5:[2,51],14:[2,51],16:[2,51],17:[2,51],19:[2,51],22:[2,51],23:[2,51],25:[2,51],27:[2,51],30:[2,51],34:[2,51],35:[2,51],36:[2,51],37:[2,51],38:[2,51],40:[2,51],42:[2,51],43:[2,51],45:[2,51],46:[2,51],47:[2,51],48:[2,51],49:[2,51],55:[2,51],56:[2,51],57:[2,51],58:[2,51],59:[2,51],61:[2,51],66:[2,51],67:[2,51],69:[2,51],71:[2,51],74:[2,51],76:[2,51],78:[2,51],79:[2,51],80:[2,51]},{5:[2,52],14:[2,52],16:[2,52],17:[2,52],19:[2,52],22:[2,52],23:[2,52],25:[2,52],27:[2,52],30:[2,52],34:[2,52],35:[2,52],36:[2,52],37:[2,52],38:[2,52],40:[2,52],42:[2,52],43:[2,52],45:[2,52],46:[2,52],47:[2,52],48:[2,52],49:[2,52],55:[2,52],56:[2,52],57:[2,52],58:[2,52],59:[2,52],61:[2,52],66:[2,52],67:[2,52],69:[2,52],71:[2,52],74:[2,52],76:[2,52],78:[2,52],79:[2,52],80:[2,52]},{5:[2,53],14:[2,53],16:[2,53],17:[2,53],19:[2,53],22:[2,53],23:[2,53],25:[2,53],27:[2,53],30:[2,53],34:[2,53],35:[2,53],36:[2,53],37:[2,53],38:[2,53],40:[2,53],42:[2,53],43:[2,53],45:[2,53],46:[2,53],47:[2,53],48:[2,53],49:[2,53],55:[2,53],56:[2,53],57:[2,53],58:[2,53],59:[2,53],61:[2,53],66:[2,53],67:[2,53],69:[2,53],71:[2,53],74:[2,53],76:[2,53],78:[2,53],79:[2,53],80:[2,53]},{5:[2,54],14:[2,54],16:[2,54],17:[2,54],19:[2,54],22:[2,54],23:[2,54],25:[2,54],27:[2,54],30:[2,54],34:[2,54],35:[2,54],36:[2,54],37:[2,54],38:[2,54],40:[2,54],42:[2,54],43:[2,54],45:[2,54],46:[2,54],47:[2,54],48:[2,54],49:[2,54],55:[2,54],56:[2,54],57:[2,54],58:[2,54],59:[2,54],61:[2,54],66:[2,54],67:[2,54],69:[2,54],71:[2,54],74:[2,54],76:[2,54],78:[2,54],79:[2,54],80:[2,54]},{4:91,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:92,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{48:[1,93]},{25:[1,95],48:[1,94]},{5:[2,63],14:[2,63],16:[2,63],17:[2,63],19:[2,63],22:[2,63],23:[2,63],25:[2,63],27:[2,63],30:[2,63],34:[2,63],35:[2,63],36:[2,63],37:[2,63],38:[2,63],40:[2,63],42:[2,63],43:[2,63],45:[2,63],46:[2,63],47:[2,63],48:[2,63],49:[2,63],55:[2,63],56:[2,63],57:[2,63],58:[2,63],59:[2,63],61:[2,63],66:[2,63],67:[2,63],69:[2,63],71:[2,63],74:[2,63],76:[2,63],78:[2,63],79:[2,63],80:[2,63]},{13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,39:96,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,65],14:[2,65],16:[2,65],17:[2,65],19:[2,65],22:[2,65],23:[2,65],25:[2,65],27:[2,65],30:[2,65],34:[2,65],35:[2,65],36:[2,65],37:[2,65],38:[2,65],40:[2,65],42:[2,65],43:[2,65],45:[2,65],46:[2,65],47:[2,65],48:[2,65],49:[2,65],55:[2,65],56:[2,65],57:[2,65],58:[2,65],59:[2,65],61:[2,65],66:[2,65],67:[2,65],69:[2,65],71:[2,65],74:[2,65],76:[2,65],78:[2,65],79:[2,65],80:[2,65]},{13:70,19:[1,15],22:[1,97],24:22,25:[1,27],28:23,31:24,32:18,39:98,40:[1,21],41:25,45:[1,100],47:[1,99],48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{13:70,19:[1,15],22:[1,101],24:22,25:[1,27],28:23,31:24,32:18,39:102,40:[1,21],41:25,45:[1,103],48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{13:70,19:[1,15],22:[1,104],24:22,25:[1,27],28:23,31:24,32:18,39:105,40:[1,21],41:25,45:[1,106],48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{68:[1,107]},{4:113,12:112,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],70:108,71:[1,109],72:110,73:111,75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{19:[2,90],22:[2,90],25:[2,90],40:[2,90],45:[2,90],47:[2,90],48:[2,90],55:[2,90],57:[2,90],58:[2,90],61:[2,90],64:[2,90],66:[2,90],67:[2,90],69:[2,90],76:[2,90],78:[2,90],79:[2,90],80:[2,90]},{19:[2,97],22:[2,97],25:[2,97],40:[2,97],45:[2,97],48:[2,97],55:[2,97],57:[2,97],58:[2,97],61:[2,97],64:[2,97],66:[2,97],67:[2,97],68:[1,114],69:[2,97],76:[2,97],78:[2,97],79:[2,97],80:[2,97]},{19:[2,98],22:[2,98],25:[2,98],40:[2,98],45:[2,98],48:[2,98],55:[2,98],57:[2,98],58:[2,98],61:[2,98],64:[2,98],66:[2,98],67:[2,98],69:[2,98],76:[2,98],78:[2,98],79:[2,98],80:[2,98]},{68:[2,75]},{68:[2,76]},{1:[2,1]},{4:115,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:116,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:117,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:119,13:118,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{19:[2,32],22:[2,32],25:[2,32],40:[2,32],48:[2,32],55:[2,32],57:[2,32],58:[2,32],61:[2,32],64:[2,32],66:[2,32],67:[2,32],69:[2,32],76:[2,32],78:[2,32],79:[2,32],80:[2,32]},{19:[2,33],22:[2,33],25:[2,33],40:[2,33],48:[2,33],55:[2,33],57:[2,33],58:[2,33],61:[2,33],64:[2,33],66:[2,33],67:[2,33],69:[2,33],76:[2,33],78:[2,33],79:[2,33],80:[2,33]},{19:[2,34],22:[2,34],25:[2,34],40:[2,34],48:[2,34],55:[2,34],57:[2,34],58:[2,34],61:[2,34],64:[2,34],66:[2,34],67:[2,34],69:[2,34],76:[2,34],78:[2,34],79:[2,34],80:[2,34]},{19:[2,35],22:[2,35],25:[2,35],40:[2,35],48:[2,35],55:[2,35],57:[2,35],58:[2,35],61:[2,35],64:[2,35],66:[2,35],67:[2,35],69:[2,35],76:[2,35],78:[2,35],79:[2,35],80:[2,35]},{1:[2,2]},{1:[2,3]},{1:[2,4]},{1:[2,5]},{1:[2,6]},{1:[2,7]},{1:[2,8]},{4:121,5:[1,120],13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:123,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42],81:122},{1:[2,10]},{5:[2,112]},{5:[2,49],14:[2,49],16:[2,49],17:[2,49],19:[2,49],22:[1,67],23:[2,49],25:[2,49],27:[2,49],30:[2,49],34:[2,49],35:[2,49],36:[2,49],37:[2,49],38:[2,49],40:[2,49],42:[2,49],43:[2,49],45:[2,49],46:[2,49],47:[2,49],48:[2,49],49:[2,49],55:[2,49],56:[2,49],57:[2,49],58:[2,49],59:[2,49],61:[2,49],66:[2,49],67:[2,49],69:[2,49],71:[2,49],74:[2,49],76:[2,49],78:[2,49],79:[2,49],80:[2,49]},{4:124,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,39:125,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,39:126,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{21:127,22:[1,128]},{5:[2,42],14:[2,42],16:[2,42],17:[2,42],19:[2,42],22:[2,42],23:[2,42],25:[2,42],27:[2,42],30:[2,42],34:[2,42],35:[2,42],36:[2,42],37:[2,42],38:[2,42],40:[2,42],42:[2,42],43:[2,42],44:87,45:[1,81],46:[1,82],47:[1,83],48:[2,42],49:[2,42],55:[2,42],56:[2,42],57:[2,42],58:[2,42],59:[1,88],61:[2,42],66:[2,42],67:[2,42],69:[2,42],71:[2,42],74:[2,42],76:[2,42],78:[2,42],79:[2,42],80:[2,42]},{13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:129,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:130,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,68],14:[2,68],16:[2,68],17:[2,68],19:[2,68],22:[2,68],23:[2,68],25:[2,68],27:[2,68],30:[2,68],34:[2,68],35:[2,68],36:[2,68],37:[2,68],38:[2,68],40:[2,68],42:[2,68],43:[2,68],45:[2,68],46:[2,68],47:[2,68],48:[2,68],49:[2,68],55:[2,68],56:[2,68],57:[2,68],58:[2,68],59:[2,68],61:[2,68],66:[2,68],67:[2,68],69:[2,68],71:[2,68],74:[2,68],76:[2,68],78:[2,68],79:[2,68],80:[2,68]},{5:[2,69],14:[2,69],16:[2,69],17:[2,69],19:[2,69],22:[2,69],23:[2,69],25:[2,69],27:[2,69],30:[2,69],34:[2,69],35:[2,69],36:[2,69],37:[2,69],38:[2,69],40:[2,69],42:[2,69],43:[2,69],45:[2,69],46:[2,69],47:[2,69],48:[2,69],49:[2,69],55:[2,69],56:[2,69],57:[2,69],58:[2,69],59:[2,69],61:[2,69],66:[2,69],67:[2,69],69:[2,69],71:[2,69],74:[2,69],76:[2,69],78:[2,69],79:[2,69],80:[2,69]},{4:131,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,46],14:[2,46],16:[2,46],17:[2,46],19:[2,46],22:[2,46],23:[2,46],25:[2,46],27:[2,46],30:[2,46],34:[2,46],35:[2,46],36:[2,46],37:[2,46],38:[2,46],40:[2,46],42:[2,46],43:[2,46],45:[2,46],46:[2,46],47:[2,46],48:[2,46],49:[2,46],55:[2,46],56:[2,46],57:[2,46],58:[2,46],59:[2,46],61:[2,46],64:[2,46],66:[2,46],67:[2,46],69:[2,46],71:[2,46],74:[2,46],76:[2,46],78:[2,46],79:[2,46],80:[2,46]},{5:[2,47],14:[2,47],16:[2,47],17:[2,47],19:[2,47],22:[2,47],23:[2,47],25:[2,47],27:[2,47],30:[2,47],34:[2,47],35:[2,47],36:[2,47],37:[2,47],38:[2,47],40:[2,47],42:[2,47],43:[2,47],45:[2,47],46:[2,47],47:[2,47],48:[2,47],49:[2,47],55:[2,47],56:[2,47],57:[2,47],58:[2,47],59:[2,47],61:[2,47],64:[2,47],66:[2,47],67:[2,47],69:[2,47],71:[2,47],74:[2,47],76:[2,47],78:[2,47],79:[2,47],80:[2,47]},{48:[1,132]},{16:[1,133],23:[1,134]},{5:[2,87],14:[2,87],16:[2,87],17:[2,87],19:[2,87],22:[2,87],23:[2,87],25:[2,87],27:[2,87],30:[2,87],34:[2,87],35:[2,87],36:[2,87],37:[2,87],38:[2,87],40:[2,87],42:[2,87],43:[2,87],44:135,45:[1,81],46:[1,82],47:[1,83],48:[2,87],49:[2,87],55:[2,87],56:[2,87],57:[2,87],58:[2,87],59:[2,87],61:[2,87],66:[2,87],67:[2,87],69:[2,87],71:[2,87],74:[2,87],76:[2,87],78:[2,87],79:[2,87],80:[2,87]},{5:[2,70],14:[2,70],16:[2,70],17:[2,70],19:[2,70],22:[2,70],23:[2,70],25:[1,80],27:[2,70],30:[2,70],34:[2,70],35:[2,70],36:[2,70],37:[2,70],38:[2,70],40:[2,70],42:[2,70],43:[2,70],44:78,45:[1,81],46:[1,82],47:[1,83],48:[2,70],49:[2,70],55:[2,70],56:[2,70],57:[2,70],58:[2,70],59:[1,79],61:[2,70],66:[2,70],67:[2,70],69:[2,70],71:[2,70],74:[2,70],76:[2,70],78:[2,70],79:[2,70],80:[2,70]},{5:[2,58],14:[2,58],16:[2,58],17:[2,58],19:[2,58],22:[2,58],23:[2,58],25:[2,58],27:[2,58],30:[2,58],34:[2,58],35:[2,58],36:[2,58],37:[2,58],38:[2,58],40:[2,58],42:[2,58],43:[2,58],45:[2,58],46:[2,58],47:[2,58],48:[2,58],49:[2,58],55:[2,58],56:[2,58],57:[2,58],58:[2,58],59:[2,58],61:[2,58],66:[2,58],67:[2,58],69:[2,58],71:[2,58],74:[2,58],76:[2,58],78:[2,58],79:[2,58],80:[2,58]},{5:[2,62],14:[2,62],16:[2,62],17:[2,62],19:[2,62],22:[2,62],23:[2,62],25:[2,62],27:[2,62],30:[2,62],34:[2,62],35:[2,62],36:[2,62],37:[2,62],38:[2,62],40:[2,62],42:[2,62],43:[2,62],45:[2,62],46:[2,62],47:[2,62],48:[2,62],49:[2,62],55:[2,62],56:[2,62],57:[2,62],58:[2,62],59:[2,62],61:[2,62],66:[2,62],67:[2,62],69:[2,62],71:[2,62],74:[2,62],76:[2,62],78:[2,62],79:[2,62],80:[2,62]},{16:[1,138],27:[1,136],29:137,30:[1,139]},{16:[2,28],27:[2,28],30:[2,28]},{49:[1,140]},{56:[1,141]},{4:142,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:143,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:144,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,64],13:70,14:[2,64],16:[2,64],17:[2,64],19:[1,15],22:[1,71],23:[2,64],25:[2,64],27:[2,64],30:[2,64],34:[2,64],35:[2,64],36:[2,64],37:[2,64],38:[2,64],40:[2,64],41:75,42:[1,76],43:[1,77],45:[2,64],46:[2,64],47:[2,64],48:[1,33],49:[2,64],50:28,51:29,52:30,53:31,54:32,55:[1,34],56:[2,64],57:[1,35],58:[1,36],59:[2,64],60:37,61:[1,38],62:39,65:43,66:[1,48],67:[1,49],69:[1,44],71:[2,64],74:[2,64],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:145,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,92],13:70,14:[2,92],16:[2,92],17:[2,92],19:[1,15],22:[1,71],23:[2,92],25:[2,92],27:[2,92],30:[2,92],34:[2,92],35:[2,92],36:[2,92],37:[2,92],38:[2,92],40:[2,92],41:75,42:[1,76],43:[1,77],45:[2,92],46:[2,92],47:[2,92],48:[1,33],49:[2,92],50:28,51:29,52:30,53:31,54:32,55:[1,34],56:[2,92],57:[1,35],58:[1,36],59:[2,92],60:37,61:[1,38],62:39,65:43,66:[1,48],67:[1,49],69:[1,44],71:[2,92],74:[2,92],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{48:[1,146]},{13:70,19:[1,15],22:[1,148],24:22,25:[1,27],28:23,31:24,32:18,39:147,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:149,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,102],13:70,14:[2,102],16:[2,102],17:[2,102],19:[1,15],22:[1,71],23:[2,102],25:[2,102],27:[2,102],30:[2,102],34:[2,102],35:[2,102],36:[2,102],37:[2,102],38:[2,102],40:[2,102],41:75,42:[1,76],43:[1,77],45:[2,102],46:[2,102],47:[2,102],48:[1,33],49:[2,102],50:28,51:29,52:30,53:31,54:32,55:[1,34],56:[2,102],57:[1,35],58:[1,36],59:[2,102],60:37,61:[1,38],62:39,65:43,66:[1,48],67:[1,49],69:[1,44],71:[2,102],74:[2,102],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{13:70,19:[1,15],22:[1,150],24:22,25:[1,27],28:23,31:24,32:18,39:151,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:152,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,106],13:70,14:[2,106],16:[2,106],17:[2,106],19:[1,15],22:[1,71],23:[2,106],25:[2,106],27:[2,106],30:[2,106],34:[2,106],35:[2,106],36:[2,106],37:[2,106],38:[2,106],40:[2,106],41:75,42:[1,76],43:[1,77],45:[2,106],46:[2,106],47:[2,106],48:[1,33],49:[2,106],50:28,51:29,52:30,53:31,54:32,55:[1,34],56:[2,106],57:[1,35],58:[1,36],59:[2,106],60:37,61:[1,38],62:39,65:43,66:[1,48],67:[1,49],69:[1,44],71:[2,106],74:[2,106],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{13:70,19:[1,15],22:[1,153],24:22,25:[1,27],28:23,31:24,32:18,39:154,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{48:[1,155]},{71:[1,156]},{5:[2,79],14:[2,79],16:[2,79],17:[2,79],19:[2,79],22:[2,79],23:[2,79],25:[2,79],27:[2,79],30:[2,79],34:[2,79],35:[2,79],36:[2,79],37:[2,79],38:[2,79],40:[2,79],42:[2,79],43:[2,79],45:[2,79],46:[2,79],47:[2,79],48:[2,79],49:[2,79],55:[2,79],56:[2,79],57:[2,79],58:[2,79],59:[2,79],61:[2,79],66:[2,79],67:[2,79],69:[2,79],71:[2,79],74:[2,79],76:[2,79],78:[2,79],79:[2,79],80:[2,79]},{16:[1,157],71:[2,81]},{16:[2,83],71:[2,83]},{16:[2,85],71:[2,85],74:[1,158]},{14:[1,160],18:159,34:[1,55],35:[1,56],36:[1,57],37:[1,58]},{13:161,19:[1,15],48:[1,162]},{5:[1,163]},{5:[2,15]},{5:[2,14]},{5:[2,49],18:164,19:[2,49],22:[1,67],25:[2,49],34:[1,55],35:[1,56],36:[1,57],37:[1,58],38:[2,49],40:[2,49],42:[2,49],43:[2,49],45:[2,49],46:[2,49],47:[2,49],48:[2,49],55:[2,49],57:[2,49],58:[2,49],59:[2,49],61:[2,49],66:[2,49],67:[2,49],69:[2,49],76:[2,49],78:[2,49],79:[2,49],80:[2,49]},{5:[2,36],16:[2,36],18:165,34:[1,55],35:[1,56],36:[1,57],37:[1,58],71:[2,36],74:[2,36]},{1:[2,9]},{5:[2,13]},{16:[1,167],23:[1,166]},{16:[1,169],23:[1,168]},{23:[1,134]},{5:[2,39],13:70,14:[2,39],16:[2,39],17:[2,39],19:[1,15],22:[1,71],23:[2,39],25:[2,39],27:[2,39],30:[2,39],34:[2,39],35:[2,39],36:[2,39],37:[2,39],38:[2,39],40:[2,39],41:75,42:[1,76],43:[1,77],45:[2,39],46:[2,39],47:[2,39],48:[1,33],49:[2,39],50:28,51:29,52:30,53:31,54:32,55:[1,34],56:[2,39],57:[1,35],58:[1,36],59:[2,39],60:37,61:[1,38],62:39,65:43,66:[1,48],67:[1,49],69:[1,44],71:[2,39],74:[2,39],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,40],13:70,14:[2,40],16:[2,40],17:[2,40],19:[1,15],22:[1,71],23:[2,40],25:[2,40],27:[2,40],30:[2,40],34:[2,40],35:[2,40],36:[2,40],37:[2,40],38:[2,40],40:[2,40],41:75,42:[1,76],43:[1,77],45:[2,40],46:[2,40],47:[2,40],48:[1,33],49:[2,40],50:28,51:29,52:30,53:31,54:32,55:[1,34],56:[2,40],57:[1,35],58:[1,36],59:[2,40],60:37,61:[1,38],62:39,65:43,66:[1,48],67:[1,49],69:[1,44],71:[2,40],74:[2,40],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,20],16:[2,20]},{4:170,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,43],14:[2,43],16:[2,43],17:[2,43],19:[2,43],22:[2,43],23:[2,43],25:[1,80],27:[2,43],30:[2,43],34:[2,43],35:[2,43],36:[2,43],37:[2,43],38:[2,43],40:[2,43],42:[2,43],43:[2,43],44:78,45:[1,81],46:[1,82],47:[1,83],48:[2,43],49:[2,43],55:[2,43],56:[2,43],57:[2,43],58:[2,43],59:[1,79],61:[2,43],66:[2,43],67:[2,43],69:[2,43],71:[2,43],74:[2,43],76:[2,43],78:[2,43],79:[2,43],80:[2,43]},{5:[2,44],14:[2,44],16:[2,44],17:[2,44],19:[2,44],22:[2,44],23:[2,44],25:[1,80],27:[2,44],30:[2,44],34:[2,44],35:[2,44],36:[2,44],37:[2,44],38:[2,44],40:[2,44],42:[2,44],43:[2,44],44:78,45:[1,81],46:[1,82],47:[1,83],48:[2,44],49:[2,44],55:[2,44],56:[2,44],57:[2,44],58:[2,44],59:[1,79],61:[2,44],66:[2,44],67:[2,44],69:[2,44],71:[2,44],74:[2,44],76:[2,44],78:[2,44],79:[2,44],80:[2,44]},{27:[1,171]},{4:172,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:173,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,55],14:[2,55],16:[2,55],17:[2,55],19:[2,55],22:[2,55],23:[2,55],25:[2,55],27:[2,55],30:[2,55],34:[2,55],35:[2,55],36:[2,55],37:[2,55],38:[2,55],40:[2,55],42:[2,55],43:[2,55],45:[2,55],46:[2,55],47:[2,55],48:[2,55],49:[2,55],55:[2,55],56:[2,55],57:[2,55],58:[2,55],59:[2,55],61:[2,55],66:[2,55],67:[2,55],69:[2,55],71:[2,55],74:[2,55],76:[2,55],78:[2,55],79:[2,55],80:[2,55]},{5:[2,67],14:[2,67],16:[2,67],17:[2,67],19:[2,67],22:[2,67],23:[2,67],25:[2,67],27:[2,67],30:[2,67],34:[2,67],35:[2,67],36:[2,67],37:[2,67],38:[2,67],40:[2,67],42:[2,67],43:[2,67],45:[2,67],46:[2,67],47:[2,67],48:[2,67],49:[2,67],55:[2,67],56:[2,67],57:[2,67],58:[2,67],59:[2,67],61:[2,67],66:[2,67],67:[2,67],69:[2,67],71:[2,67],74:[2,67],76:[2,67],78:[2,67],79:[2,67],80:[2,67]},{5:[2,22],14:[2,22],16:[2,22],17:[2,22],19:[2,22],22:[2,22],23:[2,22],25:[2,22],27:[2,22],30:[2,22],34:[2,22],35:[2,22],36:[2,22],37:[2,22],38:[2,22],40:[2,22],42:[2,22],43:[2,22],45:[2,22],46:[2,22],47:[2,22],48:[2,22],49:[2,22],55:[2,22],56:[2,22],57:[2,22],58:[2,22],59:[2,22],61:[2,22],66:[2,22],67:[2,22],69:[2,22],71:[2,22],74:[2,22],76:[2,22],78:[2,22],79:[2,22],80:[2,22]},{4:90,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],26:174,28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:175,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,30:[1,176],31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{16:[1,177],19:[2,24],22:[2,24],25:[2,24],40:[2,24],48:[2,24],55:[2,24],57:[2,24],58:[2,24],61:[2,24],64:[2,24],66:[2,24],67:[2,24],69:[2,24],76:[2,24],78:[2,24],79:[2,24],80:[2,24]},{5:[2,56],14:[2,56],16:[2,56],17:[2,56],19:[2,56],22:[2,56],23:[2,56],25:[2,56],27:[2,56],30:[2,56],34:[2,56],35:[2,56],36:[2,56],37:[2,56],38:[2,56],40:[2,56],42:[2,56],43:[2,56],45:[2,56],46:[2,56],47:[2,56],48:[2,56],49:[2,56],55:[2,56],56:[2,56],57:[2,56],58:[2,56],59:[2,56],61:[2,56],66:[2,56],67:[2,56],69:[2,56],71:[2,56],74:[2,56],76:[2,56],78:[2,56],79:[2,56],80:[2,56]},{5:[2,57],14:[2,57],16:[2,57],17:[2,57],19:[2,57],22:[2,57],23:[2,57],25:[2,57],27:[2,57],30:[2,57],34:[2,57],35:[2,57],36:[2,57],37:[2,57],38:[2,57],40:[2,57],42:[2,57],43:[2,57],45:[2,57],46:[2,57],47:[2,57],48:[2,57],49:[2,57],55:[2,57],56:[2,57],57:[2,57],58:[2,57],59:[2,57],61:[2,57],66:[2,57],67:[2,57],69:[2,57],71:[2,57],74:[2,57],76:[2,57],78:[2,57],79:[2,57],80:[2,57]},{49:[1,178]},{49:[1,179]},{27:[1,180]},{23:[1,181]},{40:[1,182]},{5:[2,95],13:70,14:[2,95],16:[2,95],17:[2,95],19:[1,15],22:[1,71],23:[2,95],25:[2,95],27:[2,95],30:[2,95],34:[2,95],35:[2,95],36:[2,95],37:[2,95],38:[2,95],40:[2,95],41:75,42:[1,76],43:[1,77],45:[2,95],46:[2,95],47:[2,95],48:[1,33],49:[2,95],50:28,51:29,52:30,53:31,54:32,55:[1,34],56:[2,95],57:[1,35],58:[1,36],59:[2,95],60:37,61:[1,38],62:39,65:43,66:[1,48],67:[1,49],69:[1,44],71:[2,95],74:[2,95],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:183,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{23:[1,184]},{4:185,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,104],13:70,14:[2,104],16:[2,104],17:[2,104],19:[1,15],22:[1,71],23:[2,104],25:[2,104],27:[2,104],30:[2,104],34:[2,104],35:[2,104],36:[2,104],37:[2,104],38:[2,104],40:[2,104],41:75,42:[1,76],43:[1,77],45:[2,104],46:[2,104],47:[2,104],48:[1,33],49:[2,104],50:28,51:29,52:30,53:31,54:32,55:[1,34],56:[2,104],57:[1,35],58:[1,36],59:[2,104],60:37,61:[1,38],62:39,65:43,66:[1,48],67:[1,49],69:[1,44],71:[2,104],74:[2,104],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{23:[1,186]},{4:187,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,108],13:70,14:[2,108],16:[2,108],17:[2,108],19:[1,15],22:[1,71],23:[2,108],25:[2,108],27:[2,108],30:[2,108],34:[2,108],35:[2,108],36:[2,108],37:[2,108],38:[2,108],40:[2,108],41:75,42:[1,76],43:[1,77],45:[2,108],46:[2,108],47:[2,108],48:[1,33],49:[2,108],50:28,51:29,52:30,53:31,54:32,55:[1,34],56:[2,108],57:[1,35],58:[1,36],59:[2,108],60:37,61:[1,38],62:39,65:43,66:[1,48],67:[1,49],69:[1,44],71:[2,108],74:[2,108],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{13:188,19:[1,15]},{5:[2,78],14:[2,78],16:[2,78],17:[2,78],19:[2,78],22:[2,78],23:[2,78],25:[2,78],27:[2,78],30:[2,78],34:[2,78],35:[2,78],36:[2,78],37:[2,78],38:[2,78],40:[2,78],42:[2,78],43:[2,78],45:[2,78],46:[2,78],47:[2,78],48:[2,78],49:[2,78],55:[2,78],56:[2,78],57:[2,78],58:[2,78],59:[2,78],61:[2,78],66:[2,78],67:[2,78],69:[2,78],71:[2,78],74:[2,78],76:[2,78],78:[2,78],79:[2,78],80:[2,78]},{4:189,12:112,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],73:190,75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:191,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:119,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:192,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{19:[2,99],22:[2,99],25:[2,99],40:[2,99],45:[2,99],48:[2,99],55:[2,99],57:[2,99],58:[2,99],61:[2,99],64:[2,99],66:[2,99],67:[2,99],69:[2,99],76:[2,99],78:[2,99],79:[2,99],80:[2,99]},{4:193,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{1:[2,11]},{4:194,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:195,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,109],14:[2,109],16:[2,109],17:[2,109],19:[2,109],22:[2,109],23:[2,109],25:[2,109],27:[2,109],30:[2,109],34:[2,109],35:[2,109],36:[2,109],37:[2,109],38:[2,109],40:[2,109],42:[2,109],43:[2,109],45:[2,109],46:[2,109],47:[2,109],48:[2,109],49:[2,109],55:[2,109],56:[2,109],57:[2,109],58:[2,109],59:[2,109],61:[2,109],66:[2,109],67:[2,109],69:[2,109],71:[2,109],74:[2,109],76:[2,109],78:[2,109],79:[2,109],80:[2,109]},{4:196,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,89],14:[2,89],16:[2,89],17:[2,89],19:[2,89],22:[2,89],23:[2,89],25:[2,89],27:[2,89],30:[2,89],34:[2,89],35:[2,89],36:[2,89],37:[2,89],38:[2,89],40:[2,89],42:[2,89],43:[2,89],44:197,45:[1,81],46:[1,82],47:[1,83],48:[2,89],49:[2,89],55:[2,89],56:[2,89],57:[2,89],58:[2,89],59:[2,89],61:[2,89],66:[2,89],67:[2,89],69:[2,89],71:[2,89],74:[2,89],76:[2,89],78:[2,89],79:[2,89],80:[2,89]},{4:198,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{16:[1,133]},{5:[2,30],14:[2,30],16:[2,30],17:[2,30],19:[2,30],22:[2,30],23:[2,30],25:[2,30],27:[2,30],30:[2,30],34:[2,30],35:[2,30],36:[2,30],37:[2,30],38:[2,30],40:[2,30],42:[2,30],43:[2,30],45:[2,30],46:[2,30],47:[2,30],48:[2,30],49:[2,30],55:[2,30],56:[2,30],57:[2,30],58:[2,30],59:[2,30],61:[2,30],66:[2,30],67:[2,30],69:[2,30],71:[2,30],74:[2,30],76:[2,30],78:[2,30],79:[2,30],80:[2,30]},{49:[1,199]},{23:[1,200]},{16:[1,202],27:[1,201]},{16:[2,29],27:[2,29],30:[2,29]},{16:[1,203],19:[2,25],22:[2,25],25:[2,25],40:[2,25],48:[2,25],55:[2,25],57:[2,25],58:[2,25],61:[2,25],64:[2,25],66:[2,25],67:[2,25],69:[2,25],76:[2,25],78:[2,25],79:[2,25],80:[2,25]},{19:[2,26],22:[2,26],25:[2,26],40:[2,26],48:[2,26],55:[2,26],57:[2,26],58:[2,26],61:[2,26],64:[2,26],66:[2,26],67:[2,26],69:[2,26],76:[2,26],78:[2,26],79:[2,26],80:[2,26]},{48:[1,204]},{5:[2,60],14:[2,60],16:[2,60],17:[2,60],19:[2,60],22:[2,60],23:[2,60],25:[2,60],27:[2,60],30:[2,60],34:[2,60],35:[2,60],36:[2,60],37:[2,60],38:[2,60],40:[2,60],42:[2,60],43:[2,60],45:[2,60],46:[2,60],47:[2,60],48:[2,60],49:[2,60],55:[2,60],56:[2,60],57:[2,60],58:[2,60],59:[2,60],61:[2,60],66:[2,60],67:[2,60],69:[2,60],71:[2,60],74:[2,60],76:[2,60],78:[2,60],79:[2,60],80:[2,60]},{48:[1,205]},{5:[2,91],14:[2,91],16:[2,91],17:[2,91],19:[2,91],22:[2,91],23:[2,91],25:[2,91],27:[2,91],30:[2,91],34:[2,91],35:[2,91],36:[2,91],37:[2,91],38:[2,91],40:[2,91],42:[2,91],43:[2,91],45:[2,91],46:[2,91],47:[2,91],48:[2,91],49:[2,91],55:[2,91],56:[2,91],57:[2,91],58:[2,91],59:[2,91],61:[2,91],66:[2,91],67:[2,91],69:[2,91],71:[2,91],74:[2,91],76:[2,91],78:[2,91],79:[2,91],80:[2,91]},{40:[1,207],63:206,64:[1,26]},{23:[1,208]},{5:[2,101],14:[2,101],16:[2,101],17:[2,101],19:[2,101],22:[2,101],23:[2,101],25:[2,101],27:[2,101],30:[2,101],34:[2,101],35:[2,101],36:[2,101],37:[2,101],38:[2,101],40:[2,101],42:[2,101],43:[2,101],45:[2,101],46:[2,101],47:[2,101],48:[2,101],49:[2,101],55:[2,101],56:[2,101],57:[2,101],58:[2,101],59:[2,101],61:[2,101],66:[2,101],67:[2,101],69:[2,101],71:[2,101],74:[2,101],76:[2,101],78:[2,101],79:[2,101],80:[2,101]},{23:[1,209]},{5:[2,105],14:[2,105],16:[2,105],17:[2,105],19:[2,105],22:[2,105],23:[2,105],25:[2,105],27:[2,105],30:[2,105],34:[2,105],35:[2,105],36:[2,105],37:[2,105],38:[2,105],40:[2,105],42:[2,105],43:[2,105],45:[2,105],46:[2,105],47:[2,105],48:[2,105],49:[2,105],55:[2,105],56:[2,105],57:[2,105],58:[2,105],59:[2,105],61:[2,105],66:[2,105],67:[2,105],69:[2,105],71:[2,105],74:[2,105],76:[2,105],78:[2,105],79:[2,105],80:[2,105]},{23:[1,210]},{14:[1,211]},{14:[1,160],18:159,34:[1,55],35:[1,56],36:[1,57],37:[1,58],71:[2,80]},{16:[2,82],71:[2,82]},{16:[2,84],71:[2,84]},{16:[2,37],71:[2,37],74:[2,37]},{49:[1,212]},{5:[2,16]},{5:[2,38],16:[2,38],71:[2,38],74:[2,38]},{16:[2,110],23:[2,110]},{5:[2,88],14:[2,88],16:[2,88],17:[2,88],19:[2,88],22:[2,88],23:[2,88],25:[2,88],27:[2,88],30:[2,88],34:[2,88],35:[2,88],36:[2,88],37:[2,88],38:[2,88],40:[2,88],42:[2,88],43:[2,88],45:[2,88],46:[2,88],47:[2,88],48:[2,88],49:[2,88],55:[2,88],56:[2,88],57:[2,88],58:[2,88],59:[2,88],61:[2,88],66:[2,88],67:[2,88],69:[2,88],71:[2,88],74:[2,88],76:[2,88],78:[2,88],79:[2,88],80:[2,88]},{16:[2,111],23:[2,111]},{5:[2,48],14:[2,48],16:[2,48],17:[2,48],19:[2,48],22:[2,48],23:[2,48],25:[2,48],27:[2,48],30:[2,48],34:[2,48],35:[2,48],36:[2,48],37:[2,48],38:[2,48],40:[2,48],42:[2,48],43:[2,48],45:[2,48],46:[2,48],47:[2,48],48:[2,48],49:[2,48],55:[2,48],56:[2,48],57:[2,48],58:[2,48],59:[2,48],61:[2,48],64:[2,48],66:[2,48],67:[2,48],69:[2,48],71:[2,48],74:[2,48],76:[2,48],78:[2,48],79:[2,48],80:[2,48]},{5:[2,21],16:[2,21]},{5:[2,23],14:[2,23],16:[2,23],17:[2,23],19:[2,23],22:[2,23],23:[2,23],25:[2,23],27:[2,23],30:[2,23],34:[2,23],35:[2,23],36:[2,23],37:[2,23],38:[2,23],40:[2,23],42:[2,23],43:[2,23],45:[2,23],46:[2,23],47:[2,23],48:[2,23],49:[2,23],55:[2,23],56:[2,23],57:[2,23],58:[2,23],59:[2,23],61:[2,23],66:[2,23],67:[2,23],69:[2,23],71:[2,23],74:[2,23],76:[2,23],78:[2,23],79:[2,23],80:[2,23]},{4:175,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{19:[2,27],22:[2,27],25:[2,27],40:[2,27],48:[2,27],55:[2,27],57:[2,27],58:[2,27],61:[2,27],64:[2,27],66:[2,27],67:[2,27],69:[2,27],76:[2,27],78:[2,27],79:[2,27],80:[2,27]},{4:213,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:214,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{49:[1,215]},{64:[1,216]},{5:[2,96],14:[2,96],16:[2,96],17:[2,96],19:[2,96],22:[2,96],23:[2,96],25:[2,96],27:[2,96],30:[2,96],34:[2,96],35:[2,96],36:[2,96],37:[2,96],38:[2,96],40:[2,96],42:[2,96],43:[2,96],45:[2,96],46:[2,96],47:[2,96],48:[2,96],49:[2,96],55:[2,96],56:[2,96],57:[2,96],58:[2,96],59:[2,96],61:[2,96],66:[2,96],67:[2,96],69:[2,96],71:[2,96],74:[2,96],76:[2,96],78:[2,96],79:[2,96],80:[2,96]},{5:[2,103],14:[2,103],16:[2,103],17:[2,103],19:[2,103],22:[2,103],23:[2,103],25:[2,103],27:[2,103],30:[2,103],34:[2,103],35:[2,103],36:[2,103],37:[2,103],38:[2,103],40:[2,103],42:[2,103],43:[2,103],45:[2,103],46:[2,103],47:[2,103],48:[2,103],49:[2,103],55:[2,103],56:[2,103],57:[2,103],58:[2,103],59:[2,103],61:[2,103],66:[2,103],67:[2,103],69:[2,103],71:[2,103],74:[2,103],76:[2,103],78:[2,103],79:[2,103],80:[2,103]},{5:[2,107],14:[2,107],16:[2,107],17:[2,107],19:[2,107],22:[2,107],23:[2,107],25:[2,107],27:[2,107],30:[2,107],34:[2,107],35:[2,107],36:[2,107],37:[2,107],38:[2,107],40:[2,107],42:[2,107],43:[2,107],45:[2,107],46:[2,107],47:[2,107],48:[2,107],49:[2,107],55:[2,107],56:[2,107],57:[2,107],58:[2,107],59:[2,107],61:[2,107],66:[2,107],67:[2,107],69:[2,107],71:[2,107],74:[2,107],76:[2,107],78:[2,107],79:[2,107],80:[2,107]},{4:217,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{19:[2,100],22:[2,100],25:[2,100],40:[2,100],45:[2,100],48:[2,100],55:[2,100],57:[2,100],58:[2,100],61:[2,100],64:[2,100],66:[2,100],67:[2,100],69:[2,100],76:[2,100],78:[2,100],79:[2,100],80:[2,100]},{49:[1,218]},{49:[1,219]},{13:70,19:[1,15],22:[1,221],24:22,25:[1,27],28:23,31:24,32:18,39:220,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{49:[2,87]},{49:[1,222]},{5:[2,59],14:[2,59],16:[2,59],17:[2,59],19:[2,59],22:[2,59],23:[2,59],25:[2,59],27:[2,59],30:[2,59],34:[2,59],35:[2,59],36:[2,59],37:[2,59],38:[2,59],40:[2,59],42:[2,59],43:[2,59],45:[2,59],46:[2,59],47:[2,59],48:[2,59],49:[2,59],55:[2,59],56:[2,59],57:[2,59],58:[2,59],59:[2,59],61:[2,59],66:[2,59],67:[2,59],69:[2,59],71:[2,59],74:[2,59],76:[2,59],78:[2,59],79:[2,59],80:[2,59]},{5:[2,61],14:[2,61],16:[2,61],17:[2,61],19:[2,61],22:[2,61],23:[2,61],25:[2,61],27:[2,61],30:[2,61],34:[2,61],35:[2,61],36:[2,61],37:[2,61],38:[2,61],40:[2,61],42:[2,61],43:[2,61],45:[2,61],46:[2,61],47:[2,61],48:[2,61],49:[2,61],55:[2,61],56:[2,61],57:[2,61],58:[2,61],59:[2,61],61:[2,61],66:[2,61],67:[2,61],69:[2,61],71:[2,61],74:[2,61],76:[2,61],78:[2,61],79:[2,61],80:[2,61]},{5:[2,93],13:70,14:[2,93],16:[2,93],17:[2,93],19:[1,15],22:[1,71],23:[2,93],25:[2,93],27:[2,93],30:[2,93],34:[2,93],35:[2,93],36:[2,93],37:[2,93],38:[2,93],40:[2,93],41:75,42:[1,76],43:[1,77],45:[2,93],46:[2,93],47:[2,93],48:[1,33],49:[2,93],50:28,51:29,52:30,53:31,54:32,55:[1,34],56:[2,93],57:[1,35],58:[1,36],59:[2,93],60:37,61:[1,38],62:39,65:43,66:[1,48],67:[1,49],69:[1,44],71:[2,93],74:[2,93],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{4:223,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{44:224,45:[1,81],46:[1,82],47:[1,83]},{23:[1,225]},{4:226,13:70,19:[1,15],22:[1,71],24:22,25:[1,27],28:23,31:24,32:18,33:13,39:16,40:[1,21],41:25,48:[1,33],50:28,51:29,52:30,53:31,54:32,55:[1,34],57:[1,35],58:[1,36],60:37,61:[1,38],62:39,63:20,64:[1,26],65:43,66:[1,48],67:[1,49],69:[1,44],75:40,76:[1,45],77:41,78:[1,46],79:[1,47],80:[1,42]},{5:[2,94],14:[2,94],16:[2,94],17:[2,94],19:[2,94],22:[2,94],23:[2,94],25:[2,94],27:[2,94],30:[2,94],34:[2,94],35:[2,94],36:[2,94],37:[2,94],38:[2,94],40:[2,94],42:[2,94],43:[2,94],45:[2,94],46:[2,94],47:[2,94],48:[2,94],49:[2,94],55:[2,94],56:[2,94],57:[2,94],58:[2,94],59:[2,94],61:[2,94],66:[2,94],67:[2,94],69:[2,94],71:[2,94],74:[2,94],76:[2,94],78:[2,94],79:[2,94],80:[2,94]},{5:[2,77],14:[2,77],16:[2,77],17:[2,77],19:[2,77],22:[2,77],23:[2,77],25:[2,77],27:[2,77],30:[2,77],34:[2,77],35:[2,77],36:[2,77],37:[2,77],38:[2,77],40:[2,77],42:[2,77],43:[2,77],45:[2,77],46:[2,77],47:[2,77],48:[2,77],49:[2,77],55:[2,77],56:[2,77],57:[2,77],58:[2,77],59:[2,77],61:[2,77],66:[2,77],67:[2,77],69:[2,77],71:[2,77],74:[2,77],76:[2,77],78:[2,77],79:[2,77],80:[2,77]}],
defaultActions: {12:[2,12],48:[2,75],49:[2,76],50:[2,1],59:[2,2],60:[2,3],61:[2,4],62:[2,5],63:[2,6],64:[2,7],65:[2,8],68:[2,10],69:[2,112],116:[2,15],117:[2,14],120:[2,9],121:[2,13],163:[2,11],194:[2,16],216:[2,87]},
parseError: function parseError(str, hash) {
    throw new Error(str);
},
parse: function parse(input) {
    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    this.lexer.setInput(input);
    this.lexer.yy = this.yy;
    this.yy.lexer = this.lexer;
    this.yy.parser = this;
    if (typeof this.lexer.yylloc == "undefined")
        this.lexer.yylloc = {};
    var yyloc = this.lexer.yylloc;
    lstack.push(yyloc);
    var ranges = this.lexer.options && this.lexer.options.ranges;
    if (typeof this.yy.parseError === "function")
        this.parseError = this.yy.parseError;
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    function lex() {
        var token;
        token = self.lexer.lex() || 1;
        if (typeof token !== "number") {
            token = self.symbols_[token] || token;
        }
        return token;
    }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == "undefined") {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            if (!recovering) {
                expected = [];
                for (p in table[state])
                    if (this.terminals_[p] && p > 2) {
                        expected.push("'" + this.terminals_[p] + "'");
                    }
                if (this.lexer.showPosition) {
                    errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                } else {
                    errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1?"end of input":"'" + (this.terminals_[symbol] || symbol) + "'");
                }
                this.parseError(errStr, {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});
            }
        }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(this.lexer.yytext);
            lstack.push(this.lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                if (recovering > 0)
                    recovering--;
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column};
            if (ranges) {
                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
            }
            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
            if (typeof r !== "undefined") {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}
};
/* Jison generated lexer */
var lexer = (function(){
var lexer = ({EOF:1,
parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },
setInput:function (input) {
        this._input = input;
        this._more = this._less = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};
        if (this.options.ranges) this.yylloc.range = [0,0];
        this.offset = 0;
        return this;
    },
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) this.yylloc.range[1]++;

        this._input = this._input.slice(1);
        return ch;
    },
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length-len-1);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length-1);
        this.matched = this.matched.substr(0, this.matched.length-1);

        if (lines.length-1) this.yylineno -= lines.length-1;
        var r = this.yylloc.range;

        this.yylloc = {first_line: this.yylloc.first_line,
          last_line: this.yylineno+1,
          first_column: this.yylloc.first_column,
          last_column: lines ?
              (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length:
              this.yylloc.first_column - len
          };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        return this;
    },
more:function () {
        this._more = true;
        return this;
    },
less:function (n) {
        this.unput(this.match.slice(n));
    },
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\n/g, "");
    },
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c+"^";
    },
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) this.done = true;

        var token,
            match,
            tempMatch,
            index,
            col,
            lines;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i=0;i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (!this.options.flex) break;
            }
        }
        if (match) {
            lines = match[0].match(/(?:\r\n?|\n).*/g);
            if (lines) this.yylineno += lines.length;
            this.yylloc = {first_line: this.yylloc.last_line,
                           last_line: this.yylineno+1,
                           first_column: this.yylloc.last_column,
                           last_column: lines ? lines[lines.length-1].length-lines[lines.length-1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length};
            this.yytext += match[0];
            this.match += match[0];
            this.matches = match;
            this.yyleng = this.yytext.length;
            if (this.options.ranges) {
                this.yylloc.range = [this.offset, this.offset += this.yyleng];
            }
            this._more = false;
            this._input = this._input.slice(match[0].length);
            this.matched += match[0];
            token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);
            if (this.done && this._input) this.done = false;
            if (token) return token;
            else return;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\n'+this.showPosition(),
                    {text: "", token: null, line: this.yylineno});
        }
    },
lex:function lex() {
        var r = this.next();
        if (typeof r !== 'undefined') {
            return r;
        } else {
            return this.lex();
        }
    },
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },
popState:function popState() {
        return this.conditionStack.pop();
    },
_currentRules:function _currentRules() {
        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;
    },
topState:function () {
        return this.conditionStack[this.conditionStack.length-2];
    },
pushState:function begin(condition) {
        this.begin(condition);
    }});
lexer.options = {};
lexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {

var YYSTATE=YY_START
switch($avoiding_name_collisions) {
case 0:/* skip whitespace */
break;
case 1:return 48
break;
case 2:return 49
break;
case 3:return 'MATH_SHIFT'
break;
case 4:yy_.yytext = this.matches[this.matches.length - 1]; return 45
break;
case 5:yy_.yytext = this.matches[this.matches.length - 1]; return 46
break;
case 6:return 47
break;
case 7:yy_.yytext=Number(this.matches[2]) + Number(this.matches[5]) / Number(this.matches[6]); return 64
break;
case 8:return 64
break;
case 9:return 42
break;
case 10:return 43
break;
case 11:yy_.yytext = this.matches[3]; return 61
break;
case 12:yy_.yytext = this.matches[this.matches.length - 1]; return 79
break;
case 13:return 80
break;
case 14:return 78
break;
case 15:return 57
break;
case 16:return 58
break;
case 17:return 66
break;
case 18:return 67
break;
case 19:return 19
break;
case 20:return 55  /* rely on mathquill */
break;
case 21:return 56 /* for pairing */
break;
case 22:return 40
break;
case 23:return 38
break;
case 24:return 14
break;
case 25:return 17
break;
case 26:return "..."
break;
case 27:return 68
break;
case 28:return 59
break;
case 29:return 5
break;
case 30:return 22
break;
case 31:return 23
break;
case 32:return 25
break;
case 33:return 27
break;
case 34:return 69
break;
case 35:return 71
break;
case 36:return 74
break;
case 37:return 36
break;
case 38:return 37
break;
case 39:return 35
break;
case 40:return 34
break;
case 41:return 16
break;
case 42:return 15
break;
case 43:return 76        /* sin, cos, sinh, ln*/
break;
case 44:yy_.yytext = '\\sign'; return 19
break;
case 45:yy_.yytext = '\\gcd'; return 19
break;
case 46:yy_.yytext = '\\lcm'; return 19
break;
case 47:yy_.yytext = '\\stdevp'; return 19
break;
case 48:yy_.yytext = '\\stdevp'; return 19
break;
case 49:yy_.yytext = '\\stdev'; return 19
break;
case 50:yy_.yytext = '\\stdev'; return 19
break;
case 51:yy_.yytext = '\\var'; return 19
break;
case 52:return 19          /* Predefined functions, as well as user-defined variables.  Doesn't include subscripts */
break;
case 53:/* skip LINE_START if it's not needed for something else */
break;
case 54:return 'UNRECOGNIZED'
break;
}
};
lexer.rules = [/^(?:(\\space|\\:|\s)+)/,/^(?:\{)/,/^(?:\})/,/^(?:\$)/,/^(?:\^([0-9]))/,/^(?:\^([a-zA-Z]))/,/^(?:\^)/,/^(?:(([0-9]+)((?:\s|\\space|\\:)*)\\frac((?:\s|\\space|\\:)*)\{([0-9]+)\}\{([0-9]+)\}))/,/^(?:[0-9]+(\.[0-9]+)?|(\.[0-9]+))/,/^(?:\*|(\\cdot))/,/^(?:\/)/,/^(?:(\\frac((?:\s|\\space|\\:)*)\{d\}\{d(((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?))\}))/,/^(?:(\\log)((?:\s|\\space|\\:)*)*_([0-9]))/,/^(?:(\\ln))/,/^(?:(\\log))/,/^(?:(\\frac))/,/^(?:(\\sqrt))/,/^(?:(\\sum))/,/^(?:(\\prod))/,/^(?:(\\length))/,/^(?:\\left\|)/,/^(?:\\right\|)/,/^(?:-)/,/^(?:\+)/,/^(?:=)/,/^(?:~)/,/^(?:\.\.\.)/,/^(?:[_])/,/^(?:!)/,/^(?:$)/,/^(?:(\()|\\left\()/,/^(?:(\))|\\right\))/,/^(?:(\[)|\\left\[)/,/^(?:(\])|\\right\])/,/^(?:(\\\{)|\\left\\\{)/,/^(?:(\\\})|\\right\\\})/,/^(?::)/,/^(?:(\\ge|>=))/,/^(?:(\\le|<=))/,/^(?:(\\gt|>))/,/^(?:(\\lt|<))/,/^(?:,)/,/^(?:(###)(((?:\s|\\space|\\:)*)((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?)((?:\s|\\space|\\:)*)(\\left\(|\()((?:\s|\\space|\\:)*)((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?)(((?:\s|\\space|\\:)*),((?:\s|\\space|\\:)*)((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?)((?:\s|\\space|\\:)*))*((?:\s|\\space|\\:)*)(\\right\)|\))((?:\s|\\space|\\:)*)=))/,/^(?:(\\(arc)?(sin|cos|tan|cot|sec|csc)h?))/,/^(?:(\\signum))/,/^(?:(\\(gcf|mcd)))/,/^(?:(\\mcm))/,/^(?:(\\stdDevP))/,/^(?:(\\stddevp))/,/^(?:(\\stdDev))/,/^(?:(\\stddev))/,/^(?:(\\variance))/,/^(?:((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?))/,/^(?:(###))/,/^(?:.)/];
lexer.conditions = {"conditional":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54],"inclusive":true},"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54],"inclusive":true}};
return lexer;})()
parser.lexer = lexer;
return parser;
});
define('math/policy',['require','graphing/graphmode'],function(require){
  var GRAPHMODE = require('graphing/graphmode');

  var Policy = {
    assignmentForbidden: function(identifier){
      return (
        identifier === 'x' ||
        identifier === 'y' ||
        identifier === 'theta' ||
        identifier.slice(0, 3) === 'tmp'
      );
    },

    validRegressionParameter: function (identifier) {
      return identifier !== 'x' && identifier !== 'y';
    },

    sliderVariables: function (identifiers) {
      if (identifiers.indexOf('theta') !== -1) {
        identifiers = identifiers.filter(function (s) { return s !== 'r'; });
      }
      var self = this;
      return identifiers.filter(function (s) { return !self.assignmentForbidden(s); });
    },

    validLHS: function (identifier) {
      return identifier !== 'theta';
    },

    unplottablePolarFunction: function (head, args) {
      if (head !== 'theta') return false;
      return args.indexOf('r') !== -1;
    },

    validDoubleInequalitySymbol: function (identifier) {
      return identifier === 'x' || identifier === 'y';
    },

    validDoubleInequalityVariables: function (identifiers) {
      if (identifiers.length > 2) return false;
      return identifiers.every(Policy.validDoubleInequalitySymbol);
    },

    validExpressionVariable: function (identifier) {
      return identifier === 'x';
    },

    validSolvedVariable: function (identifier) {
      return identifier === 'x' || identifier === 'y' || identifier === 'r';
    },

    validImplicitVariables: function (identifiers) {
      if (identifiers.length !== 2) return false;
      return (
        (identifiers[0] === 'x' && identifiers[1] === 'y') ||
        (identifiers[0] === 'y' && identifiers[1] === 'x') ||
        (identifiers[0] === 'r' && identifiers[1] === 'theta') ||
        (identifiers[0] === 'theta' && identifiers[1] === 'r')
      );
    },

    graphableListVariables: function (leftSymbol, rightSymbol) {
      return (
        leftSymbol === 'x' ||
        leftSymbol === 'y' ||
        leftSymbol === 'r' ||
        rightSymbol === 'x' ||
        rightSymbol === 'y'
      );
    },

    validParametricVariable: function (identifier) {
      return identifier === 't';
    },

    validParametricVariables: function (identifiers) {
      return identifiers.length === 1 && Policy.validParametricVariable(identifiers[0]);
    },

    validInequalityVariables: function (identifiers) {
      switch (identifiers.length) {
        case 1:
          return identifiers[0] === 'x' || identifiers[0] === 'y' || identifiers[0] === 'r';
        case 2:
          return Policy.validImplicitVariables(identifiers);
        default:
          return false;
      }
    },

    validFirstColumnVariable: function (symbol) {
      return symbol !== 'y' && symbol !== 'r' && symbol !== 'theta' && !symbol.match(/y_(\d+)/);
    },

    complicatedPolarImplicit: function (identifier, order) {
      return identifier === 'theta' || (identifier === 'r' && order !== 1);
    },

    constantGraphMode: function (symbol) {
      if (symbol === 'x') return GRAPHMODE.X;
      if (symbol === 'r') return GRAPHMODE.POLAR;
      return GRAPHMODE.Y;
    },

    graphMode: function (independent, dependent) {
      if (dependent === 'y') return GRAPHMODE.X;
      if (independent === 'x') return GRAPHMODE.X;
      if (independent === 'r' && dependent === 'theta') return GRAPHMODE.POLAR;
      return GRAPHMODE.Y;
    },

    tableableAsConstant: function (identifier) {
      if (identifier === 'x') return false;
      if (identifier === 'r') return false;
      if (identifier === 'theta') return false;
      return true;
    },

    implicitIndependent: function (identifier) {
      return 'x';
    },

    implicitDependency: function (identifier) {
      if(identifier === 'y') return 'x';
      if(identifier === 'theta') return 'r';
      return 'y';
    },

    graphableAsConstant: function (identifier) {
      return identifier === 'y' || identifier === 'x' || identifier === 'r';
    },

    graphableAsBareIdentifier: function (identifier) {
      return identifier === 'x';
    }
  };

  return Policy;
});

var define_enum_constant;
var enum_strings = {};
var debuggable_enums = true;

if(debuggable_enums){
  define_enum_constant = function(s){
    this[s] = s;
  };
}
else{
  var next_enum = 1000;
  define_enum_constant = function(s){
    enum_strings[next_enum] = s;
    this[s] = next_enum++;
  };
}

//Statement types (determined entirely from the root element of the parse tree)
define_enum_constant("EXPRESSION");              //a+1 or 1+1
define_enum_constant("FUNCTION_DEFINITION");     //f(x)=???
define_enum_constant("VARIABLE_DEFINITION");     //a=???
define_enum_constant("ORDERED_PAIR_LIST");     // (?, ?), (?, ?).  Support lists of points, but only single parametrics
define_enum_constant("DOUBLE_INEQUALITY");       // expr < y < expr, shade-between
define_enum_constant("COMPARATOR");       // expr < expr - unsolved inequality
define_enum_constant("CHAINED_COMPARATOR");       // a < ??? - not a conditional as an expression
define_enum_constant("EQUATION");         // expr = expr
define_enum_constant("CONSTANT");
define_enum_constant("IDENTIFIER");
define_enum_constant("LIST");

define("math/enums", function(){});

define('math/parsenode/base',['require','console','pjs','math/policy','math/functions','../enums'],function(require){
  //Parse-nodes are immutable objects
  //Built by the parse tree
  var console = require('console');
  var P = require('pjs');
  var Policy = require('math/policy');
  var Functions = require('math/functions');
  require('../enums');

  return P(function(node, _super, _class) {
    node.init = function() {
      this._dependencies = [];
      this._inputString = '';
      this._exports = [];
    };

    node.exportPenalty = 0;

    //Utility function for generating temporary variables
    var tmpVarCounter = 0; //Singleton used for generating tmp variables in compilation
    node.tmpVar = function () {
      return 'tmp' + tmpVarCounter++;
    };

    /* START OF ADAPTATION CODE */
    node.statementType = EXPRESSION; //TODO - remove this
    node.dependencies = function(){return this.getDependencies()};
    node.evaluateOnce = function(frame){
      if(frame === undefined) frame = {};
      var concreteTree = this.getConcreteTree(frame);
      var evaluationInfo = concreteTree.getEvaluationInfo();
      if(evaluationInfo) return evaluationInfo[0].val;
      return NaN;
    };
    /*END OF ADAPTATION CODE */

    //Track input string (for error messages, etc.)
    node.setInputString = function(s){
      this._inputString = s;
    };

    node.getInputString = function(){
      return this._inputString;
    };

    //Track dependencies and referenced variables
    //Anything that we need to be evaluated after
    //is a dependency (even things like "a" for "f(a) = a"
    //Don't track type of dependencies.  That will be checked dynamically
    //as the parse tree is rolled up
    node.addDependency = function(identifier){
      if(this.dependsOn(identifier)) return;
      this._dependencies.push(identifier);
    };

    node.addDependencies = function(identifiers){
      for(var i = 0; i < identifiers.length; i++){
        this.addDependency(identifiers[i]);
      }
    };

    node.getDependencies = function(){
      return (this._dependencies);
    };

    node.removeDependency = function(identifier){
      this._dependencies.splice(this._dependencies.indexOf(identifier), 1);
    };

    node.dependsOn = function(identifier) {
      return (this._dependencies.indexOf(identifier) > -1);
    };

    //Track which symbols we export definitions for
    node.getExports = function(){
      return this._exports;
    };

    node.exportsSymbol = function (symbol) {
      return this._exports.indexOf(symbol) > -1;
    };

    node.exportTo = function (concrete, frame) {
      var exports = this.getExports();
      if (exports.length === 0) return;
      if (exports.length > 1) {
        throw new Error("exportsTo unimplemented for nodes that define multiple symbols.");
      }

      var symbol = exports[0];
      if (Policy.assignmentForbidden(symbol)) return;
      if (frame[symbol]) return;

      // The concrete tree might be an error that blocks exporting the symbol.
      // In this case, export the error instead.
      frame[symbol] = concrete.blocksExport ? concrete : this;
    };

    node.getOperator = function () {
      return this.operator || '=';
    };

    node.isInequality = function () { return false; };

    node.isShadeBetween = function () {
      return false;
    };

    node.getAllIds = function () {
      return this.userData ? [this.userData.id] : [];
    };

    //Default to falsy evaluationInfo
    node.getEvaluationInfo = function(){
      return false;
    };

    //Default to falsy sliderInfo
    node.getSliderInfo = function(){
      return false;
    };

    node.getSliderVariables = function (concrete) {
      return Policy.sliderVariables(concrete.getDependencies());
    };

    //Default to not accepting in implicit function calls (e.g. "sin x")
    node.okForImplicitFunction = function(){
      return false;
    };

    node.getConcreteTree = function(frame){
      console.log("Warning - default empty version of getConcreteTree being called");
      return this;
    };

    node.tryGetConcreteTree = function () {
      var concrete;
      try {
        concrete = this.getConcreteTree.apply(this, arguments);
      } catch (e) {
        if (e instanceof _class) { //only catch ErrorNodes
          concrete = e;
        } else {
          throw e; //Re-throw
        }
      }
      return concrete;
    };

    //Function compilation helpers
    //TODO - put this compilation functionality somewhere more general
    node.getCompiledFunctions = function (args) {
      var strings = this.getEvalStrings();
      var source = strings.statements.join(';') + ';return ' + strings.expression;

      if (args === undefined) {
        args = this.getDependencies();

        // By convention, 'x' always comes first in the argument list
        var i = args.indexOf('x');
        if (i !== -1) {
          var tmp = args[0];
          args[0] = args[i];
          args[i] = tmp;
        }
      }

      return [{
        args: args,
        source: source,
        fn: Functions.closureFunctionWithBuiltIn(args, source)
      }];
    };

    node.getCompiledDerivatives = function () {
      var dependencies = this.getDependencies();
      var derivative = this.takeDerivative(dependencies[0] || 'x');
      return derivative.getCompiledFunctions();
    };
  });
});

define('lib/worker-i18n',['require','underscore'],function (require) {
  var _ = require('underscore');
  //in the worker, we don't want the real i18n. But we do want:
  // * a familiar API
  // * for the i18n parser to be able to go through and find strings to push to crowdin
  //
  // this function only has the 't' method, and it just turns the whole ordeal into
  // a single JSON.stringified string that can be unpacked and translated outside of the worker.

  var packString = function (message, variables) {
    if (!variables || _.size(variables) === 0) return message;
    return JSON.stringify({
      msg: message,
      vars: variables
    });
  };

  return {
    t: packString
  };
});

define('math/parsenode/error',['require','pjs','./base'],function(require){
  var P = require('pjs');
  var ParseNode = require('./base');
  return P(ParseNode, function(node, _super){
    node.init = function(msg) {
      _super.init.call(this);
      this._msg = msg;
      this._sliderVariables = [];
      this.blocksExport = true;
    };

    node.evaluateOnce = function(frame){
      return this._msg;
    };

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      return this;
    };

    node.isError = true;

    node.getError = function(){
      return this._msg;
    };

    node.setDependencies = function (symbols) {
      this._dependencies = symbols;
      return this;
    };

    node.allowExport = function () {
      this.blocksExport = false;
      return this;
    };
  });
});

define('graphing/label',['math/builtin'], function (BuiltIn) {
// Returns a label for a point with an appropriate number of decimals for the
// given scale. Scale is typically chosen to be the range of numbers displayed
// in the current viewport. Rounds to pi fractions when the denominator is 24
// or less, according to a tolerance that depends on x and scale.
//
// Label is returned as on object with the string representation given by
// label.string, and represented value label.value, which is equal to x when
// the string is a decimal representation, and equal to n*Math.PI/d for pi
// fractions. This is used for checking if a labeled value is actually a hole
// in the function.
function value(x, scale) {

  if (isNaN(x)) return { string: 'undefined', value: x };

  if (x === 0) return { string: '0', value: x };

  if (!scale) scale = x;

  var piFraction = BuiltIn.toFraction(x/Math.PI, 24);
  var nString;
  var dString;

  if (
    fewDigits(scale) &&
    BuiltIn.approx(piFraction.n/piFraction.d*Math.PI, x, 3)
  ) {
    if (piFraction.n === 0) {
      nString = "0";
    } else if (piFraction.n === 1) {
      nString = "";
    } else if (piFraction.n === -1) {
      nString = "-";
    } else {
      nString = piFraction.n.toString() + "";
    }

    if (piFraction.d === 1) {
      dString = "";
    } else {
      dString = "/" + piFraction.d.toString();
    }

    return {
      string: nString + dString,
      value: piFraction.n/piFraction.d*Math.PI
    };
  }

  var mantissa, superscript, string;
  if (fewDigits(scale)) {
    string = stripZeros(x.toFixed(decimalsFromScale(scale)));
    superscript = null;
    mantissa = null;

  } else {
    var parts = stripExponentialZeros(x.toExponential(decimalsFromScale(scale/x))).split('e');
    mantissa = parts[0] + '\u00d7' + '10';
    superscript = parts[1].replace('+', '');
    string = stripExponentialZeros(x.toExponential(decimalsFromScale(scale/x))).replace('+', '');
  }

  return { string: string, mantissa: mantissa, superscript: superscript, value: x };
}

// x and f(value(x).value), returning the results as two strings. Useful
// because the function may have a hole at value(x).value.
function point(x, xscale, yscale, fn) {
  var xlabel = value(x, xscale);
  var ylabel = value(fn(xlabel.value), yscale);
  return [xlabel, ylabel];
}

// Strip trailing zeros from a string representation of a decimal.
var trailingZerosRegex = /\.?0+$/;
function stripZeros(string) {
  if (string.indexOf('.') === -1) return string;
  return string.replace(trailingZerosRegex, '');
}

var exponentialTrailingZerosRegex = /\.?0+e/;
function stripExponentialZeros(string) {
  return string.replace(exponentialTrailingZerosRegex, 'e');
}

function fewDigits(x) {
  x = Math.abs(x);
  return 1e-4 < x && x < 1e7;
}

// Returns integer number of decimals to show given scale of numbers to be
// represented.
function decimalsFromScale(scale) {
  scale = Math.abs(scale);
  scale = Math.max(scale, 1e-16);
  return Math.max(0, Math.floor(4.5 - Math.log(scale)/Math.LN10));
}

function htmlSciNote(string) {
  string = stripExponentialZeros(string);
  return string.replace(/([\d\.\-]+)e\+?([\d\-]+)/, "$1<span class='dcg-cross'></span>10<sup>$2</sup>");
}

function latexSciNote(string) {
  string = stripExponentialZeros(string);
  return string.replace(/([\d\.\-]+)e\+?([\d\-]+)/, "$1\\times10^{$2}");
}

var symbolTable = {
  'pi': '',
  'tau': '',
  'theta': ''
};

function formatSymbol(symbol) {
  return symbolTable.hasOwnProperty(symbol) ? symbolTable[symbol] : symbol;
}

function identifierToLatex (symbol) {
  var pieces = symbol.split('_');
  var out = '';
  if (pieces[0].length > 1) out += '\\';
  out += pieces[0];
  if (pieces[1]) {
    if (pieces[1].length === 1) {
      out += '_' + pieces[1];
    } else {
      out += '_{' + pieces[1] + '}';
    }
  }
  return out;
}

function latexToIdentifier (symbol) {
  return symbol.replace(/[{}\\]/g, '');
}

return {
  stripZeros: stripZeros,
  htmlSciNote: htmlSciNote,
  latexSciNote: latexSciNote,
  value: value,
  point: point,
  formatSymbol: formatSymbol,
  identifierToLatex: identifierToLatex,
  latexToIdentifier: latexToIdentifier
};

});

// NOTE, this file is an exception to our usual style guide.
//
// It uses double quoted strings to avoid escaping a lot of single quotes, and it uses long lines
// because our i18n parser requires translation strings to be literals that appear on the same line
// as the `i18n.t(` function invocation.
define('math/errormsg',['require','lib/worker-i18n','math/parsenode/error','graphing/label','math/policy'],function(require){
  /*jshint maxlen:200*/

  var i18n = require('lib/worker-i18n');
  var ErrorNode = require('math/parsenode/error');
  var Label = require('graphing/label');
  var Policy = require('math/policy');

  return {
    parseError: function () {
      return ErrorNode(i18n.t("Sorry, I don't understand this."));
    },

    deeplyNested: function () {
      return ErrorNode(i18n.t("Definitions are nested too deeply."));
    },

    wrongArity: function(symbol, arity, providedArity){
      symbol = Label.formatSymbol(symbol);
      var msg, supplement;
      if(arity === 1){

        supplement = i18n.t("For example, try typing: __dependency__(x).", {
          dependency: symbol
        });

        if(providedArity > 1){ //requires 1 vs require an
          msg = i18n.t("Function '__dependency__' requires only 1 argument. __supplement__", {
            dependency: symbol,
            supplement: supplement
          });
        } else {
          msg = i18n.t("Function '__dependency__' requires an argument. __supplement__", {
            dependency: symbol,
            supplement: supplement
          });
        }
      } else {
        var args = [];
        //construct an example of using the function
        for (var j = 0 ; j < arity ; j++) {args[j] = j+1; }
        var recommendation = symbol + "(" + args.join(", ") + ")";

        supplement = i18n.t("For example, try typing: __recommendation__.", {
          recommendation: recommendation
        });

        msg = i18n.t("Function '__dependency__' requires __assignment_arity__ arguments. __supplement__", {
          dependency: symbol,
          assignment_arity: arity,
          supplement: supplement
        });
      }
      return ErrorNode(msg);
    },

    zeroArgReducer: function(symbol){
      return ErrorNode(i18n.t("Function '__symbol__' requires at least one argument. For example, try typing: __symbol__(1, 2).", {
        symbol: Label.formatSymbol(symbol)
      }));
    },

    missingRHS: function (symbol) {
      symbol = Label.formatSymbol(symbol);
      return ErrorNode(i18n.t("What do you want '__symbol__' to equal?", {
        symbol: symbol
      }));
    },

    malformedPoint: function () {
      return ErrorNode(i18n.t("Points are written like this: (1, 2)."));
    },

    badTrigImplicitMultiply: function () {
      return ErrorNode(i18n.t("Too complicated. Use parens."));
    },

    badTrigExponent: function (prefix) {
      var form1 = prefix + '^2';
      var form2 = prefix + '^-1';
      return ErrorNode(i18n.t("Only __form1__ and __form2__ are supported. Otherwise, use parens.", {
        form1: form1,
        form2: form2
      }));
    },

    badLogImplicitMultiply: function () {
      return ErrorNode(i18n.t("Too complicated. Use parens."));
    },

    badLogExponent: function (prefix) {
      var form = prefix + '^2';
      return ErrorNode(i18n.t("Only __form__ is supported. Otherwise, use parens.", {
        form: form
      }));
    },

    blankExpression: function () {
      return ErrorNode(i18n.t("You haven't written anything yet."));
    },

    functionNotDefined: function(symbol){
      symbol = Label.formatSymbol(symbol);
      return ErrorNode(i18n.t("Function '__dependency__' is not defined.", {
        dependency: symbol
      }));
    },

    parameterAlreadyDefined: function(symbol){
      symbol = Label.formatSymbol(symbol);
      return ErrorNode(i18n.t("You can't use '__dependency__' as a parameter of this function because '__dependency__' is already defined.", {
        dependency: symbol
      }));
    },

    cannotRedefine: function(symbol){
      symbol = Label.formatSymbol(symbol);
      return ErrorNode(i18n.t("You can't redefine '__symbol__' because it's already defined.", {
        symbol: symbol
      }));
    },

    multiplyDefined: function (symbol) {
      symbol = Label.formatSymbol(symbol);
      return ErrorNode(i18n.t("You've defined '__dependency__' in more than one place. Try picking a different variable, or deleting some of the definitions of '__dependency__'.", {
        dependency: symbol
      }));
    },

    shadowedIndex: function (symbol) {
      symbol = Label.formatSymbol(symbol);
      return ErrorNode(i18n.t("You can't use '__symbol__' as an index because it's already defined.", {
        symbol: symbol
      }));
    },

    cycle: function (symbols) {
      symbols = symbols.map(Label.formatSymbol);

      var lastSymbol = symbols.pop();

      return ErrorNode(i18n.t("'__symbols__' and '__lastSymbol__' can't be defined in terms of each other.", {
        symbols: symbols.join("', '"), lastSymbol: lastSymbol
      }));
    },

    tooManyVariables: function (symbols) {
      symbols = symbols.map(Label.formatSymbol);

      if (symbols.length === 0) {
        return ErrorNode(i18n.t("Too many variables, I don't know what to do with this."));
      }

      var lastSymbol = symbols.pop();

      return ErrorNode(i18n.t("Too many variables. Try defining '__variables__'.", {
        variables: (symbols.length ? symbols.join("', '") + "' or '" : "") + lastSymbol
      }));
    },

    addArgumentsToDefinition: function (symbols, head, args) {
      symbols = symbols.map(Label.formatSymbol);
      head = Label.formatSymbol(head);
      args = args.map(Label.formatSymbol);

      var newSignature = head + '(' + args.join(',') + ',' + symbols.join(',') + ')';
      var lastSymbol = symbols.pop();

      var interpolants = {
        symbols: symbols.join("', '"),
        lastSymbol: lastSymbol,
        newSignature: newSignature
      };

      if (symbols.length) {
        return ErrorNode(i18n.t("Try including '__symbols__' and '__lastSymbol__' as arguments by defining the function as '__newSignature__'.",
          interpolants
        ));
      } else {
        return ErrorNode(i18n.t("Try including '__lastSymbol__' as an argument by defining the function as '__newSignature__'.",
          interpolants
        ));
      }
    },

    invalidLHS: function (symbol) {
      symbol = Label.formatSymbol(symbol);
      return ErrorNode(i18n.t("Sorry, you can't graph __symbol__ as a function of anything yet.", {
        symbol: symbol
      }));
    },

    unplottablePolarFunction: function () {
      return ErrorNode(i18n.t("We can't plot  as a function of r. Try plotting r() instead."));
    },

    invalidInequalityVariables: function () {
      return ErrorNode(i18n.t('We only plot inequalities of x and y, or r and .'));
    },

    invalidImplicitVariables: function () {
      return ErrorNode(i18n.t("We only support implicit equations of x and y."));
    },

    unsolvable: function () {
      return ErrorNode(i18n.t("We don't solve complicated single-variable equations yet."));
    },

    singleVariableListSolve: function () {
      return ErrorNode(i18n.t("We don't solve single-variable equations involving lists yet."));
    },

    complicatedImplicitInequality: function () {
      return ErrorNode(i18n.t("We can only plot inequalities when one variable is quadratic or linear."));
    },

    complicatedPolarImplicit: function () {
      return ErrorNode(i18n.t("Polar equations must be linear in r."));
    },

    invalidDoubleInequalityVariables: function () {
      return ErrorNode(i18n.t('We only plot double inequalities of x and y.'));
    },

    mismatchedDoubleInequality: function () {
      return ErrorNode(i18n.t("Double inequalities must both go the same way, e.g. 1 < y < 2."));
    },

    complicatedDoubleInequality: function () {
      return ErrorNode(i18n.t("We only support solved double inequalities. Try deleting one side of the inequality."));
    },

    equationRequired: function (symbol) {
      if (symbol) {
        return ErrorNode(i18n.t("Try adding '__lhs__' to the beginning of this equation.", {
          lhs: Policy.implicitDependency(symbol) + "="
        }));
      } else {
        return ErrorNode(i18n.t("Try adding an equals sign to turn this into an equation."));
      }
    },

    variableAsFunction: function(symbol){
      symbol = Label.formatSymbol(symbol);
      return ErrorNode(i18n.t("Variable '__dependency__' can't be used as a function.", {
        dependency: symbol
      }));
    },

    nestedList: function () {
      return ErrorNode(i18n.t("Nested lists are not allowed."));
    },

    invalidTableHeader: function (supplement) {
      return ErrorNode(i18n.t("Table headers must be simple expressions. __supplement__", {
        supplement: supplement
      }));
    },

    invalidTableEntry: function (supplement) {
      return ErrorNode(i18n.t("Table entries must be simple expressions. __supplement__", {
        supplement: supplement
      }));
    },

    invalidFirstTableColumn: function () {
      return ErrorNode(i18n.t("First column may not be __most__ or __last__.", {
        most: "'y', 'r',",
        last: "''"
      }));
    },

    invalidDependentFirstTableColumn: function () {
      return ErrorNode(i18n.t("This column header can't be defined elsewhere in the calculator."));
    },

    invalidRegressionParameter: function (symbol) {
      return ErrorNode(i18n.t("'__symbol__' may not be used as a regression parameter.", {
        symbol: Label.formatSymbol(symbol)
      }));
    },

    optimizationError: function () {
      return ErrorNode(i18n.t("Failed to find regression coefficients."));
    },

    nonListRegression: function () {
      return ErrorNode(i18n.t("Regressions must contain at least one list of data."));
    },

    badListInReducer: function (symbol) {
      return ErrorNode(i18n.t("When __symbol__ is called with multiple arguments, no argument can be a list.", {
        symbol: Label.formatSymbol(symbol)
      }));
    },

    indexIntoNonList: function () {
      return ErrorNode(i18n.t("Cannot index into something that is not a list."));
    },

    listAsIndex: function () {
      return ErrorNode(i18n.t("List index must not be a list."));
    },

    variableRange: function (symbols) {
      return ErrorNode(i18n.t("Range cannot depend on free variable '__symbol__'.", {
        symbol: Label.formatSymbol(symbols[0])
      }));
    },

    nonArithmeticRange: function (symbols) {
      return ErrorNode(i18n.t("Ranges must be arithmetic sequences."));
    }
  };
});

define('math/parsenode/expression',['require','pjs','./base','math/errormsg'],function(require){
  //Expression parse-nodes have an output value
  //And can exist within an expression tree
  //This includes constants, variables, math operators, and functions
  //This does not include function calls, inequalities,
  //or variable definitions
  var P = require('pjs');
  var ParseNode = require('./base');
  var ErrorMsg = require('math/errormsg');

  return P(ParseNode, function(node, _super) {
    node.init = function(args) {
      if (!Array.isArray(args)) {
        throw new TypeError('Argument to expression constructor must be an Array.');
      }

      _super.init.call(this);
      this.args = args;
      this.registerDependencies();
      this.computeTreeSize();
    };

    //By default, we depend on all of our args
    node.registerDependencies = function(){
      for(var i = 0; i < this.args.length; i++){
        this.addDependencies(this.args[i].getDependencies());
      }
    };

    node.computeTreeSize = function () {
      var treeSize = 0;
      for (var i = 0; i < this.args.length; i++) {
        if (this.args[i].treeSize) treeSize += this.args[i].treeSize;
      }
      this.treeSize = treeSize + 1;
      if (treeSize > 1e4) throw ErrorMsg.deeplyNested();
    };

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      var concreteArgs = [];
      for(var i = 0; i < this.args.length; i++){
        concreteArgs.push(this.args[i].getConcreteTree(frame, overrides));
      }
      return this.copyWithArgs(concreteArgs);
    };

    //Default behavior.
    //Some nodes need to over-ride, since they have additional configuration beyond args
    node.copyWithArgs = function(args){
      return new this.constructor(args);
    };

  });
});

define('math/parsenode/constant',['require','pjs','./base'],function(require){
  var P = require('pjs');
  var ParseNode = require('./base');

  return P(ParseNode, function(node, _super) {
    node.init = function(value){
      _super.init.call(this, []);
      this.constantValue = value;
    };

    node.isConstant = true;

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      return this;
    };

    node.getEvalStrings = function(){
      return {
        statements: [],
        expression: this.scalarExprString()
      };
    };

    node.scalarExprString = function(){
      if(this.constantValue > 0) return String(this.constantValue);
      return '(' + String(this.constantValue) + ')';
    };

    node.getEvaluationInfo = function(){
      return [{val: this.constantValue, operator: '='}];
    };

    node.okForImplicitFunction = function(){
      return true;
    };
  });
});

define('math/parsenode/list',['require','pjs','./expression','./constant','math/errormsg'],function(require){
  var P = require('pjs');
  var Expression = require('./expression');
  var Constant = require('./constant');
  var ErrorMsg = require('math/errormsg');

  return P(Expression, function(node, _super, _class) {
    node.init = function(elements){
      _super.init.call(this, elements);
      this.length = elements.length;
    };

    node.isList = true;

    node.elementAt = function(i){
      i = Math.floor(i);
      if (i >= 0 && i < this.args.length) return this.args[i];
      return Constant(NaN);
    };

    node.getEvalStrings = function(){
      var retVal = [];
      for(var i = 0; i < this.args.length; i++){
        retVal.push(this.args[i].getEvalStrings());
      }
      return retVal;
    };

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      var concreteElements = [];
      for(var i = 0; i < this.args.length; i++){
        var concreteElement = this.args[i].getConcreteTree(frame, overrides);
        if (concreteElement.isList) throw ErrorMsg.nestedList();
        concreteElements.push(concreteElement);
      }
      return new this.constructor(concreteElements);
    };

    node.getEvaluationInfo = function(){
      /*If we're a list of constants, we're evaluable*/
      if(this.args.every(function(a){return a.isConstant})){
        return [{val: this.args.map(function(a){return a.constantValue}), operator: '='}];
      }
    };

    node.getCompiledFunctions = function (args) {
      return this.args.map(function (a) { return a.getCompiledFunctions(args)[0]; });
    };

    // Length of longest list in args. Returns Infinity if there are no lists
    // in args.
    function _listLength (args) {
      var length = Infinity;
      for (var i = 0; i < args.length; i++) {
        if (args[i].isList) length = Math.min(length, args[i].length);
      }
      return length;
    }

    _class.eachArgs = function (args, fn) {
      var length = _listLength(args);

      if (!isFinite(length)) {
        fn(args);
        return;
      }

      for (var i = 0; i < length; i++) {
        var elts = [];
        for (var j = 0; j < args.length; j++) {
          elts.push(args[j].isList ? args[j].elementAt(i) : args[j]);
        }
        fn(elts);
      }
    };

    _class.mapArgs = function (args, fn) {
      var length = _listLength(args);

      if (!isFinite(length)) return [fn(args)];

      var accum = [];
      for (var i = 0; i < length; i++) {
        var elts = [];
        for (var j = 0; j < args.length; j++) {
          elts.push(args[j].isList ? args[j].elementAt(i) : args[j]);
        }
        accum.push(fn(elts));
      }
      return accum;
    };
  });
});

define('math/parsenode/scalarexpression',['require','pjs','./expression','./constant','./list'],function(require){
  var P = require('pjs');
  var ExpressionNode = require('./expression');
  var Constant = require('./constant');
  var List = require('./list');

  //This represents expressions which follow the standard broadcast pattern
  //for all of their arguments (scalar if all arguments are scalar, otherwise
  //a list with length equal to the minimum length of their list arguments).
  //
  //On getConcreteTree, this will bubble any list arguments up above itself,
  //to convert an operation on lists to a list of operations on scalars

  return P(ExpressionNode, function(node, _super) {
    node.init = function(args) {
      _super.init.call(this, args);
    };

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      //Return a tree which supports frame-based operations like
      //computing polynomialOrder, compiling, type checks, etc.
      //
      //This operation will descend into function calls,
      //substitute variables, and collapse constants
      //
      //This operation will also perform the broadcast logic
      //to map an operation over lists into a list of scalar
      //operation trees.
      //
      //Default operation is to ignore the frame, and generate
      //an identical node but with concrete children
      var i;

      var concreteArgs = [];
      var anyIsList = false;
      for (i = 0; i < this.args.length; i++) {
        var concreteArg = this.args[i].getConcreteTree(frame, overrides);
        if (concreteArg.isList) anyIsList = true;
        concreteArgs.push(concreteArg);
      }

      if (!anyIsList) return this._constantCollapsedCopy(concreteArgs, frame);

      var self = this;
      var elements = List.mapArgs(concreteArgs, function (args) {
        return self._constantCollapsedCopy(args, frame);
      });
      return List(elements);
    };

    node._constantCollapsedCopy = function(args){
      var constantArgs = [];
      for(var i = 0; i < args.length; i++){
        if(!args[i].isConstant) //Not constant - just copy
          return this.copyWithArgs(args);
        constantArgs.push(args[i].constantValue);
      }
      return Constant(this.evaluate(constantArgs)); //Everything was a constant.  Evaluate and return
    };

    node.getEvalStrings = function(){
      //Only works when frame has been baked into the tree, so
      //that lists are guaranteed to be above us or below
      //reducers, and we don't have to deal with them
      //Default implementation:
      //Calls getEvalStrings on each argument
      //Prepends statements, and replaces expression
      //using scalarEvalExpression()
      var statements = [];
      var argExpressions = [];
      for(var i = 0; i < this.args.length; i++){
        var evalStrings = this.args[i].getEvalStrings();
        statements = statements.concat(evalStrings.statements);
        argExpressions.push(evalStrings.expression);
      }
      return {statements: statements, expression: this.scalarEvalExpression(argExpressions)};
    };

  });
});

define('math/parsenode/expressionTypes',['require','pjs','./scalarexpression'],function(require){
  var P = require('pjs');
  var ScalarExpression = require('./scalarexpression');

  return {
    Add: P(ScalarExpression, {}),
    Subtract: P(ScalarExpression, {}),
    Multiply: P(ScalarExpression, {}),
    Divide: P(ScalarExpression, {}),
    Exponent: P(ScalarExpression, {}),
    Negative: P(ScalarExpression, {}),
    And: P(ScalarExpression, {
      isInequality: function () { return this.args[0].isInequality() && this.args[1].isInequality(); }
    })
  };
});

define('math/parsenode/freevariable',['require','pjs','./scalarexpression'],function(require){
  var P = require('pjs');
  var Parent = require('./scalarexpression');

  //Only meant to exist after a call to getConcreteTree
  //This is what an identifier that is not defined in the frame becomes

  return P(Parent, function(node, _super){
    node.init = function(symbol){
      _super.init.call(this, []);
      this.addDependency(symbol);
      this._symbol = symbol;
    };

    node.isFreeVariable = true;

    node.scalarEvalExpression = function(argExpressions) {
      return this._symbol;
    };

    node.copyWithArgs = function(args){
      return this;
    };

    node._constantCollapsedCopy = function(args){
      return this;
    };

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      return this;
    };

  });
});

define('math/parsenode/identifier',['require','pjs','./expression','./freevariable','graphing/label'],function(require){
  var P = require('pjs');
  var Parent = require('./expression');
  var FreeVariable = require('./freevariable');
  var Label = require('graphing/label');

  return P(Parent, function(node, _super, _class) {
    node.init = function(symbol){
      _super.init.call(this, []);
      this._symbol = Label.latexToIdentifier(symbol);
      this.addDependency(this._symbol);
    };

    node.evaluate = function(){throw ("Cannot evaluate undefined variable " + this._symbol)};

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      //If tree is defined in frame, return concrete version of that
      var tree = frame[this._symbol];
      if (tree) {
        if (tree.isError) throw tree;
        if (tree.isFunction) return tree.getConcreteInvocationTree(frame, [], this._symbol, overrides);
        return tree.getConcreteTree(frame, overrides);
      }
      //Otherwise, we're a free variable
      return FreeVariable(this._symbol);
    };

    node.okForImplicitFunction = function(){
      return true;
    };
  });
});

define('math/parsenode/dummyindex',['require','pjs','./freevariable'],function(require){
  var P = require('pjs');
  var Parent = require('./freevariable');

  // Only meant to exist after a call to getConcreteTree
  // This is what the index symbol of a repeated operator becomes. It's main purpose
  // is to express the fact that the concrete tree no longer depends on external
  // values of that variable.

  return P(Parent, function (node, _super) {
    node.init = function () {
      _super.init.apply(this, arguments);
      this._dependencies = [];
    };
  });
});

define('math/parsenode/range',['require','pjs','./expression','math/errormsg','./list','./constant','math/builtin'],function(require){
  var P = require('pjs');
  var Parent = require('./expression');
  var ErrorMsg = require('math/errormsg');
  var List = require('./list');
  var Constant = require('./constant');
  var BuiltIn = require('math/builtin');

  return P(Parent, function(node, _super, _class) {
    node.init = function (args) {
      _super.init.call(this, args);
      this.beginning = args[0];
      this.end = args[1];
    };

    function _checkVal (concreteBeginning, concreteEnd, i, nsteps, val) {
      if (i < concreteBeginning.length) {
        if (!BuiltIn.approx(val, concreteBeginning.elementAt(i).constantValue, 10)) {
          throw ErrorMsg.nonArithmeticRange();
        }
      }
      // Note, puprosely don't check actual end value
      if (nsteps - i <= concreteEnd.length && nsteps - i > 1) {
        if (!BuiltIn.approx(val, concreteEnd.elementAt(concreteEnd.length - nsteps + i).constantValue, 10)) {
          throw ErrorMsg.nonArithmeticRange();
        }
      }
    }

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      var concreteBeginning = this.beginning.getConcreteTree(frame, overrides);
      var concreteEnd = this.end.getConcreteTree(frame, overrides);

      if (concreteBeginning.getDependencies().length) {
        throw ErrorMsg.variableRange(concreteBeginning.getDependencies());
      }
      if (concreteEnd.getDependencies().length) {
        throw ErrorMsg.variableRange(concreteEnd.getDependencies());
      }
      if (!concreteBeginning.isList || !concreteEnd.isList) {
        throw new Error("Programming Error: range bounds must be List nodes.");
      }

      var start = concreteBeginning.elementAt(0).constantValue;
      var end = concreteEnd.elementAt(concreteEnd.length - 1).constantValue;
      var diff = end - start;
      var step;
      if (concreteBeginning.length === 1) {
        step = diff >= 0 ? 1 : -1;
      } else {
        step = concreteBeginning.elementAt(1).constantValue - start;
      }
      var nsteps = Math.round(diff/step) + 1;
      if (!isFinite(nsteps) || nsteps < concreteBeginning.length || nsteps < concreteEnd.length) {
        throw ErrorMsg.nonArithmeticRange();
      }

      var accum = [Constant(start)];

      for (var i = 1; i < nsteps; i++) {
        // Barrycentric interpolation is the best way to
        // hit start and end exactly, and get good values
        // in the middle
        var val = start + i*step;
        _checkVal(concreteBeginning, concreteEnd, i, nsteps, val);
        accum.push(Constant(val));
      }

      return List(accum);
    };
  });
});

define('math/parsenode/listaccess',['require','pjs','./expression','math/errormsg'],function(require){
  var P = require('pjs');
  var Super = require('./expression');
  var ErrorMsg = require('math/errormsg');

  return P(Super, function(node, _super) {
    node.init = function(args){
      _super.init.call(this, args);
      this.list = args[0];
      this.index = args[1];
    };

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      var concreteIndex = this.index.getConcreteTree(frame, overrides);
      if (concreteIndex.isList) throw ErrorMsg.listAsIndex();
      if (concreteIndex.isConstant) {
        //Convert from 1-index user-visible math to 0-indexed internal math
        //TODO - could be more efficient, and only make that list element concrete
        //but this is hard for examples where the list has to be evaluated or looked up
        var concreteList = this.list.getConcreteTree(frame, overrides);
        if (!concreteList.isList) throw ErrorMsg.indexIntoNonList();
        return concreteList.getConcreteTree(frame, overrides).elementAt(concreteIndex.constantValue - 1);
      }
      return new this.constructor([this.list.getConcreteTree(frame, overrides), concreteIndex]);
    };

    node.getEvalStrings = function(){
      var indexStrings = this.index.getEvalStrings();
      var listStrings = this.list.getEvalStrings();
      var statements = indexStrings.statements.slice(); //Statements required to compute index

      var tmp = this.tmpVar();
      statements.push('var '+tmp);

      var caseStrings = [];
      for(var i = 0; i < listStrings.length; i++){
        caseStrings.push('case '+i+':'+
                        listStrings[i].statements.join(';')+';'+
                        tmp+'='+listStrings[i].expression);
      }
      caseStrings.push('default:'+tmp+'=NaN');
      //Convert from 1-index user-visible math to 0-indexed internal math
      var switchStatement = 'switch(Math.floor('+(indexStrings.expression)+')-1){\n' +
                            caseStrings.join(';break\n') +
                            '\n}';

      statements.push(switchStatement);
      return {statements: statements, expression: tmp};
    };
  });
});

define('math/parsenode/orderedpair',['require','pjs','./expression','./list','math/policy'],function(require){
  var P = require('pjs');
  var Expression = require('./expression');
  var List = require('./list');
  var Policy = require('math/policy');

  return P(Expression, function(node, _super, _class) {
    node.getCompiledFunctions = function (args) {
      return [
        this.args[0].getCompiledFunctions(args)[0],
        this.args[1].getCompiledFunctions(args)[0]
      ];
    };

    node.getSliderVariables = function (concrete) {
      return Policy.sliderVariables(concrete.getDependencies()).filter(function (symbol) {
        return !Policy.validParametricVariable(symbol);
      });
    };

    node.getConcreteTree = function (frame, overrides) {
      var concreteArgs = [];
      for (var i = 0; i < this.args.length; i++) {
        concreteArgs.push(this.args[i].getConcreteTree(frame, overrides));
      }

      return this.copyWithArgs(concreteArgs);
    };

    // nonstandard constructor used by parser to desugar an ordered pair list
    // into a single ordered pair with lists of coordinates, i.e. to desugar
    // (1, 2), (3, 4) into ([1,3], [2,4])
    _class.fromList = function (list) {
      if (list.length === 1) return list[0];
      var xargs = [];
      var yargs = [];
      for (var i = 0; i < list.length; i++) {
        xargs.push(list[i].args[0]);
        yargs.push(list[i].args[1]);
      }
      return _class([List(xargs), List(yargs)]);
    };
  });
});

define('math/parsenode/movablepoint',['require','pjs','./orderedpair'],function(require){
  var P = require('pjs');
  var Parent = require('./orderedpair');

  return P(Parent, function(node, _super) {
    node.init = function (args, moveIds, moveMatrix) {
      _super.init.call(this, args);
      this._moveIds = moveIds;
      this._moveMatrix = moveMatrix;
    };

    node.isMovablePoint = true;
  });
});

//Use this table to get rid of all the string comparisons used to interpret comparators
define('math/comparators',['require'],function(require){

var ComparatorTable = {
   '<': {inclusive: false, direction: -1},
  '!=': {inclusive: false, direction:  0},
   '>': {inclusive: false, direction:  1},
  '<=': {inclusive: true,  direction: -1},
  '=': {inclusive: true,  direction:  0},
  '>=': {inclusive: true,  direction:  1}
};

var getComparator = function(inclusive, direction){
  switch(direction){
    case -1:
      return (inclusive ? '<=' : '<');
    case 0:
      return (inclusive ? '=' : '!=');
    case 1:
      return (inclusive ? '>=' : '>');
    default:
      throw "Programming error.  Comparators must have a direction of -1, 0, or 1";
  }
};

return {
  table: ComparatorTable,
  get: getComparator,
};

});

define('math/parsenode/basecomparator',['require','pjs','./scalarexpression','./expressionTypes','math/comparators','math/functions'],function(require){
  var P = require('pjs');
  var ScalarExpression = require('./scalarexpression');
  var Subtract = require('./expressionTypes').Subtract;
  var comparatorTable = require('math/comparators').table;
  var Functions = require('math/functions');

  return P(ScalarExpression, function (node, _super, _class) {
    // Create concrete Comparator classes by calling BaseComparator.create(operator).
    // This happens in parsenode/comparator.js
    _class.create = function (operator, compiledOperator) {
      compiledOperator = compiledOperator || operator;
      return P(_class, function(node, _super){
        node.operator = operator;
        node.isInequality = function () { return comparatorTable[operator].direction !== 0; };
        node.compiledOperator = compiledOperator || operator;
        node.scalarEvalExpression = function (args) { return args.join(compiledOperator); };

        node.evaluate = Functions.createEvaluateFunction(node.scalarEvalExpression, 2);
      });
    };

    node.init = function (args) {
      _super.init.call(this, args);

      this._difference = comparatorTable[this.operator].direction === -1 ?
        Subtract([args[1], args[0]]) :
        Subtract([args[0], args[1]])
      ;
    };
  });
});

define('math/parsenode/comparator',['require','math/parsenode/basecomparator'],function (require) {
  var BaseComparator = require('math/parsenode/basecomparator');

  return {
    '<': BaseComparator.create('<'),
    '>': BaseComparator.create('>'),
    '<=': BaseComparator.create('<='),
    '>=': BaseComparator.create('>='),
    '=': BaseComparator.create('=', '===')
  };
});

define('math/parsenode/piecewise',['require','pjs','./scalarexpression','./constant'],function (require) {
  var P = require('pjs');
  var Parent = require('./scalarexpression');
  var Constant = require('./constant');

  var Piecewise = P(Parent, {});

  Piecewise.chain = function (args) {
    var next;
    var head = Constant(NaN); //Default if nothing matches
    while (args.length) {
      next = args.pop();
      head = Piecewise([next.condition, next.if_expr, head]);
    }
    return head;
  };

  return Piecewise;
});

define('math/parsenode/doubleinequality',['require','pjs','./base','./identifier','./constant','./piecewise','math/comparators','./comparator'],function(require){
  var P = require('pjs');
  var Parent = require('./base');
  var Identifier = require('./identifier');
  var Constant = require('./constant');
  var Piecewise = require('./piecewise');
  var Comparators = require('math/comparators');
  var Comparator = require('./comparator');

  return P(Parent, function (node, _super) {
    node.init = function (args) {
      _super.init.call(this);
      this._symbol = args[2]._symbol;
      this._operators = [args[1], args[3]];
      this._expressions = [args[0], args[4]];

      var indicatorComparator = Comparators.get(
        Comparators.table[args[1]].inclusive && Comparators.table[args[3]].inclusive,
        Comparators.table[args[1]].direction
      );

      this._indicator = Comparator[indicatorComparator]([args[0], args[4]]);
      this.addDependency(this._symbol);
      this.addDependencies(this._expressions[0].getDependencies());
      this.addDependencies(this._expressions[1].getDependencies());
    };

    node.isInequality = function () { return true; };

    node.isShadeBetween = function () { return true; };

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      return this.constructor.call(this, [
        Piecewise([this._indicator, this._expressions[0], Constant(NaN)]).getConcreteTree(frame, overrides),
        this._operators[0],
        Identifier(this._symbol), // TODO what if _symbol is in the frame?
        this._operators[1],
        Piecewise([this._indicator, this._expressions[1], Constant(NaN)]).getConcreteTree(frame, overrides)
      ]);
    };

    node.getCompiledFunctions = function (args) {
      return [
        this._expressions[0].getCompiledFunctions(args)[0], // TODO handle list expressions
        this._expressions[1].getCompiledFunctions(args)[0]
      ];
    };

    node.getCompiledDerivatives = function () {
      return [
        this._expressions[0].getCompiledDerivatives()[0],
        this._expressions[1].getCompiledDerivatives()[0]
      ];
    };
  });

});

define('math/parsenode/repeatedoperator',['require','pjs','./scalarexpression','./dummyindex','./constant','math/errormsg'],function(require){
  var P = require('pjs');
  var Parent = require('./scalarexpression');
  var DummyIndex = require('./dummyindex');
  var Constant = require('./constant');
  var ErrorMsg = require('math/errormsg');

  return P(Parent, function(node, _super) {
    node.init = function (args) {
      _super.init.call(this, args);
      this._index = args[0];
    };

    //Must define starting_value (e.g. 0)
    //Must define in_place_operator (e.g. "+=")
    //Must define evaluateConstant function

    //Always runs in a scalar environment, thanks to inheriting
    //from scalarexpression
    node.getEvalStrings = function(){
      var statements = [];

      var sum = this.tmpVar();
      var index = this._index._symbol;
      var lower_bound = this.tmpVar();
      var upper_bound = this.tmpVar();

      var lower_bound_strings = this.args[1].getEvalStrings();
      var upper_bound_strings = this.args[2].getEvalStrings();
      var summand_strings = this.args[3].getEvalStrings();

      Array.prototype.push.apply(statements, lower_bound_strings.statements);
      statements.push('var '+lower_bound+' = Math.round(' + lower_bound_strings.expression + ')');
      Array.prototype.push.apply(statements, upper_bound_strings.statements);
      statements.push('var '+upper_bound+' = Math.round(' + upper_bound_strings.expression + ')');
      statements.push('var '+sum+'='+this.starting_value);

      var loop = 'for (var '+index+'='+lower_bound+';'+index+'<='+upper_bound+';'+index+'++) {'+
          summand_strings.statements.join(';')+';'+sum+this.in_place_operator+summand_strings.expression+'};';

      var protected_loop = 'if(!isFinite('+upper_bound+'-'+lower_bound+')) {'+
          sum+'=('+upper_bound+'<'+lower_bound+'?'+this.starting_value+':NaN);}else{'+loop+'}';

      statements.push(protected_loop);

      return {statements: statements, expression: sum};
    };

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      if (frame[this._index._symbol]) throw ErrorMsg.shadowedIndex(this._index._symbol);
      var localFrame = Object.create(frame);
      localFrame[this._index._symbol] = DummyIndex(this._index._symbol);
      var concreteTree = _super.getConcreteTree.call(this, localFrame, overrides);
      return concreteTree;
    };

    node.evaluate = function(lowerBound, upperBound, summandExpression){
      //Compile summand as function of loopVariable.
      //TODO - assert that it's not a list by this point
      var fn = summandExpression.getCompiledFunctions([this._index._symbol])[0].fn;
      //We know bounds are constant, otherwise we can't evaluate to a constant
      upperBound = Math.round(upperBound);
      lowerBound = Math.round(lowerBound);

      //Protect against NaNs and Infinities
      if(!isFinite(upperBound - lowerBound)) return (upperBound < lowerBound ? this.starting_value : NaN);

      //Run the loop
      var sum = this.starting_value;
      for(var index = lowerBound; index <= upperBound; index++){
        sum = this.update(sum, fn(index));
      }
      return sum;
    };

    node._constantCollapsedCopy = function(args){
      //Should collapse to constant if summand only depends on index variable
      if(args[1].isConstant && args[2].isConstant){
        var lowerBound = args[1].constantValue;
        var upperBound = args[2].constantValue;
        var summand = args[3];
        if(summand.isConstant){
          //Constant loop can just be multiplied
          return Constant(this.evaluateConstant([lowerBound, upperBound, summand.constantValue]));
        }
        if(summand.getDependencies().length === 0){
          //Compute, since we only depend on the loop variable
          return Constant(this.evaluate(lowerBound, upperBound, summand));
        }
      }
      return this.copyWithArgs(args);
    };
  });
});

define('math/parsenode/sum',['require','pjs','./repeatedoperator'],function(require){
  var P = require('pjs');
  var Parent = require('./repeatedoperator');

  return P(Parent, function(node, _super) {
    node.in_place_operator = '+=';
    node.starting_value = 0;

    node.evaluateConstant = function(args){
      var num_loops = 1 + Math.round(args[1]) - Math.round(args[0]);
      if(num_loops <= 0) return this.starting_value;
      return num_loops * args[3];
    };

    node.update = function(sum, value){
      return sum + value;
    };
  });
});

define('math/parsenode/product',['require','pjs','./repeatedoperator'],function(require){
  var P = require('pjs');
  var Parent = require('./repeatedoperator');

  return P(Parent, function(node, _super) {
    node.in_place_operator = '*=';
    node.starting_value = 1;

    node.evaluateConstant = function(args){
      var num_loops = 1 + Math.round(args[1]) - Math.round(args[0]);
      if(num_loops <= 0) return this.starting_value;
      return Math.pow(args[3], num_loops);
    };

    node.update = function(sum, value){
      return sum * value;
    };
  });
});

define('math/parsenode/functioncall',['require','pjs','./expression','math/errormsg','./identifier','./expressionTypes'],function(require){
  var P = require('pjs');
  var Parent = require('./expression');
  var ErrorMsg = require('math/errormsg');
  var Identifier = require('./identifier');
  var Multiply = require('./expressionTypes').Multiply;

  return P(Parent, function(node, _super) {
    node.init = function(identifier, args){
      if(typeof(identifier) === 'string') identifier = Identifier(identifier);
      this._symbol = identifier._symbol; //Relying on symbol rewrite logic in Identifier
      _super.init.call(this, args);
      this.addDependency(this._symbol);
    };

    node.copyWithArgs = function (args) {
      return new this.constructor(Identifier(this._symbol), args);
    };

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      var fn = frame[this._symbol];
      if(fn && fn.isError) throw fn;
      if(!fn || !fn.isFunction){
        if(this.args.length == 1) {
          var multiplyArgs = [Identifier(this._symbol), this.args[0]];
          return Multiply(multiplyArgs).getConcreteTree(frame, overrides);
        }
        if(fn){
          throw ErrorMsg.variableAsFunction(this._symbol);
        }
        throw ErrorMsg.functionNotDefined(this._symbol);
      }

      var concreteArgs = [];
      for(var i = 0; i < this.args.length; i++){
        var concreteArg = this.args[i].getConcreteTree(frame, overrides);
        concreteArgs.push(concreteArg);
      }

      return fn.getConcreteInvocationTree(frame, concreteArgs, this._symbol, overrides);
    };
  });
});

define('math/parsenode/functionexponent',['require','pjs','./expression','./expressionTypes','./functioncall'],function(require){
  var P = require('pjs');
  var Parent = require('./expression');
  var expressionTypes = require('./expressionTypes');
  var Multiply = expressionTypes.Multiply;
  var Exponent = expressionTypes.Exponent;
  var FunctionCall = require('./functioncall');
  //Ambiguous function call / exponent node
  //e.g. a(b)^c
  //could be function a(b) raised to the c,
  //or could be a * (b)^c

  return P(Parent, function(node, _super){
    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      var fn = this.args[0]._symbol;
      if(frame[fn] && frame[fn].isFunction){
        return Exponent([FunctionCall(fn, [this.args[1]]), this.args[2]]).getConcreteTree(frame, overrides);
      } else {
        return Multiply([this.args[0], Exponent([this.args[1], this.args[2]])]).getConcreteTree(frame, overrides);
      }
    };
  });
});

define('math/parsenode/nativefunction',['require','pjs','./scalarexpression','math/errormsg','math/functions'],function(require){
  //This is the default definition of a built-in function, which can be expressed
  //as a string (e.g. "Math.sin")
  //This can be expanded to cover functions with unique signatures (like reducers),
  //Functions on BuiltIn instead of on Math, etc.
  var P = require('pjs');
  var ScalarExpression = require('./scalarexpression');
  var ErrorMsg = require('math/errormsg');
  var Functions = require('math/functions');

  var Invocation = P(ScalarExpression, function(node, _super){
    node.init = function(fn, args){
      _super.init.call(this, args);
      this._fn = fn;
      this.scalarEvalExpression = this._fn.scalarEvalExpression;
      this.evaluate = this._fn.evaluate;
    };

    node.copyWithArgs = function(args){
      return new this.constructor(this._fn, args);
    };

    node.polynomialOrder = function(symbol){
      return this.dependsOn(symbol) ? Infinity : 0;
    };
  });

  //This thing lives in the BuiltIn frame, but there's no way for a user to declare it,
  //or for it to actually exist as a term in an expression.
  //
  //It's not clear that it should actually be parsenode, since it's not parsed.
  //
  //It would be the thing that a user declared if we allowed them to pass
  //in arbitrary javascript for us to evaluate, e.g. via the API
  return P(function(node, _super, _class) {

    //Sample call is NativeFunction('Math.sin', 1)
    node.init = function(head, arity) {
      this._arity = arity; //TODO - verify this
      this.head = head;
      // create here to clouse in head
      this.scalarEvalExpression = function (argExpressions) {
        return head + '(' + argExpressions.join(',') + ')';
      };
      this.evaluate = Functions.createEvaluateFunction(this.scalarEvalExpression, arity);
    };

    node.isFunction = true;

    node.getConcreteInvocationTree = function (frame, args, symbol, overrides) {
      if(args.length !== this._arity) throw ErrorMsg.wrongArity(symbol, this._arity, args.length);
      return this._getInvocationTree(args).getConcreteTree(frame, overrides);
    };

    node._getInvocationTree = function(args){
      return Invocation(this, args);
    };

    _class.Invocation = Invocation;
  });
});

define('math/parsenode/trigfunction',['require','pjs','./nativefunction','./expressionTypes','./identifier'],function(require){
  //For functions like sin(x) which depend on the angleMultiplier
  //to switch between radians and degrees

  var P = require('pjs');
  var NativeFunction = require('./nativefunction');
  var Multiply = require('./expressionTypes').Multiply;
  var Identifier = require('./identifier');

  return P(NativeFunction, function(node, _super) {
    node.init = function(head){
      _super.init.call(this, head, 1);
    };

    node.getConcreteInvocationTree = function (frame, args, symbol, overrides) {
      if(frame.trigAngleMultiplier){
        var scaledArgs = [Multiply([args[0], Identifier('trigAngleMultiplier')])];
        return _super.getConcreteInvocationTree.call(this, frame, scaledArgs, symbol, overrides);
      } else {
        return _super.getConcreteInvocationTree.call(this, frame, args, symbol, overrides);
      }
    };
  });
});

define('math/parsenode/inversetrigfunction',['require','pjs','./nativefunction','./expressionTypes','./identifier'],function(require){
  //For functions like arcsin(x) which depend on the angleMultiplier
  //to switch between radians and degrees

  var P = require('pjs');
  var NativeFunction = require('./nativefunction');
  var Divide = require('./expressionTypes').Divide;
  var Identifier = require('./identifier');

  return P(NativeFunction, function(node, _super) {
    node.init = function(head){
      _super.init.call(this, head, 1);
    };

    node.getConcreteInvocationTree = function (frame, args, symbol, overrides) {
      if(frame.trigAngleMultiplier){
        var tree = this._getInvocationTree(args);
        return Divide([tree, Identifier('trigAngleMultiplier')]).getConcreteTree(frame);
      } else {
        return _super.getConcreteInvocationTree.call(this, frame, args, symbol, overrides);
      }
    };
  });
});

define('math/parsenode/reducerfunction',['require','pjs','./expression','./list','./constant','math/functions','math/errormsg'],function(require){
  //This is the definition of a built-in function which maps a single
  //list to a single scalar

  var P = require('pjs');
  var Expression = require('./expression');
  var List = require('./list');
  var Constant = require('./constant');
  var Functions = require('math/functions');
  var ErrorMsg = require('math/errormsg');

  var Invocation = P(Expression, function(node, _super){
    node.init = function(symbol, fn, args){
      _super.init.call(this, args);
      this._symbol = symbol;
      this._fn = fn;
      this.evalExpression = this._fn.evalExpression;
      this.evaluate = this._fn.evaluate;
    };

    node.copyWithArgs = function(args){
      return new this.constructor(this._symbol, this._fn, args);
    };

    node.getEvalStrings = function(){
      var list = this.args[0];
      var statements = [];
      var elementExpressions = [];
      for(var i = 0; i < list.length; i++){
        var elementStrings = list.elementAt(i).getEvalStrings();
        statements = statements.concat(elementStrings.statements);
        elementExpressions.push(elementStrings.expression);
      }
      var argExpressions = ['[' + elementExpressions.join(',') + ']'];
      return {statements: statements, expression: this.evalExpression(argExpressions)};
    };

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);

      var i;
      var args = this.args;

      var list;
      var collect;
      if (args.length === 0) throw ErrorMsg.zeroArgReducer(this._symbol);

      if (args.length === 1) {
        list = args[0].getConcreteTree(frame, overrides);
        collect = !list.isList;
      } else if (args.length === 2 && (args[0].isList || args[1].isList)) {
        var self = this;
        return List(List.mapArgs(this.args, function (args) {
          return self.copyWithArgs(args).getConcreteTree(frame, overrides);
        }));
      } else {
        collect = true;
      }

      var concreteArgs = [];
      if (collect) {
        for (i = 0; i < args.length; i++) {
          if (args[i].isList) throw ErrorMsg.badListInReducer(this._symbol);
          concreteArgs.push(args[i].getConcreteTree(frame, overrides));
        }
        list = List(args);
      }

      //If list elements are all constant, we can constant collapse
      var constantElements = [];
      for (i = 0; i < list.length; i++) {
        var element = list.elementAt(i);
        if(!element.isConstant){
          return this.copyWithArgs([list]);
        }
        constantElements.push(element.constantValue);
      }
      return Constant(this.evaluate([constantElements]));
    };
  });

  return P(function(node, _super, _class) {
    //Sample call is ReducerFunction('Reducers.mean', 1)
    node.init = function(head, arity) {
      this.head = head;
      if (arity !== 1) throw new Error("Higher arity reduces not yet implemented");
      this._arity = arity;
      // create here to clouse in head
      this.evalExpression = function (argExpressions) {
        return head + '(' + argExpressions.join(',') + ')';
      };
      this.evaluate = Functions.createEvaluateFunction(this.evalExpression, arity);
    };

    node.isFunction = true;
    node.isReducer = true;

    node.getConcreteInvocationTree = function (frame, args, symbol, overrides) {
      return Invocation(symbol, this, args).getConcreteTree(frame, overrides);
    };

    _class.Invocation = Invocation;
  });
});

//Definition of built-in functions and variables

define('math/builtinframe',['require','math/parsenode/constant','math/parsenode/nativefunction','math/parsenode/trigfunction','math/parsenode/inversetrigfunction','math/parsenode/reducerfunction'],function(require){
  //Defining with short names
  var Constant = require('math/parsenode/constant');
  var F = require('math/parsenode/nativefunction');
  var Trig = require('math/parsenode/trigfunction');
  var ITrig = require('math/parsenode/inversetrigfunction');
  var Reducer = require('math/parsenode/reducerfunction');

  return {
    pi: Constant(Math.PI),
    tau: Constant(2 * Math.PI),
    e: Constant(Math.E),
    trigAngleMultiplier: Constant(1),

    //Trig functions
    sin: Trig('BuiltIn.sin'),
    cos: Trig('BuiltIn.cos'),
    tan: Trig('BuiltIn.tan'),
    cot: Trig('BuiltIn.cot'),
    sec: Trig('BuiltIn.sec'),
    csc: Trig('BuiltIn.csc'),
    //Inverse trig function
    arcsin: ITrig('Math.asin'),
    arccos: ITrig('Math.acos'),
    arctan: ITrig('Math.atan'),
    arccot: ITrig('BuiltIn.acot'),
    arcsec: ITrig('BuiltIn.asec'),
    arccsc: ITrig('BuiltIn.acsc'),

    //Hyperbolic trig functions
    sinh: F('BuiltIn.sinh', 1),
    cosh: F('BuiltIn.cosh', 1),
    tanh: F('BuiltIn.tanh', 1),
    coth: F('BuiltIn.coth', 1),
    sech: F('BuiltIn.sech', 1),
    csch: F('BuiltIn.csch', 1),
    arcsinh: F('BuiltIn.asinh', 1),
    arccosh: F('BuiltIn.acosh', 1),
    arctanh: F('BuiltIn.atanh', 1),
    arccoth: F('BuiltIn.acoth', 1),
    arcsech: F('BuiltIn.asech', 1),
    arccsch: F('BuiltIn.acsch', 1),

    //Power functions
    pow: F('BuiltIn.pow', 2),
    sqrt: F('Math.sqrt', 1),
    nthroot: F('BuiltIn.nthroot', 2),
    log: F('BuiltIn.log_base', 2),
    ln: F('Math.log', 1),
    exp: F('Math.exp', 1),

    //Integer functions
    floor: F('Math.floor', 1),
    ceil: F('Math.ceil', 1),
    round: F('Math.round', 1),
    abs: F('Math.abs', 1),
    sign: F('BuiltIn.sign', 1),
    mod: F('BuiltIn.mod', 2),

    lcm: F('BuiltIn.lcm', 2),
    gcd: F('BuiltIn.gcd', 2),
    nCr: F('BuiltIn.nCr', 2),
    nPr: F('BuiltIn.nPr', 2),
    factorial: F('BuiltIn.factorial', 1),
    polyGamma: F('BuiltIn.polyGamma', 2),

    //Stats
    mean: Reducer('BuiltIn.mean', 1),
    total: Reducer('BuiltIn.total', 1),
    'var': Reducer('BuiltIn.var', 1),
    stdev: Reducer('BuiltIn.stdev', 1),
    stdevp: Reducer('BuiltIn.stdevp', 1),
    length: Reducer('BuiltIn.length', 1),
    min: Reducer('BuiltIn.listMin', 1),
    max: Reducer('BuiltIn.listMax', 1),
    argmin: Reducer('BuiltIn.argMin', 1),
    argmax: Reducer('BuiltIn.argMax', 1)
  };
});

define('math/parsenode/derivative',['require','pjs','./scalarexpression','./freevariable','./identifier','math/builtinframe'],function(require){
  var P = require('pjs');
  var Parent = require('./scalarexpression');
  var FreeVariable = require('./freevariable');
  var Identifier = require('./identifier');
  var BuiltInFrame = require('math/builtinframe');

  return P(Parent, function(node, _super){
    node.init = function (symbol, args) {
      this._symbol = Identifier(symbol)._symbol; // Use identifier normalization for symbol
      _super.init.call(this, args);
    };

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      if (frame[this._symbol]) {
        var childFrame = Object.create(frame);
        childFrame[this._symbol] = FreeVariable(this._symbol);
        var substitution = {};
        substitution[this._symbol] = frame[this._symbol];
        return _super.getConcreteTree.call(this, childFrame, overrides)
          .substitute(substitution)
          .getConcreteTree(frame, overrides)
        ;
      }
      return _super.getConcreteTree.call(this, frame, overrides);
    };

    //Not really a great name for derivatives, since they think about constants differently
    //More like getScalarConcreteTree...
    node._constantCollapsedCopy = function (concreteArgs) {
      return concreteArgs[0].takeDerivative(this._symbol).getConcreteTree(BuiltInFrame);
    };
  });
});

define('math/parsenode/equation',['require','./base','pjs','./expressionTypes','math/parsenode/comparator'],function(require){
  var Parent = require('./base');
  var P = require('pjs');
  var Subtract = require('./expressionTypes').Subtract;
  var Comparator = require('math/parsenode/comparator');

  return P(Parent, function(node, _super){
    node.init = function(lhs, rhs){
      _super.init.call(this);
      this.addDependencies(lhs.getDependencies());
      this.addDependencies(rhs.getDependencies());
      this._lhs = lhs;
      this._rhs = rhs;
      this._difference = Subtract([this._lhs, this._rhs]);
    };

    node.asComparator = function () {
      return Comparator['=']([this._lhs, this._rhs]);
    };

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      return this.asComparator().getConcreteTree(frame, overrides);
    };
  });
});

define('math/parsenode/assignment',['require','./base','math/policy','./equation','./identifier','pjs'],function(require){
  var Parent = require('./base');
  var Policy = require('math/policy');
  var Equation = require('./equation');
  var Identifier = require('./identifier');
  var P = require('pjs');

  return P(Parent, function(node, _super){
    node.init = function(symbol, expression){
      _super.init.call(this);
      symbol = symbol._symbol; //TODO - normalize symbol processing.
      //Would like to always pass around strings, but sometimes we pass around Identifiers instead
      //due to the way the parser works.
      this.addDependencies(expression.getDependencies());
      this._expression = expression;
      this._symbol = symbol;
      this._exports = Policy.assignmentForbidden(symbol) ? [] : [symbol];
    };

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      return this._expression.getConcreteTree(frame, overrides);
    };

    node.asEquation = function () {
      var eqn = Equation(Identifier(this._symbol), this._expression);
      // TODO was hard to predict by reading that this would be necessary. API smell.
      eqn.userData = this.userData;
      return eqn;
    };

    node.getSliderInfo = function () {
      if (this._expression.isConstant) return {value: this._expression.constantValue};
    };

  });
});

define('math/parsenode/functiondefinition',['require','pjs','./base','math/errormsg','math/policy'],function(require){
  var P = require('pjs');
  var ParseNode = require('./base');
  var ErrorMsg = require('math/errormsg');
  var Policy = require('math/policy');

  return P(ParseNode, function(node, _super) {

    node.init = function(symbol, args, expression) {
      _super.init.call(this);

      symbol = symbol._symbol; //TODO - normalize symbol processing.
      // Currently using Identifer constructor to normalize symbols

      this._argSymbols = args.map(function (identifier) { return identifier._symbol; });
      this._symbol = symbol;
      this._exports = Policy.assignmentForbidden(symbol) ? [] : [symbol];
      this._expression = expression;
      this.addDependencies(this._argSymbols);
      this.addDependencies(this._expression.getDependencies()); //Will depend on formal arguments
    };

    node.isFunction = true;

    node.getConcreteInvocationTree = function(frame, args, symbol, overrides) {
      if (args.length !== this._argSymbols.length) {
        throw ErrorMsg.wrongArity(this._symbol, this._argSymbols.length, args.length);
      }
      var localFrame = Object.create(frame);

      for (var i = 0; i < this._argSymbols.length; i++) {
        localFrame[this._argSymbols[i]] = args[i];
      }

      return this._expression.getConcreteTree(localFrame, overrides);
    };

    node.getConcreteTree = function(frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      for(var i = 0; i < this._argSymbols.length; i++){
        if(frame[this._argSymbols[i]]) throw ErrorMsg.parameterAlreadyDefined(this._argSymbols[i]);
        if(this._argSymbols[i] === this._symbol) throw ErrorMsg.parameterAlreadyDefined(this._argSymbols[i]);
      }
      return this._expression.getConcreteTree(frame, overrides);
    };

    node.getArgs = function(){
      return this._args;
    };

    node.getSliderVariables = function (concrete) {
      var argSymbols = this._argSymbols;
      return Policy.sliderVariables(concrete.getDependencies()).filter(function (symbol) {
        return argSymbols.indexOf(symbol) === -1;
      });
    };
  });
});

define('math/parsenode/optimizedregression',['require','pjs','./base'],function (require) {
  var P = require('pjs');
  var Parent = require('./base');

  return P(Parent, function (node, _super) {
    node.init = function (parameters, residuals, statistics, model, opts) {
      _super.init.call(this);
      this.parameters = parameters;
      this.residuals = residuals;
      this.statistics = statistics;
      this.model = model;

      this.isModelValid = opts.isModelValid;
      this.residualVariable = opts.residualVariable;
      this.residualSuggestionId = opts.residualSuggestionId;

      // An optimized regression exports its residual variable and all of its
      // parameters
      this._exports = [this.residualVariable];
      for (var p in parameters) {
        if (parameters.hasOwnProperty(p)) this._exports.push(p);
      }
      // TODO this is a little sketchy, since these dependencies are just a bunch
      // of tmpVars used for plotting.
      this.addDependencies(model.getDependencies());
    };

    // Forward getCompiledFunctions calls to model
    node.getCompiledFunctions = function () {
      return this.model.getCompiledFunctions.apply(this.model, arguments);
    };
    node.evaluate = function () {
      return this.model.evaluate.apply(this.model, arguments);
    };
  });
});

define('math/parsenode/regression',['require','pjs','./base','numeric','math/builtin','math/policy','graphing/label','math/errormsg','./optimizedregression','./list','./identifier','./constant','./freevariable','./expressionTypes','console'],function (require) {
  var P = require('pjs');
  var Parent = require('./base');
  var Numeric = require('numeric');
  var BuiltIn = require('math/builtin');
  var Policy = require('math/policy');
  var Label = require('graphing/label');
  var ErrorMsg = require('math/errormsg');
  var OptimizedRegression = require('./optimizedregression');
  var List = require('./list');
  var Identifier = require('./identifier');
  var Constant = require('./constant');
  var FreeVariable = require('./freevariable');
  var expressionTypes = require('./expressionTypes');
  var console = require('console');

  var Subtract = expressionTypes.Subtract;

  return P(Parent, function(node, _super){
    node.init = function(lhs, rhs){
      _super.init.call(this);
      this._lhs = lhs;
      this._rhs = rhs;
      this._difference = Subtract([lhs, rhs]);
      this.addDependencies(lhs.getDependencies());
      this.addDependencies(rhs.getDependencies());
    };

    node.isRegression = true;

    node.chooseResidualVariable = function (exportFrame) {
      if (this.userData && this.userData.residualVariable) {
        var stripped = Label.latexToIdentifier(this.userData.residualVariable);
        if (!exportFrame[stripped]) return stripped;
      }
      var dependencies = this.getDependencies();
      var candidate;
      for (var i = 0; i < dependencies.length; i++) {
        var match = dependencies[i].match(/_(.*)/);
        if (!match) continue;
        candidate = 'e_' + match[1];
        if (!exportFrame[candidate]) return candidate;
      }
      var n = 1;
      while (true) {
        candidate = 'e_' + n;
        if (!exportFrame[candidate]) return candidate;
        n++;
      }
    };

    function canCorrelate (modelNode, replacedNodes) {
      // Check if the model is of the form y = f(u, v)*x + g(u, v). Where f and g are
      // linearly independent linear (well, actually affine) functions of u and v.
      //
      // The point of this is to be sure that we actually can find the best linear fit
      // to the data by adjusting the model parameters.
      if (replacedNodes.length !== 1) return false;
      var dependencies = modelNode.getDependencies();
      if (dependencies.length !== 3) return false;
      var replacedSymbol = replacedNodes[0].symbol;

      if (!modelNode.isLinear(dependencies[0])) return false;
      if (!modelNode.isLinear(dependencies[1])) return false;
      if (!modelNode.isLinear(dependencies[2])) return false;

      // Check the slope and intercept of f(u, v)*x + g(u, v), for different values of
      // u and v to make sure that f(u, v) and g(u, v) are linearly independent.
      var i = dependencies.indexOf(replacedSymbol);
      if (i === -1) return false;
      var orderedDependencies = [dependencies[i]];
      i = (i + 1) % 3;
      orderedDependencies.push(dependencies[i]);
      i = (i + 1) % 3;
      orderedDependencies.push(dependencies[i]);

      // Because of the dependency ordering above, fn is a function fn(x, u, v).
      var fn = modelNode.getCompiledFunctions(orderedDependencies)[0].fn;

      var b0 = fn(0, 0, 0);
      var m0 = fn(1, 0, 0) - b0;

      var bu = fn(0, 1, 0);
      var mu = fn(1, 1, 0) - bu;

      var bv = fn(0, 0, 1);
      var mv = fn(1, 0, 1) - bv;

      // Check that [mu - m0, bu - b0] and [mv - m0, bv - b0] are linearly independent
      // vectors by making sure that the area of the parallelogram that they span is not
      // 0.
      return !BuiltIn.approx((mu-m0)*(bv-b0), (mv-m0)*(bu-b0));
    }

    node.getRHSModel = function (frame) {
      // Store a map of lists that have been replaced by temporary variables.
      // Have to linear search on this because JS doesn't have object hashes.
      var replacedNodes = [];
      var isValid = true;
      function _replaceWithFreeVariable (frame, overrides) {
        for (var i = 0; i < replacedNodes.length; i++) {
          if (replacedNodes[i].node === this) return replacedNodes[i].tmpVar;
        }
        var tmpVar = FreeVariable(this.tmpVar());
        var concrete = this.getConcreteTree(frame);
        if (concrete.getDependencies().length) isValid = false;
        replacedNodes.push({
          node: this,
          tmpVar: tmpVar,
          symbol: tmpVar._symbol,
          concrete: concrete
        });
        return tmpVar;
      }

      var overrides = {
        List: _replaceWithFreeVariable,
        TableColumn: _replaceWithFreeVariable,
        Range: _replaceWithFreeVariable
      };

      var node = this._rhs.tryGetConcreteTree(frame, overrides); // Actual work happens here

      return {
        node: node,
        replacedNodes: replacedNodes,
        canCorrelate: isValid && canCorrelate(node, replacedNodes),
        isValid: isValid
      };

    };

    function _mse (compiledDifference, solution) {
      var sse = 0;
      for (var j = 0; j < compiledDifference.length; j++) {
        var d = compiledDifference[j].fn.apply(undefined, solution);
        sse += d*d;
      }
      return sse/compiledDifference.length;
    }

    function _evaluateDifference (compiledDifference, solution) {
      var dy = [];
      for (var j = 0; j < compiledDifference.length; j++) {
        dy.push(compiledDifference[j].fn.apply(undefined, solution));
      }
      return dy;
    }

    function _evaluateJacobian (compiledJacobian, solution) {
      var JT = [];
      for (var i = 0; i < compiledJacobian.length; i++) {
        var Jj = [];
        for (var j = 0; j < compiledJacobian[i].length; j++) {
          Jj.push(compiledJacobian[i][j].fn.apply(undefined, solution));
        }
        JT.push(Jj);
      }
      return JT;
    }

    // Gauss-Newton iteration: steps parameters by solving JT*J*dx=-JT*dy
    // where dy is vector that we're minimizing the squares of, evaluated at the current
    // parameters, dx is the update to the parameters on the next step, and J and JT are
    // the Jacobian and its transpose.
    //
    // It would be better to solve the linear system using a QR decomposition instead of
    // an LUP decomposition, but Numeric.js doesn't support QR solves (yet...).
    function optimizeLinear (compiledDifference, compiledJacobian) {
      var solution = [];

      for (var i = 0; i < compiledJacobian.length; i++) { solution.push(0); }

      var JT = _evaluateJacobian(compiledJacobian, solution);

      var LUJTJ = Numeric.LU(Numeric.dot(JT, Numeric.transpose(JT)), true);

      // In principle, only need one iteration in linear cases, but additional steps help us
      // clean up rounding errors. Don't need to update jacobian because in a linear problem,
      // it is independent of the parameters.
      var lastSolution = solution;
      var converged = false;
      for (var m = 0; m < 5; m++) {
        var dy = _evaluateDifference(compiledDifference, solution);
        var dx = Numeric.neg(Numeric.LUsolve(LUJTJ, Numeric.dot(JT, dy)));
        if (!Numeric.all(Numeric.isFinite(dx))) break;
        solution = Numeric.add(lastSolution, dx);
        converged = Numeric.all(Numeric.eq(lastSolution, solution));
        if (converged) break;
        lastSolution = solution;
      }

      return {
        solution: solution,
        f: _mse(compiledDifference, solution),
        converged: converged
      };
    }

    // Modified Levenberg-Marquardt algorithm, based on
    //
    // Transtrum, Machta, and Sethna, Phys. Rev. E 83, 036701 (2011)
    // http://dx.doi.org/10.1103/PhysRevE.83.036701
    // http://link.aps.org/accepted/10.1103/PhysRevE.83.036701 [PDF]
    //
    // This is currently their "delayed gratification algorithm," but I intend to add
    // the geodesic acceleration term to implement the full "Algorithm 2" from appendix
    // B.
    //
    // The full algorithm iterates by solving
    //
    // (JT*J + lambda*I)*v=JT*dy
    // JT*J*a=JT*(dvdvdy)
    //
    // for v and a, where J and JT are the jacobian and its transpose, I is an identity
    // matrix, dy is the vector of differences that is being minimized, dvdvdy is the
    // directional second derivative of the difference vector, evaluated in the v direction,
    // and lambda is a dynamically adjusted parameter that controls step size
    //
    // The parameters are then updated according to
    // solution = solution + v + 1/2*a
    //
    // If the new solution is worse than the old solution, lambda is increased, producing
    // a smaller step. If the new solution is better, it is accepted, and lambda is decreased.
    function _optimizeNonLinear (compiledDifference, compiledJacobian, p0, maxIterations) {
      var solution = p0;
      var f = _mse(compiledDifference, solution);

      var lambda = 0.001;
      var lambdaUp = 2;
      var lambdaDown = 0.1;

      var ones = [];
      for (var j = 0; j < compiledJacobian.length; j++) { ones.push(1); }

      var it = 0;

      var converged = false;
      var JT = _evaluateJacobian(compiledJacobian, solution);
      var lastSolution = solution;
      var lastF = f;
      while (it < maxIterations && !converged) {
        var dy = _evaluateDifference(compiledDifference, solution);
        var J = Numeric.transpose(JT);
        var JTJ = Numeric.dot(JT, J);

        if (!Numeric.all(Numeric.isFinite(dy))) break;
        if (!Numeric.all(Numeric.isFinite(JTJ))) break;

        var decreased = false;

        while (it < maxIterations && !converged && !decreased) {
          it += 1;

          // metric = JT*J + lambda*I
          var LUmetric = Numeric.LU(
            Numeric.add(JTJ, Numeric.diag(Numeric.mul(lambda, ones))),
          true);

          var v = Numeric.neg(Numeric.LUsolve(LUmetric, Numeric.dot(JT, dy)));

          //TODO calculate geodesic acceleration here and add it to v.
          var dx = v;

          solution = Numeric.add(lastSolution, dx);
          f = _mse(compiledDifference, solution);

          converged = Numeric.all(Numeric.eq(solution, lastSolution));

          if (converged) {
            lastSolution = solution;
            lastF = f;
            break;
          }

          var tmpJT;
          if (isFinite(f) && f <= lastF) {
            tmpJT = _evaluateJacobian(compiledJacobian, solution);
            decreased = Numeric.all(Numeric.isFinite(tmpJT));
          }

          if (decreased) {
            JT = tmpJT;
            lastSolution = solution;
            lastF = f;
            lambda *= lambdaDown;
            // Don't let lambda underflow
            lambda = Math.max(1e-64, lambda);
            break;
          } else {
            lambda *= lambdaUp;
          }
        }
      }

      return {
        solution: lastSolution,
        f: lastF,
        converged: converged
      };
    }

    //goal of these:
    // 1/4 are negative (8), 3/4 (24) are positive
    // approximately log-normal, w/ variance of 3
    // generated on: https://www.desmos.com/calculator/1xxlt84tvo
    //plus some from Eli thrown in (1, -1, 120, 1500, -.3)
    var pseudoRandoms = [
      18.9, 0.105, 0.0113, 0.089,
      4.414, 34.32, 8.61, 0.373,
      0.06, 0.149, 1.84, 9.26,
      5, 0.7, 0.2, 1.13,
      2.61, 1.89, 1, 0.007, 30,
      120, 1500, 0.0004, 7.23,
      -1, -0.0081, -0.03, -28.6,
      -1.71, -0.4, -6.94, -0.777
    ];


    var pseudoRandom = function (seed) {
      //503 is prime. That's all it's got going for it
      var index = (seed * 503) % (pseudoRandoms.length);
      return pseudoRandoms[index];
    };

    var generateStartingValues = function (numVals, args) {
      var startingVals = [], newStartingVals, nargs = args.length;
      for (var i = 0 ; i < numVals ; i++) {
        newStartingVals = [];
        for (var j = 0 ; j < nargs ; j++) {
          //prepopulate with a few stock starting values:
          //  * all 0, which helps with y1 ~ e^(a*x1+b)
          //  * all 1, which helps with y1 ~ a*b^x1
          //then use pseudo-randomly generated parameters for the rest
          if (i === 0) {
            newStartingVals[j] = 0;
          } else if (i === 1) {
            newStartingVals[j] = 1;
          } else {
            newStartingVals[j] = pseudoRandom(i*nargs+j);
          }
        }
        startingVals.push(newStartingVals);
      }
      return startingVals;
    };

    //
    // goal of this is to try a bunch of random starting values, and only explore the ones that are closest
    // niterations is the depth to search each option
    // nreturn is the number to return
    //
    var filterStartingValues = function (compiledDifference, compiledJacobian, startingVals, niterations, nreturn) {
      var scores = [];

      for (var j = 0; j < startingVals.length; j++) {
        scores.push({
          soln: _optimizeNonLinear(compiledDifference, compiledJacobian, startingVals[j], niterations),
          startingVals: startingVals[j]
        });
      }

      scores.sort(function(el1, el2) {
        if (isNaN(el1.soln.f)) return 1;
        if (isNaN(el2.soln.f)) return -1;
        return el1.soln.f - el2.soln.f;
      });

      var toReturn = [];
      for (var i = 0 ; i < nreturn ; i++) {
        toReturn.push(scores[i].startingVals);
      }
      return toReturn;
    };

    function optimizeNonLinear (compiledDifference, compiledJacobian, args, userParams, lastExportFrame) {
      /* jshint maxcomplexity: 11 */
      var i;
      var xlast = [];
      if (!userParams) userParams = {};
      if (!lastExportFrame) lastExportFrame = {};
      for (i = 0; i < args.length; i++) {
        var symbol = args[i];
        if (lastExportFrame[symbol] && isFinite(lastExportFrame[symbol].constantValue)) {
          xlast.push(+lastExportFrame[symbol].constantValue);
        } else if (userParams.hasOwnProperty(symbol) && isFinite(userParams[symbol])) {
          xlast.push(+userParams[symbol]);
        } else {
          xlast.push(1);
        }
      }

      //generate some random starting points
      var startingVals = generateStartingValues(30, args);
      //filter these down, first by finding 5 promising starting points, and then filtering down to 1 deeply
      var firstPass = filterStartingValues(compiledDifference, compiledJacobian, startingVals, 3, 5);
      var secondPass = filterStartingValues(compiledDifference, compiledJacobian, firstPass, 60, 1);

      var solnrestart = _optimizeNonLinear(compiledDifference, compiledJacobian, secondPass[0], 250);
      var solnlast = _optimizeNonLinear(compiledDifference, compiledJacobian, xlast, 100);

      if (!isFinite(solnlast.f)) return solnrestart;
      if (solnlast.f < solnrestart.f) return solnlast;
      return BuiltIn.approx(solnlast.f, solnrestart.f, 8) ? solnlast : solnrestart;
    }

    function getCorrelation (concreteIndependent, concreteDependent) {
      var l1 = [];
      var l2 = [];
      List.eachArgs([concreteIndependent, concreteDependent], function (elts) {
        l1.push(+elts[0].constantValue);
        l2.push(+elts[1].constantValue);
      });
      return BuiltIn.corr(l1, l2);
    }

    node.getResidualSuggestionId = function (residualVariable, priorAnalysis) {
      // Search for a table who's first column is in the regressions rhs.
      // If any table that the regression depends on already has a column
      // that depends on the regression's residual variable, return undefined.
      var rhsDependencies = this._rhs.getDependencies();
      var candidateId;
      for (var id in priorAnalysis) {
        if (!priorAnalysis.hasOwnProperty(id)) continue;
        if (!priorAnalysis[id].concreteTree.isTable) continue;
        if (!priorAnalysis[id].concreteTree.columns[0]) continue;
        var rawColumns = priorAnalysis[id].rawTree.columns;
        if (!rawColumns || !rawColumns.length) continue;
        var exports = rawColumns[0].getExports();
        if (exports.length !== 1) continue;
        if (rhsDependencies.indexOf(exports[0]) === -1) continue;

        for (var i = 1; i < rawColumns.length; i++) {
          if (rawColumns[i].getDependencies().indexOf(residualVariable) !== - 1) return undefined;
        }
        candidateId = candidateId ? candidateId : id;
      }

      return candidateId ? candidateId : undefined;
    };

    node.optimize = function (frame, exportFrame, lastExportFrame, priorAnalysis) {
      /* jshint maxcomplexity: 15*/
      var concreteLHS = this._lhs.tryGetConcreteTree(frame);
      var concreteRHS = this._rhs.tryGetConcreteTree(frame);
      if (concreteLHS.isError) return concreteLHS;
      if (concreteRHS.isError) return concreteRHS;

      var concreteDifference = this._difference.tryGetConcreteTree(frame);
      if (concreteDifference.isError) return concreteDifference;
      if (!concreteDifference.isList) return ErrorMsg.nonListRegression();

      var soln, i;
      var args = concreteDifference.getDependencies();

      for (i = 0; i < args.length; i++) {
        if (!Policy.validRegressionParameter(args[i])) {
          return ErrorMsg.invalidRegressionParameter(args[i]);
        }
      }

      var compiledDifference = concreteDifference.getCompiledFunctions(args);
      if (!args.length) {
        soln = {
          f: _mse(compiledDifference, []),
          solution: []
        };
      } else {

        // Since this is a multivariate function in general, we have to be careful with our
        // isLinear check. Can't check each arg separately, because (1+x)*(1+y) is linear in
        // x and y separately, but is not linear overall (where by linear, we actually mean
        // affine, here and in many places).
        var argmap = {};
        for (i = 1; i < args.length; i++) {
          argmap[args[i]] = FreeVariable(args[0]);
        }

        var isLinear = concreteDifference.substitute(argmap).isLinear(args[0]);
        // This block can fail because takeDerivative can produce too many nodes, or possibly
        // inside calls to Numeric
        try {
          var compiledJacobian = [];
          for (i = 0; i < args.length; i++) {
            compiledJacobian.push(concreteDifference.takeDerivative(args[i]).getCompiledFunctions(args));
          }
          if (isLinear) {
            soln = optimizeLinear(compiledDifference, compiledJacobian);
          } else {
            soln = optimizeNonLinear(compiledDifference, compiledJacobian,
              args, this.userData.regressionParameters, lastExportFrame
            );
          }
        } catch (e) {
          console.log(e);
          return ErrorMsg.optimizationError();
        }
      }
      var localFrame = Object.create(frame, parameters);
      var parameters = {};
      for (i = 0; i < args.length; i++) {
        localFrame[args[i]] = parameters[args[i]] = Constant(soln.solution[i]);
      }

      var model = this.getRHSModel(frame);
      var residuals = this._difference.getConcreteTree(localFrame);

      // If the lhs depends on parameters, return the RMS of the residuals instead of Rsquared.
      var statistics;
      var msqres = soln.f;
      var lhsVariance = concreteLHS.isList ?
        BuiltIn.var(concreteLHS.args.map(function (c) {return +c.constantValue})) :
        0
      ;
      if (
        concreteLHS.getDependencies().length ||
        !isFinite(lhsVariance) ||
        lhsVariance <= 0 ||
        !(this._lhs instanceof Identifier || this._lhs instanceof List)
      ) {
        statistics = {
          'RMSE': Math.sqrt(msqres)
        };
      } else if (model.canCorrelate) {
        statistics = {
          'r': getCorrelation(concreteLHS, model.replacedNodes[0].concrete)
        };
      } else {
        statistics = {
          'Rsquared': 1 - msqres/lhsVariance
        };
      }

      var substitutedModel = model.node.isError ? model.node : model.node.substitute(parameters);

      var residualVariable = this.chooseResidualVariable(exportFrame);
      var residualSuggestionId = this.getResidualSuggestionId(residualVariable, priorAnalysis);
      // Update userData here because there is no guarantee that the new value has to
      // to come back from the frontend.
      this.userData.residualVariable = Label.identifierToLatex(residualVariable);

      return OptimizedRegression(parameters, residuals, statistics, substitutedModel, {
        isModelValid: model.isValid,
        residualVariable: residualVariable,
        residualSuggestionId: residualSuggestionId
      });
    };

    node.exportTo = function (concrete, frame) {
      if (concrete.isError) return;
      for (var symbol in concrete.parameters) {
        if (!concrete.parameters.hasOwnProperty(symbol)) continue;
        if (Policy.assignmentForbidden(symbol)) continue;
        frame[symbol] = frame[symbol] ? ErrorMsg.multiplyDefined(symbol) : concrete.parameters[symbol];
      }

      // Never expect this to happen, but just to be safe...
      if (Policy.assignmentForbidden(concrete.residualVariable)) return;
      // Shouldn't have to worry about residualVariable being in the frame, since we chose it not to be.
      frame[concrete.residualVariable] = concrete.residuals;
    };

    // Regressions should never suggest sliders
    node.getSliderVariables = function () { return []; };
  });
});

define ('math/parsenode/table',['require','pjs','./base','math/policy','./constant','./list'],function (require) {
  var P = require('pjs');
  var Parent = require('./base');
  var Policy = require('math/policy');
  var Constant = require('./constant');
  var List = require('./list');

  return P(Parent, function (node, _super) {
    node.init = function (columns) {
      _super.init.call(this);
      this.columns = columns;
      this._exports = [];
      for (var i = 0; i < columns.length; i++) {
        this.addDependencies(columns[i].getDependencies());
        Array.prototype.push.apply(this._exports, columns[i].getExports());
      }
    };

    node.exportPenalty = 1;

    node.isTable = true;

    node.canAutoRegress = function (concrete) {
      /* jshint maxcomplexity: 11 */
      if (concrete.isError) return false;
      if (this.columns.length > 2) return false;

      for (var i = 0; i < this.columns.length; i++) {
        var symbols = this.columns[i].getExports();
        if (symbols.length !== 1) return false;
        if (Policy.assignmentForbidden(symbols[0])) return false;
        if (concrete.columns[i].isError) return false;
        if (!concrete.columns[i].isIndependent) return false;
        var columnLength = concrete.columns[i].values.args.length;
        if (columnLength < 2) return false;
        for (var j = 0; j < columnLength; j++) {
          if (isNaN(+concrete.columns[i].values.args[j].constantValue)) return false;
        }
      }

      return true;
    };

    function _replaceErrorWithNaN (arg) {
      return (arg.isError) ? Constant(NaN) : arg;
    }

    // Note, only exports table column values. Will need to modify this if we allow,
    // e.g., assignments in headers.
    node.exportTo = function (concrete, frame) {
      for (var i = 0; i < this.columns.length; i++) {
        var symbols = this.columns[i].getExports();
        if (!symbols.length) continue;
        var symbol = symbols[0];
        if (Policy.assignmentForbidden(symbol)) continue;
        if (frame[symbol]) continue;
        // Replace errors with NaN's for export
        if (concrete.isError) {
          frame[symbol] = concrete;
        } else if (concrete.columns[i].isError) {
          frame[symbol] = concrete.columns[i];
        } else {
          frame[symbol] = List(concrete.columns[i].values.args.map(_replaceErrorWithNaN));
        }
      }
    };

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      var concreteColumns = [];
      var localFrame = Object.create(frame);
      for (var i = 0; i < this.columns.length; i++) {
        var concreteColumn = this.columns[i].getConcreteTree(localFrame, frame, overrides);
        if (concreteColumn.isIndependent) {
          localFrame[concreteColumn.header._symbol] = concreteColumn.values;
        }
        concreteColumns.push(concreteColumn);
      }
      return this.constructor(concreteColumns);
    };

    // TODO shim
    node.getAllIds = function () {
      return this.columns.map(function (c) { return c.header.userData.id; });
    };
  });
});
define ('math/parsenode/tablecolumn',['require','pjs','./base','./list','./identifier','math/policy'],function (require) {
  var P = require('pjs');
  var Parent = require('./base');
  var List = require('./list');
  var Identifier = require('./identifier');
  var Policy = require('math/policy');

  return P(Parent, function (node, _super) {
    node.init = function (header, length, values) {
      _super.init.call(this);
      this.header = header;
      this.length = length;
      this.values = values;
      this.isIndependent = false; // May be changed to true in a concrete tree
      this.addDependencies(header.getDependencies());
      this.addDependencies(values.getDependencies());
      this._exports = this._computeExports();
    };

    node._computeExports = function () {
      if (!(this.header instanceof Identifier)) return [];
      var symbol = this.header._symbol;
      return Policy.assignmentForbidden(symbol) ? [] : [symbol];
    };

    // Override getConcreteTree to allow storing errors in individual elements
    // instead of propagating errors to the top of the column.
    node.getConcreteTree = function (frame, parentFrame) {
      var concreteHeader = this.header.getConcreteTree(frame);
      var concreteElements;
      var concrete;
      if (concreteHeader.isFreeVariable) {
        concreteElements = [];
        for (var i = 0; i < this.values.args.length; i++) {
          var concreteElement = this.values.args[i].tryGetConcreteTree(frame);
          concreteElements.push(concreteElement);
        }
        concrete = this.constructor(concreteHeader, this.length, List(concreteElements));
        concrete.isIndependent = true;
        concrete.isDiscrete = true;
        return concrete;
      } else {
        if (concreteHeader.isConstant) {
          var values = [];
          for (var n = 0; n < this.length; n++) values.push(concreteHeader);
          concreteElements = List(values);
        } else {
          concreteElements = concreteHeader;
        }
        concreteHeader = this.header.getConcreteTree(parentFrame);
        concrete = this.constructor(concreteHeader, this.length, concreteElements);
        concrete.isDiscrete = !!(concreteHeader.isList || concreteHeader.isConstant);
        return concrete;
      }
    };
  });
});

define('math/parsenode/solvedequation',['require','pjs','./base'],function (require) {

  var P = require('pjs');
  var ParseNode = require('./base');

  return P(ParseNode, function(node, _super) {
    node.init = function (symbol, expression) {
      _super.init.call(this);
      this._symbol = symbol; // The symbol that was solved for.
      this._expression = expression;
      this.addDependencies(expression.getDependencies());
    };

    node.getConcreteTree = function (frame, overrides) {
      if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
      return this.constructor(this._symbol, this._expression.getConcreteTree(frame, overrides));
    };

    node.getEvaluationInfo = function () {
      if (this._expression.isList) {
        return this._expression.args.map(function (a) {
          return {val: a.constantValue, operator: '='};
        });
      }
      return this._expression.getEvaluationInfo();
    };

    // Delegate to _expression
    node.getCompiledFunctions = function () {
      return this._expression.getCompiledFunctions.apply(this._expression, arguments);
    };
    node.evaluate = function () {
      return this._expression.evaluate.apply(this._expression, arguments);
    };
  });
});

define('parsenodes',['require','math/parsenode/expressionTypes','math/parsenode/base','math/parsenode/expression','math/parsenode/scalarexpression','math/parsenode/error','math/parsenode/constant','math/parsenode/identifier','math/parsenode/freevariable','math/parsenode/dummyindex','math/parsenode/list','math/parsenode/range','math/parsenode/listaccess','math/parsenode/orderedpair','math/parsenode/movablepoint','math/parsenode/basecomparator','math/parsenode/comparator','math/parsenode/doubleinequality','math/parsenode/repeatedoperator','math/parsenode/sum','math/parsenode/product','math/parsenode/functioncall','math/parsenode/functionexponent','math/parsenode/piecewise','math/parsenode/derivative','math/parsenode/assignment','math/parsenode/functiondefinition','math/parsenode/equation','math/parsenode/regression','math/parsenode/table','math/parsenode/tablecolumn','math/parsenode/nativefunction','math/parsenode/reducerfunction','math/parsenode/solvedequation','math/parsenode/optimizedregression'],function(require){
  var expressionParseNodes = require('math/parsenode/expressionTypes'); //Require expressionsTypes

  var nodes = {
    //Base Types
    Base:         require('math/parsenode/base'),
    Expression:   require('math/parsenode/expression'),
    ScalarExpression: require('math/parsenode/scalarexpression'),

    //Primitive Types
    Error:        require('math/parsenode/error'),
    Constant:     require('math/parsenode/constant'),
    Identifier:   require('math/parsenode/identifier'),
    FreeVariable: require('math/parsenode/freevariable'),
    DummyIndex:   require('math/parsenode/dummyindex'),

    //List types
    List:         require('math/parsenode/list'),
    Range:        require('math/parsenode/range'),
    ListAccess:   require('math/parsenode/listaccess'),

    // Points and point lists
    OrderedPair:        require('math/parsenode/orderedpair'),
    MovablePoint:       require('math/parsenode/movablepoint'),

    //Expressions and operators
    BaseComparator:   require('math/parsenode/basecomparator'),
    Comparator:       require('math/parsenode/comparator'),
    DoubleInequality: require('math/parsenode/doubleinequality'),
    RepeatedOperator:  require('math/parsenode/repeatedoperator'),
    Sum:              require('math/parsenode/sum'),
    Product:          require('math/parsenode/product'),
    FunctionCall:     require('math/parsenode/functioncall'),
    FunctionExponent: require('math/parsenode/functionexponent'),
    Piecewise:        require('math/parsenode/piecewise'),
    Derivative:       require('math/parsenode/derivative'),

    //Exports and definitions
    Assignment:         require('math/parsenode/assignment'),
    FunctionDefinition: require('math/parsenode/functiondefinition'),
    Equation:           require('math/parsenode/equation'),
    Regression:         require('math/parsenode/regression'),

    // Tables
    Table:            require('math/parsenode/table'),
    TableColumn:      require('math/parsenode/tablecolumn'),

    // Concrete function call nodes
    NativeFunction:   require('math/parsenode/nativefunction'),
    ReducerFunction:  require('math/parsenode/reducerfunction'),

    // Concrete solved equation
    SolvedEquation:   require('math/parsenode/solvedequation'),
    OptimizedRegression: require('math/parsenode/optimizedregression')

  };

  //Each of the simple expression types
  for(var nodeType in expressionParseNodes){
    nodes[nodeType] = expressionParseNodes[nodeType];
  }

  for (var t in nodes) {
    if (!nodes.hasOwnProperty(t)) continue;
    if (t === 'Comparator') continue;
    nodes[t].prototype.type = t;
  }

  for (var op in nodes.Comparator) {
    if (!nodes.Comparator.hasOwnProperty(op)) continue;
    nodes.Comparator[op].prototype.type = 'Comparator[\'' + op + '\']';
  }

  return nodes;
});

define('math/inverses',[],function () {
  var inverses = {};

  // Functions with an inverse spelled arcname
  var arcNames = [
    'sin',
    'cos',
    'tan',
    'cot',
    'sec',
    'csc',
    'sinh',
    'cosh',
    'tanh',
    'coth',
    'sech',
    'csch'
  ];

  arcNames.forEach(function (name) {
    inverses[name] = 'arc' + name;
    inverses['arc' + name] = name;
  });

  return inverses;
});
/*
* baseparser is separated from parser so that it can be used inside
* features without creating a circular dependency. Outside users
* should include parser, which adds features to the baseparse.
*/
define('math/baseparser',['require','jison','parsenodes','math/inverses','math/errormsg'],function(require){
  var jison = require('jison');
  var yy = jison.yy;
  var ParseNodes = require('parsenodes');
  var inverses = require('math/inverses');
  var ErrorMsg = require('math/errormsg');

  var exports = {};

  //Public parsing API
  exports.parse = function(input) {
    try {
      return jison.parse('###'+input);
    } catch (e) {
      if (e instanceof ParseNodes.Error) return e;
      return ErrorMsg.parseError();
    }
  };

  yy.ErrorMsg = ErrorMsg;

  yy.setInput = function (node, range) {
    //Don't ever show the '###' mark we insert to mark the start of the string
    node.setInputString(yy.lexer.matched.slice(Math.max(3, range.first_column), range.last_column));
  };

  //Make all ParseNodes available on yy object for jison
  for(var nodeType in ParseNodes){
    yy[nodeType] = ParseNodes[nodeType];
  }

  //Register known inverses
  yy.inverses = inverses;

  /* This function takes the entire function declaration as a single lexed token and parses with a regexp,
   * to keep the overall grammar context-free and LALR(1)-parseable.
   * TODO - generate this once, not every time we parse a function declaration */
  yy.parseFunctionDeclaration = function (declaration_string) {
    declaration_string = declaration_string.replace('###', '');  //Strip off start-of-line marker
    var whitespace_pattern =  //Non-capturing latex whitespace pattern
       "(?:\\s|\\\\space|\\\\\\:)*";
       //   \s   \\space  \\ \ :
    var id_body_pattern = //Non-capturing latex identifier pattern
       "(?:[a-zA-Z]|\\\\[a-zA-Z]+)";
    var id_subscript_pattern = //Non-capturing latex subscript pattern
       "(?:_[a-zA-Z0-9]|_{[a-zA-Z0-9]+})?";
    var id_pattern = id_body_pattern+id_subscript_pattern;

    var arglist_pattern = //Non-capturing comma-separated list of identifiers in whitespace-free string
      "(?:" + id_pattern + "(?:\\," + id_pattern + ")*)";

    var declaration_pattern = //Captures function name as first group, and arglist as second group
      "(" + id_pattern + ")" + "(?:\\\\left)?\\((" + arglist_pattern + ")(?:\\\\right)?\\)=";

    var declaration_regexp = new RegExp(declaration_pattern);
    var whitespace_regexp = new RegExp(whitespace_pattern, "g");
    //Want "g" flag to ensure global capturing of whitespace
    declaration_string = declaration_string.replace(whitespace_regexp, '');
    var match = declaration_regexp.exec(declaration_string);

    return {
      identifier: ParseNodes.Identifier(match[1]),      //match[1] is the function symbol.
      //match[2] is the argument list.  Split it on commas.
      args: match[2].split(',').map(function (symbol) { return ParseNodes.Identifier(symbol); }),
    };
  };

  return exports;
});

// String representation of parse nodes that should return the same parse tree when executed.
// Intended to be used for debugging and experiments, not for implementing other features.
define('math/features/repr',['require','parsenodes'],function (require) {
  var nodes = require('parsenodes');

  var reprArgs = function (args, prefix, level) {
    level = level || 0;
    var lastIndent = Array(level + 1).join('  ');
    var indent = lastIndent + '  ';
    return '[' + '\n' +
      indent + args.map(function (arg) {
        return arg.repr(prefix, level + 1);
      }).join(',\n' + indent) + '\n' +
    lastIndent + ']';
  };

  var reprHead = function (head, prefix) {
    prefix = prefix || '';
    return '' + prefix + '' + head;
  };

  nodes.DoubleInequality.prototype.repr =
  nodes.Expression.prototype.repr = function (prefix, level) {
    return reprHead(this.type, prefix) + '(' + reprArgs(this.args, prefix, level) + ')';
  };

  nodes.Identifier.prototype.repr =
  nodes.FreeVariable.prototype.repr = function (prefix) {
    return reprHead(this.type, prefix) + '(\'' + this._symbol + '\')';
  };

  nodes.Constant.prototype.repr = function (prefix) {
    return reprHead(this.type, prefix) + '(' + this.constantValue + ')';
  };

  nodes.FunctionCall.prototype.repr = function (prefix, level) {
    return reprHead(this.type, prefix) + '(' +
      '\'' + this._symbol + '\'' + ', ' + reprArgs(this.args, prefix, level) +
    ')';
  };

  nodes.Assignment.prototype.repr = function (prefix, level) {
    return reprHead(this.type, prefix) + '(' +
      nodes.Identifier(this._symbol).repr(prefix, level) + ', ' +
      this._expression.repr(prefix, level) +
    ')';
  };

  nodes.Regression.prototype.repr =
  nodes.Equation.prototype.repr = function (prefix, level) {
    return reprHead(this.type, prefix) + '(' +
      this._lhs.repr(prefix, level) + ', ' +
      this._rhs.repr(prefix, level) +
    ')';
  };

  nodes.FunctionDefinition.prototype.repr = function (prefix, level) {
    return reprHead(this.type, prefix) + '(' +
      nodes.Identifier(this._symbol).repr(prefix, level) + ', ' +
      reprArgs(this._argSymbols.map(function (s) { return nodes.Identifier(s); }), prefix, level) + ', ' +
      this._expression.repr(prefix, level) +
    ')';
  };

  nodes.Error.prototype.repr = function (prefix, level) {
    return reprHead(this.type, prefix) + '(\'' + this._msg + '\')';
  };

  nodes.Derivative.prototype.repr = function (prefix, level) {
    return reprHead(this.type, prefix) + '(' +
      '\'' + this._symbol + '\'' + ', ' + reprArgs(this.args, prefix, level) +
    ')';
  };

  nodes.SolvedEquation.prototype.repr = function (prefix, level) {
    return reprHead(this.type, prefix) + '(' +
      '\'' + this._symbol + '\'' + ', ' + this._expression.repr(prefix, level) +
    ')';
  };

  nodes.OptimizedRegression.prototype.repr = function (prefix, level) {
    return reprHead(this.type, prefix) + '(' +
      JSON.stringify(this.parameters) + ', ' +
      JSON.stringify(this.residuals) + ', ' +
      JSON.stringify(this.statistics) + ', ' +
      this.model.repr(prefix, level + 1) + ', ' +
      JSON.stringify({
        isModelValid: this.isModelValid,
        residualVariable: this.residualVariable,
        residualSuggestionId: this.residualSuggestionId
      }) +
    ')';
  };

  // TODO, Table could be an expression
  nodes.Table.prototype.repr = function (prefix, level) {
    return reprHead(this.type, prefix) + '(' + reprArgs(this.columns, prefix, level) + ')';
  };

  nodes.TableColumn.prototype.repr = function (prefix, level) {
    return reprHead(this.type, prefix) + '(' +
      this.header.repr(prefix, level) + ', ' + this.length + ', ' +
      reprArgs(this.values, prefix, level) +
    ')';
  };


});

define('math/features/scalarEvalExpression',['require','parsenodes','math/functions'],function(require){
  var nodes = require('parsenodes');
  var Functions = require('math/functions');

  var expressions = {
    Add: function(args){
      return '(' + args.join('+') + ')';
    },
    Multiply: function(args){
      return '(' + args.join('*') + ')';
    },
    Divide: function(args){
      return '(' + args.join('/') + ')';
    },
    Subtract: function(args){
      return '(' + args.join('-') + ')';
    },
    Exponent: function(args){
      return 'BuiltIn.pow('+args.join(',')+')';
    },
    Negative: function(args){
      return '(-' + args[0] + ')';
    },
    And: function(args){
      //Used for Chained Comparators (a<b<c becomes a<b && b<c)
      //TODO - this naively re-evaluates middle terms
      //TODO - this doesn't check that directions agree
      return args.join('&&');
    },
    Piecewise: function(args){
      //TODO - this will naively evaluate statements
      //for all branches.
      //This will produce correct output, but performance
      //will be better if we only evaluate needed statements
      return '('+args[0]+'?'+args[1]+':'+args[2]+')';
    }
  };

  var arities = {
    Add: 2,
    Multiply: 2,
    Divide: 2,
    Subtract: 2,
    Exponent: 2,
    Negative: 1,
    And: 2,
    Piecewise: 3
  };

  for (var nodeType in expressions) {
    var p = nodes[nodeType].prototype;
    p.scalarEvalExpression = expressions[nodeType];
    p.evaluate = Functions.createEvaluateFunction(p.scalarEvalExpression, arities[nodeType]);
  }

});

define('math/features/okForImplicitFunction',['require','parsenodes'],function(require){
  var nodes = require('parsenodes');

  nodes.Add.prototype.okForImplicitFunction =
  nodes.Subtract.prototype.okForImplicitFunction =
  nodes.Add.prototype.okForImplicitFunction =
  nodes.Multiply.prototype.okForImplicitFunction =
  nodes.Divide.prototype.okForImplicitFunction =
  nodes.Exponent.prototype.okForImplicitFunction = function(){
    for(var i = 0; i < this.args.length; i++){
      if(!this.args[i].okForImplicitFunction()) return false;
    }
    return true;
  };
});

define('math/features/constantcollapsedcopy',['require','parsenodes'],function(require) {
  var nodes = require('parsenodes');
  var Constant = nodes.Constant;

  var defs = {
    Add: function (args) {
      if (args[0].isConstant && args[1].isConstant) {
        return Constant(this.evaluate([args[0].constantValue, args[1].constantValue]));
      }
      if (args[0].constantValue === 0) return args[1];
      if (args[1].constantValue === 0) return args[0];
      return this.copyWithArgs(args);
    },
    Multiply: function (args) {
      if (args[0].isConstant && args[1].isConstant) {
        return Constant(this.evaluate([args[0].constantValue, args[1].constantValue]));
      }
      if (args[0].constantValue === 1) return args[1];
      if (args[1].constantValue === 1) return args[0];
      return this.copyWithArgs(args);
    },
    Subtract: function (args) {
      if (args[0].isConstant && args[1].isConstant) {
        return Constant(this.evaluate([args[0].constantValue, args[1].constantValue]));
      }
      if (args[0].constantValue === 0) return nodes.Negative([args[1]]);
      if (args[1].constantValue === 0) return args[0];
      return this.copyWithArgs(args);
    },
    Divide: function (args) {
      if (args[0].isConstant && args[1].isConstant) {
        return Constant(this.evaluate([args[0].constantValue, args[1].constantValue]));
      }
      if (args[1].constantValue === 1) return args[0];
      return this.copyWithArgs(args);
    },
    Exponent: function (args) {
      if (args[0].isConstant && args[1].isConstant) {
        return Constant(this.evaluate([args[0].constantValue, args[1].constantValue]));
      }
      if (args[1].constantValue === 1) return args[0];
      return this.copyWithArgs(args);
    },
    Negative: function (args) {
      if (args[0].isConstant) return Constant(-args[0].constantValue);
      if (args[0] instanceof nodes.Negative) return args[0].args[0];
      return this.copyWithArgs(args);
    },
    And: function (args) {
      if (args[0].isConstant && args[1].isConstant) {
        return Constant(args[0].constantValue && args[1].constantValue);
      }
      if (args[0].isConstant && args[0] === true) return args[1];
      if (args[0].isConstant && args[0] === false) return Constant(false);
      if (args[1].isConstant && args[1] === true) return args[0];
      if (args[1].isConstant && args[1] === false) return Constant(false);
      return this.copyWithArgs(args);
    },
    Piecewise: function (args) {
      if (args[0].isConstant && args[0].constantValue === true) return args[1];
      if (args[0].isConstant && args[0].constantValue === false) return args[2];
      return this.copyWithArgs(args);
    }
  };

  for (var k in defs) {
    nodes[k].prototype._constantCollapsedCopy = defs[k];
  }

});
define('math/features/polynomialorder',['require','parsenodes'],function (require) {
  var nodes = require('parsenodes');

  var polynomialOrders = {
    Expression:     "this.dependsOn(symbol) ? Infinity : 0",
    FreeVariable:   "(symbol === this._symbol ? 1 : 0)",
    Constant:       "0",
    Add:            "Math.max(order0, order1)",
    Subtract:       "Math.max(order0, order1)",
    Multiply:       "order0 + order1",
    Negative:       "order0",
    Divide:         "order1 > 0 ? Infinity : order0"
  };

  //Convert data above into proper member functions
  var wrap = function (expr) {
    /*jshint evil: true */
    expr = expr.replace("order0", "this.args[0].polynomialOrder(symbol)");
    expr = expr.replace("order1", "this.args[1].polynomialOrder(symbol)");
    return new Function(['symbol'], 'return ' + expr);
  };

  for (var nodeType in polynomialOrders) {
    var order = polynomialOrders[nodeType];
    nodes[nodeType].prototype.polynomialOrder = wrap(order);
  }

  nodes.Exponent.prototype.polynomialOrder = function (symbol) {
    var baseOrder = this.args[0].polynomialOrder(symbol);
    var exponentOrder = this.args[1].polynomialOrder(symbol);
    if (baseOrder === 0 && exponentOrder === 0) return 0;
      var exponent = this.args[1];
      if (exponent.isConstant &&
         exponent.constantValue === Math.round(exponent.constantValue) &&
         exponent.constantValue > 0) {
        return baseOrder * exponent.constantValue;
      }
    return Infinity;
  };

  // Allow piecewise expressions of the form {f(x):5} where f(x) is a boolean
  // expression in symbol
  nodes.Piecewise.prototype.polynomialOrder = function (symbol) {
    if (!this.dependsOn(symbol)) return 0;
    if (!this.args[2].isConstant || !isNaN(this.args[2].constantValue)) return Infinity;
    if (this.args[1].dependsOn(symbol)) return Infinity;
    return 0;
  };

  nodes.List.prototype.polynomialOrder = function (symbol) {
    var order = 0;
    for (var i = 0; i < this.args.length; i++) {
      order = Math.max(order, this.args[i].polynomialOrder(symbol));
    }
    return order;
  };
});

define('math/features/polynomialcoefficients',['require','parsenodes'],function (require) {
  var nodes = require('parsenodes');
  var zero = nodes.Constant(0);
  var one = nodes.Constant(1);

  nodes.FreeVariable.prototype.getPolynomialCoefficients = function (symbol) {
    if (symbol === this._symbol) return [zero, one];
    return [this];
  };

  nodes.Constant.prototype.getPolynomialCoefficients = function (symbol) {
    return [this];
  };

  nodes.Add.prototype.getPolynomialCoefficients = function (symbol) {
    var coeffs0 = this.args[0].getPolynomialCoefficients(symbol);
    var coeffs1 = this.args[1].getPolynomialCoefficients(symbol);
    var order0 = coeffs0.length - 1;
    var order1 = coeffs1.length - 1;
    var coeffs = [];
    for (var i = 0; i <= Math.max(order0, order1); i++) {
      if (order0 >= i && order1 >= i) {
        coeffs.push(nodes.Add([coeffs0[i], coeffs1[i]]));
      } else {
        coeffs.push(order0 > order1 ? coeffs0[i] : coeffs1[i]);
      }
    }
    return coeffs;
  };

  nodes.Subtract.prototype.getPolynomialCoefficients = function (symbol) {
    var coeffs0 = this.args[0].getPolynomialCoefficients(symbol);
    var coeffs1 = this.args[1].getPolynomialCoefficients(symbol);
    var order0 = coeffs0.length - 1;
    var order1 = coeffs1.length - 1;
    var coeffs = [];
    for (var i = 0; i <= Math.max(order0, order1); i++) {
      if (order0 >= i && order1 >= i) {
        coeffs.push(nodes.Subtract([coeffs0[i], coeffs1[i]]));
      } else {
        coeffs.push(order0 > order1 ? coeffs0[i] : nodes.Negative([coeffs1[i]]));
      }
    }
    return coeffs;
  };

  nodes.Negative.prototype.getPolynomialCoefficients = function (symbol) {
    var coeffs0 = this.args[0].getPolynomialCoefficients(symbol);
    var coeffs = [];
    for (var i = 0; i < coeffs0.length; i++) {
      coeffs.push(nodes.Negative([coeffs0[i]]));
    }
    return coeffs;
  };

  nodes.Exponent.prototype.getPolynomialCoefficients = function (symbol) {
    var coeffs0 = this.args[0].getPolynomialCoefficients(symbol);
    var coeffs1 = this.args[1].getPolynomialCoefficients(symbol);
    var order0 = coeffs0.length - 1;
    var order1 = coeffs1.length - 1;
    if (order1 > 0) throw "can't solve for variable in exponent";
    if (order0 === 0) return [nodes.Exponent([coeffs0[0], coeffs1[0]])];
    if (this.args[1].isConstant) {
      var exponent = this.args[1].constantValue;
      switch(exponent) {
        case 0:
          return [zero];
        case 1:
          return coeffs0;
        case 2:
          return nodes.Multiply([this.args[0], this.args[0]]).getPolynomialCoefficients(symbol);
      }
    }
    throw "Unable to compile polynomial representation";
  };

  nodes.Multiply.prototype.getPolynomialCoefficients = function (symbol) {
    var coeffs0 = this.args[0].getPolynomialCoefficients(symbol);
    var coeffs1 = this.args[1].getPolynomialCoefficients(symbol);
    var order0 = coeffs0.length - 1;
    var order1 = coeffs1.length - 1;
    var coeffs = [];
    for (var i = 0; i <= order0; i++) {
      for (var j = 0; j <= order1; j++) {
        var newTerm = nodes.Multiply([coeffs0[i], coeffs1[j]]);
        var currentTerm = coeffs[i+j];
        if (currentTerm === undefined) {
          coeffs[i+j] = newTerm;
        } else {
          coeffs[i+j] = nodes.Add([currentTerm, newTerm]);
        }
      }
    }
    return coeffs;
  };

  nodes.Divide.prototype.getPolynomialCoefficients = function (symbol) {
    var coeffs0 = this.args[0].getPolynomialCoefficients(symbol);
    var coeffs1 = this.args[1].getPolynomialCoefficients(symbol);
    var order1 = coeffs1.length - 1;
    var coeffs = [];
    if (order1 > 0) throw "Can't solve for variable in denominator";
    for (var i = 0; i < coeffs0.length; i++) {
      coeffs.push(nodes.Divide([coeffs0[i], coeffs1[0]]));
    }
    return coeffs;
  };

  nodes.Expression.prototype.getPolynomialCoefficients = function (symbol) {
    if (this.dependsOn(symbol)) throw "Unimplemented polynomialCoefficient call";
    return [this];
  };

  // Only treating special case of expressions like {f(x):2} where f(x) is a boolean
  // expression in symbol. Everything else is screened out by polynomialOrder.
  //
  // In this case, behave as if condition is satisfied. Later, we use node.extractConditions
  // to reapply the original conditions to the solution.
  nodes.Piecewise.prototype.getPolynomialCoefficients = function (symbol) {
    if (!this.dependsOn(symbol)) return [this];
    var ifExprCoeffs = this.args[1].getPolynomialCoefficients(symbol);
    if (this.args[0].dependsOn(symbol)) return ifExprCoeffs;
    return [nodes.Piecewise(this.args[0], ifExprCoeffs[0], this.args[2])];
  };

});

// node.extractConditions(symbol, replacement) applies conditions in
// expression given by node to expression given by replacement, replacing
// instances of symbol in the conditions with replacement.
//
// The rationale for this is to allow solving expressions like
// y=sin(x){0<y<2}. Our solver first solves this to y=sin(x),
// and then extractConditions wraps the solution to be y={0<sin(x)<2:sin(x)}
define('math/features/extractconditions',['require','parsenodes'],function (require) {
  var nodes = require('parsenodes');

  nodes.Expression.prototype.extractConditions = function (symbol, replacement) {
    for (var i = 0; i < this.args.length; i++) {
      var arg = this.args[i];
      replacement = arg.extractConditions(symbol, replacement);
    }
    return replacement;
  };

  nodes.Constant.prototype.extractConditions = function (symbol, replacement) {
    return replacement;
  };

  nodes.Piecewise.prototype.extractConditions = function (symbol, replacement) {
    if (!this.dependsOn(symbol)) return replacement;
    if (!this.args[0].dependsOn(symbol)) {
      replacement = this.args[1].extractConditions(symbol, replacement);
      replacement = this.args[2].extractConditions(symbol, replacement);
      return replacement;
    }
    var substitution = {};
    substitution[symbol] = replacement;
    return nodes.Piecewise([
      this.args[0].substitute(substitution),
      replacement,
      nodes.Constant(NaN)
    ]);
  };
});

// node.boundDomain(symbol) returns an upper bound on the domain of symbol for
// which the expression given by node is defined.
//
//
// Returns false if we cannot bound the domain, or a domain in the form
// [xmin, xmax], in which case it should be valid for the plotter to plot the
// function only from xmin to xmax,.
//
// Ignores the distinction between strict and non-strict inequalities. This is
// important because the function may return NaN when evaluated exactly at the
// domain bounds, so the plotter needs to know how to deal with that.
// Otherwise, the domain bound should be "nearly tight" in the sense that it is
// tight up to floating point rounding.
//
// May return false when we don't know how to supply a "nearly tight" domain.
define('math/features/bounddomain',['require','parsenodes','math/builtinframe'],function (require) {
  var nodes = require('parsenodes');
  var BuiltInFrame = require('math/builtinframe');

  var zero = nodes.Constant(0);

  nodes.Base.prototype.boundDomain = function (symbol) {
    return false;
  };

  // Bail on lists for now. Cound bound each term separately, but
  // can't just take intersection of term bounds.
  nodes.List.prototype.boundDomain = function (symbol) {
    return false;
  };

  // The domain of an expression is the intersection of the domains of
  // its arguments.
  nodes.Expression.prototype.boundDomain = function (symbol) {
    var out = [-Infinity, Infinity];
    for (var i = 0; i < this.args.length; i++) {
      var arg = this.args[i];
      var domain = arg.boundDomain(symbol);
      if (!domain) return false;
      out = [Math.max(out[0], domain[0]), Math.min(out[1], domain[1])];
    }
    return out;
  };

  nodes.Constant.prototype.boundDomain = function (symbol) {
    return [-Infinity, Infinity];
  };

  // Tighten domain for piecewise functions with a linear inequality condition
  // and a NaN else_expr.
  nodes.Piecewise.prototype.boundDomain = function (symbol) {
    if (!this.args[2].isConstant || !isNaN(this.args[2].constantValue)) return false;
    var condDomain = this.args[0].boundDomain(symbol);
    var ifExprDomain = this.args[1].boundDomain(symbol);
    if (!condDomain || !ifExprDomain) return false;
    return [Math.max(condDomain[0], ifExprDomain[0]), Math.min(condDomain[1], ifExprDomain[1])];
  };

  nodes.BaseComparator.prototype.boundDomain = function (symbol) {
    if (this.operator === '=') return false; // Just bail on equality case
    var differenceTree = this._difference;
    var polynomialOrder = differenceTree.polynomialOrder(symbol);
    if (polynomialOrder > 1) return false;
    // Should strictly check sign of 0 order term, and return either complete or empty
    // set accordingly, but for plotting, this isn't relevant.
    if (polynomialOrder < 1) return [-Infinity, Infinity];

    var coeffTrees = differenceTree.getPolynomialCoefficients(symbol);
    var b = coeffTrees[1] ? coeffTrees[1].getConcreteTree(BuiltInFrame) : zero;
    var c = coeffTrees[0] ? coeffTrees[0].getConcreteTree(BuiltInFrame) : zero;

    // Only handle cases that constant collapse to finite constants.
    if (!b.isConstant || !c.isConstant) return false;
    if (!isFinite(b.constantValue) || !isFinite(c.constantValue)) return false;

    // Same note as polynomialOrder < 1 above.
    if (b.constantValue === 0) return [-Infinity, Infinity];

    var soln = -c.constantValue/b.constantValue;
    return (b.constantValue < 0) ? [-Infinity, soln] : [soln, Infinity];
  };
});
define('math/features/derivative',['require','parsenodes','math/baseparser','math/builtinframe'],function (require) {
  var Nodes = require('parsenodes');
  var Parser = require('math/baseparser');
  var BuiltInFrame = require('math/builtinframe');

  var zero = Nodes.Constant(0);
  var one = Nodes.Constant(1);
  var two = Nodes.Constant(2);

  var derivatives = {
    FreeVariable:   function (symbol) {return symbol === this._symbol ? one : zero},
    Constant:       function (symbol) {
      return isFinite(this.constantValue) ? zero : Nodes.Constant(this.constantValue);
    },
    Negative:       function (symbol) {return Nodes.Negative([this.args[0].takeDerivative(symbol)])},
    // ['x_1', 'y_1']
    Add: function (symbol) {
      return Nodes.Add([
        this.args[0].takeDerivative(symbol),
        this.args[1].takeDerivative(symbol)
      ]);
    },
    // Subtract: ['x_1', '-y_1'],
    Subtract: function (symbol) {
      return Nodes.Subtract([
        this.args[0].takeDerivative(symbol),
        this.args[1].takeDerivative(symbol)
      ]);
    },
    // Multiply: ['x*y_1', 'x_1*y'],
    Multiply: function(symbol){
      return Nodes.Add([
        checkDependence(symbol, this.args[0], Nodes.Multiply([this.args[0].takeDerivative(symbol), this.args[1]])),
        checkDependence(symbol, this.args[1], Nodes.Multiply([this.args[0], this.args[1].takeDerivative(symbol)])),
      ]);
    },
    // ['x_1/y, -(x*y_1)/y^2']
    Divide: function (symbol) {
      return Nodes.Subtract([
        checkDependence(symbol, this.args[0], Nodes.Divide([this.args[0].takeDerivative(symbol), this.args[1]])),
        checkDependence(symbol, this.args[1], Nodes.Divide([
          Nodes.Multiply([this.args[0], this.args[1].takeDerivative(symbol)]),
          Nodes.Exponent([this.args[1], two])
        ]))
      ]);
    },
    // ['y*x^y*x_1', '\\ln(x)*x^y*y_1']
    Exponent: function (symbol) {
      return Nodes.Add([
        checkDependence(symbol, this.args[0], Nodes.Multiply([
          Nodes.Multiply([
            this.args[1],
            Nodes.Exponent([this.args[0], Nodes.Subtract([this.args[1], one])])
          ]),
          this.args[0].takeDerivative(symbol)
        ])),
        checkDependence(symbol, this.args[1], Nodes.Multiply([
          Nodes.Multiply([
            Nodes.FunctionCall('\\ln', [this.args[0]]),
            Nodes.Exponent([this.args[0], this.args[1]])
          ]),
          this.args[1].takeDerivative(symbol)
        ]))
      ]).getConcreteTree(BuiltInFrame);
    },
    Sum: function (symbol) {
      return this.copyWithArgs([
        this.args[0],
        this.args[1],
        this.args[2],
        this.args[3].takeDerivative(symbol)
      ]);
    },
    Product: function (symbol) {
      // If product has no zero terms, use (sum_i fi'/fi)(product_i fi)
      // If product has exactly 1 zero at ith term, use f1*f2*...*fi'*...*fn
      // If product has more than 1 non-zero term, then its derivative is 0.

      var nzeros = Nodes.Sum([
        this.args[0],
        this.args[1],
        this.args[2],
        Nodes.Piecewise([
          Nodes.Comparator['=']([zero, this.args[3]]),
          one,
          zero
        ])
      ]);

      var noZeros = Nodes.Multiply([
        Nodes.Sum([
          this.args[0],
          this.args[1],
          this.args[2],
          Nodes.Divide([
            this.args[3].takeDerivative(symbol),
            this.args[3]
          ])
        ]),
        Nodes.Product(this.args)
      ]);

      var oneZero = Nodes.Product([
        this.args[0],
        this.args[1],
        this.args[2],
        Nodes.Piecewise([
          Nodes.Comparator['=']([zero, this.args[3]]),
          this.args[3].takeDerivative(symbol),
          this.args[3]
        ])
      ]);

      return Nodes.Piecewise([
        Nodes.Comparator['=']([zero, nzeros]),
        noZeros,
        Nodes.Piecewise([
          Nodes.Comparator['=']([one, nzeros]),
          oneZero,
          zero
        ])
      ]);
    },
    Piecewise: function (symbol) {
      // TODO incorrect at condition boundaries
      if (this.args.length === 2) {
        return Nodes.Piecewise([
          this.args[0],
          this.args[1].takeDerivative(symbol)
        ]);
      } else if (this.args.length === 3) {
        return Nodes.Piecewise([
          this.args[0],
          this.args[1].takeDerivative(symbol),
          this.args[2].takeDerivative(symbol)
        ]);
      }
    },
    List: function (symbol) {
      return Nodes.List(this.args.map(function (arg) {
        return arg.takeDerivative(symbol);
      }));
    },
    ListAccess: function (symbol) {
      return this.constructor([this.args[0].takeDerivative(symbol), this.args[1]]);
    },
    SolvedEquation: function (symbol) {
      return this._expression.takeDerivative(symbol);
    },
    OptimizedRegression: function (symbol) {
      return this.model.takeDerivative(symbol);
    }
  };

  Nodes.NativeFunction.Invocation.prototype.takeDerivative = function (symbol) {
    return this._fn.takeDerivative(symbol, this.args);
  };

  Nodes.ReducerFunction.Invocation.prototype.takeDerivative = function (symbol) {
    return this._fn.takeDerivative(symbol, this.args);
  };

  // TODO restrict domain on derivatives of inverse functions
  var oneArgFunctionDerivatives = {
    exp: '\\exp(x)*x_1',
    ln: '\\{x >= 0: x_1/x \\}',
    sqrt: 'x_1/(2*\\sqrt{x})',
    sin: '\\cos(x)*x_1',
    cos: '-\\sin(x)*x_1',
    tan: '\\sec(x)^2*x_1',
    arcsin: 'x_1/\\sqrt{1 - x^2}',
    arccos: '-x_1/\\sqrt{1 - x^2}',
    arctan: 'x_1/(1+x^2)',
    sinh: '\\cosh(x)*x_1',
    cosh: '\\sinh(x)*x_1',
    tanh: '(\\sech(x))^2*x_1',
    arcsinh: 'x_1/\\sqrt{x^2 + 1}',
    arccosh: '\\{ x > 0: x_1/\\sqrt{x^2 - 1} \\}',
    arctanh: '\\{ \\abs(x) < 1: x_1/(1 - x^2) \\}',
    csc: '-\\cot(x)*\\csc(x)*x_1',
    sec: '\\tan(x)*\\sec(x)*x_1',
    cot: '-\\csc(x)^2*x_1',
    arccsc: '-x_1/(x\\sqrt{x^2 - 1})',
    arcsec: 'x_1/(x\\sqrt{x^2 - 1})',
    arccot: '-x_1/(1+x^2)',
    csch: '-\\coth(x)*\\csch(x)*x_1',
    sech: '-\\tanh(x)*\\sech(x)*x_1',
    coth: '-(\\csch(x))^2*x_1',
    arccsch: '-x_1/(x*\\sqrt{1 + x^2})',
    arcsech: '\\{ x >= 0: -x_1/(x*\\sqrt{1 - x^2}) \\}',
    arccoth: '\\{ \\abs(x) > 1 : x_1/(1 - x^2) \\}',
    factorial: '(x)!*\\polyGamma(0, x + 1)*x_1',
    floor: '\\{ \\mod(x, 1) > 0: 0*x_1 \\}',
    ceil: '\\{ \\mod(x, 1) > 0: 0*x_1 \\}',
    round: '\\{ \\abs(\\mod(x, 1) - 0.5) > 0: 0*x_1 \\}',
    abs: '\\{ \\abs(x) > 0: \\sign(x)*x_1 \\}',
    sign: '\\{ \\abs(x) > 0: 0*x_1 \\}',
    mean: '\\mean(x_1)',
    total: '\\total(x_1)',
    length: '0',
    'var': '2\\mean((x-\\mean(x))*(x_1-\\mean(x_1)))',
    stdev: '\\length(x)/(\\length(x) - 1)*\\mean((x-\\mean(x))*(x_1-\\mean(x_1)))/\\stdev(x)',
    stdevp: '\\mean((x-\\mean(x))*(x_1-\\mean(x_1)))/\\stdevp(x)',
    // TODO: ignores the case that the supremum/infimum of x contains more than 1 element.
    // In that case, the result should be NaN unless the derivative of all of the elements
    // of the supremum/infimum are equal.
    min: 'x_1[\\argmin(x)]',
    max: 'x_1[\\argmax(x)]',
    // zero would be an okay answer here too, but this usually isn't relevant
    argmin: '0/0',
    argmax: '0/0'
  };

  var twoArgFunctionDerivatives = {
    log: [
      // d/dx ln(x) is actually real for negative x, too, but showing the
      // derivative in places where we don't show the function is confusing,
      // so restrict to x > 0.
      '\\{x > 0: \\frac{x_1}{x*\\ln(y)}\\}',
      '\\frac{-\\log_{y}(x)*y_1}{y*\\ln(y)}'
    ],
    pow: [
      'y*x^{y - 1}*x_1',
      'x^{y}*\\ln(x)*y_1'
    ],
    nthroot: [
      'x^{1/y - 1}/y*x_1',
      '-\\frac{x^{1/y}*\\ln(x)*y_1}{y^2}'
    ],
    polyGamma: [
      '0/0',
      '\\polyGamma(1 + x, y)*y_1'
    ],
    mod: [
      '\\{ \\abs(\\mod(x, y)) > 0: x_1 \\}',
      // Check whether division results in an integer directly instead
      // of computing mod of the args because division sometimes results
      // in an integer when modulus does not result in 0, e.g.
      //
      // 3.8 % -0.7599999999999999 -> 3.3306690738754696e-16, but
      // 3.8 / -0.7599999999999999 -> -5
      //
      // This can confuse the jump detector, resulting in spurious
      // connections.
      //
      //TODO still have some spurious connections near 0 in d/dx mod(3,x).
      // Why?
      '\\{ \\mod(x/y, 1) > 0: -\\floor(x/y)*y_1 \\}'
    ],
    // We actually round arguments for these functions, so to be consistent,
    // these could be defined as 0 except at integers where they're undefined,
    // but that is not a standard definition.
    //
    // Can also define continuous nCr and nPr using gamma function.
    lcm: ['0/0', '0/0'],
    gcd: ['0/0', '0/0'],
    nCr: ['0/0', '0/0'],
    nPr: ['0/0', '0/0']
  };

  var oneArgDerivativeFunction = function (derivativeTree) {
    return function (symbol, args) {
      var substitutions = {
        x: args[0],
        x_1: args[0].takeDerivative(symbol)
      };
      return checkDependence(symbol, args[0], derivativeTree.substitute(substitutions)).getConcreteTree(BuiltInFrame);
    };
  };

  var twoArgDerivativeFunction = function (derivativeTree1, derivativeTree2) {
    return function (symbol, args) {
      var substitutions = {
        x: args[0],
        x_1: args[0].takeDerivative(symbol),
        y: args[1],
        y_1: args[1].takeDerivative(symbol)
      };

      return Nodes.Add([
        checkDependence(symbol, args[0], derivativeTree1.substitute(substitutions)),
        checkDependence(symbol, args[1], derivativeTree2.substitute(substitutions))
      ]).getConcreteTree(BuiltInFrame);
    };
  };

  for (var k in oneArgFunctionDerivatives) {
    BuiltInFrame[k].takeDerivative = oneArgDerivativeFunction(
      Parser.parse(oneArgFunctionDerivatives[k])
    );
  }

  for (k in twoArgFunctionDerivatives) {
    BuiltInFrame[k].takeDerivative = twoArgDerivativeFunction(
      Parser.parse(twoArgFunctionDerivatives[k][0]),
      Parser.parse(twoArgFunctionDerivatives[k][1])
    );
  }

  var checkDependence = function (symbol, arg, tree) {
    return arg.dependsOn(symbol) ? tree : zero;
  };

  for(var nodeType in derivatives){
    var derivative = derivatives[nodeType];
    Nodes[nodeType].prototype.takeDerivative = derivative;
  }
});

// substitute does non-recursive replacement of identifiers specified in a frame.
// It differs from getConcreteTree by being non-recursive. Currently, this feature
// is used only in the derivative system to substitute arguments into derivative
// definitions.
define('math/features/substitute',['require','parsenodes'],function (require) {
  var Nodes = require('parsenodes');

  var substitutions = {
    Identifier: function (frame) { return frame[this._symbol] ? frame[this._symbol] : this; },
    FreeVariable: function (frame) { return frame[this._symbol] ? frame[this._symbol] : this; },
    Constant: function (frame) { return this; },
    Expression: function (frame) {
      return this.copyWithArgs(this.args.map(function (arg) {
        return arg.substitute(frame);
      }));
    },
    List: function (frame) {
      return Nodes.List(this.args.map(function (arg) {
        return arg.substitute(frame);
      }));
    },
    SolvedEquation: function (symbol) {
      return this.constructor(this._symbol, this._expression.substitute(symbol));
    },
    OptimizedRegression: function (symbol) {
      return this.constructor(
        this.model.substitute(symbol),
        this.parameters,
        this.residualVariables,
        this.residuals,
        this.statistics
      );
    }
  };

  for (var key in substitutions) {
    Nodes[key].prototype.substitute = substitutions[key];
  }
});

// Only defines a function on basecomparator, but making this a feature because
// it needs to use baseparser.
define('math/features/solve',['require','math/baseparser','math/parsenode/constant','math/parsenode/equation','math/parsenode/solvedequation','math/parsenode/basecomparator','math/parsenode/list','math/errormsg','math/builtinframe','math/policy'],function (require) {
  var Parser = require('math/baseparser');
  var Constant = require('math/parsenode/constant');
  var Equation = require('math/parsenode/equation');
  var SolvedEquation = require('math/parsenode/solvedequation');
  var BaseComparator = require('math/parsenode/basecomparator');
  var List = require('math/parsenode/list');
  var ErrorMsg = require('math/errormsg');
  var BuiltInFrame = require('math/builtinframe');
  var Policy = require('math/policy');

  var zero = Constant(0);

  // Can't easily write this as a single calculator expression because the length
  // of the result depends on values.
  var linearSolutionTree = Parser.parse('[-c/b]');
  var degenerateSolutionTree = Parser.parse('[-b/(2*a)]');
  var generalSolutionTree = Parser.parse('[\\{a>0:q,p\\},\\{a>0:p,q\\}]');
  function _solveSingleVariableEquation (localFrame) {
    _populateFrame(localFrame);
    if (localFrame.a.constantValue === 0) {
      if (localFrame.b.constantValue === 0) {
        return Constant(localFrame.c.constantValue === 0);
      }
      return linearSolutionTree.getConcreteTree(localFrame);
    }
    // f - g is the discriminant. If it's negative, there are no solutions
    // If it's 0, there is only one solution (with multiplicity 2)
    if (localFrame.f.constantValue - localFrame.g.constantValue < 0) {
      return List([Constant(false)]);
    }
    if (localFrame.f.constantValue - localFrame.g.constantValue === 0) {
      return degenerateSolutionTree.getConcreteTree(localFrame);
    }
    return generalSolutionTree.getConcreteTree(localFrame);
  }


  function _populateABC (coeffTrees) {
    var localFrame = Object.create(BuiltInFrame);
    // Set up a frame with variables relevant to the solution of a quadratic inequality
    // or equation: ax^2+bx+c=0
    localFrame.a = coeffTrees[2] ? coeffTrees[2].tryGetConcreteTree(BuiltInFrame) : zero;
    localFrame.b = coeffTrees[1] ? coeffTrees[1].tryGetConcreteTree(BuiltInFrame) : zero;
    localFrame.c = coeffTrees[0] ? coeffTrees[0].tryGetConcreteTree(BuiltInFrame) : zero;
    return localFrame;
  }

  var fTree = Parser.parse('b*b');
  var gTree = Parser.parse('4*a*c');
  // p and q are the two solutions to the quadratic equation.
  var pTree = Parser.parse('(-b+\\sqrt{b*b-4*a*c})/(2*a)');
  var qTree = Parser.parse('(-b-\\sqrt{b*b-4*a*c})/(2*a)');
  var eqnSolutionTree = Parser.parse('[' +
    '\\{a=0:\\{b<0:-c/b\\},q\\},' +
    '\\{a=0:\\{b>=0:-c/b\\},p\\}' +
  ']');
  var inequalitySolutionTree = Parser.parse('[' +
    '\\{a=0:\\{b<0:-c/b\\},a>0:q\\},' +
    '\\{a=0:\\{b=0:\\{c>0:-m\\}\\},a>0:\\{f<g:-m\\},p\\},' +
    '\\{a=0:\\{b=0:\\{c>0:m\\}\\},a>0:\\{f<g:m\\},q\\},' +
    '\\{a=0:\\{b>0:-c/b\\},a>0:p\\}' +
  ']');

  function _effectiveOrder (localFrame) {
    if (localFrame.a.constantValue === 0) {
      if (localFrame.b.constantValue === 0) return 0;
      return 1;
    }
    return 2;
  }

  function _chooseVariable (concreteDifference, dependencies, isInequality) {
    //ask for trees to represent the coefficients

    var variableOfInterest;
    var effectiveOrders = [];
    var localFrames = [];
    var localFrame;
    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      var order = concreteDifference.polynomialOrder(dependency);
      var orderTooHigh = order > 2;
      var invalidVariable = dependencies.length > 1 && !Policy.validSolvedVariable(dependency);
      // piecewiseIneqality check is a little bit subtle. Relies on the fact that extractConditions
      // returns the original expression iff it finds no piecewise expressions that depend on
      // dependency.
      var piecewiseInequality = isInequality && concreteDifference.extractConditions(dependency, zero) !== zero;

      if (orderTooHigh || invalidVariable || piecewiseInequality) {
        localFrames[i] = {};
        effectiveOrders[i] = Infinity;
        continue;
      }

      localFrames[i] = [];
      effectiveOrders[i] = 0;
      for (var j = 0; j < concreteDifference.args.length; j++) {
        localFrame = _populateABC(concreteDifference.args[j].getPolynomialCoefficients(dependency));
        localFrames[i][j] = localFrame;
        effectiveOrders[i] = Math.max(effectiveOrders[i], _effectiveOrder(localFrame));
      }
    }

    var effectiveOrder;
    if (dependencies.length === 1) {
      localFrame = localFrames[0];
      variableOfInterest = dependencies[0];
      effectiveOrder = effectiveOrders[0];
    } else { // dependencies.length === 2
      var index;
      if (effectiveOrders[0] === 0) {
        index = 1;
      } else if (effectiveOrders[1] === 0) {
        index = 0;
      } else {
        index = effectiveOrders[0] < effectiveOrders[1] ? 0 : 1;
      }
      localFrame = localFrames[index];
      variableOfInterest = dependencies[index];
      effectiveOrder = effectiveOrders[index];
    }

    return {
      localFrame: localFrame,
      variableOfInterest: variableOfInterest,
      effectiveOrder: effectiveOrder
    };
  }

  var solvers = {
    singleVariable: _solveSingleVariableEquation,
    inequality: function (localFrame) {
      _populateFrame(localFrame);
      return inequalitySolutionTree.getConcreteTree(localFrame);
    },
    generalEquation: function (localFrame) {
      _populateFrame(localFrame);
      return eqnSolutionTree.getConcreteTree(localFrame);
    }
  };

  function _chooseSolver (dependencies, isInequality) {
    if (isInequality) return solvers.inequality;
    if (dependencies.length === 1) return solvers.singleVariable;
    return solvers.generalEquation;
  }

  function _populateFrame (localFrame) {
    // f - g is the discriminant
    localFrame.f = fTree.getConcreteTree(localFrame);
    localFrame.g = gTree.getConcreteTree(localFrame);
    // p and q are the two solutions to the quadratic equation.
    localFrame.p = pTree.getConcreteTree(localFrame);
    localFrame.q = qTree.getConcreteTree(localFrame);
    // m is a standin for Infinity. This is kind of a hack to help us shade from a
    // solution to "infinity," working around the fact that the rest of the pipeline
    // doesn't always handle infinity well.
    localFrame.m = Constant(1e305);
  }

  Equation.prototype.solve = function (frame) {
    return this.asComparator().solve(frame);
  };

  BaseComparator.prototype.solve = function (frame) {
    /* jshint maxcomplexity:18 */
    var concrete = this.tryGetConcreteTree(frame);
    if (concrete.isError) return concrete;
    if (concrete.isConstant) return concrete;

    var isInequality = this.getOperator() !== '=';

    //get concrete tree for the difference
    var concreteDifference = this._difference.tryGetConcreteTree(frame);

    var dependencies = concreteDifference.getDependencies();

    if (dependencies.length === 0) {
      if (concreteDifference.isList) return List(concreteDifference.args.map(function (arg) {
        return Constant(arg.constantValue === 0);
      }));
      return Constant(concreteDifference.constantValue === 0);
    }

    if (dependencies.length === 1 && concreteDifference.isList && !isInequality) {
      return ErrorMsg.singleVariableListSolve();
    }

    // After this point, it's easier if we can just assume everything is a list.
    var concreteDifferences = concreteDifference.isList ? concreteDifference : List([concreteDifference]);

    if (dependencies.length > 2) {
      return ErrorMsg.tooManyVariables(this.getSliderVariables(concrete)).setDependencies(dependencies);
    }

    if (isInequality && !Policy.validInequalityVariables(dependencies)) {
      return ErrorMsg.invalidInequalityVariables().setDependencies(dependencies);
    }

    if (dependencies.length === 2 && !Policy.validImplicitVariables(dependencies)) {
      return ErrorMsg.invalidImplicitVariables().setDependencies(dependencies);
    }

    var result = _chooseVariable(concreteDifferences, dependencies, isInequality);
    var localFrame = result.localFrame;
    var effectiveOrder = result.effectiveOrder;
    var variableOfInterest = result.variableOfInterest;

    if (Policy.complicatedPolarImplicit(variableOfInterest, effectiveOrder)) {
      if (isInequality || dependencies.length > 1) {
        return ErrorMsg.complicatedPolarImplicit().setDependencies(dependencies);
      }
    }

    if (effectiveOrder > 2) {
      if (dependencies.length === 1) return ErrorMsg.unsolvable().setDependencies(dependencies);
      if (isInequality) return ErrorMsg.complicatedImplicitInequality().setDependencies(dependencies);
      return concreteDifference;
    }

    var solveScalar = _chooseSolver(dependencies, isInequality);

    var allBranches = [];
    for (var i = 0; i < localFrame.length; i++) {
      var branches = solveScalar(localFrame[i]);
      if (branches.isError) return branches;
      if (branches.isConstant) {
        allBranches.push(branches);
        continue;
      }
      for (var j = 0; j < branches.args.length; j++) {
        var branch = branches.args[j];
        var restricted = concreteDifferences.args[i]
          .extractConditions(variableOfInterest, branch)
          .getConcreteTree(frame)
        ;
        allBranches.push(restricted);
      }
    }

    return SolvedEquation(variableOfInterest, List(allBranches));
  };
});
// Basically temporary shim to support the API of the current formula object and allow integration into the rest of the
// system. API here is just a direct copy, funny naming and all.

define('math/evaluationstate',['require','graphing/graphmode','parsenodes','graphing/label'],function(require){
  var GRAPHMODE = require('graphing/graphmode');
  var nodes = require('parsenodes');
  var Label = require('graphing/label');

  function _tableCellValue (concrete) {
    if (concrete.isError) return concrete.getError();
    if (concrete.constantValue === undefined) return '';
    return +concrete.constantValue;
  }

  function _tableState (raw, concrete) {
    var columnData = [];
    for (var i = 0; i < raw.columns.length; i++) {
      var column = concrete.columns[i];
      var state = {
        dependent: !column.isIndependent,
        discrete: column.isIndependent
      };
      if (column.isError) {
        state.error = column.getError();
        state.values = [];
      } else {
        state.values = column.values.args.map(_tableCellValue);
      }
      columnData.push(state);
    }
    return {
      can_auto_regress: raw.canAutoRegress(concrete),
      column_data: columnData
    };
  }

  var _defaultEvaluationState = function () {
    return {
     operator: '=',
     variables: []
    };
  };

  var EvaluationState = function (raw, concrete) {
    /* jshint maxcomplexity:20 */
    //Compute serializable evaluation state from raw and concrete parseTrees

    // Tables follow a completely different format for their
    // evaluation state.
    if (raw.isTable) return _tableState(raw, concrete);

    //Reasonable defaults
    var state = _defaultEvaluationState();

    //What errors should it return? (if any)
    if (concrete.isError) {
      state.error = concrete.getError();
      state.variables = raw.getSliderVariables(concrete);
      return state;
    }

    if (concrete.isMovablePoint) {
      state.move_ids = concrete._moveIds;
      state.move_matrix = concrete._moveMatrix;
    }

    if (raw.isInequality()) state.is_inequality = true;
    state.operator = raw.getOperator();

    //Does it assign anything
    if (concrete instanceof nodes.SolvedEquation) {
      // Set assignment for things like x=3, but not for equations
      // that are satisfied everywhere or nowhere
      if (
        concrete._expression.constantValue !== true &&
        concrete._expression.constantValue !== false
      ) {
        state.assignment = concrete._symbol;
      }
    } else if (raw instanceof nodes.Assignment) {
      // Cover assignments that don't need to be solved, like b=1+2
      state.assignment = raw._symbol;
    }

    //How should it be graphed? (if at all)
    var graphMode = raw.getGraphMode(concrete);
    if (graphMode !== GRAPHMODE.NONE) {
      state.is_graphable = true;

      if (graphMode === GRAPHMODE.XYPOINT)         state.is_point_list = true;
      if (graphMode === GRAPHMODE.XYPOINT_MOVABLE) state.is_point_list = true;
      if (graphMode === GRAPHMODE.PARAMETRIC)      state.is_parametric = true;
      if (concrete.isShadeBetween())               state.is_shade_between = true;

      var table_info = raw.tableInfo(concrete);
      if (table_info) {
        state.is_tableable = true;
        state.table_info = table_info;
      }
    }

    //What sliders should it prompt for? (none if graphable)
    state.variables = state.is_graphable ? [] : raw.getSliderVariables(concrete);

    var sliderInfo = raw.getSliderInfo();
    if (sliderInfo) {
      state.is_slidable = true;
      state.is_animatable = !state.is_graphable; //Don't animate graphed sliders
      state.constant_value = sliderInfo.value;
    } else if (concrete.isConstant) {
      state.constant_value = concrete.constantValue;
    }

    //How should it be evaluated? (if at all)
    var values = concrete.getEvaluationInfo();
    if (values && !raw.isConstant && !raw.isFunction && !state.is_graphable && !state.is_slidable) {
      state.is_evaluable = true;
      state.zero_values = values;
    }

    if (concrete instanceof nodes.OptimizedRegression) {
      var parameterValues = {};
      for (var p in concrete.parameters) {
        if (!concrete.parameters.hasOwnProperty(p)) continue;
        parameterValues[Label.identifierToLatex(p)] = +concrete.parameters[p].constantValue;
      }

      state.is_regression = true;
      state.regression = {
        parameters: parameterValues,
        residualVariable: Label.identifierToLatex(concrete.residualVariable),
        residualSuggestionId: concrete.residualSuggestionId,
        statistics: concrete.statistics
      };
    }

    return state;
  };

  EvaluationState.default = _defaultEvaluationState;

  return EvaluationState;
});

define('math/statementanalysis',['require','math/evaluationstate','pjs','graphing/graphmode'],function(require){
  var getEvaluationState = require('math/evaluationstate');
  var P = require('pjs');
  var GRAPHMODE = require('graphing/graphmode');

  return P(function(analysis){
    analysis.init = function(raw, concrete){
      this.rawTree = raw;
      this.concreteTree = concrete;
      this.evaluationState = getEvaluationState(raw, concrete);
    };

    analysis.exportTo = function (frame) {
      this.rawTree.exportTo(this.concreteTree, frame);
    };

    analysis.graph = function (viewState) {
      return this.rawTree.graph(this.concreteTree, viewState);
    };

    analysis.getGraphMode = function () {
      return this.rawTree.getGraphMode(this.concreteTree);
    };

    analysis.getGraphInfo = function () {
      return this.rawTree.getGraphInfo(this.concreteTree);
    };

    analysis.shouldIntersect = function () {
      if (!this.evaluationState.is_graphable) return false;
      if (!this.rawTree.userData.shouldGraph) return false;
      var graphMode = this.getGraphMode();
      return graphMode === GRAPHMODE.X || graphMode === GRAPHMODE.Y;
    };
  });
});

define('math/features/analyze',['require','parsenodes','math/statementanalysis','math/builtinframe','math/policy','math/errormsg','math/comparators'],function(require){
  var nodes = require('parsenodes');
  var StatementAnalysis = require('math/statementanalysis');
  var BuiltInFrame = require('math/builtinframe');
  var Policy = require('math/policy');
  var Constant = nodes.Constant;
  var ErrorMsg = require('math/errormsg');
  var Comparators = require('math/comparators');
  var FreeVariable = nodes.FreeVariable;

  var zero = Constant(0);

  nodes.Base.prototype.analyze = function(frame){
    return StatementAnalysis(this, this.tryGetConcreteTree(frame));
  };

  nodes.Expression.prototype.analyze = function(frame){
    var concrete = this.tryGetConcreteTree(frame);
    if (concrete.isError) return StatementAnalysis(this, concrete);
    var dependencies = concrete.getDependencies();
    if (dependencies.length > 1) {
      if (Policy.validImplicitVariables(dependencies)) {
        return StatementAnalysis(this, ErrorMsg.equationRequired().setDependencies(dependencies));
      } else {
        return StatementAnalysis(
          this,
          ErrorMsg.tooManyVariables(this.getSliderVariables(concrete)).setDependencies(dependencies)
        );
      }
    } else if (dependencies.length === 1 && !Policy.validExpressionVariable(dependencies[0])) {
      return StatementAnalysis(
        this,
        ErrorMsg.equationRequired(dependencies[0]).setDependencies(dependencies)
      );
    } else {
      return StatementAnalysis(this, concrete);
    }
  };

  nodes.Identifier.prototype.analyze = function (frame) {
    return StatementAnalysis(this, this.tryGetConcreteTree(frame));
  };

  nodes.FunctionDefinition.prototype.analyze = function(frame){
    if (BuiltInFrame[this._symbol]) {
      return StatementAnalysis(this, ErrorMsg.cannotRedefine(this._symbol));
    }

    //Make sure free variables are all arguments
    var concrete = this.tryGetConcreteTree(frame);
    if (concrete.isError) return StatementAnalysis(this, concrete);
    var argSymbols = this._argSymbols;

    var dependencies = concrete.getDependencies();

    var freeVariables = dependencies.filter(function (symbol) {
      return argSymbols.indexOf(symbol) === -1;
    });

    if (Policy.unplottablePolarFunction(this._symbol, dependencies)) {
      return StatementAnalysis(this, ErrorMsg.unplottablePolarFunction());
    }

    if (freeVariables.some(Policy.assignmentForbidden)) {
      return StatementAnalysis(
        this,
        ErrorMsg.addArgumentsToDefinition(freeVariables, this._symbol, argSymbols).setDependencies(dependencies)
      );
    } else if (freeVariables.length) {
      return StatementAnalysis(
        this,
        ErrorMsg.tooManyVariables(this.getSliderVariables(concrete)).setDependencies(dependencies)
      );
    } else {
      return StatementAnalysis(this, concrete);
    }
  };

  nodes.Assignment.prototype.analyze = function(frame){
    var lhs = this._symbol;
    if (!Policy.validLHS(lhs)) return StatementAnalysis(this, ErrorMsg.invalidLHS(lhs));
    if (BuiltInFrame[lhs]) return StatementAnalysis(this, ErrorMsg.cannotRedefine(lhs));

    var concrete = this.tryGetConcreteTree(frame);
    if (concrete.isError) return StatementAnalysis(this, concrete);
    var dependencies = concrete.getDependencies();

    // If the assigned symbol appears on the RHS, analyze as an equation
    if (dependencies.indexOf(this._symbol) !== -1) {
      var eqnAnalysis = this.asEquation().analyze(frame);
      return StatementAnalysis(this, eqnAnalysis.concreteTree);
    }

    if (dependencies.length > 1) {
      return StatementAnalysis(
        this,
        ErrorMsg.tooManyVariables(this.getSliderVariables(concrete)).allowExport().setDependencies(dependencies)
      );
    }

    return StatementAnalysis(this, concrete);
  };

  nodes.Regression.prototype.analyze = function (frame, exportFrame, lastExportFrame, priorAnalysis) {
    return StatementAnalysis(this, this.optimize(frame, exportFrame, lastExportFrame, priorAnalysis));
  };

  nodes.Equation.prototype.analyze =
  nodes.BaseComparator.prototype.analyze = function (frame) {
    return StatementAnalysis(this, this.solve(frame));
  };

  nodes.DoubleInequality.prototype.analyze = function (frame) {
    var concrete = this.tryGetConcreteTree(frame);
    if (concrete.isError) return StatementAnalysis(this, concrete);

    var dependencies = concrete.getDependencies();

    if (Comparators.table[this._operators[0]].direction !== Comparators.table[this._operators[1]].direction) {
      return StatementAnalysis(this, ErrorMsg.mismatchedDoubleInequality());
    }

    if (!Policy.validDoubleInequalitySymbol(concrete._symbol)) {
      return StatementAnalysis(
        this,
        ErrorMsg.invalidDoubleInequalityVariables().setDependencies(dependencies)
      );
    }

    if (!Policy.validDoubleInequalityVariables(dependencies)) {
      return StatementAnalysis(
        this,
        ErrorMsg.invalidDoubleInequalityVariables().setDependencies(dependencies)
      );
    }

    if (dependencies.length > 2) {
      return StatementAnalysis(
        this,
        ErrorMsg.tooManyVariables(this.getSliderVariables(concrete)).setDependencies(dependencies)
      );
    }

    if (
      concrete._expressions[0].getDependencies().indexOf(concrete._symbol) !== -1 ||
      concrete._expressions[1].getDependencies().indexOf(concrete._symbol) !== -1
    ) {
      return StatementAnalysis(this, ErrorMsg.complicatedDoubleInequality().setDependencies(dependencies));
    }

    return StatementAnalysis(this, concrete);
  };

  // Complicated double inequalities like x < y^2 < z compile to And comparators.
  nodes.And.prototype.analyze = function (frame) {
    var concrete = this.tryGetConcreteTree(frame);
    if (concrete.isError) return StatementAnalysis(this, concrete);

    var dependencies = concrete.getDependencies();
    if (dependencies.length) {
      if (Policy.validDoubleInequalityVariables(dependencies)) {
        return StatementAnalysis(
          this,
          ErrorMsg.complicatedDoubleInequality().setDependencies(dependencies)
        );
      }
      return StatementAnalysis(
        this,
        ErrorMsg.tooManyVariables(this.getSliderVariables(concrete)).setDependencies(dependencies)
      );
    }

    return StatementAnalysis(this, concrete);
  };

  nodes.OrderedPair.prototype.analyze = function (frame, priorAnalysis) {
    //movable points rely on prior analysis to find moveIds
    var concrete = this.tryGetConcreteTree(frame);
    if (concrete.isError) return StatementAnalysis(this, concrete);
    var analysis = StatementAnalysis(this, concrete);

    //Check for free variables that aren't t
    var dependencies = concrete.getDependencies();

    if (dependencies.length) {
      if (Policy.validParametricVariables(dependencies)) return analysis;
      return StatementAnalysis(
        this,
        ErrorMsg.tooManyVariables(this.getSliderVariables(concrete)).setDependencies(dependencies)
      );
    }

    //Check preconditions for being a movable point
    if(!analysis.evaluationState.is_graphable) return analysis;
    if(analysis.evaluationState.variables.length !== 0) return analysis;
    if(this.args[0].isList || this.args[1].isList) return analysis; //We only move single points

    var movable;
    var coupled;
    var moveIds = [undefined, undefined];
    var moveMatrix = [
      [1, 0, 0],
      [0, 1, 0]
    ];

    var coordTrees = this.args; //Each coordinate of the point
    coordTrees.forEach(function(tree, index){
      /* jshint maxcomplexity:14 */
      if(coupled) return;
      var symbols = tree.getDependencies();
      var otherTree = coordTrees[index === 0 ? 1 : 0];
      var definitionId;

      // Symbols are stored in order of lexical first appearance in _referencedSymbols.
      // Traversing the array in reverse order means we will move the slider variable that
      // has the last first occurance.
      for (var i = symbols.length - 1; i >= 0; i--) {
        definitionId = undefined;
        var symbol = symbols[i];
        //Make sure the variable is defined by a slider
        //TODO - find statement ID from symbol var definitionId = frame.getDefinitionId(symbol);
        for(var id in priorAnalysis){
          //Find id of slider defining symbol if there is one
          if(priorAnalysis[id].evaluationState.assignment === symbol &&
             priorAnalysis[id].evaluationState.is_slidable){
              definitionId = id;
              break;
          }
        }
        //Make sure we found a slider
        if(definitionId === undefined) continue;

        //Make sure we are linear in the variable

        //Create a frame that shadows the definition of our symbol of interest
        //So that we can ask for the polynomialOrder, etc.
        var localFrame = Object.create(frame);
        localFrame[symbol] = FreeVariable(symbol);
        var concreteTree = tree.tryGetConcreteTree(localFrame);
        if (concreteTree.isError) continue;
        var order = concreteTree.polynomialOrder(symbol);
        if (order !== 1) continue;

        //Find the parameters
        var coeffs = concreteTree.getPolynomialCoefficients(symbol);
        var b = coeffs[1] ? coeffs[1].getConcreteTree(localFrame) : zero;
        var c = coeffs[0] ? coeffs[0].getConcreteTree(localFrame) : zero;
        if (!c.isConstant || !b.isConstant) continue;
        if (b.constantValue === 0) continue;

        // Don't handle coupled variables (yet...)
        //var otherOrder = otherTree.polynomialOrder(frame, symbol);
        var otherConcreteTree = otherTree.tryGetConcreteTree(localFrame);
        if (otherConcreteTree.isError) continue;
        var otherOrder = otherConcreteTree.polynomialOrder(symbol);
        if (otherOrder > 0) {
          //if other moveID exists, continue
          if (moveIds[0]) continue;
          //set coupled = true to prevent future links
          if (otherOrder !== 0) coupled = true;
        }

        moveMatrix[index][index] = 1 / b.constantValue;  //Linear term
        moveMatrix[index][2] = -c.constantValue / b.constantValue;      //Constant term

        movable = true;
        moveIds[index] = definitionId;

        break;
      }

    });

    if (movable) {
      // Avoid double updating in case of [ 'a = 1', '(a, a)' ]
      // TODO - may be able to avoid this check with coupling check above
      if (moveIds[1] === moveIds[0]) moveIds[1] = undefined;
      return StatementAnalysis(this, nodes.MovablePoint(concrete.args, moveIds, moveMatrix));
    } else {
      return analysis;
    }
  };

  function _removeLocals (symbols, localFrame) {
    return symbols.filter(function(symbol) { return !localFrame[symbol]; });
  }

  nodes.Table.prototype.analyze = function (frame) {
    var localFrame = Object.create(frame);

    // Note, currently process column definitions left to right.
    // Could switch to running dependency ordering first.
    var concreteColumns = [];
    var firstColumnSymbol;
    for (var i = 0; i < this.columns.length; i++) {
      var columnAnalysis = this.columns[i].analyze(localFrame, frame);
      if (i === 0) {
        // First column must be an independent variable. Check with Policy
        // that that variable is valid.
        if (!columnAnalysis.concreteTree.isIndependent) {
          columnAnalysis = StatementAnalysis(this.columns[i], ErrorMsg.invalidDependentFirstTableColumn());
        } else if (!Policy.validFirstColumnVariable(columnAnalysis.concreteTree.header._symbol)) {
          columnAnalysis = StatementAnalysis(this.columns[i], ErrorMsg.invalidFirstTableColumn());
        } else {
          firstColumnSymbol = columnAnalysis.concreteTree.header._symbol;
        }
      }
      if (columnAnalysis.concreteTree.isIndependent) {
        localFrame[columnAnalysis.concreteTree.header._symbol] = columnAnalysis.concreteTree.values;
      } else if (!columnAnalysis.concreteTree.isError) {
        // Dependent columns must have no dependencies, or depend only on the
        // first column variable
        var dependencies = columnAnalysis.concreteTree.header.getDependencies();
        var freeDependencies = _removeLocals(dependencies, localFrame);
        if (freeDependencies.length) {
          columnAnalysis = StatementAnalysis(
            this.columns[i],
            ErrorMsg.tooManyVariables(freeDependencies).setDependencies(freeDependencies)
          );
        }
      }
      concreteColumns.push(columnAnalysis.concreteTree);
    }
    var concreteTable = nodes.Table(concreteColumns);
    var analysis = StatementAnalysis(this, concreteTable);
    analysis.evaluationState.is_graphable = true; // TODO wrong place for this
    return analysis;
  };

  nodes.TableColumn.prototype.analyze = function (frame, parentFrame) {
    var headerError = this.header.tableError();
    if (headerError) return StatementAnalysis(this, ErrorMsg.invalidTableHeader(headerError));

    var concrete = this.tryGetConcreteTree(frame, parentFrame);
    if (concrete.isError) return StatementAnalysis(this, concrete);
    // TODO following error checking lines should not be necessary, because an error in
    // the header should throw
    if (concrete.header.isError) return StatementAnalysis(this, concrete.header);
    if (concrete.values.isError) return StatementAnalysis(this, concrete.values);
    for (var i = 0; i < concrete.values.args.length; i++) {
      if (concrete.values.args[i].isError) continue;
      var entryError = this.values.args[i] && this.values.args[i].tableError();
      if (entryError) {
        concrete.values.args[i] = ErrorMsg.invalidTableEntry(entryError);
        continue;
      }
      var dependencies = concrete.values.args[i].getDependencies();
      if (dependencies.length) {
        concrete.values.args[i] = ErrorMsg.tooManyVariables(dependencies).setDependencies(dependencies);
      }
    }

    return StatementAnalysis(this, concrete);
  };
});

define('math/features/getgraphmode',['require','parsenodes','math/policy','graphing/graphmode'],function (require) {
  var nodes = require('parsenodes');
  var Policy = require('math/policy');
  var GRAPHMODE = require('graphing/graphmode');

  // Default to graphing nothing.
  nodes.Base.prototype.getGraphMode = function (concrete) {
    return GRAPHMODE.NONE;
  };

  nodes.Identifier.prototype.getGraphMode = function (concrete) {
    if (Policy.graphableAsBareIdentifier(this._symbol)) return GRAPHMODE.Y;
    return GRAPHMODE.NONE;
  };

  nodes.Expression.prototype.getGraphMode = function (concrete) {
    var dependencies = concrete.getDependencies();
    if (dependencies.length !== 1) return GRAPHMODE.NONE;
    return GRAPHMODE.Y;
  };

  // Helper for solved assignments and equations
  function _solvedEquationGraphInfo (concrete) {
    var dependencies = concrete._expression.getDependencies();
    if (dependencies.length !== 1) return GRAPHMODE.NONE;
    var independent = concrete._symbol;
    var dependent = dependencies[0];
    return Policy.graphMode(independent, dependent);
  }

  nodes.BaseComparator.prototype.getGraphMode = function (concrete) {
    // concrete is either
    // 1. a constant Boolean
    // 2. a SolvedEquation
    // 3. an Expression representing a multivariate implicit inequality
    var dependencies = concrete.getDependencies();
    if (concrete.isConstant) return GRAPHMODE.NONE;
    if (concrete instanceof nodes.SolvedEquation) {
      if (dependencies.length === 0) {
        if (Policy.graphableAsConstant(concrete._symbol)) return Policy.constantGraphMode(concrete._symbol);
        return GRAPHMODE.NONE;
      }
      return _solvedEquationGraphInfo(concrete);
    }
    return GRAPHMODE.NONE;
  };

  nodes.DoubleInequality.prototype.getGraphMode = function (concrete) {
    return Policy.constantGraphMode(concrete._symbol);
  };

  nodes.Equation.prototype.getGraphMode = function (concrete) {
    // concrete is either
    // 1. a constant Boolean
    // 2. a SolvedEquation
    // 3. an Expression representing a multivariate implicit function
    if (concrete.isConstant) return GRAPHMODE.NONE;
    if (concrete instanceof nodes.SolvedEquation) return _solvedEquationGraphInfo(concrete);

    if (concrete.getDependencies().length !== 2) return GRAPHMODE.NONE;
    return GRAPHMODE.IMPLICIT;
  };

  nodes.Assignment.prototype.getGraphMode = function (concrete) {
    // concrete is either a SolvedEquation or an Expression.
    if (concrete instanceof nodes.SolvedEquation) return _solvedEquationGraphInfo(concrete);

    var dependencies = concrete.getDependencies();

    switch (dependencies.length) {
      case 0:
        if (!Policy.graphableAsConstant(this._symbol)) return GRAPHMODE.NONE;
        return Policy.constantGraphMode(this._symbol);
      case 1:
        if (concrete.isList && !Policy.graphableListVariables(this._symbol, dependencies[0])) {
          return GRAPHMODE.NONE;
        }
        return Policy.graphMode(this._symbol, dependencies[0]);
      case 2:
        return GRAPHMODE.IMPLICIT;
      default:
        return GRAPHMODE.NONE;
    }
  };

  nodes.FunctionDefinition.prototype.getGraphMode = function (concrete) {
    if (this._argSymbols.length !== 1) return GRAPHMODE.NONE;

    var graphMode = Policy.graphMode(this._symbol, this._argSymbols[0]);
    var dependencies = concrete.getDependencies();
    switch (dependencies.length) {
      case 0:
        return graphMode;
      case 1:
        if (dependencies[0] !== this._argSymbols[0]) return GRAPHMODE.NONE;
        return graphMode;
      default:
        return GRAPHMODE.NONE;
    }
  };

  nodes.OrderedPair.prototype.getGraphMode = function (concrete) {
    if (concrete.isMovablePoint) return GRAPHMODE.XYPOINT_MOVABLE;
    var dependencies = concrete.getDependencies();
    if (dependencies.length === 0) return GRAPHMODE.XYPOINT;
    return Policy.validParametricVariables(dependencies) ? GRAPHMODE.PARAMETRIC : GRAPHMODE.NONE;
  };

  nodes.List.prototype.getGraphMode = function (concrete) {
    /*If we have one free variable, we're graphable*/
    if (concrete.getDependencies().length !== 1) return GRAPHMODE.NONE;
    return GRAPHMODE.Y;
  };

  nodes.Regression.prototype.getGraphMode = function (concrete) {
    if (!(this._lhs instanceof nodes.Identifier) && !(this._lhs instanceof nodes.List)) return GRAPHMODE.NONE;
    if (!concrete.isModelValid) return GRAPHMODE.NONE;
    if (concrete.model.getDependencies().length !== 1) return GRAPHMODE.NONE;
    return GRAPHMODE.Y;
  };

});
define('math/features/getgraphinfo',['require','parsenodes','math/builtinframe'],function (require) {
  var nodes = require('parsenodes');
  var BuiltInFrame = require('math/builtinframe');

  // Needs to be a feature because it relies on BuiltInFrame.

  nodes.Base.prototype.getGraphInfo = function (concrete) {
    var dependencies = concrete.getDependencies();

    var isLinear, domainBound;
    var linearCoefficients = [NaN, NaN];

    switch (dependencies.length) {
      case 0:
        isLinear = true;
        linearCoefficients = [+concrete.constantValue, 0];
        domainBound = [-Infinity, Infinity];
        break;
      case 1:
        domainBound = concrete.boundDomain(dependencies[0]);
        if (!domainBound) {
          domainBound = [-Infinity, Infinity];
          isLinear = false;
        } else {
          isLinear = concrete.isLinear(dependencies[0]);
        }
        if (isLinear) {
          var cs = concrete.getPolynomialCoefficients(dependencies[0]);
          linearCoefficients[0] = cs[0] ? +cs[0].getConcreteTree(BuiltInFrame).constantValue : 0;
          linearCoefficients[1] = cs[1] ? +cs[1].getConcreteTree(BuiltInFrame).constantValue : 0;
        }
        break;
      case 2: isLinear = false; domainBound = [-Infinity, Infinity]; break;
    }

    return {
      graphMode: this.getGraphMode(concrete),
      color: this.userData.color,
      style: this.userData.style,
      operator: this.getOperator(),
      isLinear: isLinear,
      linearCoefficients: linearCoefficients,
      domainBound: domainBound
    };
  };
});

// node.tableInfo returns either
// 1. false if the node cannot be converted to a table
// 2 {
//     independent_variable: 'symbol',
//     dependent_column: 'latex',
//     values: [[x1, y1], [x2, y2], ...], // (optional),
//     by_reference: t/f // Whether the table should replace or reference the statement
//   }
define('math/features/tableinfo',['require','parsenodes','math/policy'],function (require) {
  var nodes = require('parsenodes');
  var Policy = require('math/policy');

  var latexTrim = function (str) {
    return str.replace(/^( |\\space)+/, '').replace(/( |\\space)+$/, '');
  };

  // Default to graphing nothing.
  nodes.Base.prototype.tableInfo = function (concrete) {
    return false;
  };

  nodes.Identifier.prototype.tableInfo = function (concrete) {
    if (!Policy.graphableAsBareIdentifier(this._symbol)) return false;
    if (!Policy.validFirstColumnVariable(this._symbol)) return false;
    return {
      independent_variable: this._symbol,
      dependent_column: this._inputString,
      by_reference: false
    };
  };

  nodes.Expression.prototype.tableInfo = function (concrete) {
    var dependencies = concrete.getDependencies();

    if (dependencies.length !== 1) return false;
    var independent = dependencies[0];
    if (!Policy.validFirstColumnVariable(independent)) return false;

    return {
      independent_variable: independent,
      dependent_column: this._inputString,
      by_reference: false
    };
  };

  nodes.Assignment.prototype.tableInfo = function (concrete) {
    // concrete is either a SolvedEquation or an Expression.
    if (concrete instanceof nodes.SolvedEquation) return false;
    // Comes up in the case of generated expressions. We won't need to table those anyway.
    if (!this._inputString.length) return false;

    var dependencies = concrete.getDependencies();

    if (dependencies.length > 1) return false;
    var independent;
    if (dependencies.length === 0) {
      if (!Policy.tableableAsConstant(this._symbol)) return false;
      independent = Policy.implicitIndependent(this._symbol);
    } else {
      independent = dependencies[0];
    }

    if (!Policy.validFirstColumnVariable(independent)) return false;

    var dependent = Policy.assignmentForbidden(this._symbol) ?
      latexTrim(this._inputString.replace(/[^=]*=/,'')) :
      latexTrim(this._inputString.split('=')[0])
    ;

    return {
      independent_variable: independent,
      dependent_column: dependent,
      by_reference: !Policy.assignmentForbidden(this._symbol)
    };
  };

  nodes.FunctionDefinition.prototype.tableInfo = function (concrete) {
    if (this._argSymbols.length !== 1) return false;
    // Comes up in the case of generated expressions. We won't need to table those anyway.
    if (!this._inputString.length) return false;

    var dependencies = concrete.getDependencies();

    if (dependencies.length > 1) return false;
    var independent = this._argSymbols[0];
    if (!Policy.validFirstColumnVariable(independent)) return false;

    var assignmentForbidden = Policy.assignmentForbidden(this._symbol);
    var dependent = assignmentForbidden ?
      latexTrim(this._inputString.replace(/[^=]*=/,'')) :
      latexTrim(this._inputString.split('=')[0])
    ;

    return {
      independent_variable: independent,
      // Close to this._symbol, but we want to preserve, e.g., curly brackets in
      // a_{ro}.
      dependent_column: dependent,
      by_reference: !assignmentForbidden
    };
  };

  nodes.BaseComparator.prototype.tableInfo = function (concrete) {
    return false;
  };

  nodes.DoubleInequality.prototype.tableInfo = function (concrete) {
    return false;
  };

  nodes.Equation.prototype.tableInfo = function (concrete) {
    return false;
  };

  nodes.OrderedPair.prototype.tableInfo = function (concrete) {
    var dependencies = concrete.getDependencies();
    if (dependencies.length !== 0) return false;
    if (concrete.isMovablePoint) return false;
    return {
      independent_variable: 'x',
      dependent_column: 'y',
      by_reference: false,
      // TODO, would like to be able to pass full expressions to tables,
      // not just numbers
      values: nodes.List.mapArgs(concrete.args, function (pair) {
        return [+pair[0].constantValue, +pair[1].constantValue];
      })
    };
  };

  nodes.List.prototype.tableInfo = function (concrete) {
    return false;
  };
});
define('math/features/tableerror',['require','parsenodes','lib/worker-i18n'],function (require) {
  var nodes = require('parsenodes');
  var i18n = require('lib/worker-i18n');

  nodes.Base.prototype.tableError = function () {
    if (this.isInequality()) return i18n.t("Inequalities are not allowed.");
    return false;
  };
  nodes.List.prototype.tableError = function () {
    return i18n.t("Lists are not allowed.");
  };
  nodes.OrderedPair.prototype.tableError = function () {
    return i18n.t("Points are not allowed.");
  };
  nodes.Equation.prototype.tableError =
  nodes.Assignment.prototype.tableError = function () {
    return i18n.t("Equations are not allowed.");
  };
  nodes.FunctionDefinition.prototype.tableError = function () {
    return i18n.t("Function definitions are not allowed.");
  };
});
define('math/features/islinear',['require','parsenodes'],function (require) {
  var nodes = require('parsenodes');

  nodes.Base.prototype.isLinear = function (symbol) {
    return false;
  };

  nodes.Expression.prototype.isLinear = function (symbol) {
    return this.polynomialOrder(symbol) <= 1;
  };

  nodes.SolvedEquation.prototype.isLinear = function (symbol) {
    return this._expression.isLinear(symbol);
  };

  nodes.OptimizedRegression.prototype.isLinear = function (symbol) {
    return this.model.isLinear(symbol);
  };

});
define('graphing/columnmode',{
  POINTS: 'POINTS',
  LINES: 'LINES',
  POINTS_AND_LINES: 'POINTS_AND_LINES'
});

define('math/features/graph',['require','parsenodes','math/plotter','graphing/graphmode','math/comparators','graphing/columnmode'],function (require) {
  var nodes = require('parsenodes');
  var Plotter = require('math/plotter');
  var GRAPHMODE = require('graphing/graphmode');
  var Comparators = require('math/comparators');
  var COLUMNMODE = require('graphing/columnmode');
  var List = nodes.List;

  function copyDefinedPOIs (points) {
    var xs = [];
    var ys = [];

    var len = points.length;
    for (var i=0; i<len; i++) {
      xs.push(points[i][0]);
      ys.push(points[i][1]);
    }

    return {
      defined: {x: xs, y: ys}
    };
  }

  nodes.Base.prototype._graph = function (concrete, viewState, graphInfo) {
    if (graphInfo.graphMode === GRAPHMODE.NONE) return false;

    //Compile, pass to plotter, and return
    var fns = concrete.getCompiledFunctions();
    var derivatives;

    // TODO, taking derivatives can throw an error if the nodecount of the
    // tree gets to large. Can just plot without derivatives if we can't
    // compute them. Would be nice to clean this up.
    try {
      derivatives = concrete.getCompiledDerivatives();
    } catch (e) {
      // do nothing
    }

    var branches = [];
    for (var i = 0; i < fns.length; i++) {
      var localGraphInfo;
      if (concrete.isList) {
        localGraphInfo = this.getGraphInfo(concrete.args[i]);
        localGraphInfo.graphMode = graphInfo.graphMode;
      } else {
        localGraphInfo = graphInfo;
      }

      var branch = derivatives ?
        Plotter.computeGraphData(viewState, localGraphInfo, fns[i].fn, derivatives[i].fn) :
        Plotter.computeGraphData(viewState, localGraphInfo, fns[i].fn)
      ;
      branch.compiled = fns[i];
      branches.push(branch);
    }

    return branches;
  };

  nodes.Base.prototype.graph = function (concrete, viewState) {
    var graphInfo = this.getGraphInfo(concrete);
    return this._graph(concrete, viewState, graphInfo);
  };

  nodes.BaseComparator.prototype.graph = function (concrete, viewState) {
    var graphMode = this.getGraphInfo(concrete).graphMode;
    if (graphMode === GRAPHMODE.NONE) return false;
    if (!concrete instanceof nodes.SolvedEquation) return false;

    var operator = this.getOperator();
    //Compile, pass to plotter, and return
    var fns = concrete.getCompiledFunctions();

    var derivatives;
    try {
      derivatives = concrete.getCompiledDerivatives();
    } catch (e) {
      // do nothing
    }

    var branch, i;
    var branches = [];
    var polarities = [ -1, 0, 0, 1 ];

    var nbranches = fns.length;
    for (i = 0; i < nbranches; i++) {
      var graphInfo = this.getGraphInfo(concrete._expression.args[i]);
      graphInfo.graphMode = graphMode;
      branch = derivatives ?
        Plotter.computeGraphData(viewState, graphInfo, fns[i].fn, derivatives[i].fn) :
        Plotter.computeGraphData(viewState, graphInfo, fns[i].fn)
      ;
      branch.compiled = fns[i];
      branch.operator = Comparators.get(
        Comparators.table[operator].inclusive,
        polarities[i % 4]
      );
      branches.push(branch);
    }

    for (i = 0; i < nbranches; i += 4) {
      var polygons = Plotter.polygonsFromSegments(
        branches[i + 1].segments,
        branches[i + 2].segments,
        graphMode
      );
      branches.push({
        graphMode: GRAPHMODE.POLYGONFILL,
        segments: polygons,
        poi:{}
      });
    }

    return branches;
  };

  nodes.DoubleInequality.prototype.graph = function (concrete, viewState) {
    var graphInfo = this.getGraphInfo(concrete);
    if (graphInfo.graphMode === GRAPHMODE.NONE) return false;

    var branches = [];
    var op0 = Comparators.get(Comparators.table[this._operators[0]].inclusive, 0);
    var op1 = Comparators.get(Comparators.table[this._operators[1]].inclusive, 0);

    var userData = this.userData;

    var self = this;
    List.eachArgs(concrete._expressions, function (args) {
      var branch0, branch1;
      args[0].userData = args[1].userData = userData; // TODO ick, prefer nodes to be immutable
      branch0 = self._graph(args[0], viewState, graphInfo)[0];
      branch0.operator = op0;
      branches.push(branch0);
      branch1 = self._graph(args[1], viewState, graphInfo)[0];
      branch1.operator = op1;
      branches.push(branch1);

      var polygons = Plotter.polygonsFromSegments(branch0.segments, branch1.segments, branch0.graphMode);
      branches.push({
        graphMode: GRAPHMODE.POLYGONFILL,
        segments: polygons,
        poi:{}
      });
    });

    return branches;
  };

  nodes.OrderedPair.prototype.graph = function (concrete, viewState) {
    var graphInfo = this.getGraphInfo(concrete);
    var points;
    switch (graphInfo.graphMode) {
      case GRAPHMODE.XYPOINT_MOVABLE:
        points = [[concrete.args[0].constantValue, concrete.args[1].constantValue]];

        return [{
          segments: [points],
          graphMode: graphInfo.graphMode,
          color: this.userData.color,
          style: this.userData.style,
          poi: copyDefinedPOIs(points)
        }];
      case GRAPHMODE.XYPOINT:
        points = [];
        List.eachArgs(concrete.args, function (args) {
          if (isFinite(args[0].constantValue) && isFinite(args[1].constantValue)) {
            points.push([args[0].constantValue, args[1].constantValue]);
          }
        });

        return[{
          segments: [points],
          graphMode: graphInfo.graphMode,
          color: this.userData.color,
          style: this.userData.style,
          poi: copyDefinedPOIs(points)
        }];
      case GRAPHMODE.PARAMETRIC:
        var userData = this.userData;
        var branches = List.mapArgs(concrete.args, function (args) {
          // Handle case that args don't actually depend on t. This can
          // happen for some elements in a parametric with list coordinates,
          // e.g. (1, [t, 2]) has one curve and one point.
          if (args[0].isConstant && args[1].isConstant) {
            var points = [[args[0].constantValue, args[1].constantValue]];
            return {
              segments: [points],
              graphMode: GRAPHMODE.XYPOINT,
              color: userData.color,
              style: userData.style,
              poi: copyDefinedPOIs(points)
            };
          } else {
            var fn1 = args[0].getCompiledFunctions()[0].fn;
            var fn2 = args[1].getCompiledFunctions()[0].fn;
            // TODO modify parametric plotter to work with array of fns instead
            // of an fn that returns an array
            var fn = function (t) {return [fn1(t), fn2(t)];};
            graphInfo.domain = userData.domain;
            return Plotter.computeGraphData(viewState, graphInfo, fn);
          }
        });

        return branches;
      default:
        return false;
    }
  };

  nodes.Regression.prototype.graph = function (concrete, viewState) {
    var graphInfo = this.getGraphInfo(concrete);
    return this._graph(concrete.model, viewState, graphInfo);
  };

  function _flatten (arr) { return Array.prototype.concat.apply([], arr); }

  nodes.Table.prototype.graph = function (concrete, viewState) {
    /* jshint maxcomplexity:13 */
    var graphs = [];

    if (concrete.columns[0].isError) return graphs;
    var firstColumnValues = concrete.columns[0].values;

    for (var i = 1; i < this.columns.length; i++) {
      var column = concrete.columns[i];
      if (column.isError) continue;
      var userData = this.columns[i].header.userData;
      if (userData.hidden) continue;
      var columnMode = userData.columnMode;
      var showPoints = columnMode === COLUMNMODE.POINTS || columnMode === COLUMNMODE.POINTS_AND_LINES;
      var showLine = columnMode === COLUMNMODE.LINES || columnMode === COLUMNMODE.POINTS_AND_LINES;
      //Connect the dots if we're independent numbers, or an externally defined list
      //Draw a smooth line if it's a defined function
      var showDiscreteLine = showLine && column.isDiscrete;
      var showContinuousLine = showLine && !column.isDiscrete;

      var branches = [];
      if (showPoints || showDiscreteLine) {
        var segments = [];
        var thisSegment = [];
        var columnValues = column.values;
        /* jshint loopfunc: true */
        List.eachArgs([firstColumnValues, columnValues], function (args) {
          if (isFinite(args[0].constantValue) && isFinite(args[1].constantValue)) {
            thisSegment.push([args[0].constantValue, args[1].constantValue]);
          } else {
            segments.push(thisSegment);
            thisSegment = [];
          }
        });
        segments.push(thisSegment);
        if (showPoints) {
          branches.push({
            segments: segments,
            graphMode: GRAPHMODE.XYPOINT,
            poi: copyDefinedPOIs(segments),
            color: userData.color,
            style: userData.style
          });
        }
        if (showDiscreteLine) {
          branches.push({
            // flatten segments into format expected by line plotter
            segments: segments.map(_flatten),
            // Using PARAMETRIC instead of Y here is a bit of a hack
            // to keep graph controller from trying to trace, etc.
            graphMode: GRAPHMODE.PARAMETRIC,
            poi: [],
            color: userData.color,
            style: userData.style
          });
        }
      }
      if (showContinuousLine) {
        var continuousBranches = this.columns[i].header.graph(concrete.columns[i].header, viewState);
        if (continuousBranches.length) Array.prototype.push.apply(branches, continuousBranches);
      }

      if (branches.length) graphs[userData.id] = branches;
    }
    return graphs;
  };
});

define('parser',['require','math/baseparser','math/features/repr','math/features/scalarEvalExpression','math/features/okForImplicitFunction','math/features/constantcollapsedcopy','math/features/polynomialorder','math/features/polynomialcoefficients','math/features/extractconditions','math/features/bounddomain','math/features/derivative','math/features/substitute','math/features/solve','math/features/analyze','math/features/getgraphmode','math/features/getgraphinfo','math/features/tableinfo','math/features/tableerror','math/features/islinear','math/features/graph'],function (require) {
  var Parser = require('math/baseparser');

  //Append each types of node with additional features
  require('math/features/repr');
  require('math/features/scalarEvalExpression');
  require('math/features/okForImplicitFunction');
  require('math/features/constantcollapsedcopy');
  require('math/features/polynomialorder');
  require('math/features/polynomialcoefficients');
  require('math/features/extractconditions');
  require('math/features/bounddomain');
  require('math/features/derivative');
  require('math/features/substitute');
  require('math/features/solve');
  require('math/features/analyze');
  require('math/features/getgraphmode');
  require('math/features/getgraphinfo');
  require('math/features/tableinfo');
  require('math/features/tableerror');
  require('math/features/islinear');
  require('math/features/graph');

  return Parser;
});

define('math/finddependencyorder',['require','math/builtinframe','underscore'],function (require) {
  var BuiltInFrame = require('math/builtinframe');
  var _ = require('underscore');
  // Order statements according to their dependencies.
  //
  // Optional 2nd arguments is a list of ids giving the roots to start searching
  // for dependencies from. This is used by the regression pass to only traverse
  // statements that regressions depend on, and to preserve order in case of ties
  // for the purpose of picking good residual variables.
  //
  // Implements Tarjan's algorithm
  //
  // https://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm
  //
  // to topologically sort DAG of strongly connected components of dependency graph.
  // A strongly connected component is a subgraph for which every node can be
  // reached by following directed edges from every other node. Any time we find a
  // strongly connected component with more than one statement in it, that's a
  // cyclic dependency error.
  function findDependencyOrder (statements, roots) {
    /* jshint maxcomplexity:16 */
    var exportLevels = [];
    var assignments = {}; // symbol => [id] of assigners
    var multiplyDefined = {}; // symbol => sentinal
    var cyclicallyDefined = {}; // symbol => [symbols]
    var nodes = {}; // id => { id: #, index: #, lowval: #, error: {}, instack: t/f }
    var index = 0; // Number of nodes reached so far in DFS
    var stack = []; // [node]
    var resolved = []; // [id]
    var id, i, j, symbol, penalty;

    if (!roots) {
      roots = [];
      for (id in statements) {
        if (statements.hasOwnProperty(id)) roots.push(id);
      }
    }

    // Separate statements by export penalty
    for (id in statements) {
      if (!statements.hasOwnProperty(id)) continue;
      penalty = statements[id].exportPenalty || 0;
      while (exportLevels.length < penalty + 1) exportLevels.push([]);
      exportLevels[penalty].push(id);
    }

    for (penalty = 0; penalty < exportLevels.length; penalty++) {
      var levelAssignments = {};
      for (i = 0; i < exportLevels[penalty].length; i++) {
        id = exportLevels[penalty][i];
        var exports = statements[id].getExports();

        // Fill in dictionary of assignments at the current level, skipping
        // symbols that have already been assigned at a lower penalty
        for (j = 0; j < exports.length; j++) {
          symbol = exports[j];
          if (BuiltInFrame[symbol]) continue;
          if (assignments[symbol]) continue;
          levelAssignments[symbol] = levelAssignments[symbol] || [];
          levelAssignments[symbol].push(id);
          if (levelAssignments[symbol].length > 1) multiplyDefined[symbol] = true;
        }
      }
      // Commit assignments from this level to the accumulated assignments
      // dictionary
      for (symbol in levelAssignments) {
        assignments[symbol] = levelAssignments[symbol];
      }
    }

    // Traverse all nodes, finding their strongly connected components.
    // Note that strongConnect calls itself recursively.
    for (i = 0; i < roots.length; i++) {
      if (!nodes.hasOwnProperty(roots[i])) strongConnect(roots[i]);
    }

    function strongConnect(id) {
      nodes[id] = nodes[id] || {};
      var v = nodes[id];
      var w;
      v.id = id;
      v.index = index;
      v.lowlink = index;
      stack.push(v);
      v.instack = true;
      index++;

      var dependencies = statements[id].getDependencies();
      for (var i = 0; i < dependencies.length; i++) {
        var symbol = dependencies[i];
        if (!assignments.hasOwnProperty(symbol)) continue;
        var assigners = assignments[symbol];

        // Visit the dependencies w of v
        for (var j = 0; j < assigners.length; j++) {
          var assigner = assigners[j];
          if (!nodes.hasOwnProperty(assigner)) {
            // assigner has not yet been visited; recurse on it
            strongConnect(assigner);
            w = nodes[assigner];
            v.lowlink = Math.min(v.lowlink, w.lowlink);
          } else {
            w = nodes[assigner];
            // If w is already in the stack, it is part of the SCC of v
            if (w.instack) v.lowlink = Math.min(v.lowlink, w.index);
          }
        }
      }

      // If v is a root node, the current stack is a strongly connected component
      if (v.lowlink === v.index) {
        w = stack.pop();
        w.instack = false;

        if (w === v) {
          markSingle(v);
        } else {
          var scc = [w];
          while (true) {
            w = stack.pop();
            w.instack = false;
            scc.push(w);
            if (w === v) break;
          }
          markCycle(scc);
        }
      }
    }

    function markSingle (v) {
      resolved.push(v.id);
    }

    function markCycle (scc) {
      var cycleSymbols = [];
      var v;
      var i;

      for (i = scc.length - 1; i >= 0; i--) {
        v = scc[i];
        var exports = statements[v.id].getExports();

        // TODO for expressions with multiple exports, does not distinguish between
        // symbols that are and are not involved in the cycle.
        Array.prototype.push.apply(cycleSymbols, exports);

        cycleSymbols.push(exports[0]);
        resolved.push(v.id);
      }

      cycleSymbols = _.unique(cycleSymbols);
      cycleSymbols.sort();

      for (i = 0; i < cycleSymbols.length; i++) {
        cyclicallyDefined[cycleSymbols[i]] = cycleSymbols;
      }
    }

    return {
      resolved: resolved,
      multiplyDefined: multiplyDefined,
      cyclicallyDefined: cyclicallyDefined
    };
  }

  return findDependencyOrder;
});
define('math/context',['require','console','pjs','underscore','./plotter','./poi','parser','math/builtinframe','math/parsenode/constant','math/parsenode/table','math/parsenode/tablecolumn','math/parsenode/freevariable','math/parsenode/list','math/finddependencyorder','math/errormsg','graphing/graphmode'],function(require){
  var console = require('console');
  var P = require('pjs');
  var _ = require('underscore');
  var Plotter = require('./plotter');
  var POI = require('./poi');
  var Parser = require('parser');
  var BuiltInFrame = require('math/builtinframe');
  var Constant = require('math/parsenode/constant');
  var Table = require('math/parsenode/table');
  var TableColumn = require('math/parsenode/tablecolumn');
  var FreeVariable = require('math/parsenode/freevariable');
  var List = require('math/parsenode/list');
  var findDependencyOrder = require('math/finddependencyorder');
  var ErrorMsg = require('math/errormsg');
  var GRAPHMODE = require('graphing/graphmode');

  return P(function(context){

    // callback noop
    context.triggerGraphComputed = function(){};
    context.triggerStatusChange = function(){};
    context.triggerRemoveGraph = function(){};
    context.triggerRender = function(){};
    context.triggerRenderSlowly = function(){};
    context.triggerDidAddStatement = function(){};
    context.triggerDidRemoveStatement = function(){};
    context.triggerDidSetCompleteState = function(){};
    context.triggerDidUpdateIntersections = function () {};

    context.init = function(frame){
      if(!frame) frame = BuiltInFrame;
      // Only trigAngleMultiplier is ever updated in parent_frame
      this.parent_frame = Object.create(frame);
      // statements export definitions to this.frame
      this.frame = Object.create(this.parent_frame);
      this.lastFrame = Object.create(this.parent_frame);
      this.regressionFrame = Object.create(this.parent_frame);
      this.statements = {};    //Each statement should be immutable
      this.analysis = {};    //This can be cleaned out at re-derived each round
      this.currentStatus = {}; //Remember last sent message, so that we only update when necessary
      this.unanalyzedIds = {};
      this.unpublishedIds = {};
      this.intersectIds = {};
    };

    context.processChangeSet = function (changeSet) {
      /* jshint maxcomplexity:44 */
      var ids, triggerRender;

      if (changeSet.isCompleteState) {
        this.invalidate();
        this.statements = {};
      }

      // update the viewport
      if (changeSet.viewState) {
        this.setViewState(changeSet.viewState);
      }

      // update degree mode
      if (changeSet.hasOwnProperty('degreeMode')) {
        this.setDegreeMode(changeSet.degreeMode);
      }

      // change which expressions 'intersectId' attempts to intersect with
      if (changeSet.hasOwnProperty('intersectIds')) {
        this.intersectIds = changeSet.intersectIds;
      }

      if (changeSet.statements) {
        for (var id in changeSet.statements) {
          var statement = changeSet.statements[id];

          // remove the statement if it is null
          if (statement === null) {
            if (!changeSet.isCompleteState && this.statements.hasOwnProperty(id)) {
              ids = this.statements[id].getAllIds();
            }

            this.removeStatement(id);

            if (!changeSet.isCompleteState && ids) {
              for (var i = 0; i < ids.length; i++) {
                this.triggerRemoveGraph(ids[i]);
              }
              this.triggerDidRemoveStatement(id);
            }
          } else {
            this.addStatement(statement);

            if (!changeSet.isCompleteState) {
              this.triggerDidAddStatement(statement);
            }
          }
        }
      }

      if (changeSet.isCompleteState) {
        this.triggerDidSetCompleteState(changeSet.statements);

        //Temporarily use slow rendering callback
        //TODO - handle renderSlowly via some other mechanism.
        triggerRender = this.triggerRender;
        this.triggerRender = this.triggerRenderSlowly;
      }

      this.updateAnalysis();

      if (changeSet.hasOwnProperty('intersectId')) this._updateIntersections(changeSet.intersectId);

      this.publishChanges();

      if (changeSet.isCompleteState) {
        this.triggerRender = triggerRender;
      }
    };

    context.setViewState = function (viewState) {
      if (_.isEqual(viewState, this.viewState)) return;
      this.viewState = viewState;
      for (var id in this.statements) {
        if (!this.statements.hasOwnProperty(id)) continue;
        this.unpublishedIds[id] = true;
      }
    };

    context.getViewState = function () {
      if (!this.viewState) return;
      // Hack to smuggle trigAngleMultiplier into viewState while allowing these to be
      // set separately by external calls.
      var localViewState = Object.create(this.viewState);
      if (this.parent_frame && this.parent_frame.trigAngleMultiplier) {
        localViewState.trigAngleMultiplier = this.parent_frame.trigAngleMultiplier.constantValue;
      } else {
        localViewState.trigAngleMultiplier = 1.0;
      }
      return localViewState;
    };

    context.setDegreeMode = function(use_degrees) {
      this.parent_frame.trigAngleMultiplier = Constant(use_degrees ? Math.PI / 180 : 1);
      this.invalidate();
    };

    context.publishChanges = function(){
      this.updateAnalysis();
      this._publishAllStatuses();
      this._graphAllChanged();
      this.unpublishedIds = {};
    };

    // `_publishAllStatuses`, `_graphAllChanged`, and `_updateIntersections`
    // use `this.analysis`, and so expect it to be up to date, i.e. no statements
    // should have been added or removed since `this.updateAnalysis()` was called.
    //
    context._publishAllStatuses = function(){
      //Compute new states, but only send them out if they're different from what we sent last time
      var changes = {};
      var lastStatus = this.currentStatus;
      this.currentStatus = {};

      for (var id in this.unpublishedIds) {
        if (!this.analysis.hasOwnProperty(id)) continue;
        var newState = this.analysis[id].evaluationState;
        if (JSON.stringify(newState) !== JSON.stringify(lastStatus[id])) {
          changes[id] = newState;
        }
        this.currentStatus[id] = newState;
      }

      this.triggerStatusChange(changes);
    };

    context._graphAllChanged = function(){
      /* jshint maxcomplexity:13 */
      var viewState = this.getViewState();
      if (!Plotter.validateViewState(viewState)) return;

      for (var id in this.unpublishedIds) {
        if (!this.analysis.hasOwnProperty(id)) continue;
        var analysis = this.analysis[id];
        if (analysis.rawTree.isTable) {
          var graphs = analysis.graph(viewState);
          var columnIds = analysis.rawTree.getAllIds();
          for (var i = 0; i < columnIds.length; i++) {
            if (graphs[columnIds[i]]) {
              this.triggerGraphComputed(columnIds[i], graphs[columnIds[i]]);
            } else {
              this.triggerRemoveGraph(columnIds[i]);
            }
          }
        } else if (analysis.evaluationState.is_graphable && analysis.rawTree.userData.shouldGraph) {
          this.triggerGraphComputed(id, analysis.graph(viewState));
          if (this.intersectIds.hasOwnProperty(id)) this._updateIntersections(id);
        } else {
          this.triggerRemoveGraph(id); //TODO - removing evaluable things every cycle
        }
      }

      // Recompute all visible intersections for curves that weren't regraphed.
      // Curves that were regraphed already had their intersections updated in
      // the graph routine. Need to do this because we're only keeping track of
      // one partner in an intersection, and the other partner might have
      // changed.
      if (_.keys(this.unpublishedIds).length) {
        for (var intersectId in this.intersectIds) {
          if (this.unpublishedIds.hasOwnProperty(intersectId)) continue;
          if (this.intersectIds.hasOwnProperty(intersectId)) this._updateIntersections(intersectId);
        }
      }

      this.triggerRender();
    };

    // Find all intersections between a curve with the given id and other
    // curves.
    context._updateIntersections = function (id) {
      if (!this.viewState) return;
      var analysis = this.analysis[id];

      if (!analysis || !analysis.shouldIntersect()) {
        this.triggerDidUpdateIntersections(id, []);
        return;
      }

      this.findSomeIntersectionsWith(id).streamRest();
    };

    // context.findSomeIntersectionsWith computes as many intersections with the
    // curve with given id as it can in 20 ms and then returns an object:
    // {
    //   intersections: // Intersections found so far
    //   streamRest: // Function that will stream the rest of the intersections
    //               // back to the grapher.
    // }
    //
    // We run a different timeout for every curve id that is having
    // having intersections computed on it so that we can start computing
    // intersections with a few curves at once without having them cancel
    // eachother. This will happen if you open intersections on a few different
    // curves and then change something that triggers a graphAll.
    //
    // Note that we typically only stick the intersection POI on one of the two
    // curves that is involved in an intersection (the one that was selected
    // when the intersection was computed).
    var streamIntersectionsTimeouts = {};
    context.findSomeIntersectionsWith = function (id1) {
      this.cancelIntersectionStreaming(id1);
      var runFor = 20; // ms
      var waitFor = 60; // ms
      var self = this;
      var push = Array.prototype.push;
      var viewState = this.getViewState();
      var analysis1 = self.analysis[id1];
      var graphInfo = analysis1.getGraphInfo();
      var graphMode = graphInfo.graphMode;
      var compiled1 = analysis1.concreteTree.getCompiledFunctions();

      var otherAnalyses = [];
      for (var id2 in self.analysis) {
        if (!self.analysis.hasOwnProperty(id2)) continue;
        if (String(id2) === String(id1)) continue;
        if (!self.analysis[id2].shouldIntersect()) continue;
        otherAnalyses.push(self.analysis[id2]);
      }

      // intersections accumulator and iterator i are modified during successive
      // calls to computeSome()
      var intersections = [];
      for (var branch = 0; branch < compiled1.length; branch++) {
        intersections[branch] = { x: [], y: [], intersects: [] };
      }
      var i = otherAnalyses.length - 1;
      var stream = false;
      var computeSome = function () {
        /* jshint maxcomplexity:14 */
        /* jshint loopfunc: true */
        var now = new Date();
        var updated = false;
        var fn1;
        var fn2;
        var newIntersections;
        var analysis2, graphMode2, compiled2;
        var swap;
        var indicatorSamples;
        var domain;
        for (i; i >= 0; i--) {
          if (new Date() - now > runFor) {
            if (!stream) return;
            streamIntersectionsTimeouts[id1] = setTimeout(computeSome, waitFor);
            if (!updated) return;
            self.triggerDidUpdateIntersections(id1, intersections);
            return;
          }
          analysis2 = otherAnalyses[i];
          graphMode2 = analysis2.getGraphInfo().graphMode;

          var modesxx = graphMode === GRAPHMODE.X && graphMode2 === GRAPHMODE.X;
          var modesyy = graphMode === GRAPHMODE.Y && graphMode2 === GRAPHMODE.Y;
          var modesxy = graphMode === GRAPHMODE.X && graphMode2 === GRAPHMODE.Y;
          var modesyx = graphMode === GRAPHMODE.Y && graphMode2 === GRAPHMODE.X;
          // Currently only intersect x and y graphs
          if (!(modesxx || modesyy || modesxy || modesyx)) continue;

          compiled2 = analysis2.concreteTree.getCompiledFunctions();

          for (var branch1=0; branch1 < compiled1.length; branch1++) {
            fn1 = compiled1[branch1].fn;
            domain = Plotter.computeDomain(viewState, graphInfo, fn1);
            for (var branch2 = 0; branch2 < compiled2.length; branch2++) {
              fn2 = compiled2[branch2].fn;

              var indicatorFn;
              if (modesxx || modesyy) {
                indicatorFn = function (x) { return fn2(x) - fn1(x); };
              } else if (modesxy || modesyx) {
                indicatorFn = function (x) { return x - fn2(fn1(x)); };
              } else {
                continue;
              }
              indicatorSamples = Plotter.sampleXY(indicatorFn, domain).segments;
              newIntersections = POI.findIntersections(
                indicatorSamples,
                fn1,
                indicatorFn
              );
              if (newIntersections.x.length) updated = true;
              newIntersections.intersects = Array(newIntersections.x.length);
              for (var j = 0, jlen = newIntersections.x.length; j < jlen; j++) {
                newIntersections.intersects[j] = analysis2.id;
              }
              // Need to swap x and y if graphmode is GRAPHMODE.X
              if (graphMode === GRAPHMODE.X) {
                swap = newIntersections.y;
                newIntersections.y = newIntersections.x;
                newIntersections.x = swap;
              }
              push.apply(intersections[branch1].x, newIntersections.x);
              push.apply(intersections[branch1].y, newIntersections.y);
              push.apply(intersections[branch1].intersects, newIntersections.intersects);
            }
          }
        }

        if (!stream || !updated) return;
        self.triggerDidUpdateIntersections(id1, intersections);
        self.cancelIntersectionStreaming(id1);
      };

      computeSome();

      return {
        intersections: intersections,
        streamRest: function () {
          // Slightly wasteful, but handy for clearing old intersections early.
          self.triggerDidUpdateIntersections(id1, intersections);
          stream = true;
          computeSome();
        }
      };
    };

    context.cancelIntersectionStreaming = function (id) {
      clearTimeout(streamIntersectionsTimeouts[id]);
      delete streamIntersectionsTimeouts[id];
    };

    //Takes a object representing a statement
    //Expects statement to have properties:
    // * id (integer)
    // * latex (string)
    // * shouldGraph (boolean)
    // * color (string)
    context.addStatement = function(statement){
      if(!statement) return;
      var id = statement.id;
      this.markDirty(id); // Mark existing dependencies as dirty

      if (statement.type === 'table') {
        var previousIds = [];  //Used to tell tables to ungraph old columns

        if (this.statements.hasOwnProperty(id)) previousIds = this.statements[id].getAllIds();

        statement.shouldGraph = true; // TODO hack

        var columns = statement.columns;
        var parsedColumns = [];
        var header, values, parsedColumn;

        var maxLength = 0;
        for (var n = 0; n < columns.length; n++) {
          maxLength = Math.max(columns[n].values.length, maxLength);
        }

        for (var i = 0; i < columns.length; i++) {
          header = Parser.parse(columns[i].latex);
          values = [];
          var lastNonEmptyIndex = 0;
          for (var j = 0; j < columns[i].values.length; j++) {
            if (columns[i].values[j].replace(/\\space/g, '').match(/\S/)) {
              values.push(Parser.parse(columns[i].values[j]));
              lastNonEmptyIndex = j;
            } else {
              // Parse blank entries as NaN
              values.push(Constant(NaN));
            }
          }
          values.splice(lastNonEmptyIndex + 1);
          parsedColumn = TableColumn(header, maxLength, List(values));
          parsedColumn.id = columns[i].id;
          // Hang onto things like color, style, and columnMode
          if (parsedColumn.header) parsedColumn.header.userData = columns[i];
          parsedColumns.push(parsedColumn);
        }

        this.statements[id] = Table(parsedColumns);

        // NOTE: quadratic algorithm; assuming you can't have that many table columns
        var self = this;
        var currentIds = this.statements[id].getAllIds();
        previousIds.forEach(function (id) {
          if (currentIds.indexOf(id) === -1) self.triggerRemoveGraph(id);
        });
      } else {
        this.statements[id] = Parser.parse(statement.latex);
      }

      this.statements[id].userData = statement; //Hold on to domain, color, etc.

      // Need to mark clean before marking dirty again because otherwise we'll
      // hit an early return and fail to mark new dependencies dirty.
      this.markClean(statement.id);
      this.markDirty(statement.id); // Mark any new dependencies as dirty
    };

    context.removeStatement = function(id){
      if(!this.statements.hasOwnProperty(id)) return;
      // Looks like it was already deleted.
      // This happens when a table is deleted, and then each column is deleted.
      var statement = this.statements[id];

      this.markDirty(id); //Mark dirty before deletion
      if (statement.isTable) {
        var self = this;
        statement.getAllIds().forEach(function (id) { self.triggerRemoveGraph(id); });
      } else {
        this.triggerRemoveGraph(id); //TODO - removes even if it wasn't graphed
      }

      delete this.statements[id];
    };

    context.invalidate = function(){
      for (var id in this.statements) {
        if (this.statements.hasOwnProperty(id)) this.markDirty(id);
      }
      this.currentStatus = {};
      // TODO too conservative.
      this.frame = Object.create(this.parent_frame);
      this.regressionFrame = Object.create(this.parent_frame);
    };

    context.markDirty = function(id){
      if (!this.statements[id]) return;
      if (this.unanalyzedIds[id]) return;

      this.unanalyzedIds[id] = true;
      this.unpublishedIds[id] = true;
      delete this.analysis[id];

      var statement = this.statements[id];

      var symbols = statement.getExports();
      for (var i = 0; i < symbols.length; i++) {
        this.markSymbolDirty(symbols[i]);
      }

      if (statement.isRegression) {
        // TODO too conservative. Problem with regressions is that we need to
        // mark their (recursive) dependencies dirty as well as their exports,
        // since they might export any of their recursive dependencies.
        //
        // Note, when this is fixed, don't forget to mark residualVariable dirty
        // too.
        this.invalidate();
      }

      this.cancelIntersectionStreaming(id);
    };

    context.markSymbolDirty = function (symbol) {
      delete this.frame[symbol];
      delete this.regressionFrame[symbol];
      for (var id in this.statements) {
        if (!this.statements.hasOwnProperty(id)) continue;
        if (this.statements[id].dependsOn(symbol)) this.markDirty(id);
        if (this.statements[id].exportsSymbol(symbol)) this.markDirty(id);
      }
    };

    context.markClean = function(id){
      delete this.unanalyzedIds[id];
    };

    context.getFrame = function(){
      this.updateAnalysis();
      return this.frame;
    };

    context.getAnalysis = function(){
      this.updateAnalysis();
      return this.analysis;
    };

    context.getStatus = function(id){
      this.updateAnalysis();
      if (!this.analysis[id]) return undefined;
      return this.analysis[id].status;
    };

    //Returns an object that mirrors the API of Formula
    context.getEvaluationState = function(id){
      this.updateAnalysis();
      if (!this.analysis[id]) return undefined;
      return this.analysis[id].evaluationState;
    };

    function exportErrors(dependencyOrder, frame) {
      var multiplyDefined = dependencyOrder.multiplyDefined;
      var cyclicallyDefined = dependencyOrder.cyclicallyDefined;

      var symbol;
      for (symbol in multiplyDefined) {
        if (!multiplyDefined.hasOwnProperty(symbol)) continue;
        frame[symbol] = ErrorMsg.multiplyDefined(symbol);
      }
      for (symbol in cyclicallyDefined) {
        if (!cyclicallyDefined.hasOwnProperty(symbol)) continue;
        frame[symbol] = ErrorMsg.cycle(cyclicallyDefined[symbol]);
      }
    }

    context._updateRegressions = function (dirtyStatements) {
      var frame = this.frame;
      var lastFrame = this.lastFrame;
      var regressionFrame = this.regressionFrame;

      var id;

      // In this pass, we are only interested in statements that dirty regressions
      // depend on.
      var roots = [];
      for (id in dirtyStatements) {
        if (!dirtyStatements.hasOwnProperty(id)) continue;
        if (dirtyStatements[id].isRegression) roots.push(id);
      }

      // Prefer to process regressions that already have a residualVariable first.
      var self = this;
      roots.sort(function (a, b) {
        var aHasResidual = self.statements[a].userData && self.statements[a].userData.residualVariable;
        var bHasResidual = self.statements[b].userData && self.statements[b].userData.residualVariable;

        if (aHasResidual && !bHasResidual) return -1;
        if (bHasResidual && !aHasResidual) return 1;
        return 0;
      });

      // Walk through statements in dependencyOrder populating the regression frame, and then
      // run the regressions.
      var dependencyOrder = findDependencyOrder(dirtyStatements, roots);
      exportErrors(dependencyOrder, regressionFrame);
      var resolved = dependencyOrder.resolved;
      // TODO this is needed for determining whether we can add a regression plot suggestion,
      // but it isn't a full "analysis" because its members don't have evaluation states.
      var regressionAnalysis = {};

      for (var i = 0; i < resolved.length; i++) {
        id = resolved[i];

        if (this.statements[id].isRegression) {
          // Also pass frame to allow regression to pick a residual variable
          this.analysis[id] = dirtyStatements[id].analyze(
            regressionFrame,
            frame,
            lastFrame,
            regressionAnalysis
          );
          this.analysis[id].exportTo(frame);
          delete dirtyStatements[id];
        } else {
          // TODO not clear if it is sound to just call getConcreteTree here, or if
          // we need to run more of analyze. Only expect to run into assignments,
          // function definitions, and tables/table columns here. Don't want to throw
          // tooManyVariable errors here like we normally would in analyze.
          //
          //  Definitely not working on tables right now because they don't implement
          //  getConcreteTree yet. They probably should.
          var concrete = dirtyStatements[id].tryGetConcreteTree(regressionFrame);
          dirtyStatements[id].exportTo(concrete, regressionFrame);
          regressionAnalysis[id] = {rawTree: dirtyStatements[id], concreteTree: concrete};
        }
      }
    };

    context.updateAnalysis = function(){
      var id;
      var dirtyStatements = {};
      for (id in this.unanalyzedIds) {
        if (this.unanalyzedIds.hasOwnProperty(id) && this.statements[id]) {
          dirtyStatements[id] = this.statements[id];
        }
      }

      // Note: mutates dirtyStatements to remove regressions
      this._updateRegressions(dirtyStatements);

      var analysis = this.analysis;
      var frame = this.frame;

      // _updateRegressions has already taken care of analyzing regressions and
      // exporting regressed parameters to the frame. Now analyze all other
      // statements.
      var dependencyOrder = findDependencyOrder(dirtyStatements);
      exportErrors(dependencyOrder, frame);
      var resolved = dependencyOrder.resolved;

      for (var i = 0; i < resolved.length; i++) {
        id = resolved[i];

        // Special handling when 'r' is in the frame. First, check if the statement
        // is graphable as a polar equation with r removed from the frame. If not,
        // use the full frame.
        if (frame.r) {
          var localFrame = Object.create(frame, {r: FreeVariable('r')});
          analysis[id] = this.statements[id].analyze(localFrame, analysis);
          if (analysis[id].getGraphMode() === GRAPHMODE.POLAR) {
            analysis[id].exportTo(frame);
            continue;
          }
        }

        //Pass in previous analysis to allow populating movable points
        analysis[id] = this.statements[id].analyze(frame, analysis);
        analysis[id].exportTo(frame, dependencyOrder);
      }

      this.unanalyzedIds = {};
      this.lastFrame = Object.create(this.parent_frame);
      for (var symbol in frame) {
        if (frame.hasOwnProperty(symbol)) this.lastFrame[symbol] = frame[symbol];
      }
    };

    //Below this point, these are shims for compatibility with existing tests
    //TODO - remove these and re-factor tests
    context.evaluateOnce = function(id){
      console.log("Deprecated console.evaluateOnce - this should not run in production code");
      return this.analysis[id].concreteTree.constantValue;
    };

    context.compile = function(id){
      console.log("Deprecated console.compile - this should not run in production code");
      var compiled = this.analysis[id].concreteTree.getCompiledFunctions();
      if(compiled.length === 1) return compiled[0];
      return compiled;
    };

    context.evalStrings = function(id){
      console.log("Deprecated console.evalStrings - this should not run in production code");
      return this.analysis[id].concreteTree.getEvalStrings();
    };
  });
});

define('worker/workercore',['require','math/context','math/functions'],function(require){
  var EvaluatorContext = require('math/context');
  var Functions = require('math/functions');

  return function(sendMessage){

    //Initialize environment
    var context = EvaluatorContext(); //TODO - pass in frame

    //Functions to send data back to main thread
    context.triggerGraphComputed = function(id, data) {
      Functions.dehydrateGraphData(data);
      sendMessage('graphComputed', {id:id, graphData:data});
    };

    context.triggerDidUpdateIntersections = function(id, intersections) {
      sendMessage('updateIntersections', {id:id, intersections:intersections});
    };

    context.triggerRender = function(){
      sendMessage('render');
    };

    context.triggerRenderSlowly = function(){
      sendMessage('renderSlowly');
    };

    context.triggerRemoveGraph = function(id){
      sendMessage('removeGraph', id);
    };

    context.triggerStatusChange = function(data){
      sendMessage('statusChange', data);
    };

    return {
      processChangeSet: function (changeSet) {
        context.processChangeSet(changeSet);

        sendMessage('processChangeSet', changeSet);
      }
    };

  };

});

define('worker/fakeworker',['require','worker/workercore'],function(require){
  var WorkerCore = require('worker/workercore');

  return function(messageListener){
    var fakeWorker = {};
    var workerCore = WorkerCore(sendMessage);

    //Handle message from worker to UI thread
    function sendMessage(type, payload){
      messageListener({type:type, payload:payload});
    }

    //Handle messages from UI thread to worker
    fakeWorker.postMessage = function(e){
      setTimeout(function(){
        workerCore.processChangeSet(e);
      }, 0);
    };

    return fakeWorker;
  };
});

define('worker/workerpool',['require','console','api/cross_origin_worker','pjs','underscore_model','./fakeworker','underscore'],function(require){
  var console = require('console');
  var CrossOriginWorkerURL = require('api/cross_origin_worker');
  var P = require('pjs');
  var UnderscoreModel = require('underscore_model');
  var FakeWorker = require('./fakeworker');
  var _ = require('underscore');

  var WorkerPool = P(UnderscoreModel, function (pool, _super) {
    pool.init = function (workerPath, maxWorkers) {
      _super.init.call(this);

      this.workers = [];
      this.maxWorkers = maxWorkers;
      this.workerPath = workerPath;

      this.crossOriginWorkerURL = CrossOriginWorkerURL(this.workerPath);

      if (this.allowedToSpawnWorker()) {
        console.log('WorkerPool: allowed to use ' + this.maxWorkers + ' workers.');
      } else {
        console.log('WorkerPool: will not try to use workers');
      }
    };

    pool.allowedToSpawnWorker = function () {
      return this.crossOriginWorkerURL && this.workers.length < this.maxWorkers;
    };

    pool.killWorker = function (worker) {
      var workerIndex = _.indexOf(this.workers, worker);
      if ( workerIndex !== -1) {
        console.log("terminated worker " + (workerIndex + 1) + " of " + this.workers.length);
        worker.terminate();
        this.workers = _.without(this.workers, worker);

        // the evaluators respond to onWorkerKilled() by resending the last unfinished job
        // back into the worker pool. Sending the jobs back in the same order
        // will starve any jobs after the long-running one. We randomize the order we
        // tell the evaluators to prevent starvation.
        _.shuffle(_.values(worker.__connections)).forEach(function (connection) {
          if (connection && connection.onWorkerKilled) {
            connection.onWorkerKilled();
          }
        });
      }
    };

    pool.spawnWorker = function () {
      try {
        var worker = new Worker(this.crossOriginWorkerURL);
        worker.__connections = {};
        worker.__isFake = false;
        worker.onerror = function (evt) {console.log(evt)};
        worker.addEventListener('message', function (e) {
          var data = e.data;
          if (data && data.log) {
          console.log('worker log: ', JSON.parse(data.log));
            return;
          }
          if (data && data.connectionId) {
            var connection = worker.__connections[data.connectionId];
            if (connection) {
              connection.onResponse(data.originalMessage);
            }
          }
        });

        this.workers.push(worker);
        console.log('spawned worker ' + this.workers.length + " of " + this.workers.length);
        return worker;
      } catch (e) {
        // Fallback when we can't support real workers. Can happen if
        // 1. window.Worker does not exist (IE < 10)
        // 2. We're working cross domain and the browser can't build Blobs.
        //    (for the API; all versions of IE I've been able to test)
        console.log(e.message);
        console.log('failed to spawn worker ' + (this.workers.length + 1) + " of " + (this.workers.length + 1));
        return null;
      }
    };

    pool.spawnFakeWorker = function () {
      console.log("spawning fake worker");
      var worker = FakeWorker(function (data) {
        // a FakeWorker will only have a single connection. Send the message there.
        _.values(worker.__connections)[0].onResponse(data);
      });
      worker.__isFake = true;
      worker.__connections = {};
      return worker;
    };

    pool.findLeastUsedWorker = function () {
      var countConnectionsToWorker = function (worker) {
        return _.size(worker.__connections);
      };

      var worker = _.sortBy(this.workers, countConnectionsToWorker)[0];
      if (worker) {
        console.log('reusing worker ' + (_.indexOf(this.workers, worker) + 1) + ' of ' + this.workers.length);
      }
      return worker;
    };

    // pick the worker with the fewest connections.
    pool.allocateWorker = function () {
      var worker = null;

      // try to spawn a worker if we're allowed to. The spawn may fail, but we'll
      // recover by either reusing an existing worker or by resorting to a fake worker.
      if (this.allowedToSpawnWorker()) {
        worker = this.spawnWorker();
      }

      // we didn't create a worker last step. So let's find the least used worker.
      if (!worker) {
        worker = this.findLeastUsedWorker();
      }

      // we can't re-use an already created worker. Let's spawn a fake worker.
      if (!worker) {
        worker = this.spawnFakeWorker();
      }
      return worker;
    };

  });

  return WorkerPool;
});

define('worker/workerpoolconnection',['require','pjs','underscore_model'],function(require){
  var P = require('pjs');
  var UnderscoreModel = require('underscore_model');

  var WorkerPoolConnection = P(UnderscoreModel, function (connection, _super) {
    connection.init = function (workerPool) {
      _super.init.call(this);

      this.workerPool = workerPool;

      // get a worker and allow the worker to lookup this connection
      this.worker = workerPool.allocateWorker();
      this.worker.__connections[this.guid] = this;
    };

    connection.killWorker = function () {
      if (!this.worker.__isFake) {
        this.workerPool.killWorker(this.worker);
      }
    };

    // to be overriden by the owner of the connection
    connection.onWorkerKilled = function () {};

    // to be overriden by the owner of the connection
    connection.onResponse = function (data) {};

    connection.sendMessage = function (data) {
      if (this.worker.__isFake) {
        this.worker.postMessage(data);
      } else {
        this.worker.postMessage({connectionId: this.guid, originalMessage: data});
      }
    };
  });

  return WorkerPoolConnection;
});
define('main/evaluator',['require','pjs','math/functions','worker/workerpool','worker/workerpoolconnection'],function (require) {
  var P = require('pjs');
  //var BuiltInFrame = require('math/builtinframe');
  var Functions = require('math/functions');
  var WorkerPool = require('worker/workerpool');
  var WorkerPoolConnection = require('worker/workerpoolconnection');

  var cloneJSON = function (json) {
    if (json === undefined) return undefined;
    return JSON.parse(JSON.stringify(json));
  };

  var KILL_WORKER_TIME = 4000;

var Evaluator = P(function (evaluator) {

  // Overwritten in calc.js
  evaluator.triggerStatusChange = function (changes) {};
  evaluator.triggerRemove = function (id) {};
  evaluator.triggerGraphComputed = function (id, graphData) {};
  evaluator.triggerUpdateIntersections = function (id, intersections) {};
  evaluator.triggerRender = function () {};
  evaluator.triggerRenderSlowly = function () {};

  evaluator.init = function (workerPool) {
    this.__state = {};
    this.changeSet = null;
    this.cumulativeChangeSet = {};
    this.clearJobTimer();
    this.syncId = 1;
    this.processingDisabled = false;

    if (!workerPool) {
      workerPool = WorkerPool();
    }

    this.workerPool = workerPool;
    this.createWorkerPoolConnection();

    this.syncRequests = [];
  };

  evaluator.createWorkerPoolConnection = function () {
    if (this.workerPoolConnection) {
      this.workerPoolConnection.onResponse = function () {};
      this.workerPoolConnection.onWorkerKilled = function () {};
    }

    this.workerPoolConnection = WorkerPoolConnection(this.workerPool);

    var self = this;
    this.workerPoolConnection.onResponse = function (data) {
      self.listeners[data.type].call(self, data.payload);
    };

    this.workerPoolConnection.onWorkerKilled = function () {
      // create another connection
      self.createWorkerPoolConnection();

      // we were trying to do a job and the worker was killed.
      // Send the job back in.
      if (self.hasJobInWorker()) {
        self.changeSet = cloneJSON(self.cumulativeChangeSet);
        self.__state.changed = true;
        self.__state.droppedMessage = true;
        self.clearJobTimer(); // we had a job in there, but it's wiped out
      }

      // we did not have a job in the worker, but the worker has lost all
      // of our state. We must send our entire state back in the next time
      // that we add a change to the changeSet. Wait for a change.
      else {
        self.changeSet = cloneJSON(self.cumulativeChangeSet);
        self.__state.changed = false;
      }

      self.processChangeSet();
    };
  };

  evaluator.listeners = {};

  evaluator.listeners.processChangeSet = function (changeSet) {
    var syncId = changeSet.syncId;

    // find all waiting sync ids <= syncId and call callback
    while (this.syncRequests.length && this.syncRequests[0].id <= syncId) {
      var syncRequest = this.syncRequests.shift();
      syncRequest.callback();
    }

    this.__state.droppedMessage = false;

    // try to send another job in
    this.clearJobTimer();
    this.processChangeSet();
  };

  evaluator.listeners.removeGraph = function (id) {
    this.triggerRemove(id);
  };

  evaluator.listeners.graphComputed = function (payload) {
    Functions.rehydrateGraphData(payload.graphData);
    this.triggerGraphComputed(payload.id, payload.graphData);
  };

  evaluator.listeners.updateIntersections = function (payload) {
    this.triggerUpdateIntersections(payload.id, payload.intersections);
  };

  evaluator.listeners.statusChange = function (changes) {
    //Updates to status of expression-list items
    this.triggerStatusChange(changes);
  };

  evaluator.listeners.render = function () {
    this.triggerRender();
  };

  evaluator.listeners.renderSlowly = function () {
    this.triggerRenderSlowly();
  };

  evaluator._disableProcessing = function () {
    this.processingDisabled = true;
  };

  evaluator._enableProcessing = function () {
    this.processingDisabled = false;
    this.processChangeSet();
  };

  // Allows multiple messages to be pushed onto a changeset without
  // intermediate processing.
  evaluator.batch = function (fn) {
    var alreadyDisabled = this.processingDisabled;
    this._disableProcessing();
    try{
      fn();
    }
    finally{
      // Want to make sure that if calls to evaluator.batch are nested, only the
      // outermost call reenables processing.
      if (!alreadyDisabled) this._enableProcessing();
    }
  };

  evaluator.clearJobTimer = function () {
    this.__jobStartTime = -1;
  };

  evaluator.startJobTimer = function () {
    this.__jobStartTime = new Date().getTime();
  };

  evaluator.hasJobInWorker = function () {
    return this.__jobStartTime !== -1;
  };

  evaluator.getJobElapsedTime = function () {
    if (this.hasJobInWorker()) {
      return new Date().getTime() - this.__jobStartTime;
    } else {
      return NaN;
    }
  };

  //Set up outgoing communication to worker
  evaluator.processChangeSet = function(){
    if (this.processingDisabled) return;
    var previousJobIsLongRunning = this.getJobElapsedTime() >= KILL_WORKER_TIME;

    // after dropping a message don't wait forever for your job to finish. Kill the
    // worker again to get the job attempted again.
    if (this.__state.droppedMessage && previousJobIsLongRunning) {
      this.workerPoolConnection.killWorker();
      return;
    }

    if (this.__state.changed && this.changeSet) {
      if (this.changeSet.isCompleteState && previousJobIsLongRunning) {
        this.workerPoolConnection.killWorker();
      } else if (!this.hasJobInWorker()) {
        var changeSet = this.changeSet;
        this.changeSet = null;
        this.__state.changed = false;
        this.startJobTimer();
        this.workerPoolConnection.sendMessage(changeSet);
      } else {
        // there is a job in the worker. Don't send another job in.
      }
    }

  };

  // Utility for applying changes to both the current change set and the cumulative
  // change set.
  //
  // Calls the passed function with this.changeSet, then this.cumulativeChangeSet, then
  // calls processChangeSet.
  evaluator.applyToChangeSets = function (fn) {
    this.__state.changed = true;
    if (!this.changeSet) this.changeSet = {};
    if (!this.cumulativeChangeSet) this.cumulativeChangeSet = {};
    var self = this;
    this.batch(function () {
      fn(self.changeSet);
      fn(self.cumulativeChangeSet);
      self.processChangeSet();
    });
  };

  evaluator.setViewState = function (viewState) {
    this.applyToChangeSets(function (changeSet) {
      changeSet.viewState = cloneJSON(viewState);
    });
  };

  // the evaluator has no way of telling the difference between a completely new
  // state and a state where a bunch of stuff was both deleted and added. We explicitly
  // tell it here. The only reason it matters is that if we're doing a completely new state
  // we're free to kill the worker and start fresh. That can get us out of a long running computation
  // or an errored worker that stops responding.
  evaluator.markAsCompleteState = function () {
    this.applyToChangeSets(function (changeSet) {
      changeSet.isCompleteState = true;
    });
  };

  //Takes a object representing an "expression" (TODO - rename this concept)
  //Expects expr to have properties:
  // * id (integer)
  // * latex (string)
  // * shouldGraph (boolean)
  // * color (string)
  evaluator.addStatement = function (statement) {
    this.applyToChangeSets(function (changeSet) {
      if (!changeSet.statements) changeSet.statements = {};
      changeSet.statements[statement.id] = cloneJSON(statement);
    });
  };

  evaluator.addStatements = function (statements) {
    var self = this;
    this.batch(function () {
      for (var i=0; i < statements.length; i++) {
        self.addStatement(statements[i]);
      }
    });
  };

  evaluator.removeStatement = function (id) {
    this.applyToChangeSets(function (changeSet) {
      if (!changeSet.statements) changeSet.statements = {};
      // Use _ = null instead of delete _ because we need to communicate
      // to the worker that if the statement was present before, it
      // should be removed.
      changeSet.statements[id] = null;
    });
  };

  evaluator.removeStatements = function (ids) {
    var self = this;
    this.batch(function () {
      for (var i = 0; i < ids.length; i++) {
        self.removeStatement(ids[i]);
      }
    });
  };

  // TODO - rename setIntersectIds and updateIntersections. They trip
  // me up every time.
  evaluator.setIntersectIds = function (intersectIds) {
    this.applyToChangeSets(function (changeSet) {
      changeSet.intersectIds = cloneJSON(intersectIds);
    });
  };

  evaluator.updateIntersections = function (id) {
    this.applyToChangeSets(function (changeSet) {
      changeSet.intersectId = id;
    });
  };

  evaluator.setDegreeMode = function (use_degrees) {
    this.applyToChangeSets(function (changeSet) {
      changeSet.degreeMode = use_degrees;
    });
  };

  evaluator.notifyWhenSynced = function (callback) {
    this.syncId++;

    //Put the request in a list
    this.syncRequests.push({id: this.syncId, callback: callback});

    // send sync request to worker. when it comes back, we'll call the
    // callback
    var self = this;
    this.applyToChangeSets(function (changeSet) {
      changeSet.syncId = self.syncId;
    });
  };

});

return Evaluator;
});

define('lib/rounding',['require','math/distance'],function(require){
  var Distance = require('math/distance');

  var Rounding = {
    // Returns the shortest decimal between two numbers according to the following rules
    //
    // 1. 0 is the shortest decimal in any range that contains it.
    // 2. Decimals with a larger exponent are shorter than decimals with a smaller exponent
    // 3. Of decimals with the same exponent, 1 is the shortest
    // 4. When there are multiple decimals in the range that are equally sort, the closest to
    //    the mean of x1 and x2 is chosen.
    shortestDecimalBetween: function (x1, x2) {
      var mean = Distance.mean(x1, x2);

      if (x1 > 0 !== x2 > 0) return 0;
      if (x1 === 0 || x2 === 0) return 0;

      // Already know x1 and x2 have the same sign, so make them positive
      // to avoid complication of leading '-' sign.
      var sign = x1 > 0 ? 1 : -1;
      var u1 = (Math.abs(x1)).toExponential().split('e');
      var u2 = (Math.abs(x2)).toExponential().split('e');

      var m1 = u1[0];
      var m2 = u2[0];

      var e1 = u1[1];
      var e2 = u2[1];

      if (e2 !== e1) {
        return sign*Math.pow(10, Math.max(parseFloat(e1), parseFloat(e2)));
      }

      if (m1[0] !== m2[0]) return parseFloat(mean.toPrecision(1));

      var precision = 1;

      // Start at 2 to skip the decimal point. We've already examined
      // the leading digit.
      for (var i = 2; i < Math.min(m1.length, m2.length); i++) {
        precision++;
        if (m1[i] !== m2[i]) break;
      }

      return parseFloat(mean.toPrecision(precision));

    }
  };

  return Rounding;
});

define('graphing/viewport',['require','lib/rounding'],function (require) {
  var Rounding = require('lib/rounding');

  function Viewport (xmin, xmax, ymin, ymax) {
    this.xmin = xmin !== undefined ? xmin : -10;
    this.xmax = xmax !== undefined ? xmax :  10;
    this.ymin = ymin !== undefined ? ymin : -10;
    this.ymax = ymax !== undefined ? ymax :  10;
  }

  Viewport.prototype.toObject = function () {
    return {
      xmin: this.xmin,
      ymin: this.ymin,
      xmax: this.xmax,
      ymax: this.ymax
    };
  };

  Viewport.fromObject = function (obj) {
    return new Viewport(obj.xmin, obj.xmax, obj.ymin, obj.ymax);
  };

  Viewport.prototype.equals = function (viewport) {
    if (this.xmin !== viewport.xmin) return false;
    if (this.ymin !== viewport.ymin) return false;
    if (this.xmax !== viewport.xmax) return false;
    if (this.ymax !== viewport.ymax) return false;

    return true;
  };

  Viewport.prototype.isXValid = function() {
    return (this.xmax - this.xmin > 0);
  };

  Viewport.prototype.isYValid = function() {
    return (this.ymax - this.ymin > 0);
  };

  Viewport.prototype.isValid = function () {
    return this.isXValid() && this.isYValid();
  };

  Viewport.prototype.isSquare = function (screen) {
    return Math.abs(screen.height - screen.width*this.aspectRatio()) < 1;
  };

  Viewport.prototype.aspectRatio = function () {
    return (this.ymax-this.ymin)/(this.xmax-this.xmin);
  };

  Viewport.prototype.squareXAxis = function (screen) {
    var xrange = this.xmax - this.xmin;
    var yrange = this.ymax - this.ymin;
    var xcenter = this.xmin + xrange/2;
    var new_xrange = yrange/screen.height * screen.width;

    this.xmin = xcenter - new_xrange/2;
    this.xmax = xcenter + new_xrange/2;
  };

  Viewport.prototype.squareYAxis = function (screen) {
    if (screen.width === 0 || screen.height === 0) return;
    var xrange = this.xmax - this.xmin;
    var yrange = this.ymax - this.ymin;
    var ycenter = this.ymin + yrange/2;
    var new_yrange = xrange/screen.width * screen.height;

    this.ymin = ycenter - new_yrange/2;
    this.ymax = ycenter + new_yrange/2;
  };

  Viewport.prototype.squareCrop = function (screen) {
    // Square axes in a way that is guaranteed to reduce the viewport
    if (this.aspectRatio() > screen.height/screen.width) {
      this.squareYAxis(screen);
    } else {
      this.squareXAxis(screen);
    }
  };

  // rounds the viewport so that it's not more precise than a pixel
  Viewport.prototype.round = function (screen) {
    if (screen.height === 0 || screen.width === 0) return;
    var xrange = this.xmax - this.xmin;
    var yrange = this.ymax - this.ymin;

    var x_pixel_units = xrange/screen.width;
    var y_pixel_units = yrange/screen.height;

    // Do things this way to try to maintain xrange and yrange when panning.
    this.xmin = Rounding.shortestDecimalBetween(
      this.xmin - x_pixel_units/10,
      this.xmin + x_pixel_units/10
    );
    this.xmax = Rounding.shortestDecimalBetween(
      this.xmin + xrange - x_pixel_units/10,
      this.xmin + xrange + x_pixel_units/10
    );
    this.ymin = Rounding.shortestDecimalBetween(
      this.ymin + y_pixel_units/10,
      this.ymin - y_pixel_units/10
    );
    this.ymax = Rounding.shortestDecimalBetween(
      this.ymin + yrange + y_pixel_units/10,
      this.ymin + yrange - y_pixel_units/10
    );
  };

  Viewport.prototype.clone = function() {
    return new Viewport(this.xmin, this.xmax, this.ymin, this.ymax);
  };

  // calculates a distance from the origin that is guaranteed to reach out past
  // the edge of the viewport for all values of theta. The actual value doesn't
  // matter much. This is used for clipping and the value will get truncated
  // during the clipping routine. In theory could use a really big number but
  // it's possible that we won't pick a big enough number.
  Viewport.prototype.polarDiameter = function() {
     var d1 = Math.abs(this.xmax), d2 = Math.abs(this.xmin);
     var d3 = Math.abs(this.ymax), d4 = Math.abs(this.ymin);

     // Distance can be at most sqrt(2)*magnitude of largest limit.
     // the 1.5 gives a little padding
     return 1.5 * Math.max(d1, d2, d3, d4);
  };

  //the largest visible radius. Note: this should always be strictly smaller than polarDiameter
  Viewport.prototype.largestR = function() {
    //if xmin is positive, then xmax is bigger than abs(xmin)
    //if xmax is negative, then -xmin is bigger than abs(xmax)
    return Math.sqrt(
      Math.pow(Math.max(-this.xmin, this.xmax), 2) +
      Math.pow(Math.max(-this.ymin, this.ymax), 2)
    );
  };

  //the smallest visible radius on the screen
  Viewport.prototype.smallestR = function() {
    //origin is visible
    if (this.xmin <= 0 && this.xmax >= 0 && this.ymin <= 0 && this.ymax >= 0) return 0;
    //y-axis is visible: return wherever on that's smallest
    if (this.xmin <= 0 && this.xmax >= 0) return Math.min(Math.abs(this.ymin), Math.abs(this.ymax));
    //x-axis is visible: return wherever on that's smallest
    if (this.ymin <= 0 && this.ymax >= 0) return Math.min(Math.abs(this.xmin), Math.abs(this.xmax));

    // both x & y axes are offscreen. one of the corners is the min.
    // If both negative, then -xmax is positive and smaller.
    // If both positive, then xmin positive and smaller
    return Math.sqrt(
      Math.pow(Math.max(this.xmin, -this.xmax), 2) +
      Math.pow(Math.max(this.ymin, -this.ymax), 2)
    );
  };

  return Viewport;
});

define('graphing/projection',['require','./viewport'],function (require) {
  var Viewport = require('./viewport');

  // A single object that contains all the information to map from
  // the theoretical space to the canvas space.
  var Projection = function (screen, viewport, settings) {
    this.screen = screen;
    this.viewport = viewport;
    this.settings = settings;
  };

  Projection.prototype.calculateViewportForScreen = function (newScreen) {
    var vp = this.viewport;
    var dw = (newScreen.width / this.screen.width - 1) * (vp.xmax - vp.xmin);
    var dh = (newScreen.height / this.screen.height - 1) * (vp.ymax - vp.ymin);

    var newViewport = new Viewport(vp.xmin-dw/2, vp.xmax+dw/2, vp.ymin-dh/2, vp.ymax+dh/2);
    newViewport.round(newScreen);

    return newViewport;
  };

  Projection.prototype.mapx = function(x) {
      return (x - this.viewport.xmin)*this.screen.width/(this.viewport.xmax - this.viewport.xmin);
  };

  Projection.prototype.mapy = function(y) {
      return this.screen.height - (y - this.viewport.ymin)*this.screen.height/(this.viewport.ymax - this.viewport.ymin);
  };

  Projection.prototype.map_pt = function(pt) {
      return {x: this.mapx(pt.x), y: this.mapy(pt.y)};
  };

  Projection.prototype.reverse_mapx = function (mapped_x) {
    return mapped_x * (this.viewport.xmax - this.viewport.xmin)/this.screen.width + this.viewport.xmin;
  };

  Projection.prototype.reverse_mapy = function (mapped_y) {
    return (
      -(mapped_y - this.screen.height)*(this.viewport.ymax - this.viewport.ymin)/this.screen.height + this.viewport.ymin
    );
  };

  Projection.prototype.reverse_map_pt = function (mapped_pt) {
    return {x: this.reverse_mapx(mapped_pt.x), y: this.reverse_mapy(mapped_pt.y)};
  };

  return Projection;
});

define('graphing/viewporttransformation',['require','pjs','./viewport','./projection'],function(require){
  var P = require('pjs');
  var Viewport = require('./viewport');
  var Projection = require('./projection');

  var ViewportTransformation = P(function (proto) {
    // Constructor can take 2 arguments for a translation only, 3 arguments
    // for a uniform scaling, or 4 arguments for different scalings along x
    // and y.
    proto.init = function (xOffset, yOffset, xScale, yScale) {
      this.xOffset = xOffset !== undefined ? xOffset : 0;
      this.yOffset = yOffset !== undefined ? yOffset : 0;
      this.xScale = xScale !== undefined ? xScale : 1;
      this.yScale = yScale !== undefined ? yScale : this.xScale;
    };

    proto.compose = function (transformation) {
      return new ViewportTransformation(
        transformation.xScale*this.xOffset + transformation.xOffset,
        transformation.yScale*this.yOffset + transformation.yOffset,
        transformation.xScale*this.xScale,
        transformation.yScale*this.yScale
      );
    };

    proto.lerp = function (transformation, ratio) {
      return new ViewportTransformation(
        (1 - ratio)*this.xOffset + ratio*transformation.xOffset,
        (1 - ratio)*this.yOffset + ratio*transformation.yOffset,
        (1 - ratio)*this.xScale + ratio*transformation.xScale,
        (1 - ratio)*this.yScale + ratio*transformation.yScale
      );
    };

    proto.transformProjection = function (projection) {
      var viewport = projection.viewport;
      var screen = projection.screen;

      var vmidx = (viewport.xmin + viewport.xmax)/2;
      var vmidy = (viewport.ymin + viewport.ymax)/2;
      var vminx = vmidx + (viewport.xmin - vmidx)/this.xScale;
      var vmaxx = vmidx + (viewport.xmax - vmidx)/this.xScale;
      var vminy = vmidy + (viewport.ymin - vmidy)/this.yScale;
      var vmaxy = vmidy + (viewport.ymax - vmidy)/this.yScale;

      // Pixel coord vs cartesian coord flip means that voffset_y needs to be flipped.
      var vox = this.xOffset * (vmaxx-vminx) / screen.width;
      var voy = -this.yOffset * (vmaxy-vminy) / screen.height;

      return new Projection(
        projection.screen,
        new Viewport(vminx-vox, vmaxx-vox, vminy-voy, vmaxy-voy),
        projection.settings
      );
    };
  });

  return ViewportTransformation;
});

define('graphing/screen',['require'],function(require) {
  function Screen(width, height) {
      this.width = width;
      this.height = height;

      return this;
  }

  return Screen;
});

define('loadcss!css/poi', function(){});
// Disable text selection

/* global jQuery */
;(function($){

  $.fn.disableTextSelection = function( removeFocus ) {

    if (removeFocus) {
      this.each(function(){
        $(this).bind("mousedown touchstart", function(){
          $(document.activeElement).focusout();
        });
      });
    }

    return this.each(function() {
    $(this).attr('unselectable', 'on').css({
                   '-moz-user-select':'none',
                   '-webkit-user-select':'none',
                   'user-select':'none'
               })
               .each(function() {
                   this.onselectstart = function() { return false; };
               });
    });
  };

})(jQuery);


define("jquery.disabletextselection", function(){});

define('graphing/canvaslayer',['require','jquery','pjs','browser','jquery.disabletextselection'],function (require) {
  var $ = require('jquery');
  var P = require('pjs');
  var Browser = require('browser');
  require('jquery.disabletextselection');

  var CanvasLayer = P(function (layer) {

    layer.init = function () {
      this.$ = $("<div class='dcg-graph-outer'></div>")
      .css('position', 'absolute')
      .css('overflow', 'hidden')
      .disableTextSelection(Browser.IS_IE);

      this.canvas_node = $("<canvas class='dcg-graph-inner'></canvas>")
      .css('position', 'relative')
      .css('display', 'block')
      .disableTextSelection(Browser.IS_IE);

      this.devicePixelRatio = (window.devicePixelRatio || 1);
      this.ctx = this.canvas_node[0].getContext('2d');

      // Canvas used to hold an image of the graph when we're panning/scaling.
      this.unscaledCanvas = document.createElement('canvas');

      // Flag for whether we're in the middle of a pan/scale
      this.transforming = false;

      this.$.append(this.canvas_node);
    };

    layer.resize = function (width, height) {
      // concession to retina iPads, where there is a horrendous performance
      // drop between 1023 pixels, and its full width, 1024 pixels. This
      // problem also occurs on desktop Safari as of version 6, so full screen
      // safari on a retina laptop will still be a bad experience.
      //
      // see minimal examlpe at http://jsbin.com/ulobuh/4
      if (width === 1024 && this.devicePixelRatio === 2) width = 1023;

      // early trap if not changing size
      if (width === this.width && height === this.height) return;

      this.width = width;
      this.height = height;

      this.$.css('width', width + "px")
      .css('height', height + "px");

      this.canvas_node.css('width', width + "px")
      .css('height', height + "px")
      .attr('width', width*this.devicePixelRatio)
      .attr('height', height*this.devicePixelRatio);

      if (this.unscaledCanvas) {
        this.unscaledCanvas.width = width;
        this.unscaledCanvas.height = height;
      }

      this.ctx.scale(this.devicePixelRatio, this.devicePixelRatio);
    };

    // should get overridden by subclass
    layer.redraw = function () {};

    layer.saveUnscaledCanvas = function (projection) {

      // if we've already saved it, don't want to overwrite it. You must release
      // it if you want to resave it.
      if (this.transforming) return;
      this.transforming = true;

      var ctx = this.unscaledCanvas.getContext('2d');
      var width = this.unscaledCanvas.width;
      var height = this.unscaledCanvas.height;
      ctx.clearRect(0, 0, width, height);
      ctx.drawImage(this.canvas_node[0], 0, 0, width, height);
    };

    layer.releaseUnscaledCanvas = function () {
      this.transforming = false;
    };

    layer.paintScaledCanvas = function (transformation) {
      // can't do this if we don't have an unscaledCanvas to scale
      if (!this.unscaledCanvas) return;

      var t = transformation;

      var width = this.ctx.canvas.width;
      var height = this.ctx.canvas.height;

      this.ctx.save();
      this.ctx.clearRect(0, 0, width, height);

      this.ctx.setTransform(
        t.xScale, 0,
        0, t.yScale,
        t.xOffset*this.devicePixelRatio - 0.5*(t.xScale - 1)*width,
        t.yOffset*this.devicePixelRatio - 0.5*(t.yScale - 1)*height
      );
      this.ctx.drawImage(this.unscaledCanvas, 0, 0, width, height);
      this.ctx.restore();
    };
  });

  return CanvasLayer;
});

define('graphing/clipping',[], function(){

var Clipping = {

  TOP: 1,
  BOTTOM: 2,
  LEFT: 4,
  RIGHT: 8,
  ALL: 15,
  X: 12,
  Y: 3,

  POLAR_RADIAN_EQUALITY: 1,
  POLAR_RADIAN_INEQUALITY: 2,
  POLAR_DEGREE_EQUALITY: 3,
  POLAR_DEGREE_INEQUALITY: 4,
  Y_EQUALS: 5,
  X_EQUALS: 6,

  mapSegmentToCanvas: function (segment, viewport, screen, graphType) {
    /* jshint maxcomplexity:15 */
    var output = [];
    var xmin = viewport.xmin;
    var ymin = viewport.ymin;
    var xrange = viewport.xmax-viewport.xmin;
    var yrange = viewport.ymax-viewport.ymin;
    var width = screen.width;
    var height = screen.height;
    var xscale = width/xrange;
    var yscale = -height/yrange;
    var len = segment.length;
    var i,x,y,theta,r;

    if (graphType === Clipping.Y_EQUALS) {

      for (i=0; i < len; i+=2) {
        x = (segment[i]-xmin)*xscale - 0.5;
        y = (segment[i+1]-ymin)*yscale+height - 0.5;
        output.push(x,y);
      }

    } else if (graphType === Clipping.X_EQUALS) {

      for (i=0; i < len; i+=2) {
        x = (segment[i+1]-xmin)*xscale - 0.5;
        y = (segment[i]-ymin)*yscale+height - 0.5;
        output.push(x,y);
      }

    } else if (graphType === Clipping.POLAR_RADIAN_EQUALITY) {

      for (i=0; i<segment.length; i+=2) {
        theta = segment[i];
        r = segment[i+1];
        x = (r*Math.cos(theta)-xmin)*xscale - 0.5;
        y = (r*Math.sin(theta)-ymin)*yscale+height - 0.5;
        output.push(x,y);
      }

    } else if (graphType === Clipping.POLAR_RADIAN_INEQUALITY) {

      for (i=0; i<segment.length; i+=2) {
        theta = segment[i];
        r = segment[i+1];
        if (r < 0) r = 0;
        x = (r*Math.cos(theta)-xmin)*xscale - 0.5;
        y = (r*Math.sin(theta)-ymin)*yscale+height - 0.5;
        output.push(x,y);
      }

    } else if (graphType === Clipping.POLAR_DEGREE_EQUALITY) {

      for (i=0; i<segment.length; i+=2) {
        theta = segment[i]*Math.PI/180;
        r = segment[i+1];
        x = (r*Math.cos(theta)-xmin)*xscale - 0.5;
        y = (r*Math.sin(theta)-ymin)*yscale+height - 0.5;
        output.push(x,y);
      }

    } else if (graphType === Clipping.POLAR_DEGREE_INEQUALITY) {

      for (i=0; i<segment.length; i+=2) {
        theta = segment[i]*Math.PI/180;
        r = segment[i+1];
        if (r < 0) r = 0;
        x = (r*Math.cos(theta)-xmin)*xscale - 0.5;
        y = (r*Math.sin(theta)-ymin)*yscale+height - 0.5;
        output.push(x,y);
      }

    }

    return output;
  },

  clipStrokeEdges: function (segment, viewport) {
    return Clipping.clipFillEdges(segment, viewport, Clipping.ALL, true);
  },

  clipFillEdge: function (input, inside_test, exit_point, is_open) {
    var output = [];
    var push = [].push;
    var start_index;

    if(is_open){  //stroke
      x = input[0];
      y = input[1];
      start_index = 2;
      inside = inside_test(x, y);
      if(inside) output.push(x, y);
    } else {      //fill
      x = input[input.length - 2];
      y = input[input.length - 1];
      start_index = 0;
      inside = inside_test(x, y);
    }

    for (var i = start_index; i < input.length; i+=2) {
      var x_prev = x;
      var y_prev = y;
      var inside_prev = inside;

      var x = input[i];
      var y = input[i+1];
      var inside = inside_test(x, y);

      if(!inside && !inside_prev){
        continue;
      }
      if(inside && inside_prev){
        output.push(x, y);
      }
      if(inside && !inside_prev){
        push.apply(output, exit_point(x, y, x_prev, y_prev));
        output.push(x, y);
      }
      if(!inside && inside_prev){
        push.apply(output, exit_point(x_prev, y_prev, x, y));
      }
    }
    return output;
  },

  clipFillEdges: function (input, viewport, edges, is_open) {
    /* jshint bitwise: false */
    var xmin = viewport.xmin;
    var xmax = viewport.xmax;
    var ymin = viewport.ymin;
    var ymax = viewport.ymax;

    var test_xmin = function (x, y) {
      return x >= xmin;
    };
    var test_xmax = function (x, y) {
      return x <= xmax;
    };
    var test_ymin = function (x, y) {
      return y >= ymin;
    };
    var test_ymax = function (x, y) {
      return y <= ymax;
    };

    var entry_xmin = function (x, y, x2, y2) {
      var dy = y2-y;
      return [xmin, y+dy*(xmin-x)/(x2-x)];
    };
    var entry_xmax = function (x, y, x2, y2) {
      var dy = y2-y;
      return [xmax, y+dy*(xmax-x)/(x2-x)];
    };
    var entry_ymin = function (x, y, x2, y2) {
      var dx = x2-x;
      return [x+dx*(ymin-y)/(y2-y), ymin];
    };
    var entry_ymax = function (x, y, x2, y2) {
      var dx = x2-x;
      return [x+dx*(ymax-y)/(y2-y), ymax];
    };

    var output = input;

    if (edges & Clipping.LEFT) {
      output = Clipping.clipFillEdge(input, test_xmin, entry_xmin, is_open);
    }

    if (edges & Clipping.BOTTOM) {
      output = Clipping.clipFillEdge(output, test_ymin, entry_ymin, is_open);
    }

    if (edges & Clipping.RIGHT) {
      output = Clipping.clipFillEdge(output, test_xmax, entry_xmax, is_open);
    }

    if (edges & Clipping.TOP) {
      output = Clipping.clipFillEdge(output, test_ymax, entry_ymax, is_open);
    }

    return output;
  },

  clipAllFillEdges: function (input, viewport) {
   return Clipping.clipFillEdges(input, viewport, Clipping.ALL, false);
  },

  computePolarFill: function(segment, fillTowards, polarInterval) {

    var all_segments = [];

    var theta;
    var start_theta = segment[0];
    var end_theta = start_theta+polarInterval;
    var limited_segment = [];
    all_segments.push(limited_segment);

    // detect 2pi intervals and split into separate segments
    for (var i=0; i<segment.length; i+=2) {
      theta = segment[i];
      var r = segment[i+1];
      if (r<0) r = 0;

      if (theta>=end_theta) {

        limited_segment = [];
        all_segments.push(limited_segment);
        start_theta = segment[i-2]; //previous theta
        end_theta = start_theta;
        // Make sure that end_theta always increases. Adding polarInterval
        // only once isn't enough because theta might change by more than
        // polarInterval between two samples.
        while(theta >= end_theta) end_theta += polarInterval;
        i -= 4; //go back 1 theta (for loop will +2)

      } else {
        limited_segment.push(theta,r);
      }

    }

    if (fillTowards === 0) {
      // just fill towards the origin
      for (i=0; i<all_segments.length; i++) {
        all_segments[i].push(0,0);
      }

    } else {

      // shade toward outside. trace around counter clockwise, jump to the
      // outside, and trace around clockwise again at pi/8 intervals. Then
      // go to the starting theta with very large radius.
      var clockwise_step = polarInterval/16;
      var radius = fillTowards;
      for (i=0; i<all_segments.length; i++) {
        var seg = all_segments[i];
        start_theta = seg[0];
        end_theta = seg[seg.length-2];
        for (theta = end_theta; theta > start_theta; theta -= clockwise_step) {
          seg.push( theta, radius);
        }
        seg.push( start_theta, radius);
      }

    }

    return all_segments;
  },

  computeCartesianFill: function(segment, fillTowards) {
    // copy the incoming segment and push it to the list
    segment = segment.slice();

    // add a couple points that decide which direction we fill
    segment.push(segment[segment.length-2], fillTowards);
    segment.push(segment[0], fillTowards);

    return [segment];
  }
};

return Clipping;
});

define('graphing/constants',[],function () {
  return {
    ANIMATE_ZOOM_DURATION: 500,
    DOUBLETAP_ZOOM: 2.0,
    ZOOM_FACTOR: 1.125,

    MAX_DOTTED_SEGMENTS: 1000,
    STROKE_ALPHA: 0.7,
    HIGHLIGHTED_STROKE_ALPHA: 1,
    FILL_ALPHA: 0.4,
    POINT_ALPHA: 0.9,
    HIGHLIGHTED_POINT_ALPHA: 0.6,
    POLAR_ALPHA: 0.2,
    POI_ALPHA: 0.01
  };
});

//TODO - something is slow about this when zoomed way out.
//       could be subpixel rendering.
define('graphing/dasheddrawer',['require','./constants','math/distance'],function(require){
  var constants = require('./constants');
  var Distance = require('math/distance');

function DashedDrawer(ctx, seglen) {
    this.pattern = [11,7];
    this.replen = this.pattern[0] + this.pattern[1];

  if (seglen !== null && seglen/this.replen > constants.MAX_DOTTED_SEGMENTS) {
        this.pattern[0] = seglen*this.pattern[0]/this.replen/constants.MAX_DOTTED_SEGMENTS;
        this.pattern[1] = seglen*this.pattern[1]/this.replen/constants.MAX_DOTTED_SEGMENTS;
    }

    this.pstate = 0; // 0 being "draw a line"
    this.dstaccum = 0.0;
    this.px = null;
    this.py = null;
    this.ctx = ctx;

    return this;
}

DashedDrawer.getTotalSegmentLength = function(segment) {
  if (segment.length < 4) return 0;

  var len = 0;
  var x = segment[0];
  var y = segment[1];

  for (var i = 2; i < segment.length; i+=2) {
    var nx = segment[i];
    var ny = segment[i+1];

    len += Distance.hypot(nx-x,ny-y);

    x = nx;
    y = ny;
  }

  return len;
};

DashedDrawer.prototype.start = function(x,y) {
    if(!this.ctx.desmos_batching) this.ctx.beginPath();
    this.px = x;
    this.py = y;
};

DashedDrawer.prototype.next = function(x,y) {
    var dstlimit = this.pattern[this.pstate];
    var dstincr = Math.sqrt(Math.pow(x-this.px,2) + Math.pow(y-this.py,2));

  if (dstincr > 0.00001) {
    while (dstincr + this.dstaccum >= dstlimit) {
            // Draw up to the phase change, change phase.
            // compute actual line-to point
            var incrx = x - this.px;
            var incry = y - this.py;

            // Scaling factor
            var linedst = dstlimit - this.dstaccum;
            incrx *= linedst/dstincr;
            incry *= linedst/dstincr;

            // Draw if in the draw state
      if (this.pstate === 0) {
                this.ctx.moveTo(this.px, this.py);
                this.ctx.lineTo(this.px+incrx, this.py+incry);
            }

            // Reset the accumulator
            this.dstaccum = 0.0;
            this.px += incrx;
            this.py += incry;
            // Flip the pattern state
            this.pstate = 1-this.pstate;
            dstlimit = this.pattern[this.pstate];
            dstincr -= linedst;
        }

    // Draw up to the target point.
    if (this.pstate === 0) {
            this.ctx.moveTo(this.px, this.py);
            this.ctx.lineTo(x, y);
        }
    }
    this.px = x;
    this.py = y;
    this.dstaccum += dstincr;
};

DashedDrawer.prototype.skip = function(x,y) {
  this.px = x;
  this.py = y;
};

DashedDrawer.prototype.close = function() {
    if(!this.ctx.desmos_batching) this.ctx.stroke();

    this.pstate = 0; // 0 being "draw a line"
    this.dstaccum = 0.0;
    this.px = null;
    this.py = null;
};

return DashedDrawer;
});

define('graphing/graphslayer',['require','pjs','underscore','./canvaslayer','./clipping','./dasheddrawer','./constants','./viewport','graphing/graphmode'],function (require) {
  var P = require('pjs');
  var _ = require('underscore');
  var CanvasLayer = require('./canvaslayer');
  var Clipping = require('./clipping');
  var DashedDrawer = require('./dasheddrawer');
  var constants = require('./constants');
  var Viewport = require('./viewport');
  var GRAPHMODE = require('graphing/graphmode');

  var screenToClippingViewport = function (screen) {
    return new Viewport(-3, screen.width + 3, -3, screen.height + 3);
  };

  var GraphsLayer = P(CanvasLayer, function (layer) {

      layer.redraw = function (projection, graphSketches, drawOrder) {
        var screen = projection.screen;

        // make sure that this is the correct size
        this.resize(screen.width, screen.height);
        // Clear out the drawing area
        this.ctx.clearRect(0, 0, screen.width, screen.height);
        this.redrawToCtx(this.ctx, projection, graphSketches, drawOrder);

      };

      layer.redrawToCtx = function (ctx, projection, graphSketches, drawOrder) {
        // Do the drawing of the segments
        if (drawOrder === undefined || drawOrder.length < _.size(graphSketches)) {
          // If we don't have a drawOrder, or it doesn't include all of our graphSketches then make a new order.
          drawOrder = _.keys(graphSketches);
        }
        drawOrder.forEach(function (id) {
          var sketch = graphSketches[id];
          if (sketch !== undefined) {
            if (sketch.visible) {
              GraphsLayer.drawSketchToCtx(graphSketches[id], ctx, projection);
            }
          }
        });
      };

  });

  GraphsLayer.eachSegment = function (sketch, fn) {
    for (var i = 0; i < sketch.branches.length; i++) {
      var branch = sketch.branches[i];
      for (var j = 0; j < branch.segments.length; j++) {
        var segment = branch.segments[j];
        fn(branch, segment);
      }
    }
  };

  GraphsLayer.drawSketchToCtx = function (sketch, ctx, projection) {
      if (!sketch.branches || !sketch.branches.length) return;
      ctx.lineWidth = projection.settings.graphLineWidth;
      ctx.strokeStyle = sketch.color;
      ctx.fillStyle = sketch.color;
      ctx.lineJoin = "round";
      ctx.lineCap = "round";

      //If we're drawing points, draw points and return
      var allowMovable = !!projection.settings.takingScreenshot;
      ctx.desmos_batching = true;
      ctx.beginPath();
      ctx.save();
      GraphsLayer.eachSegment(sketch, function (branch, segment) {
        if (branch.graphMode === GRAPHMODE.XYPOINT ||
            (branch.graphMode === GRAPHMODE.XYPOINT_MOVABLE && allowMovable)) {
          GraphsLayer.drawPointsToCtx(ctx, projection, segment, branch.style);
        }
      });

      ctx.globalAlpha = constants.POINT_ALPHA;
      ctx.stroke();
      ctx.restore();
      ctx.desmos_batching = false;

      //If we're filling, fill.  No batching, because we want polar to shade deeper in overlaps
      GraphsLayer.eachSegment(sketch, function (branch, segment) {
        if (branch.graphMode === GRAPHMODE.XYPOINT || branch.graphMode === GRAPHMODE.XYPOINT_MOVABLE) return;
        var graphMode = GRAPHMODE.Y;
        if (branch.flip) graphMode = GRAPHMODE.X;
        if (branch.graphMode) graphMode = branch.graphMode;

        if (graphMode === GRAPHMODE.POLYGONFILL) {
          GraphsLayer.fillPolygonToCtx(ctx, projection, segment);
        } else {
          var op = branch.operator;
          var fill = (
            op == "<" || op == ">" || op == "<=" || op == ">=" ||
            op == "\\leq" || op == "\\le" || op == "\\geq" || op == "\\ge"
          );
          var fill_d = (op == "<=" || op == "<" || op == "\\leq" || op == "\\le");

          if (fill) GraphsLayer.fillGraphStrokeToCtx(ctx, projection, segment, fill_d, graphMode);
        }
      });

      //If we're drawing segments, draw them
      ctx.desmos_batching = true;
      ctx.beginPath();
      GraphsLayer.eachSegment(sketch, function (branch, segment) {
        if (branch.graphMode === GRAPHMODE.XYPOINT || branch.graphMode === GRAPHMODE.XYPOINT_MOVABLE) return;
        var graphMode = GRAPHMODE.Y;
        if (branch.flip) graphMode = GRAPHMODE.X;
        if (branch.graphMode) graphMode = branch.graphMode;

        var op = branch.operator;
        // != is used for shade-between lines which should be dashed but not filled
        var dotted = (op == "<" || op == ">" || op == '!=' || sketch.style === 'dashed');

        GraphsLayer.drawGraphStrokeToCtx(ctx, projection, segment, dotted, graphMode, op);
      });
      ctx.globalAlpha = constants.STROKE_ALPHA;
      ctx.stroke();
      ctx.globalAlpha = 1.0;
      ctx.desmos_batching = false;
  };

  GraphsLayer.drawGraphStrokeToCtx = function (ctx, projection, segment, dotted, graphMode, op) {
    ctx.globalAlpha = projection.settings.highlight ?
      constants.HIGHLIGHTED_STROKE_ALPHA : constants.STROKE_ALPHA
    ;

    // takes the raw array of numbers and maps it to the canvas. Then it clips.
    var graphType = GraphsLayer.getClippingGraphType(graphMode, op !== "=", projection.settings);
    var scaled = Clipping.mapSegmentToCanvas(segment, projection.viewport, projection.screen, graphType);
    var clipped = Clipping.clipStrokeEdges(scaled, screenToClippingViewport(projection.screen));
    var i;

    // draws the clipped segment as a solid curve
    if (!dotted) {

      if (!ctx.desmos_batching) ctx.beginPath();
      ctx.moveTo(clipped[0],clipped[1]);
      for (i=0; i<clipped.length; i+=2) {
        ctx.lineTo(clipped[i], clipped[i+1]);
      }
      if (!ctx.desmos_batching) ctx.stroke();

    // draws the clipped segment as a dashed curve
    } else {

      var buf = new DashedDrawer(ctx, DashedDrawer.getTotalSegmentLength(clipped) );
      buf.start(clipped[0], clipped[1]);
      for (i=2; i < clipped.length; i+=2) {
        buf.next(clipped[i], clipped[i+1]);
      }
      buf.close();

    }

    ctx.globalAlpha = 1.0;
  };

  GraphsLayer.mapPointToScreen = function (projection, x, y) {
    // if the point is more than 20px off the screen in any direction, we just
    // don't draw it.
    var padding = 20;
    var mx = projection.mapx(x)-0.5;
    if (mx < -padding || mx > projection.screen.width+padding) return null;

    var my = projection.mapy(y)-0.5;
    if (my < -padding || my > projection.screen.height+padding) return null;

    return {x: mx, y: my};
  };

  GraphsLayer.drawPointToCtx = function (ctx, projection, x, y, alpha, style) {

    var pt = GraphsLayer.mapPointToScreen(projection, x, y);
    var size;
    if (!pt) return false;

    ctx.globalAlpha = projection.settings.highlight ?
      constants.HIGHLIGHTED_POINT_ALPHA : constants.POINT_ALPHA
    ;
    if (alpha) ctx.globalAlpha = alpha;
    ctx.globalAlpha = constants.POINT_ALPHA;
    if (!ctx.desmos_batching) ctx.beginPath();
    // For some reason we need a full polygon, but a small one.

    if (style === 'cross') {
      // The values for this and the open style are largely eyeballed so they
      // seem cohesize when mixed. They may change based on other peoples eyeballs
      size = projection.settings.pointLineWidth * 0.4;
      ctx.moveTo(pt.x-size, pt.y-size);
      ctx.lineTo(pt.x+size, pt.y+size);
      ctx.moveTo(pt.x+size, pt.y-size);
      ctx.lineTo(pt.x-size, pt.y+size);
      ctx.lineWidth = projection.settings.pointLineWidth * 0.3;
    } else if (style === 'open') {
      size = projection.settings.pointLineWidth * 0.5;
      ctx.moveTo(pt.x + size, pt.y);
      ctx.arc(pt.x, pt.y, size, 0, Math.PI*2, true);
      ctx.closePath();
      ctx.fillStyle = "white";
      ctx.lineWidth = projection.settings.pointLineWidth * 0.25;
      ctx.fill();
    } else {
      ctx.moveTo(pt.x-0.1, pt.y-0.1);
      ctx.lineTo(pt.x-0.1, pt.y+0.1);
      ctx.lineTo(pt.x+0.1, pt.y+0.1);
      ctx.lineTo(pt.x+0.1, pt.y-0.1);
    }
    if (!ctx.desmos_batching) ctx.stroke();

    ctx.globalAlpha = 1.0;

    return true;
  };

  GraphsLayer.drawPointsToCtx = function (ctx, projection, segment, style) {
      ctx.lineWidth = projection.settings.pointLineWidth;
      for (var i=0; i < segment.length; i++) {
        GraphsLayer.drawPointToCtx(ctx, projection, segment[i][0], segment[i][1], false, style);
      }
  };

  GraphsLayer.fillGraphStrokeToCtx = function (ctx, projection, segment, fillDown, graphMode) {
    ctx.globalAlpha = (graphMode === GRAPHMODE.POLAR) ? constants.POLAR_ALPHA : constants.FILL_ALPHA;

    var fill_paths = null;
    var clipped_edges = null;
    var fillTowards;

    if (graphMode === GRAPHMODE.POLAR) {

      clipped_edges = Clipping.ALL;
      var radius = fillDown ? 0 : projection.viewport.polarDiameter();
      var interval = projection.settings.degreeMode ? 180.0 : 2*Math.PI;
      fill_paths = Clipping.computePolarFill(segment, radius, interval);

    } else if (graphMode === GRAPHMODE.Y) {

      clipped_edges = Clipping.Y;
      fillTowards = fillDown ? projection.viewport.ymin : projection.viewport.ymax;
      fill_paths = Clipping.computeCartesianFill(segment, fillTowards);

    } else if (graphMode === GRAPHMODE.X) {

      clipped_edges = Clipping.X;
      fillTowards = fillDown ? projection.viewport.xmin : projection.viewport.xmax;
      fill_paths = Clipping.computeCartesianFill(segment, fillTowards);

    }

    // scale, clip, and then draw each fill path
    var clipped_viewport = screenToClippingViewport(projection.screen);
    for (var i=0; i<fill_paths.length; i++) {

      // scale the segment
      var map_graphType = GraphsLayer.getClippingGraphType(graphMode, true, projection.settings);
      var scaled = Clipping.mapSegmentToCanvas(fill_paths[i], projection.viewport, projection.screen, map_graphType);

      // clip the segment
      var clipped = Clipping.clipFillEdges(scaled, clipped_viewport, clipped_edges);

      // draw the segment
      if (clipped.length >= 6) {
        ctx.beginPath();

        ctx.moveTo(clipped[0],clipped[1]);
        for (var j=2; j<clipped.length; j+=2) {
          ctx.lineTo(clipped[j],clipped[j+1]);
        }

        ctx.closePath();
        ctx.fill();
      }
    }

    ctx.globalAlpha = 1.0;
  };

  GraphsLayer.fillPolygonToCtx = function (ctx, projection, segment) {
    ctx.globalAlpha = constants.FILL_ALPHA;

    var clipped_viewport = screenToClippingViewport(projection.screen);

    var scaled = Clipping.mapSegmentToCanvas(segment, projection.viewport, projection.screen, Clipping.Y_EQUALS);

    // clip the segment
    var clipped = Clipping.clipFillEdges(scaled, clipped_viewport, Clipping.ALL);

    // draw the segment
    if (clipped.length >= 6) {
      ctx.beginPath();

      ctx.moveTo(clipped[0],clipped[1]);
      for (var j=2; j<clipped.length; j+=2) {
        ctx.lineTo(clipped[j],clipped[j+1]);
      }

      ctx.closePath();
      ctx.fill();
    }

    ctx.globalAlpha = 1.0;
  };

  GraphsLayer.getClippingGraphType = function (graphMode, isInequality, settings) {
    switch (graphMode) {

      case GRAPHMODE.X:
        return Clipping.X_EQUALS;

      case GRAPHMODE.IMPLICIT:
      case GRAPHMODE.PARAMETRIC:
      case GRAPHMODE.Y:
        return Clipping.Y_EQUALS;

      case GRAPHMODE.POLAR:
        if (settings.degreeMode) {
          return isInequality ? Clipping.POLAR_DEGREE_INEQUALITY : Clipping.POLAR_DEGREE_EQUALITY;
        } else {
          return isInequality ? Clipping.POLAR_RADIAN_INEQUALITY : Clipping.POLAR_RADIAN_EQUALITY;
        }

    }
  };

  return GraphsLayer;
});

define('graphing/poidotslayer',['require','loadcss!css/poi','pjs','./graphslayer','./canvaslayer','math/poi','./constants'],function(require) {

  // TODO - we have both a poidots layer and poilabels layer. This is including the css for both layers. Either
  // split the css into two separate files or combine the two layers into a single file
  require('loadcss!css/poi');

  var P = require('pjs');
  var GraphsLayer = require('./graphslayer');
  var CanvasLayer = require('./canvaslayer');
  var POITYPE = require('math/poi');
  var constants = require('./constants');

// TODO - rename from 'POIDotsLayer to something like SketchStyleLayer.
var POIDotsLayer = P(CanvasLayer, function(layer, _super){

    layer.init = function () {
      _super.init.apply(this, arguments);
      this.$.addClass('dcg-poi-dots-layer');
    };

    layer.redraw = function (projection, graphSketches) {

      // make sure that this is the correct size
      this.resize(projection.screen.width, projection.screen.height);

      // Clear out the drawing area
      this.ctx.clearRect(0, 0, projection.screen.width, projection.screen.height);

      // Iterate through each graphSketch, find the ones that should showPOI
      // and draw the poi dots. Also, we save the dots we drew.
      var savedPOI = [];
      for (var id in graphSketches) {
        var sketch = graphSketches[id];

        if (sketch.visible) {

          if (sketch.showHighlight) {
            POIDotsLayer.drawSketchHighlight(sketch, this.ctx, projection);
          }

          var pois = sketch.getPOI();
          if (
            sketch.showPOI ||
            // Always run this routine on defined POI. They aren't drawn to the screen, but they
            // need to be available to be opened. This is easier in the current system
            // than ensuring that showPOI is always set to true for these sketches.
            (pois.length && pois[0].type === POITYPE.DEFINITION)
          ) {
            savedPOI.push.apply(savedPOI,POIDotsLayer.drawPOIs(pois, this.ctx, "#AAAAAA", projection));
          }
        }
      }
      this.savedPOI = savedPOI;
    };

    layer.getDrawnPOI = function () {
      return this.savedPOI || [];
    };
});

POIDotsLayer.drawSketchHighlight = function (sketch, ctx, projection) {
  projection.settings.setProperty('highlight', true);
  GraphsLayer.drawSketchToCtx(sketch, ctx, projection);
  projection.settings.setProperty('highlight', false);
};

POIDotsLayer.drawPOIs = function (pois, ctx, color, projection) {

  ctx.lineWidth = projection.settings.pointLineWidth;
  ctx.strokeStyle = color || "#AAAAAA";
  ctx.fillStyle = color || "#AAAAAA";
  ctx.lineJoin = "round";
  ctx.lineCap = "round";

  var oldGlobalAlpha = ctx.globalAlpha;
  ctx.globalAlpha = constants.POI_ALPHA;

  var poiOnScreen = [];

  var i, plen = pois.length;
  var poi;

  // we don't draw dots for POI that are defined. There is already a dot
  // for the point on the screen. But, we want there to be a POI registered
  // still, so we add it to the list of poiOnScreen
  if (plen && pois[0].type === POITYPE.DEFINITION) {
    for (i=0; i<plen; i++) {
      poi = pois[i];
      if (GraphsLayer.mapPointToScreen(projection, poi.x, poi.y)) {
        poiOnScreen.push(poi);
      }
    }
  }

  // actually draw them on screen
  else {
    for (i=0; i<plen; i++) {
      poi = pois[i];
      if (GraphsLayer.drawPointToCtx(ctx, projection, poi.x, poi.y, constants.POI_ALPHA)) {
        poiOnScreen.push(poi);
      }
    }
  }

  ctx.globalAlpha = oldGlobalAlpha;
  return poiOnScreen;
};

return POIDotsLayer;
});

define('graphing/domlayer',['require','pjs','jquery','browser','jquery.disabletextselection'],function(require){
  var P = require('pjs');
  var $ = require('jquery');
  var Browser = require('browser');
  require('jquery.disabletextselection');

var DOMLayer = P(function(layer){

  layer.init = function ($root) {
    this.$ = $("<div class='dcg-graph-outer'></div>")
           .css('position', 'absolute')
           .css('overflow', 'hidden')
           .disableTextSelection(  Browser.IS_IE  );

    this.dom_node = $("<div></div>")
                     .css('position', 'relative')
                     .css('display', 'block')
                     .disableTextSelection(  Browser.IS_IE  );

    this.$root = $root;
    this.$.append(this.dom_node);
  };

  // can't use jquery addClass and removeClass because they are slow on ipad.
  // the problem appears to be that jquery implementation keeps setting the
  // className property of the element even if nothing has changed. In turn,
  // ios appears to rerender everything since .className was set. So we only
  // add/remove the class if it'll change the className of the body.
  layer.addGlobalClass = function(className) {
    if (!this.$root.hasClass(className)) {
      this.$root.addClass(className);
    }
  };
  layer.removeGlobalClass = function(className) {
   if (this.$root.hasClass(className)) {
     this.$root.removeClass(className);
   }
  };

  layer.resize = function (width, height) {

    // early trap if not changing size
    if (width === this.width && height === this.height) return;

    this.width = width;
    this.height = height;

    this.$.css('width', width + "px")
          .css('height', height + "px");

    this.dom_node.css('width', width + "px")
                 .css('height', height + "px");
  };

  // should get overridden by subclass
  layer.redraw = function() {};
});

return DOMLayer;
});

define('graphing/poilabelslayer',['require','pjs','jquery','./domlayer','./label','graphing/graphmode','math/poi'],function(require){
  var P = require('pjs');
  var $ = require('jquery');
  var DOMLayer = require('./domlayer');
  var Label = require('./label');
  var GRAPHMODE = require('graphing/graphmode');
  var POITYPE = require('math/poi');

var POILabelsLayer = P(DOMLayer, function(layer, _super){

    layer.init = function (width, height, $root) {
      _super.init.call(this, width, height, $root);
      this.$.addClass('dcg-poi-labels-layer');
    };

    layer.redraw = function (projection, graphSketches) {

      // make sure that this is the correct size
      this.resize(projection.screen.width, projection.screen.height);

      // Clear out the drawing area
      this.dom_node.find('.dcg-poi').remove();

      // check if an old hoveredPOI was set and clear it out if so
      var hoveredPOI = this.hoveredPOI;
      var hoveredSketch = hoveredPOI ? hoveredPOI.sketch : null;
      var foundHoveredSketch = false;

      // Iterate through each graphSketch, find the opened poi and draw them
      // also saves which ones were drawn.
      var savedPOI = [];
      for (var id in graphSketches) {
        var sketch = graphSketches[id];
        if (sketch === hoveredSketch) foundHoveredSketch = true;
        if (!sketch.visible) continue;

        var pois = POILabelsLayer.drawOpenPOI(sketch, this.dom_node, projection);
        if (pois.length) {
          savedPOI.push.apply(savedPOI,pois);
        }
      }

      // we had a hoveredPOI set but the sketch isn't there any more. clear out
      // the hoverdPOI property.
      if (!foundHoveredSketch) {
        hoveredPOI = this.hoveredPOI = null;
      }

      if (hoveredPOI && hoveredPOI.sketch.visible) {

        if (!hoveredPOI.isOpen()) {
          POILabelsLayer.drawHoveredPOI(this.dom_node, hoveredPOI, projection);
          this.addGlobalClass('dcg-mouse-over-closed-poi');
        } else {
          this.addGlobalClass('dcg-mouse-over-opened-poi');
        }

      } else {

         this.removeGlobalClass('dcg-mouse-over-closed-poi');
         this.removeGlobalClass('dcg-mouse-over-opened-poi');

      }

      this.savedPOI = savedPOI;
    };

    layer.getDrawnPOI = function () {
      return this.savedPOI || [];
    };

});

POILabelsLayer.getPointLabel = function(poi_in, viewport) {
  var xscale = viewport.xmax - viewport.xmin;
  var yscale = viewport.ymax - viewport.ymin;
  var labels;
  var graphMode = poi_in.getGraphMode();

  if (graphMode === GRAPHMODE.XYPOINT || graphMode === GRAPHMODE.XYPOINT_MOVABLE) {

    labels = [
      Label.value(poi_in.x, xscale),
      Label.value(poi_in.y, yscale)
    ];

  } else {

    var flip = graphMode === GRAPHMODE.X;
    var independent = (flip) ? poi_in.y : poi_in.x;
    var fn = poi_in.getCompiledFunction();
    labels = Label.point(independent, xscale, yscale, fn);

    if (flip) {
      var tmp = labels[0];
      labels[0] = labels[1];
      labels[1] = tmp;
    }

  }
  var x_label = (
    labels[0].superscript ? labels[0].mantissa + '<sup>' + labels[0].superscript + '</sup>' : labels[0].string
  );
  var y_label = (
    labels[1].superscript ? labels[1].mantissa + '<sup>' + labels[1].superscript + '</sup>' : labels[1].string
  );
  return {
    x: labels[0].value,
    x_label: x_label,
    y: labels[1].value,
    y_label: y_label,
    is_hole: !isFinite(labels[1].value)
  };
};

// TODO - cleanup. Copied and modified from main/grapher.js
POILabelsLayer.createSinglePOI = function(poi_in, viewport) {

  var pt = POILabelsLayer.getPointLabel(poi_in, viewport);
  var hole = pt.is_hole ? ' dcg-hole' : '';
  var real = poi_in.type === POITYPE.DEFINITION ? ' dcg-real' : '';

  var x_label = pt.x_label.replace("", "<span class='dcg-pi'></span>");
  var y_label = pt.y_label.replace("", "<span class='dcg-pi'></span>");

  return $(
    '<div class="dcg-tracept dcg-poi' + hole + real +'">' +
    '  <div class="dcg-pt"></div>' +
    '  <div class="dcg-label">'+ x_label + ', ' + y_label + '</div>' +
    '  <div class="dcg-arrow""></div>' +
    '</div>'
  );
};

POILabelsLayer.drawHoveredPOI = function (dom, poi, projection) {
  var screen_x = projection.mapx(poi.x);
  var screen_y = projection.mapy(poi.y);

  // ensure is on screen. TODO - duplicate of code elsewhere. Might want to centralize that.
  if (
    screen_x > -20 && screen_y > -20 &&
    screen_x < projection.screen.width + 20 && screen_y < projection.screen.height + 20
  ) {
    var dom_poi = POILabelsLayer.createSinglePOI(poi, projection.viewport);
    dom_poi.css({
      left: screen_x + "px",
      top: screen_y + "px"
    });
    dom_poi.addClass('dcg-mouseover');
    dom.append(dom_poi);
  }

};

POILabelsLayer.drawOpenPOI = function (sketch, dom, projection) {

  var pois = sketch.openPOI;
  if (!pois.length) return [];

  var poiOnScreen = [];
  for (var i=0; i<pois.length; i++) {
    var poi = pois[i];
    var screen_x = projection.mapx(poi.x);
    var screen_y = projection.mapy(poi.y);

    // ensure is on screen. TODO - duplicate of code elsewhere. Might want to centralize that.
    if (
      screen_x > -20 && screen_y > -20 &&
      screen_x < projection.screen.width + 20 && screen_y < projection.screen.height + 20
    ) {
      var dom_poi = POILabelsLayer.createSinglePOI(poi, projection.viewport);
      dom_poi.css({
        left: screen_x + "px",
        top: screen_y + "px"
      });
      dom_poi.addClass('dcg-opened');

      dom.append(dom_poi);
      poiOnScreen.push(poi);
    }
  }

  return poiOnScreen;
};

return POILabelsLayer;
});

define('graphing/stepnumber',['require','pjs'],function(require){
var P = require('pjs');

// a reference to a ctx to do measurements on. Shared between
// all instances of StepNumber
var STATIC_CTX = document.createElement('canvas').getContext('2d');

var StepNumber = P(function(proto){

  proto.init = function (label, fontSize) {
    this._label = label;
    this._fontSize = fontSize;
    this._layout = this._computeLayout(label, fontSize);
  };

  // TODO - memoize
  // the layout assumes text is centered both vertically and horizontall when drawn on the ctx.
  // That's why width/2 and height/2 is used so often.
  proto._computeLayout = function (label, fontSize) {
    var layout = {};

    if (label.superscript) {

      layout.mantissa_height = fontSize;
      StepNumber.setCtxFontSize(STATIC_CTX, layout.mantissa_height);
      layout.mantissa_width = STATIC_CTX.measureText(label.mantissa).width;

      layout.superscript_height = Math.round(0.8 * fontSize);
      StepNumber.setCtxFontSize(STATIC_CTX, layout.superscript_height);
      layout.superscript_width = STATIC_CTX.measureText(label.superscript).width;

      layout.mantissa_x = 0;
      layout.mantissa_y = fontSize / 5;
      layout.superscript_x = layout.mantissa_width / 2 + layout.superscript_width / 2;
      layout.superscript_y = -fontSize / 4;

      layout.top = layout.superscript_y - layout.superscript_height / 2;
      layout.bottom = layout.mantissa_y + layout.mantissa_height / 2;
      layout.left = layout.mantissa_x - layout.mantissa_width / 2;
      layout.right = layout.superscript_x + layout.superscript_width / 2;

    } else {

      layout.mantissa_height = fontSize;
      StepNumber.setCtxFontSize(STATIC_CTX, fontSize);
      layout.mantissa_width = STATIC_CTX.measureText(label.string).width;

      layout.mantissa_x = 0;
      layout.mantissa_y = 0;

      layout.top = layout.mantissa_y - layout.mantissa_height / 2;
      layout.bottom = layout.mantissa_y + layout.mantissa_height / 2;
      layout.left = layout.mantissa_x - layout.mantissa_width / 2;
      layout.right = layout.mantissa_x + layout.mantissa_width / 2;

    }

    return layout;
  };

  proto.getRect = function () {
    return this.getRectWhenCenteredAt({x: 0, y: 0});
  };

  proto.getRectWhenCenteredAt = function (centerPt) {
    return {
      left: this._layout.left + centerPt.x,
      right: this._layout.right + centerPt.x,
      top: this._layout.top + centerPt.y,
      bottom: this._layout.bottom + centerPt.y
    };
  };

  proto.getWidth = function () {
    return this._layout.right - this._layout.left;
  };

  proto.getHeight = function () {
    return this._layout.bottom - this._layout.top;
  };

  proto.clampBoundsWithinRect = function (centerPt, rect) {
    var clampedCenterPt = {};

    if (centerPt.x + this._layout.left < rect.left) {
      clampedCenterPt.x = rect.left - this._layout.left;
    } else if (centerPt.x + this._layout.right > rect.right) {
      clampedCenterPt.x = rect.right - this._layout.right;
    } else {
      clampedCenterPt.x = centerPt.x;
    }

    if (centerPt.y + this._layout.top < rect.top) {
      clampedCenterPt.y = rect.top - this._layout.top;
    } else if (centerPt.y + this._layout.bottom > rect.bottom) {
      clampedCenterPt.y = rect.bottom - this._layout.bottom;
    } else {
      clampedCenterPt.y = centerPt.y;
    }

    return clampedCenterPt;
  };

  proto.getValue = function () {
    return this._label.value;
  };

  // TODO - memioze
  proto.getMinusWidth = function () {
    if (this.getValue() < 0) {
      StepNumber.setCtxFontSize(STATIC_CTX, this._fontSize);
      return STATIC_CTX.measureText("-1").width - STATIC_CTX.measureText("1").width;
    } else {
      return 0;
    }
  };

  proto.getString = function () {
    if (this._label.superscript) {
      return this._label.mantissa + '^' + this._label.superscript;
    } else {
      return this._label.string;
    }
  };

  proto.drawCenteredAt = function (ctx, centerPt) {
    var x = centerPt.x;
    var y = centerPt.y;

    ctx.save();
    StepNumber.setCtxFontSize(ctx, this._fontSize);

    if (this._label.superscript) {
      ctx.fillText(this._label.mantissa, this._layout.mantissa_x + x, this._layout.mantissa_y + y);
      ctx.fillText(this._label.superscript, this._layout.superscript_x + x, this._layout.superscript_y + y);
    } else {
      ctx.fillText(this._label.string, this._layout.mantissa_x + x, this._layout.mantissa_y + y);
    }

    ctx.restore();
  };

});

StepNumber.setCtxFontSize = function (ctx, fontSize) {
  ctx.font = fontSize + "px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
};

return StepNumber;
});

define('graphing/computestepsizes',['require','./stepnumber','./label'],function(require){
var StepNumber = require('./stepnumber');
var Label = require('./label');

var ComputeStepSizes = {};

var eachStep = function (min, max, step, func) {
  var nmin = Math.ceil(min/step);
  var nmax = Math.floor(max/step);
  var invstep = 1/step;
  if (nmin > nmax) return;
  // If step===0, this would loop forever. This is designed for drawing
  // gridlines to a screen, so it shouldn't need to use more steps than
  // there are pixels.
  if (nmax - nmin > 10000) return;
  for (var n = nmin; n <= nmax; n++) func(n/invstep);
};

ComputeStepSizes.RATIONAL_STEPS = {
  base: 10,
  major: [ 1, 2, 5 ],
  minor: [ 4, 4, 5 ]
};

ComputeStepSizes.PI_STEPS = {
  base: 10,
  major: [ Math.PI, 2*Math.PI, 5*Math.PI ],
  minor: [ 4, 4, 5 ]
};

ComputeStepSizes.PI_FRAC_STEPS = {
  base: 2,
  major: [ Math.PI/3 ],
  minor: [ 3 ]
};

function generateSteps(step) {
  if (!step) return ComputeStepSizes.RATIONAL_STEPS;

  return {
    base: 10,
    major: [step, 2*step, 5*step],
    minor: [4, 4, 5]
  };
}

// TODO - test
ComputeStepSizes.bestStep = function (exact, steps) {

  // JM: What does this mean...

  /* 1 + xrange/bestMultiple <= expectedX
  * xrange/(expectedX-1) <= bestMultiple
  * xrange/(expectedX-1) <= mult*base^exp
  * (xrange/expectedX-1) / mult <= base^exp
  * ceil(log((range/expectedX-1)/mult)/log(base)) = exp
  */
  var major, bestMajor = Infinity, bestMinor, exp, num;
  for (var i=0; i < steps.major.length; i++) {
    major = steps.major[i];
    exp = Math.ceil(Math.log(exact/major)/Math.log(steps.base));
    num = major*Math.pow(steps.base, exp);

    if (num < bestMajor) {
      bestMajor = num;
      bestMinor = bestMajor/steps.minor[i];
    }
  }

  return { major: bestMajor, minor: bestMinor };
};

// simply generate the labels and make sure there is space between them.
// TODO - test
ComputeStepSizes.countStepsInRange = function (min, max, step) {
  return 1 + (max - min) / step;
};

ComputeStepSizes.calculateSpaceBetweenRects = function (rect1, rect2) {
  var vertSpace;
  var horizSpace;

  if (rect1.right < rect2.left) {
    horizSpace = rect2.left - rect1.right;
  } else if (rect2.right < rect1.left) {
    horizSpace = rect1.left - rect2.right;
  } else {
    horizSpace = 0;
  }

  if (rect1.bottom < rect2.top) {
    vertSpace = rect2.top - rect1.bottom;
  } else if (rect2.bottom < rect1.top) {
    vertSpace = rect1.top - rect2.bottom;
  } else {
    vertSpace = 0;
  }

  return Math.max(vertSpace, horizSpace);
};

// assumes that each label takes up projection.settings.pixelsPerLabel
// in order to get a rough step size to start working with
ComputeStepSizes.estimateMajors = function (projection) {
  var width = projection.screen.width;
  var height = projection.screen.height;
  var xRange = projection.viewport.xmax - projection.viewport.xmin;
  var yRange = projection.viewport.ymax - projection.viewport.ymin;
  var pixelsPerLabel = projection.settings.pixelsPerLabel;

  return {
    majorStepX: pixelsPerLabel/width * xRange,
    majorStepY: pixelsPerLabel/height * yRange,
  };
};

// TODO - test
ComputeStepSizes.cartesian = function (projection) {
  /* jshint maxcomplexity:16 */
  var cartesianSteps = {};

  var xStep = Math.abs(projection.settings.xAxisStep);
  var yStep = Math.abs(projection.settings.yAxisStep);
  var xRange = projection.viewport.xmax - projection.viewport.xmin;
  var yRange = projection.viewport.ymax - projection.viewport.ymin;
  var xIsMultipleOfPi = Label.value(xStep, xRange).string.indexOf('') >= 0;
  var yIsMultipleOfPi = Label.value(yStep, yRange).string.indexOf('') >= 0;
  var numXLabels = ComputeStepSizes.countStepsInRange(projection.viewport.xmin, projection.viewport.xmax, xStep);
  var numYLabels = ComputeStepSizes.countStepsInRange(projection.viewport.ymin, projection.viewport.ymax, yStep);
  var estimatedMajors = ComputeStepSizes.estimateMajors(projection);
  var fontSize = projection.settings.labelSize;

  // if the step is exactly pi we want to fall through to legacy pi labels at the end
  if (xStep && xStep !== Math.PI) {
    if (numXLabels >= 3 && numXLabels < 100) {
      var maxWidth = 0;
      eachStep(projection.viewport.xmin, projection.viewport.xmax, xStep, function (step) {
        var stepNumber = StepNumber(Label.value(step, xRange), fontSize);
        maxWidth = Math.max(stepNumber.getWidth(), maxWidth);
      });

      // check if there's enough room to fit this many labels with a little padding
      if (numXLabels * (maxWidth + 10) <= projection.screen.width) {
        cartesianSteps.majorStepX = xStep;
        cartesianSteps.minorStepX = xStep / 4;
      }
    }
  }

  // if the step is exactly pi we want to fall through to legacy pi labels at the end
  if (yStep && yStep !== Math.PI) {
    if (numYLabels >= 3 && numYLabels < 100) {
      var maxHeight = 0;
      eachStep(projection.viewport.ymin, projection.viewport.ymax, yStep, function (step) {
        var stepNumber = StepNumber(Label.value(step, yRange), fontSize);
        maxHeight = Math.max(stepNumber.getHeight(), maxHeight);
      });

      // check if there's enough room to fit this many labels with a little padding
      if (numYLabels * (maxHeight + 10) <= projection.screen.height) {
        cartesianSteps.majorStepY = yStep;
        cartesianSteps.minorStepY = yStep / 4;
      }
    }
  }

  // either the user didn't define an xstep or the user defined an inappropriate xstep.
  if (!cartesianSteps.majorStepX) {
    var defaultXSteps;
    if (xIsMultipleOfPi) {
      if (estimatedMajors.majorStepX >= 1) {
        defaultXSteps = ComputeStepSizes.PI_STEPS;
      } else {
        defaultXSteps = ComputeStepSizes.PI_FRAC_STEPS;
      }
    } else {
      defaultXSteps = generateSteps(xStep);
    }

    var defaultXLabels = ComputeStepSizes.bestStep(estimatedMajors.majorStepX, defaultXSteps);
    cartesianSteps.majorStepX = defaultXLabels.major;
    cartesianSteps.minorStepX = defaultXLabels.minor;
  }

  // either the user didn't define an ystep or the user defined an inappropriate ystep.
  if (!cartesianSteps.majorStepY) {
    var defaultYSteps;
    if (yIsMultipleOfPi) {
      if (estimatedMajors.majorStepY >= 1) {
        defaultYSteps = ComputeStepSizes.PI_STEPS;
      } else {
        defaultYSteps = ComputeStepSizes.PI_FRAC_STEPS;
      }
    } else {
      defaultYSteps = generateSteps(yStep);
    }

    var defaultYLabels = ComputeStepSizes.bestStep(estimatedMajors.majorStepY, defaultYSteps);
    cartesianSteps.majorStepY = defaultYLabels.major;
    cartesianSteps.minorStepY = defaultYLabels.minor;
  }

  // If the axes have similar extents, prefer to choose the same steps for
  // x and y. Could both be undefined or defined to same number
  if (xStep === yStep) {
    var maxRatio = 2;
    var pixel_scale_ratio = (projection.screen.width / xRange) / (projection.screen.height / yRange);
    if (pixel_scale_ratio >= 1 && pixel_scale_ratio <= maxRatio) {
      cartesianSteps.majorStepX = cartesianSteps.majorStepY;
      cartesianSteps.minorStepX = cartesianSteps.minorStepY;
    } else if( pixel_scale_ratio <= 1 && pixel_scale_ratio >= 1/maxRatio ) {
      cartesianSteps.majorStepY = cartesianSteps.majorStepX;
      cartesianSteps.minorStepY = cartesianSteps.minorStepX;
    }
  }

  return cartesianSteps;
};

ComputeStepSizes.polar = function (projection) {
  var estimatedStepSizes = ComputeStepSizes.estimateMajors(projection);
  var bestX = ComputeStepSizes.bestStep(estimatedStepSizes.majorStepX, ComputeStepSizes.RATIONAL_STEPS);
  var bestY = ComputeStepSizes.bestStep(estimatedStepSizes.majorStepY, ComputeStepSizes.RATIONAL_STEPS);
  var bestR = bestX.major > bestY.major ? bestX : bestY;

  return {
    majorStepR: bestR.major,
    minorStepR: bestR.minor
  };
};

return ComputeStepSizes;
});

define('graphing/gridlayer',['require','pjs','./canvaslayer','./stepnumber','./label','./computestepsizes'],function(require){
var P = require('pjs');
var CanvasLayer = require('./canvaslayer');
var StepNumber = require('./stepnumber');
var Label = require('./label');
var ComputeStepSizes = require('./computestepsizes');

var GridLayer = P(CanvasLayer, function(layer){

  layer.redraw = function (projection, scaleAxis) {
    var screen = projection.screen;
    // make sure that this is the correct size
    this.resize(screen.width, screen.height);
    // Clear out the drawing area
    this.ctx.clearRect(0, 0, screen.width, screen.height);
    this.redrawToCtx(this.ctx, projection, scaleAxis);
  };

  layer.redrawToCtx = function (ctx, projection, scaleAxis) {

    if (projection.settings.polarMode) {
      projection.settings.setProperty('computedStepSizes', ComputeStepSizes.polar(projection));
    } else {
      projection.settings.setProperty('computedStepSizes', ComputeStepSizes.cartesian(projection));
    }

    if (projection.settings.showGrid) {
      if (projection.settings.polarMode) {
        this.drawPolarGrid(ctx, projection);
       } else {
        this.drawCartesianGrid(ctx, projection);
      }
    }

    this.drawAxes(ctx, projection, scaleAxis);

    var numberBounds;
    if (projection.settings.polarMode) {
      numberBounds = this.drawPolarStepNumbers(ctx, projection);
      this.drawLabels(ctx, projection, numberBounds);
    } else {
      numberBounds = this.drawCartesianStepNumbers(ctx, projection);
      this.drawLabels(ctx, projection, numberBounds);
    }
  };

  layer.addTextShadow = function(ctx) {
    ctx.shadowBlur = 4;
    ctx.shadowColor = "white";
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
  };

  layer.drawPolarGrid = function (ctx, projection) {
    var stepSizes = projection.settings.computedStepSizes;
    var minorOpacity = projection.settings.minorAxisOpacity;
    var majorOpacity = projection.settings.majorAxisOpacity;
    var adjustedMajorOpacity = 1 - (1 - majorOpacity)/(1 - minorOpacity);

    var x = Math.round(projection.mapx(0)) - 0.5;
    var y = Math.round(projection.mapy(0)) - 0.5;
    var rh = projection.screen.height/(projection.viewport.ymax-projection.viewport.ymin);
    var rw = projection.screen.width/(projection.viewport.xmax-projection.viewport.xmin);
    var scale = rh/rw;
    var y_scaled = y/scale;
    var rmin = projection.viewport.smallestR();
    var rmax = projection.viewport.largestR();

    // we don't want to draw from stepSizes.minorStepR if the origin is way off
    // the screen. We figure out the first multiples of minorStepR and
    // majorStepR that are visible (or nearly visible).
    var firstMinorStepR = stepSizes.minorStepR * Math.max(1, Math.floor(rmin/stepSizes.minorStepR));
    var firstMajorStepR = stepSizes.majorStepR * Math.max(1, Math.floor(rmin/stepSizes.majorStepR));

    // minor circles
    ctx.save();
    ctx.scale(1, scale);
    ctx.beginPath();
    eachStep(firstMinorStepR, rmax, stepSizes.minorStepR, function (value) {
      var r = projection.mapx(value) - x;
      ctx.moveTo(x+r, y_scaled);
      ctx.arc(x, y_scaled, r, 0, 2 * Math.PI);
    });
    ctx.restore();
    ctx.lineWidth=1;
    ctx.strokeStyle = "rgba(0, 0 , 0, " + minorOpacity + ")";
    ctx.stroke();

    // minor radial lines
    ctx.beginPath();
    //if rmin > 0, the origin is offscreen. tacky, but use this as the cue to double-up the lines
    var rInterval = (rmin > 0 ? 5 : 15);
    eachStep(0, 359, rInterval, function (degrees) {
      ctx.moveTo(x,y);
      var x_px = projection.mapx(rmax * Math.cos(degrees*Math.PI/180));
      var y_px = projection.mapy(rmax * Math.sin(degrees*Math.PI/180));
      ctx.lineTo(Math.round(x_px) - 0.5, Math.round(y_px) - 0.5);
    });
    ctx.stroke();

    // major circles
    ctx.save();
    ctx.scale(1, scale);
    ctx.beginPath();
    eachStep(firstMajorStepR, rmax, stepSizes.majorStepR, function (value) {
      var r = projection.mapx(value) - x;
      ctx.moveTo(x+r, y_scaled);
      ctx.arc(x, y_scaled, r, 0, 2 * Math.PI);
    });
    ctx.restore();
    ctx.lineWidth=1;
    ctx.strokeStyle = "rgba(0, 0 , 0, " + adjustedMajorOpacity + ")";
    ctx.stroke();

    // major radial lines
    ctx.beginPath();
    eachStep(0, 360-15, 90, function (degrees) {
      ctx.moveTo(x,y);
      var x_px = projection.mapx(rmax * Math.cos(degrees*Math.PI/180));
      var y_px = projection.mapy(rmax * Math.sin(degrees*Math.PI/180));
      ctx.lineTo(Math.round(x_px) - 0.5, Math.round(y_px) - 0.5);
    });
    ctx.stroke();

  };

  layer.drawCartesianGrid = function (ctx, projection) {
    var stepSizes = projection.settings.computedStepSizes;

    var xmin = projection.viewport.xmin, ymin = projection.viewport.ymin;
    var xmax = projection.viewport.xmax, ymax = projection.viewport.ymax;

    var width = projection.screen.width;
    var height = projection.screen.height;

    var minorOpacity = projection.settings.minorAxisOpacity;
    var majorOpacity = projection.settings.majorAxisOpacity;

    ctx.lineWidth = 1;

    // Minor gridlines

    ctx.beginPath();

    ctx.strokeStyle = "rgba(0, 0 , 0, " + minorOpacity + ")";

    eachStep(xmin, xmax, stepSizes.minorStepX, function (value) {
      var pixelValue = Math.round(projection.mapx(value));
      if (pixelValue === width) return;
      ctx.moveTo(pixelValue - 0.5, 0);
      ctx.lineTo(pixelValue - 0.5, height);
    });

    eachStep(ymin, ymax, stepSizes.minorStepY, function (value) {
      var pixelValue = Math.round(projection.mapy(value));
      if (pixelValue === height) return;
      ctx.moveTo(0, pixelValue - 0.5);
      ctx.lineTo(width, pixelValue - 0.5);
    });

    ctx.stroke();

    // Major gridlines

    ctx.beginPath();
    // Compensate for double stroking major gridlines. Strokes opacities
    // compose as o3 = 1 - (1 - o1)(1 - o2). We know what we've stroked so
    // far (o1), and what final stroke we'd like (o3), so solve for o2:
    // o2 = 1 - (1 - o3)/(1 - o1).
    var adjustedMajorOpacity = 1 - (1 - majorOpacity)/(1 - minorOpacity);
    ctx.strokeStyle = "rgba(0, 0 , 0, " + adjustedMajorOpacity + ")";

    eachStep(xmin, xmax, stepSizes.majorStepX, function (value) {
      var pixelValue = Math.round(projection.mapx(value));
      if (pixelValue === width) return;
      ctx.moveTo(pixelValue - 0.5, 0);
      ctx.lineTo(pixelValue - 0.5, height);
    });

    eachStep(ymin, ymax, stepSizes.majorStepY, function (value) {
      var pixelValue = Math.round(projection.mapy(value));
      if (pixelValue === height) return;
      ctx.moveTo(0, pixelValue - 0.5);
      ctx.lineTo(width, pixelValue - 0.5);
    });

    ctx.stroke();

  };

  layer.drawAxes = function(ctx, projection, scaleAxis) {
    var lineOffset = projection.settings.axisLineOffset;
    var axisOpacity = projection.settings.axisOpacity.toString();

    var scaleAxisStyle = "rgba(127,205,230," + axisOpacity + ")";
    var normalAxisStyle = "rgba(0,0,0," + axisOpacity + ")";
    var xAxisArrows = projection.settings.xAxisArrows;
    var yAxisArrows = projection.settings.yAxisArrows;
    var showXAxis = projection.settings.showXAxis;
    var showYAxis = projection.settings.showYAxis;

    var scaleAxisMultiplier = 3;

    var pixelX = Math.round(projection.mapx(0)) - lineOffset;
    var pixelY = Math.round(projection.mapy(0)) - lineOffset;
    var height = projection.screen.height;
    var width = projection.screen.width;

    function drawArrow (x,y,angle) {
      var angleOffset = Math.PI/6;
      var hyp = 8*ctx.lineWidth;
      ctx.moveTo(x + Math.cos(angle-angleOffset)*hyp, y + Math.sin(angle-angleOffset)*hyp);
      ctx.lineTo(x,y);
      ctx.lineTo(x + Math.cos(angle+angleOffset)*hyp, y + Math.sin(angle+angleOffset)*hyp);
    }

    if (showYAxis) {
      ctx.lineWidth = projection.settings.axisLineWidth * (scaleAxis === 'y' ? scaleAxisMultiplier : 1);
      ctx.strokeStyle = scaleAxis === 'y' ? scaleAxisStyle : normalAxisStyle;
      ctx.beginPath();
      ctx.moveTo(pixelX, 0);
      ctx.lineTo(pixelX, height);
      if (yAxisArrows === 'both') {
        drawArrow(pixelX, height, 3*Math.PI/2);
        drawArrow(pixelX, 0, Math.PI/2);
      } else if (yAxisArrows === 'positive') {
        drawArrow(pixelX, 0, Math.PI/2);
      }
      ctx.stroke();
    }

    if (showXAxis) {
      ctx.lineWidth = projection.settings.axisLineWidth * (scaleAxis === 'x' ? scaleAxisMultiplier : 1);
      ctx.strokeStyle = scaleAxis === 'x' ? scaleAxisStyle : normalAxisStyle;
      ctx.beginPath();
      ctx.moveTo(0, pixelY);
      ctx.lineTo(width, pixelY);
      if (xAxisArrows === 'both') {
        drawArrow(0, pixelY, 0);
        drawArrow(width, pixelY, Math.PI);
      } else if (xAxisArrows === 'positive') {
        drawArrow(width, pixelY, Math.PI);
      }
      ctx.stroke();
    }

  };


  layer.drawPolarStepNumbers = function (ctx, projection) {
    ctx.save();
    var showGrid = projection.settings.showGrid;
    var showXNumbers = projection.settings.xAxisNumbers && projection.settings.showXAxis;
    var showYNumbers = projection.settings.yAxisNumbers && projection.settings.showYAxis;
    var showPolarNumbers = showGrid && projection.settings.polarNumbers;
    var stepSizes = projection.settings.computedStepSizes;

    var rmax = projection.viewport.largestR();
    var rmin = projection.viewport.smallestR();
    var xmin = projection.viewport.xmin, xmax = projection.viewport.xmax;
    var ymin = projection.viewport.ymin, ymax = projection.viewport.ymax;
    var width = projection.screen.width;
    var height = projection.screen.height;
    var screenRect = {left: 3, right: width - 3, top: 3, bottom: height - 3};

    var hangingColor = projection.settings.labelHangingColor;
    var normalColor = projection.settings.labelNormalColor;

    var fontSize = projection.settings.labelSize;
    var textHeight = fontSize;

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.addTextShadow(ctx);
    ctx.font = fontSize.toString() + "px Arial";
    ctx.fillStyle = normalColor;

    function intersectX (r, bounds, numbers) {
      var y = Math.sqrt(r*r-bounds*bounds);
      if (ymin <= y && y <= ymax) {
        numbers.push({x: projection.mapx(bounds), y: projection.mapy(y)});
      }
      if (ymin <= -y && -y <= ymax) {
        numbers.push({x: projection.mapx(bounds), y: projection.mapy(-y)});
      }
    }

    function intersectY (r, bounds, numbers) {
      var x = Math.sqrt(r*r-bounds*bounds);
      if (xmin <= x && x <= xmax) {
        numbers.push({x: projection.mapx(x), y: projection.mapy(bounds)});
      }
      if (xmin <= -x && -x <= xmax) {
        numbers.push({x: projection.mapx(-x), y: projection.mapy(bounds)});
      }
    }

    var xAxis = projection.mapx(0);
    var yAxis = projection.mapy(0);

    // if the axis is on screen add labels for it
    var xAxisIsWithinViewport = ymin <= 0 && 0 <= ymax;
    var yAxisIsWithinViewport = xmin <= 0 && 0 <= xmax;
    var addXNumbers = xAxisIsWithinViewport && showXNumbers;
    var addYNumbers = yAxisIsWithinViewport && showYNumbers;
    var addEdgeNumbers = '';

    // neither axis is on the screen
    if (!addXNumbers && !addYNumbers && showGrid) {

      // figure out which edge is closest to an axis
      var leftDistance = Math.abs(xAxis);
      var rightDistance = Math.abs(xAxis-width);
      var topDistance = Math.abs(yAxis);
      var bottomDistance = Math.abs(yAxis-height);

      var leftRightWinner, topBottomWinner, leftRightDis, topBottomDis;

      if (leftDistance <= rightDistance) {
        leftRightWinner = 'left';
        leftRightDis = leftDistance;
      } else {
        leftRightWinner = 'right';
        leftRightDis = rightDistance;
      }

      if (topDistance <= bottomDistance) {
        topBottomWinner = 'top';
        topBottomDis = topDistance;
      } else {
        topBottomWinner = 'bottom';
        topBottomDis = bottomDistance;
      }

      if (showXNumbers && showYNumbers) {
        addEdgeNumbers = leftRightDis <= topBottomDis ? leftRightWinner : topBottomWinner;
      } else if (showYNumbers) {
        addEdgeNumbers = leftRightWinner;
      } else if (showXNumbers) {
        addEdgeNumbers = topBottomWinner;
      }
    }

    // the space taken up by the numbers. the axis labels will use this stepSizesrmation
    // to figure out where to jump to.
    var xBounds = {left: 0, right: width, top: yAxis-1, bottom: yAxis+1};
    var yBounds = {left: xAxis-1, right: xAxis+1, top: 0, bottom: height};

    // label each circle where it crosses the x axis, the y axis, and
    // whenever it leaves or enters the viewport.
    eachStep(0, rmax, stepSizes.majorStepR, function (r) {
      /* jshint maxcomplexity:12 */
      var xNumbers = [];
      var yNumbers = [];
      var edgeNumbers = [];

      var stepNumber = StepNumber(Label.value(r, rmax), fontSize);
      var rect = stepNumber.getRect();

      if (r > 0) {
        // check if circle intersects positive y axis
        if (addYNumbers && ymin <= r && r <= ymax) {
          yNumbers.push({x: xAxis - rect.right - 5, y: projection.mapy(r)});
        }

        // check if circle intersects negative y axis
        if (addYNumbers && ymin <= -r && -r <= ymax) {
          yNumbers.push({x: xAxis - rect.right - 5, y: projection.mapy(-r)});
        }

        // check if circle intersects positive x axis
        if (addXNumbers && xmin <= r && r <= xmax) {
          xNumbers.push({x: projection.mapx(r), y: yAxis - rect.top + 3});
        }

        // check if circle intersects negative x axis
        if (addXNumbers && xmin <= -r && -r <= xmax) {
          xNumbers.push({x: projection.mapx(-r), y: yAxis - rect.top + 3});
        }
      }

      // only show 0 if one of the axes are turned off
      else {
        if (addYNumbers && !showXNumbers && ymin <= r && r <= ymax) {
          yNumbers.push({x: xAxis - rect.right - 5, y: projection.mapy(r)});
        } else if (addXNumbers && !showYNumbers && xmin <= r && r <= xmax) {
          xNumbers.push({x: projection.mapx(r), y: yAxis - rect.top + 3});
        }
      }

      // if we're supposed to add numbers to an edge, do it
      switch (addEdgeNumbers) {
        case "top":
          intersectY(r, ymax, edgeNumbers);
          break;

        case "bottom":
          intersectY(r, ymin, edgeNumbers);
          break;

        case "left":
          intersectX(r, xmin, edgeNumbers);
          break;

        case "right":
          intersectX(r, xmax, edgeNumbers);
          break;
      }

      xNumbers.forEach(function (centerPt) {
        centerPt = stepNumber.clampBoundsWithinRect(centerPt, screenRect);
        stepNumber.drawCenteredAt(ctx, centerPt);
        expandBounds(xBounds, stepNumber.getRectWhenCenteredAt(centerPt));
      });

      yNumbers.forEach(function (centerPt) {
        centerPt = stepNumber.clampBoundsWithinRect(centerPt, screenRect);
        stepNumber.drawCenteredAt(ctx, centerPt);
        expandBounds(yBounds, stepNumber.getRectWhenCenteredAt(centerPt));
      });

      edgeNumbers.forEach(function (centerPt) {
        centerPt = stepNumber.clampBoundsWithinRect(centerPt, screenRect);
        stepNumber.drawCenteredAt(ctx, centerPt);
      });
    });

    if (showPolarNumbers) {
      // figure out which circle to label radial lines along.
      // Rule here: halfway between the largest and smallest r (rmin and rmax).
      // not scientific. Round up. Let's see how it feels

      // 0 => 0th circle. 1 => first circle, etc;
      var minRadNum = Math.ceil(rmin / stepSizes.majorStepR);
      var maxRadNum = Math.floor(rmax / stepSizes.majorStepR);
      var radiusNum = Math.ceil((minRadNum + maxRadNum)/2);
      var radial_label_radius = radiusNum * stepSizes.majorStepR;


      //if rmin > 0, the origin is offscreen. tacky, but use this as the cue to double-up the lines
      var rInterval = (rmin > 0 ? 15 : 30);

      // label radial lines
      eachStep(0, 359, rInterval, function (degrees) {
        var string;
        if (projection.settings.degreeMode) {
          string = degrees.toString() + "";
        } else {
          string = Label.value(degrees*Math.PI/180, 2*Math.PI).string;
        }

        var textHalfWidth = ctx.measureText(string).width/2;
        var r = radial_label_radius / 1.05;

        var x = r * Math.cos(degrees*Math.PI/180);
        var y = r * Math.sin(degrees*Math.PI/180);

        // only draw numbers that are on the screen
        if (x < xmin || x > xmax|| y < ymin || y > ymax) return;

        var pixelX = projection.mapx(x);
        var pixelY = projection.mapy(y);

        // some adjustments to the numbers along the axes
        if (degrees === 0 || degrees === 180) {
          pixelY -= textHeight;
        } else if (degrees === 90 || degrees === 270) {
          pixelX += textHalfWidth+3;
        }

        var clampedPixelX = clamp(pixelX, 3 + textHalfWidth, width - 3 - textHalfWidth);
        var clampedPixelY = clamp(pixelY, 3 + textHeight, height - 3 - textHeight);

        ctx.fillStyle = hangingColor;
        ctx.fillText(string, clampedPixelX, clampedPixelY);
      });
    }
    ctx.restore();
    return {
      x: xBounds,
      y: yBounds
    };
  };

  layer.drawLabels = function (ctx, projection, numberBounds) {
    /* jshint maxcomplexity:11 */
    var xmin = projection.viewport.xmin, xmax = projection.viewport.xmax;
    var ymin = projection.viewport.ymin, ymax = projection.viewport.ymax;
    var width = projection.screen.width;
    var height = projection.screen.height;
    var xscale = (xmax - xmin) / width;
    var yscale = (ymax - ymin) / height;
    var normalColor = projection.settings.labelNormalColor;
    var xAxis = projection.mapx(0);
    var yAxis = projection.mapy(0);
    var fontSize = projection.settings.labelSize;

    //labelEdgePadding is the distance from the edge of the viewport along the label
    var labelEdgePadding = 15;

    var labelFontSize = Math.round(fontSize * 1.25);
    var xLabel = projection.settings.showXAxis && projection.settings.xAxisLabel;
    var yLabel = projection.settings.showYAxis && projection.settings.yAxisLabel;
    var xBounds = numberBounds.x;
    var yBounds = numberBounds.y;

    if (xLabel && xBounds) {
      ctx.save();
      ctx.font = labelFontSize.toString() + "px Arial";

      this.addTextShadow(ctx);
      ctx.fillStyle = normalColor;
      var xLabelPosition;

      if (ctx.__xLabelOffset && projection.settings.isViewportTransient) {
        if (approxEqual(ctx.__xLabelOffset.xscale, xscale) && approxEqual(ctx.__xLabelOffset.yscale, yscale)) {
          xLabelPosition = {x: ctx.__xLabelOffset.x + xAxis, y: ctx.__xLabelOffset.y + yAxis};
        }
      }

      if (!xLabelPosition) {
        var xWidth = ctx.measureText(xLabel).width;
        var xLeft = width - xWidth - labelEdgePadding;
        var xHeight = labelFontSize;

        // there is space below the numbers, draw the label there
        if (xBounds.bottom + xHeight < height) {
          xLabelPosition = {x: xLeft, y: xBounds.bottom + xHeight};
        }
        // there isn't space below the numbers, so draw above them
        else {
          //I don't know why we want xHeight/2 here. It fixes
          //behavior in projector & regular mode though. Otherwise,
          //when floated on top of the x-axis, the label was too far away
          xLabelPosition = {x: xLeft, y: xBounds.top - xHeight/2};
        }

        ctx.__xLabelOffset = {
          x: xLabelPosition.x - xAxis,
          y: xLabelPosition.y - yAxis,
          xscale: xscale,
          yscale: yscale
        };
      }
      ctx.fillText(xLabel, xLabelPosition.x, xLabelPosition.y);
      ctx.restore();
    } else {
      ctx.__xLabelPosition = null;
    }

    if (yLabel && yBounds) {
      ctx.save();

      this.addTextShadow(ctx);
      ctx.font = labelFontSize.toString() + "px Arial";
      ctx.fillStyle = normalColor;
      var yLabelPosition;

      if (ctx.__yLabelOffset && projection.settings.isViewportTransient) {
        if (approxEqual(ctx.__yLabelOffset.xscale, xscale) && approxEqual(ctx.__yLabelOffset.yscale, yscale)) {
          yLabelPosition = {x: ctx.__yLabelOffset.x + xAxis, y: ctx.__yLabelOffset.y + yAxis};
        }
      }

      if (!yLabelPosition) {
        var yHeight = ctx.measureText(yLabel).width;
        var yTop = 0 + labelEdgePadding + yHeight;
        var yWidth = labelFontSize;

        // there is space to the left of the numbers, draw the label there
        if (yBounds.left - yWidth > 0) {
          //I don't know why we want yWidth/2 here. It fixes
          //behavior in projector & regular mode though. Otherwise,
          //when floated on the left of the y-axis, it was too far away
          yLabelPosition = {x: yBounds.left - yWidth/2, y: yTop};
        }

        // there isn't space to the left of the numbers, so draw the label to the right of them
        else {
          yLabelPosition = {x: yBounds.right + yWidth, y: yTop};
        }

        ctx.__yLabelOffset = {
          x: yLabelPosition.x - xAxis,
          y: yLabelPosition.y - yAxis,
          xscale: xscale,
          yscale: yscale
        };
      }

      ctx.translate(yLabelPosition.x, yLabelPosition.y);
      ctx.rotate(-Math.PI/2);
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();
    } else {
      ctx.__yLabelPosition = null;
    }
  };

  layer.drawCartesianStepNumbers = function(ctx, projection) {
    ctx.save();

    var stepSizes = projection.settings.computedStepSizes;

    var showXAxis = projection.settings.showXAxis;
    var showYAxis = projection.settings.showYAxis;
    var drawXNumbers = showXAxis && projection.settings.xAxisNumbers;
    var drawYNumbers = showYAxis && projection.settings.yAxisNumbers;

    var xmin = projection.viewport.xmin, xmax = projection.viewport.xmax;
    var ymin = projection.viewport.ymin, ymax = projection.viewport.ymax;
    var width = projection.screen.width;
    var height = projection.screen.height;
    var screenRect = {left: 3, top: 3, right: width - 3, bottom: height - 3};

    var hangingColor = projection.settings.labelHangingColor;
    var normalColor = projection.settings.labelNormalColor;

    var xAxis = projection.mapx(0);
    var yAxis = projection.mapy(0);

    var fontSize = projection.settings.labelSize;
    this.addTextShadow(ctx);

    // the space taken up by the numbers. the axis labels will use this stepSizesrmation
    // to figure out where to jump to
    var xBounds = {left: 0, right: width, top: yAxis-1, bottom: yAxis+1};
    var yBounds = {left: xAxis-1, right: xAxis+1, top: 0, bottom: height};

    var zeroDrawn = false;
    if (showXAxis && showYAxis && (drawXNumbers || drawYNumbers)) {
      zeroDrawn = true;
      ctx.fillStyle = normalColor;

      var zeroStepNumber = StepNumber(Label.value(0,1), fontSize);

      zeroStepNumber.drawCenteredAt(ctx, {
        x: xAxis - zeroStepNumber.getRect().right - 5,
        y: yAxis - zeroStepNumber.getRect().top + 3
      });
    }

    if (drawXNumbers) {
      eachStep(xmin, xmax, stepSizes.majorStepX, function (step) {
        var stepNumber = StepNumber(Label.value(step, xmax - xmin), fontSize);
        var centerPt = {
          x: projection.mapx(stepNumber.getValue()) - stepNumber.getMinusWidth(),
          y: yAxis - stepNumber.getRect().top + 3
        };
        var clampedCenterPt = stepNumber.clampBoundsWithinRect(centerPt, screenRect);

        ctx.fillStyle = (centerPt.y === clampedCenterPt.y) ? normalColor : hangingColor;

        if (stepNumber.getString() === '0' && zeroDrawn) {
          return;
        }

        stepNumber.drawCenteredAt(ctx, clampedCenterPt);
        expandBounds(xBounds, stepNumber.getRectWhenCenteredAt(clampedCenterPt));
      });
    }

    if (drawYNumbers) {

      eachStep(ymin, ymax, stepSizes.majorStepY, function (step) {
        var stepNumber = StepNumber(Label.value(step, ymax - ymin), fontSize);
        var centerPt = {
          x: xAxis - 5 - stepNumber.getRect().right,
          y: projection.mapy(stepNumber.getValue())
        };
        var clampedCenterPt = stepNumber.clampBoundsWithinRect(centerPt, screenRect);

        ctx.fillStyle = (centerPt.x === clampedCenterPt.x) ? normalColor : hangingColor;

        if (stepNumber.getString() === '0' && zeroDrawn) {
          return;
        }

        stepNumber.drawCenteredAt(ctx, clampedCenterPt);
        expandBounds(yBounds, stepNumber.getRectWhenCenteredAt(clampedCenterPt));
      });
    }

    ctx.restore();

    return {
      x: xBounds,
      y: yBounds
    };
  };

});

var eachStep = function (min, max, step, func) {
  var nmin = Math.ceil(min/step);
  var nmax = Math.floor(max/step);
  var invstep = 1/step;
  if (nmin > nmax) return;
  // If step===0, this would loop forever. This is designed for drawing
  // gridlines to a screen, so it shouldn't need to use more steps than
  // there are pixels.
  if (nmax - nmin > 10000) return;
  for (var n = nmin; n <= nmax; n++) func(n/invstep);
};

var clamp = function (value, min, max) {
  if (value < min) return min;
  if (value > max) return max;
  return value;
};

var expandBounds = function (cumBounds, numBounds) {
  if (numBounds.left < cumBounds.left) cumBounds.left = numBounds.left;
  if (numBounds.right > cumBounds.right) cumBounds.right = numBounds.right;
  if (numBounds.top < cumBounds.top) cumBounds.top = numBounds.top;
  if (numBounds.bottom > cumBounds.bottom) cumBounds.bottom = numBounds.bottom;
};

var approxEqual = function (num1, num2) {
   var A = Math.abs(num1), B = Math.abs(num2), epsilon = 0.0001;
   return Math.abs(A - B) <= (A < B ? B : A) * epsilon;
};

return GridLayer;
});

define('graphing/poi',[], function(){

// This is a very coupled class. It should be used along side GraphSketch.
function POI(x, y, type, sketch, branch) {
  this.x = x;
  this.y = y;
  this.type = type;
  this.sketch = sketch;
  this.branch = branch;
}

POI.prototype.getGraphMode = function () {
  return this.sketch.branches[this.branch].graphMode;
};

POI.prototype.getCompiledFunction = function () {
  return this.sketch.branches[this.branch].compiled.fn;
};

POI.prototype.isOpen = function () {
  return this.sketch.openPOI.indexOf(this) >= 0;
};

POI.prototype.close = function () {
  var index = this.sketch.openPOI.indexOf(this);
  if (index === -1) return false;

  this.sketch.openPOI.splice(index,1);
  return true;
};

POI.prototype.open = function () {
  if (this.isOpen()) return false;

  this.sketch.openPOI.push(this);
  return true;
};

return POI;
});

define('graphing/graphsketch',['require','math/poi','./poi','math/distance','graphing/graphmode'],function(require){
  var POITYPE = require('math/poi');
  var POI = require('./poi');
  var Distance = require('math/distance');
  var GRAPHMODE = require('graphing/graphmode');

function GraphSketch (id, branches) {
  // mutable properties
  this.color = '#000000';
  this.style = 'normal';
  this.visible = true;
  this.showPOI = false;
  this.showHighlight = false;
  this.selected = false;
  this.openPOI = []; // the points that are opened and visible
  this.hiddenOpenPOI = []; // the points that were opened previously,
                           // but not mapped to screen any longer.
  // immutable properties
  this.id = id;
  this.branches = branches !== undefined ? branches : [];
}

// looks inside the branches and finds POI. Only needs to do this
// once because branches are immutable. This caches the results. Also
// note that this implementation postpones the conversion from one
// large array of numbers to array of objects until someone actually
// cares about this graphsketch's poi.
GraphSketch.prototype.getPOI = function () {

  if (this.__cachedPOI) return this.__cachedPOI;

  var branch, graphMode;
  this.__cachedPOI = [];
  for (var i=0; i<this.branches.length; i++) {
    branch = this.branches[i];
    graphMode = branch.graphMode;

    var pois = branch.poi;
    if (graphMode === GRAPHMODE.X || graphMode === GRAPHMODE.Y) {
      this._pushPOI(pois.zeros, i, POITYPE.ZERO);
      this._pushPOI(pois.intercept, i, POITYPE.INTERCEPT);
      this._pushPOI(pois.extrema, i, POITYPE.EXTREMUM);
      this._pushPOI(pois.intersections, i, POITYPE.INTERSECTION);
    } else if (graphMode === GRAPHMODE.XYPOINT || graphMode === GRAPHMODE.XYPOINT_MOVABLE) {
      this._pushPOI(pois.defined, i, POITYPE.DEFINITION);
    }
  }

  return this.__cachedPOI;
};

GraphSketch.prototype._pushPOI = function (pois, i, type) {
  if (!pois) return;

  for (var j=0, plen = pois.x.length; j < plen; j++) {

    var poi = new POI();
    poi.type = type;
    poi.x = pois.x[j];
    poi.y = pois.y[j];
    poi.branch = i;
    poi.sketch = this;
    if (pois.intersects) poi.intersects = pois.intersects[j];

    this.__cachedPOI.push(poi);
  }
};

GraphSketch.prototype.updateIntersections = function (intersections) {
  for (var i = 0, ilen = this.branches.length; i < ilen; i++) {
    this.branches[i].poi.intersections = intersections[i];
  }
  this.__cachedPOI = undefined;
  this.getPOI();
  this.reopenPOIFrom(this);
};

GraphSketch.prototype.updateFrom = function (sketch) {
  if (!sketch) return;

  this.visible = true;

  if (sketch.openPOI.length || sketch.hiddenOpenPOI.length) {
    this.reopenPOIFrom(sketch);
  }

  this.showPOI = sketch.showPOI;
  this.showHighlight = sketch.showHighlight;
  this.selected = sketch.selected;
};

// TODO - change all the cryptic variable names to meaningful names
GraphSketch.prototype.reopenPOIFrom = function (sketch) {
  /* jshint maxcomplexity:12 */
  var openPOI = [];
  var hiddenOpenPOI = [];
  var pois, n_pts, min, n_j, o_pt, n_pt;
  var t_poi, poi, poi_type;
  var i, j;

  var newPoints = {};
  var oldPoints = {};

  // categorize all new poi
  pois = this.getPOI();

  for (i=0; i<pois.length; i++) {
    poi = pois[i];
    poi_type = poi.type;

    if (!newPoints[poi_type]) {
      newPoints[poi_type] = [poi];
    } else {
      newPoints[poi_type].push(poi);
    }

  }

  // categorize all old poi
  pois = sketch.openPOI.concat(sketch.hiddenOpenPOI);
  for (i=0; i<pois.length; i++) {
    poi = pois[i];
    poi_type = poi.type;

    if (!oldPoints[poi_type]) {
      oldPoints[poi_type] = [poi];
    } else {
      oldPoints[poi_type].push(poi);
    }

  }

  // reopen the new points that were closest to the old opened points
  for (var type in oldPoints) {
    t_poi = oldPoints[type];
    n_pts = newPoints[type] || [];

    for (i = t_poi.length-1; i >= 0; i--) {
      o_pt = t_poi[i];
      min = Infinity;
      n_j = -1;

      for (j = n_pts.length-1; j>=0; j--) {
        n_pt = n_pts[j];
        if (!n_pt) continue;
        // Don't allow intersections to jump between functions.
        if (n_pt.intersects !== o_pt.intersects) continue;

        var dis = Distance.hypot(o_pt.x-n_pt.x, o_pt.y-n_pt.y);
        if (dis < min) {
          n_j = j;
          min = dis;
        }
      }

      if (n_j != -1) {
        openPOI.push(n_pts[n_j]); // open the poi again
        n_pts[n_j] = null;
      } else {
        hiddenOpenPOI.push(o_pt); // mark point as opened but not mapped to screen
      }
    }
  }

  this.openPOI = openPOI;
  this.hiddenOpenPOI = hiddenOpenPOI;
};

return GraphSketch;
});

define('graphing/imagelayer',['require','pjs','./canvaslayer','underscore'],function(require){
var P = require('pjs');
var CanvasLayer = require('./canvaslayer');
var _ = require('underscore');

var ImageLayer = P(CanvasLayer, function(layer){

  layer.redraw = function (projection, graphImages, drawOrder) {
    // Optimization for case when there are no images.
    var isEmpty = !_.size(graphImages);
    if (this.isEmpty && isEmpty) return;
    this.isEmpty = isEmpty;

    var screen = projection.screen;
    this.resize(screen.width, screen.height);
    this.ctx.save();
    this.ctx.clearRect(0, 0, screen.width, screen.height);
    this.ctx.strokeStyle = '#6993C7';
    this.ctx.lineWidth = 2;
    this.redrawToCtx(this.ctx, projection, graphImages, drawOrder);

    this.ctx.restore();
  };

  layer.redrawToCtx = function (ctx, projection, graphImages, drawOrder) {
    // Do the drawing of the segments
    if (drawOrder === undefined || drawOrder.length < _.size(graphImages)) {
      // If we don't have a drawOrder, or it doesn't include all of our graphSketches then make a new order.
      drawOrder = _.keys(graphImages);
    }

    // draw images in correct order
    var self = this;
    for (var i = 0; i<drawOrder.length; i++) {
      var image = graphImages[drawOrder[i]];
      if (image && image.shouldGraph) {
        self.drawImageToCtx(image, ctx, projection);
      }
    }
  };

  layer.drawImageToCtx = function (image, ctx, projection) {
    var img_x = image.computed_x;
    var img_y = image.computed_y;
    var img_width = image.computed_width;
    var img_height = image.computed_height;

    // check if values are all numbers
    if (!isFinite(img_x) || !isFinite(img_y) || !isFinite(img_width) || !isFinite(img_height)) {
      return;
    }

    ctx.globalAlpha = image.opacity;

    var height = projection.mapy(img_height) - projection.mapy(0);
    var width = projection.mapx(img_width) - projection.mapx(0);

    // calculate the topLeft given the center as input
    var x = projection.mapx(img_x) - width / 2;
    var y = projection.mapy(img_y) + height / 2;

    // We want to correctly invert any images with negative dimensions.
    // This means flipping the context, dimension and associated positioning.
    var yflip = (img_height < 0) ? -1 : 1;
    var xflip = (img_width < 0) ? -1 : 1;
    ctx.save();
    ctx.scale(xflip, yflip);

    var canvasX = x*xflip;
    var canvasY = y*yflip;
    var canvasW = Math.abs(width);
    var canvasH = Math.abs(height);

    ctx.drawImage(image.imageObj, canvasX, canvasY, canvasW, canvasH);
    if (image.selected) {
      ctx.beginPath();
      ctx.rect(canvasX, canvasY, canvasW, canvasH);
      ctx.stroke();
    }

    ctx.restore();
  };

});

return ImageLayer;
});

define('graphing/tracelayer',['require','pjs','./domlayer','./poi','./poilabelslayer'],function (require) {
  var P = require('pjs');
  var DOMLayer = require('./domlayer');
  var POI = require('./poi');
  var POILabelsLayer = require('./poilabelslayer');

  var TraceLayer = P(DOMLayer, function(layer, _super) {
    layer.init = function () {
      _super.init.apply(this, arguments);
      this.$.addClass('dcg-trace-layer');
    };

    layer.redraw = function (projection) {

      // make sure that this is the correct size
      this.resize(projection.screen.width, projection.screen.height);

      // Clear out the drawing area
      this.dom_node.find('.dcg-tracept').remove();

      var poi = this.traceInfo ? this.traceInfo.pt : null;
      if (!poi) return;

      var screen_x = projection.mapx(poi.x);
      var screen_y = projection.mapy(poi.y);

      // ensure is on screen. TODO - duplicate of code elsewhere. Might want to centralize that.
      if (
        screen_x > -20 && screen_y > -20 &&
        screen_x < projection.screen.width+20 && screen_y < projection.screen.height+20
      ) {

        // TODO - this is nasty. the createSinglePOI assumes that we pass in an
        //        instance of the POI class. traceInfo.pt is not a POI. Putting
        //        this here just to test tracing for now.
        var real_poi = new POI(poi.x,
                               poi.y,
                               POI.ZERO,
                               this.traceInfo.branchInfo.sketch,
                               this.traceInfo.branchInfo.branch);

        var dom_poi = POILabelsLayer.createSinglePOI(real_poi, projection.viewport);
        dom_poi.css({
          left: screen_x + "px",
          top: screen_y + "px"
        });
        dom_poi.addClass('dcg-temp');
        dom_poi.removeClass('dcg-poi');
        dom_poi.find('.dcg-pt').css('background-color', real_poi.sketch.color);
        dom_poi.find('.dcg-pt').css('border-color', real_poi.sketch.color);
        this.dom_node.append(dom_poi);

      }
    };
  });

  return TraceLayer;
});

define('graphing/movablepointslayer',['require','pjs','jquery','./domlayer','graphing/graphmode','browser'],function (require) {
  var P = require('pjs');
  var $ = require('jquery');
  var DOMLayer = require('./domlayer');
  var GRAPHMODE = require('graphing/graphmode');
  var Browser = require('browser');

  var MovablePointsLayer = P(DOMLayer, function(layer, _super){

    layer.init = function () {
      _super.init.apply(this, arguments);
      //collection of movablePoints that are rendered to the DOM
      // $ is a handle to the jquery element
      // shouldGarbageCollect is a flag
      //
      //We need to do this inside of init so that this object isn't
      //shared across graphs when we insert multiple graphs on a page
      //with the API
      this.renderedMovablePoints = {};
    };



    layer.redraw = function (projection, graphSketches) {
      /* jshint maxcomplexity:12 */
      // make sure that this is the correct size
      this.resize(projection.screen.width, projection.screen.height);

      // clear out hoveredSketchId if the sketch is gone
      var hoveredSketch = graphSketches[this.hoveredSketchId];
      if (!hoveredSketch) {
        this.hoveredSketchId = null;
      }

      // clear out pressedSketchId if the sketch is gone
      var pressedSketch = graphSketches[this.pressedSketchId];
      if (!pressedSketch) {
        this.pressedSketchId = null;
      }

      // Iterate through each graphSketch, find the opened poi and draw them
      // also saves which ones were drawn.
      var savedPOI = [];

      for (var id in this.renderedMovablePoints) {
        this.renderedMovablePoints[id].shouldGarbageCollect = true;
      }

      for (id in graphSketches) {
        var sketch = graphSketches[id];
        if (!sketch.visible) continue;

        var styles = {
          hovered: sketch === hoveredSketch,
          pressed: sketch === pressedSketch
        };

        var point = this.drawMovablePoint(sketch, this.dom_node, projection, styles);
        if (point) {
          savedPOI.push(point);
        }
      }

      for (id in this.renderedMovablePoints) {
        if (this.renderedMovablePoints[id].shouldGarbageCollect) {
          this.renderedMovablePoints[id].$.remove();
          delete(this.renderedMovablePoints[id]);
        }
      }

      if (hoveredSketch && hoveredSketch.visible) {
         this.addGlobalClass('dcg-mouse-over-movable-point');
      } else {
         this.removeGlobalClass('dcg-mouse-over-movable-point');
      }

      if (pressedSketch && pressedSketch.visible) {
         this.addGlobalClass('dcg-dragging-movable-point');
      } else {
         this.removeGlobalClass('dcg-dragging-movable-point');
      }

      this.savedPOI = savedPOI;
    };

    layer.getDrawnPOI = function () {
      return this.savedPOI;
    };

    layer.init = function (width, height, $root) {
      _super.init.call(this, width, height, $root);
      this.renderedMovablePoints = {};
    };

    layer.drawMovablePoint = function (sketch, dom, projection, styles) {

      if (!sketch.branches ||
           sketch.branches.length !== 1 ||
           sketch.branches[0].graphMode !== GRAPHMODE.XYPOINT_MOVABLE) {
             return;
      }

      var poi = sketch.getPOI()[0];
      var screen_x = projection.mapx(poi.x);
      var screen_y = projection.mapy(poi.y);

      if (!(sketch.id in this.renderedMovablePoints)) {
        var $el = $("<div class='dcg-movable-point'>")
                    .append($("<div class='dcg-background'></div>"))
                    .append($("<div class='dcg-dot'></div></div>"));
        dom.append($el);
        this.renderedMovablePoints[sketch.id] = {
          $: $el,
          shouldGarbageCollect: true
        };
      }

      var dom_poi = this.renderedMovablePoints[sketch.id].$;

      // ensure is on screen. TODO - duplicate of code elsewhere. Might want to centralize that.
      if (
        screen_x > -20 && screen_y > -20 &&
        screen_x < projection.screen.width + 20 && screen_y < projection.screen.height + 20
      ) {
        dom_poi.css({
          transform: Browser.translateRule(screen_x, screen_y),
          backgroundColor: sketch.color
        });

        dom_poi.toggleClass('highlight', !!sketch.showHighlight);
        dom_poi.toggleClass('dcg-simulate-hovered', !!styles.hovered);
        dom_poi.toggleClass('dcg-simulate-active', !!styles.pressed);

        //don't garbage collect this point
        this.renderedMovablePoints[sketch.id].shouldGarbageCollect = false;
      }
      return poi;
    };


  });

return MovablePointsLayer;
});
// fixes an issue with ghost clicks. borrowed the idea of using capture phase rather than bubble phase from:
//    https://developers.google.com/mobile/articles/fast_buttons?csw=1#ghost
//
// but the solution there is far from complete. It doesn't deal with focus being placed in textboxes still, and
// it doesn't prevent the ghost events from propagating down and back up through the dom. Mathquill listens for
// the mousedown and mouseup events, so when they were triggered erroneously, we should prevent them from propagating.
//
// the event handlers defined here need to be added before jquery has chance to add it's own listeners. This is
// especially important for the focus and blur events. The fact that touchtracking.js is split into two separate
// events here is unfortunate, but I think it's fine for now. There are talks of refactoring the touchtracking.js
// code anyways.
define('ipad.ghostevents',['require'],function (require) {

  var inGhostEventMode = false;
  var startingActiveElement = null;

  function stopGhostEvent (evt) {
    if (inGhostEventMode) {
      evt.stopPropagation();
      evt.stopImmediatePropagation();
    }
  }

  function stopAndPreventGhostEvent (evt) {
    if (inGhostEventMode) {
      evt.preventDefault();
      evt.stopPropagation();
      evt.stopImmediatePropagation();
    }
  }

  // will get overriden by touchtracking.js
  // would be better not do things this way, but we need to split touchtracking.js into
  // a part that jquery depends on and a part that depends on jquery. This little inconvenience is what
  // splices all of touchtracking back together
  var touchTrackingCallbacks = {
    isGhostEvent: function (evt) {
      return false;
    }
  };

  // don't send ghost mousedwon events; someone might be listening for them
  document.addEventListener('mousedown', function (evt) {
    startingActiveElement = document.activeElement;

    inGhostEventMode = touchTrackingCallbacks.isGhostEvent(evt);

    // stop the mousedown event
    stopGhostEvent(evt);
  }, true);

  // don't send ghost mouseup events; someone might be listening for them
  document.addEventListener('mouseup', stopGhostEvent, true);

  // prevent links from being followed on ghost clicks.
  document.addEventListener('click', function (evt) {
    stopAndPreventGhostEvent(evt);

    // put focus where it was before the start of these events. the focusin and focusout
    // events fired from this will be stopped.
    if (inGhostEventMode && document.activeElement !== startingActiveElement) {
      if (document.activeElement) document.activeElement.blur();
      if (startingActiveElement) startingActiveElement.focus();
    }

    // anything after this is not a ghost event
    inGhostEventMode = false;
  }, true);

  // we prevent focus events from firing during ghost events
  document.addEventListener('focus', stopAndPreventGhostEvent, true);
  document.addEventListener('blur', stopAndPreventGhostEvent, true);

  return touchTrackingCallbacks;
});

/*
 * Touch/Mouse event handling gets complicated when a user has both a touch
 * device attached and a mouse attached. This tracking system helps deal with
 * that situation. We listen for the touch and mouse events on the document
 * and redispatch new, normalized events that work for many different devices
 * It's important to note that evt.stopPropagation() cannot be called on any
 * events that this is listening for.
 *
 * It normalizes 'touchStart' and 'mouseDown' to the 'tapstart' event.
 * It normalizes 'touchMove' and 'mouseMove' to the 'tapmove' event.
 * It normalizes 'touchEnd' and 'mouseUp' to the 'tapend' event.
 * It sends out a 'tap' event after a single touchStart and touchEnd.
 * It sends out a 'longhold' event if 500ms after a single 'tapstart'
 *    there hasn't been another event and the 'tapstart' is the only touch.
 *    Events have a 'wasLongheld' property that lets you know if a longhold
 *    has happened.
 *
 * TODO - dispatch 'doubletap' event after 'tap' and 'tap' near same location.
 *
 * One thing that it does is enforce that only one device, either touch or
 * or mouse, be used at a time. TOUCH_MODE starts on 'touchStart' and ends when
 * when all touches are lifted. MOUSE_MODE starts on 'mouseDown' and ends on
 * 'mouseUp'. When in TOUCH_MODE, it ignores all MOUSE_MODE events. When in
 * MOUSE_MODE, it ignores all TOUCH_MODE events.
 *
 * There is still one other slight complication. The ipad issues a 'mouseDown'
 * event after the 'touchEnd' event. That means following the logic above, we'd
 * leave TOUCH_MODE on touchEnd, and we'd get a mouseDown event. That'd put us
 * in MOUSE_MODE. We'd process the 'mouseDown' as if it were from a mouse, and
 * we'd happily process the 'mouseUp' event as well. In order to combat that,
 * on each 'mouseDown' event we check if we've recently been in TOUCH_MODE. We
 * enforce that half a second has passed since a person was in TOUCH_MODE
 * before they can enter MOUSE_MODE. If we decide that that's not ideal, we
 * can check if the mouseDown is near the 'touchStart' or 'touchEnd' events, but
 * that sounds like an unnecessary complication.
 *
 * One other interesting thing is that 'mouseMove' can be dispatched even when
 * the mouse button isn't pressed. For that reason, this doesn't require that
 * you be in MOUSE_MODE to listen for 'mouseMove' events.
 *
 * UPDATE 24/10 - DM
 * I have put in support for pointerevents & MSPointerEvents to allow for multitouch
 * on Windows 8 machines. For once, MS have made a good move and proposed a useful
 * standard in pointerevents - down the line that may end up being the W3C standard
 * which will involve some more work here. Primarily, they don't track multiple touches
 * in a single event, so here we are keeping track of them and then conforming that array
 * to the rest of our more touch/tap-esque system.
 */
define('touchtracking',['require','jquery','ipad.ghostevents'],function(require){

  var $ = require('jquery');
  var GhostEvents = require('ipad.ghostevents');

  GhostEvents.isGhostEvent = function (evt) {
    // I've seen no indication of "ghost events" when using PointerEvents.
    // Disabling altogether because the logic below doesn't work for PointerEvents.
    // The ipad appears to be the only device that sends legacy events after
    // the mouseup. Other devices send the legacy events after their touch,pointerevent
    // equivalent:
    //
    // ipad: touchstart, touchmove, touchend, mousedown, mouseup, click
    // surface: pointerdown, mousedown, pointerup, mouseup, click
    //
    // The logic below assumes that the touchend (or pointerend) has happened before
    // the evt in question. If it has not, then lastTarget will be null and we
    // will consider evt a ghostevent. The ghostevent code is specially tailored
    // to the ipad, so I'm not quick to change it.
    //
    // TODO - maybe make ghost event detection opt in rather opt out. IIRC, android
    // uses the same event sequence as the surface, so it's possible we're detecting
    // ghostevents on android when we shouldn't be.
    //
    // The effect of wrongly considering an event a ghost event is we preventDefault()
    // on it and possibly stopPropagation(). We also do fun things with focus.
    if (window.PointerEvent) {
      return false;
    }

    // not a ghost event if it's from a mouse
    if (mode !== TOUCH_MODE && !hasRecentlyEndedTouchMode()) {
      return false;
    }

    // it's a ghost event if the target of the event and our lastTarget aren't ancestors. What has happened is
    // the dom moved around while the legacy events were being generated. We'll be ignoring the upcoming
    // legacy events.
    if (evt.target === lastTarget) return false;
    if (evt.target && $.contains(evt.target, lastTarget)) return false;
    if (lastTarget && $.contains(lastTarget, evt.target)) return false;

    return true;
  };

  var NO_MODE = 0;    // nothing pressed
  var TOUCH_MODE = 1; // finger is on screen
  var MOUSE_MODE = 2; // mouse is held down

  var mode = NO_MODE;
  var modeEvents = {};
  var modeTargets = [];
  var endTouchModeTime = 0;
  var endTouchModeTimeout = null;
  var lastTarget = null;

  var longholdTimeout = null;
  var pointerTouches = [];

  // returns an array of node, parent, grandparent, etc
  var getAncestors = function (node) {
    var nodes = [];
    while (node) {
      nodes.push(node);
      node = node.parentNode;
    }

    return nodes;
  };

  // only returns nodes within a .dcg-tap-container
  var filterSortedNodesWithinScope = function (sortedNodes) {
    var filtered = [];
    for (var i=0; i<sortedNodes.length; i++) {
      var node = sortedNodes[i];
      filtered.push(node);

      if ($(node).hasClass('dcg-tap-container')) {
        return filtered;
      }
    }

    return [];
  };

  var beginMode = function (evnt) {
    lastTarget = null;

    if (evnt.type === 'mousedown') {
      mode = MOUSE_MODE;
      modeTargets = getAncestors(evnt.target);
    } else if (evnt.type === 'pointerdown' || evnt.type === 'MSPointerDown') {
      //we'll have filtered out all mouse and pen events by here, so this must've been a touch
      mode = TOUCH_MODE;
      modeTargets = getAncestors(evnt.target);
    } else {
      mode = TOUCH_MODE;
      modeTargets = getAncestors(evnt.originalEvent.touches[0].target);
    }
    // make the elements under the mouse look pressed
    $(filterSortedNodesWithinScope(modeTargets)).addClass('dcg-depressed');

    // save original scroll positions for elements we've moused on
    $(modeTargets).each(function(){
      var elm = $(this);

      elm.data({
        originalScrollTop: elm.scrollTop(),
        originalScrollLeft: elm.scrollLeft()
      });
    });

    modeEvents = {};
  };

  var endMode = function (evnt) {
    lastTarget = null;

    // nothing is pressed anymore
    $('.dcg-depressed').removeClass('dcg-depressed');

    // check if any of the elements we originally moused on have scrolled.
    $(modeTargets).each(function(){
      var elm = $(this);
      var verticalOffset = elm.data('originalScrollTop') - elm.scrollTop();
      var horizontalOffset = elm.data('originalScrollLeft') - elm.scrollLeft();
      // save original scroll positions
      if (verticalOffset || horizontalOffset) {
        modeEvents.scroll = true;
      }
    });

    if (modeEvents.tapstart===1 && modeEvents.tapend===1 && !modeEvents.tapcancel && !modeEvents.scroll) {

      // get the x and y position of event.
      var x = evnt.device === 'mouse' ? evnt.pageX : evnt.originalEvent.changedTouches[0].pageX;
      var y = evnt.device === 'mouse' ? evnt.pageY : evnt.originalEvent.changedTouches[0].pageY;

      // run through the original modeTargets to see if the touchend is
      // with the bounds.
      var tap_escaped_boundary = false;
      for (var i=0; i<modeTargets.length && !tap_escaped_boundary; i++) {
        var target = $(modeTargets[i]);
        var offset = target.offset();

        // don't let tap events escape from a tapboundary.
        //
        // we allow you to mousedown on one element and mouseup on another. We
        // dispatch the tap event on the common ancestor. This allows you to be
        // imprecise when clicking. Sometimes that isn't ideal however. Say
        // you mouse down on a slider thumb and mouse up on the expression. By
        // default, we'd dispatch a tap event on the expression. That'd cause
        // the expression to be selected and focused. That's not what we want.
        // So, we define a tapboundary on the slider element. That will not
        // allow a tap event to start within the slider and end somewhere
        // outside of it. It must terminate within the boundary, otherwise we
        // won't dispatch a tap event at all.
        if (target.attr('tapboundary') === 'true') {
          tap_escaped_boundary = true;
        }

        if (offset) {

          // check if within top and left sides
          if (x < offset.left || y < offset.top) continue;

          // check if within right side
          if (x > offset.left + target.outerWidth()) continue;

          // check if within bottom side
          if (y > offset.top + target.outerHeight()) continue;

        }

        lastTarget = target[0];
        dispatchEvent('tap', evnt, lastTarget);
        break;
      }
    }

    // start the timer after we process the tap event.
    // this fires an event 1000ms in the future. If anything had caused the ipad
    // legacy events to get delayed, that'll also cause this function call to
    // get delayed. For us to switch back to MOUSE_MODE, this event must have
    // fired and it must not have been fired within 500ms of us trying to
    // switch to MOUSE_MODE
    if (mode === TOUCH_MODE) {
      endTouchModeTimeout = setTimeout(function(){
        endTouchModeTimeout = null;
        endTouchModeTime = new Date().getTime();
      }, 1000);
    }

    modeTargets = [];
    mode = NO_MODE;
  };

  var hasRecentlyEndedTouchMode = function () {
    return endTouchModeTimeout || new Date().getTime() - endTouchModeTime < 500;
  };

  // it's important to clone touches because some devices keep updating the
  // same reference to a touch.
  var clone = function (touches) {
    var cloned = [];
    for (var i=0; i<touches.length; i++) {

      var touch = touches[i];
      cloned.push({

        identifier: touch.identifier,
        x: touch.pageX,
        y: touch.pageY,

        screenX: touch.screenX,
        screenY: touch.screenY,
        pageX: touch.pageX,
        pageY: touch.pageY,
        clientX: touch.clientX,
        clientY: touch.clientY
      });
    }
    return cloned;
  };

  var dispatchEvent = function (type, evnt, differentTarget) {
    // count an event type. used to figure out if we should send out
    // a tap and doubletap event.
    if (modeEvents[type.toLowerCase()] === undefined) {
      modeEvents[type.toLowerCase()] = 1;
    } else {
      modeEvents[type.toLowerCase()]++;
    }

    var newEvnt = $.event.fix(evnt.originalEvent);
        newEvnt.type = type;
        newEvnt.device = mode === TOUCH_MODE ? 'touch' : 'mouse';
        newEvnt.touches = clone(evnt.originalEvent.touches);
        newEvnt.changedTouches = clone(evnt.originalEvent.changedTouches);
        newEvnt.target = differentTarget ? differentTarget : evnt.target;

        var wasLongheld = modeEvents.longhold > 0;
        newEvnt.wasLongheld = function () { return wasLongheld };

    // send out a 'longhold' 500ms after a 'tapstart' as long as nothing else happens between
    // now and then.
    clearTimeout(longholdTimeout);
    if (newEvnt.type === 'tapstart' && newEvnt.touches.length === 1) {
      longholdTimeout = setTimeout(function () {
        dispatchEvent('longhold', evnt, differentTarget);
      }, 500);
    }

    $(newEvnt.target).trigger(newEvnt);
  };

    // TODO - Remember nodes given .hovered last time instead of querying. Only
  //        problem I can see here is that it's possible for a person to
  //        clone an object that has the .hover and add it to
  //        the dom. Then it'll never lose the .hover class. If we find
  //        any more performance problems with this, then maybe we can worry
  //        about it, but I don't think we need that optimization.
  // Already optimized to leave .hover on elements that still are hovered. Saw
  // a preformance problem with sliders before optimization and problem went
  // away after optimization.
  var setHoveredNode = function (node) {

    var hoverableNodes = modeTargets; // gets a list of nodes that were under the mouse when it was pressed
    var checkIfNodeIsHoverable = !!modeTargets.length; // simple mouse move with no mouse down
    var hoveredBefore = $.makeArray($('.dcg-hovered'));
    var hoveredNow = [];
    var lostHover = [];
    var gainedHover = [];

    filterSortedNodesWithinScope(getAncestors(node)).forEach(function (node) {
      // only add to hovered list if it can be hovered.
      if (!checkIfNodeIsHoverable || hoverableNodes.indexOf(node) !== -1) {

        // hovered now, but wasn't before
        if (hoveredBefore.indexOf(node) === -1) {
          gainedHover.push(node);
        }

        hoveredNow.push(node);
      }
    });

    // find the ones that used to be hovered but aren't any more
    for (var i=0; i<hoveredBefore.length; i++) {
      node = hoveredBefore[i];
      if (hoveredNow.indexOf(node) === -1) {
        lostHover.push(node);
      }
    }

    $(lostHover).removeClass('dcg-hovered').trigger('tipsyhide');
    $(gainedHover).addClass('dcg-hovered').trigger('tipsyshow');
  };


  var removePointerEventById = function (id) {
    // Returns the removed event for use in some handlers
    for (var i = 0; i < pointerTouches.length; i++) {
      if (pointerTouches[i].pointerId === id) {
        return pointerTouches.splice(i, 1)[0];
      }
    }
  };

  //From:
  //http://msdn.microsoft.com/en-us/library/windows/apps/hh466130.aspx
  //IE10 uses longs, IE11 uses strings
  var isMSTouchEvent = function (evnt) {
    return (
      evnt.originalEvent.pointerType === 'touch' ||
      evnt.originalEvent.pointerType === 2
    );
  };

  // Apply touch & mouse event handlers for everything that isn't IE10+
  // and mspointerevents (IE10) & pointerevents for IE(11).
  $(document).on('pointerdown MSPointerDown', function (evnt) {
    if (mode === MOUSE_MODE || !isMSTouchEvent(evnt)) return;

    // setup TOUCH_MODE
    if (mode === NO_MODE) {
      beginMode(evnt);
    }

    // nothing can be hovered now
    setHoveredNode(null);

    // normalize pointer-event to a touch-event
    evnt.originalEvent.identifier = evnt.originalEvent.pointerId;
    evnt.originalEvent.touches = pointerTouches;
    evnt.originalEvent.changedTouches = [evnt.originalEvent];
    pointerTouches.push(evnt.originalEvent);

    dispatchEvent('tapstart', evnt);
  });

  $(document).on('pointermove MSPointerMove', function (evnt) {
    if (mode !== TOUCH_MODE || !isMSTouchEvent(evnt)) return;

    // Pointer events don't get updated, so we need to remove any existing
    // instances of this pointerId we are tracking and add the new data in.
    removePointerEventById(evnt.originalEvent.pointerId);
    pointerTouches.push(evnt.originalEvent);

    // normalize pointer-event to a touch-event
    evnt.originalEvent.identifier = evnt.originalEvent.pointerId;
    evnt.originalEvent.touches = pointerTouches;
    evnt.originalEvent.changedTouches = [evnt.originalEvent];
    dispatchEvent('tapmove', evnt);
  });

  $(document).on('pointercancel MSPointerCancel', function (evnt) {
    if (mode !== TOUCH_MODE || !isMSTouchEvent(evnt)) return;

    // Pointer events don't get updated, so we need to remove any existing
    // instances of this pointerId we are tracking
    removePointerEventById(evnt.originalEvent.pointerId);

    // normalize pointer-event to a touch-event
    evnt.originalEvent.identifier = evnt.originalEvent.pointerId;
    evnt.originalEvent.touches = pointerTouches;
    evnt.originalEvent.changedTouches = [evnt.originalEvent];

    dispatchEvent('tapcancel', evnt);
    // switch back to no mode if all touches are gone
    if (evnt.originalEvent.touches.length===0) {
      endMode(evnt);
    }
  });

  $(document).on('pointerup MSPointerUp', function (evnt) {
    if (mode !== TOUCH_MODE || !isMSTouchEvent(evnt)) return;

    // Pointer events don't get updated, so we need to remove any existing
    // instances of this pointerId we are tracking
    removePointerEventById(evnt.originalEvent.pointerId);

    // normalize pointer-event to a touch-event
    evnt.originalEvent.identifier = evnt.originalEvent.pointerId;
    evnt.originalEvent.touches = pointerTouches;
    evnt.originalEvent.changedTouches = [evnt.originalEvent];

    dispatchEvent('tapend', evnt);
    // switch back to no mode if all touches are gone
    if (evnt.originalEvent.touches.length===0) {
      endMode(evnt);
    }
  });

  $(document).on('touchstart', function (evnt) {
    if (mode === MOUSE_MODE) return;

    // setup TOUCH_MODE
    if (mode === NO_MODE) {
      beginMode(evnt);
    }

    // nothing can be hovered now
    setHoveredNode(null);
    dispatchEvent('tapstart', evnt);
  });

  $(document).on('touchmove', function (evnt) {
    if (mode !== TOUCH_MODE) return;
    dispatchEvent('tapmove', evnt);
  });

  $(document).on('touchcancel', function (evnt) {
    if (mode !== TOUCH_MODE) return;
    dispatchEvent('tapcancel', evnt);
    // switch back to no mode if all touches are gone
    if (evnt.originalEvent.touches.length===0) {
      endMode(evnt);
    }
  });

  $(document).on('touchend', function (evnt) {
    if (mode !== TOUCH_MODE) return;
    dispatchEvent('tapend', evnt);
    // switch back to no mode if all touches are gone
    if (evnt.originalEvent.touches.length===0) {
      endMode(evnt);
    }
  });

  $(document).on('mousedown', function (evnt) {
    if (evnt.button === 1 || evnt.button === 2) return;

    // Take evasive action for legacy clicks--that is, click events that are
    // synthesized by touch browsers after a sequence of touches has ended.
    // The problem we're trying to solve here is that if you move a DOM
    // element in response to a touch event, then the legacy mouse events will
    // be fired on whatever element happens to now be under where the touch
    // event occurred.
    //
    // For example, the "functions" menu is hidden when one of its buttons is
    // touched, and the legacy click event is subsequently fired on the graph
    // paper. This takes focus from the expression that was being edited.
    //
    // The solution is to preventDefault() on the legacy events if we are in
    // touch mode. However, this prevents inputs, textareas, and selects from
    // being focused properly in mobile webkit browsers. We compromise by
    // firing preventDefault() only if the target is not an input, textarea,
    // or select.
    if (mode === TOUCH_MODE || hasRecentlyEndedTouchMode()) {
      if (!$(evnt.target).is('input, textarea, select')) {
        evnt.preventDefault();
      }
      return;
    }

    // setup MOUSE_MODE
    beginMode(evnt);

    // add in missing touch api information
    evnt.originalEvent.touches = [evnt];
    evnt.originalEvent.changedTouches = [evnt];

    dispatchEvent('tapstart', evnt);
  });

  // Stop mousedown event from propagating for any element with an ancestor with
  // class .do-not-blur (and no ancestor with .do-blur)
  $(document).ready(function() {
    $(document).on("mousedown", function(e) {
      var doNotBlur = !!$(e.target).closest('.dcg-do-not-blur').length,
        doBlur    = !!$(e.target).closest('.dcg-do-blur').length;
      if (doNotBlur && !doBlur) {
        e.preventDefault();
      }

      // we use preventDefault() in places and that will cause text selection
      // to be preserved when it shouldn't be. On mouse down, if the only
      // thing with selection is something that has the .dcg-text-selectable class
      // then we can safely remove selection.
      var selection = window.getSelection();
      if (selection.rangeCount === 1) {
        var range = selection.getRangeAt(0);
        if (
          range.startContainer === range.endContainer &&
          $(range.startContainer).closest('.dcg-text-selectable').length
        ) {
          selection.removeAllRanges();
        }
      }

    });
  });

  // If the mouse isn't pressed, then the mousemove that moves us off the
  // the screen isn't reported. That'll leave the last hovered element hoverd.
  // this checks if we are in NO_MODE and have a mouseleave event.
  $(document).on('mouseleave', function (evnt) {
    // we can move the mouse while not being in mouseMode
    if (mode !== NO_MODE) return;

    // check if a significant amount of time has passed since
    // switching from TOUCH_MODE to NO_MODE
    if (hasRecentlyEndedTouchMode()) return;

    // nothing is hovered
    setHoveredNode(null);
  });

  $(document).on('mousemove', function (evnt) {
    if (evnt.button === 1 || evnt.button === 2) return;

    // we can move the mouse while not being in mouseMode
    if (mode === TOUCH_MODE) return;

    // check if a significant amount of time has passed since
    // switching from TOUCH_MODE to MOUSE_MODE
    if (hasRecentlyEndedTouchMode()) return;

    setHoveredNode(evnt.target);

    // add in missing touch api information
    evnt.originalEvent.touches = [evnt]; // TODO - not perfect because it could be a non-touch
    evnt.originalEvent.changedTouches = [evnt];

    dispatchEvent('tapmove', evnt);
  });


  $(document).on('mouseup', function (evnt) {
    if (evnt.button === 1 || evnt.button === 2) return;

    if (mode !== MOUSE_MODE) return;

    // add in missing touch api information
    evnt.originalEvent.touches = [];
    evnt.originalEvent.changedTouches = [evnt];

    dispatchEvent('tapend', evnt);

    endMode(evnt);
  });

  /* Uncomment to see visual dots on screen following mouse events

  $(document).on('tapstart tapend tapmove tap tapcancel', function (evt){
    console.log(evt.type, evt.originalEvent.changedTouches);

    function drawDot (touch, c, r, o) {
      if (evt.isDefaultPrevented()) r *= 10;

      var styles = [
        'position:absolute',
        'z-index: 5000000',
        'pointer-events: none',
        'left:' + (touch.pageX-r) + 'px',
        'top:' + (touch.pageY-r) + 'px',
        'width:' + (2*r) + 'px',
        'height:' + (2*r) + 'px',
        'border-radius:' + r + 'px',
        'background:'+ c,
        'opacity:'+ o
      ];

      return $('<div style="'+ styles.join(';') +'"></div>').appendTo('body');
    }

    for (var i in evt.originalEvent.changedTouches) {
      var touch = evt.originalEvent.changedTouches[i];
      if (evt.type === 'tapstart') {
        drawDot(touch, '#0F0', 6, .5);
      } else if (evt.type === 'tapend') {
        drawDot(touch, '#F00', 6, .5);
      } else if (evt.type === 'tapmove') {
        drawDot(touch, '#00F', 3, 1);
      } else if (evt.type === 'tap') {
        drawDot(touch, '#FF0', 12, .5);
      }
    }
  });

  */

  //Utilities to allow other modules to query this state
  return {
    isTapActive: function(){
      return (mode !== NO_MODE);
    }
  };

});

/*! Copyright (c) 2013 Brandon Aaron (http://brandon.aaron.sh)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Version: 3.1.9
 *
 * Requires: jQuery 1.2.2+
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define('vendor/jquery.mousewheel',['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.9',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
        },

        getLineHeight: function(elem) {
            return parseInt($(elem)['offsetParent' in $.fn ? 'offsetParent' : 'parent']().css('fontSize'), 10);
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));

define('graphing/viewportcontroller',['require','jquery','pjs','./viewporttransformation','math/distance','./constants','touchtracking','jquery.handleevent','vendor/jquery.mousewheel'],function (require) {
  var $ = require('jquery');
  var P = require('pjs');
  var ViewportTransformation = require('./viewporttransformation');
  var Distance = require('math/distance');
  var constants = require('./constants');

  require('touchtracking');

  require('jquery.handleevent');
  require('vendor/jquery.mousewheel');

  var GraphController = P(function (proto) {
    proto.init = function (grapher, graphSettings) {
      this.grapher = grapher;
      this.graphSettings = graphSettings;
      this.$ = this.grapher.$;

      // callback
      this.triggerViewportStable = function () {};
      // using for jquery's animate feature. Would be nice to use something
      // more suited to only animation, but probably not worth the overhead.
      this.$animation = $('<div></div>');

      if (!this.graphSettings.config.lockViewport) {
        this.addMouseWheelEventHandler();
        this.addTouchEventHandler();
      }
    };

    proto.getViewport = function () {
      return this.grapher.viewport.clone();
    };

    proto.setViewport = function (viewport) {
      if (!viewport.isValid()) return;
      if (!this.grapher.isInTransientState() && viewport.equals(this.grapher.viewport)) {
        this.triggerViewportStable();
        return;
      }

      this.grapher.viewport = viewport.clone();
      this.endTransientState();
    };

    proto.setTransformation = function (transformation) {

      this.grapher.beginTransientState();
      this.grapher.transformation = transformation;
      this.grapher.redrawAllLayers();

      clearTimeout(this.endTransientTimeout);
      this.endTransientTimeout = setTimeout(this.endTransientState.bind(this), 250);
    };

    proto.endTransientState = function () {
      clearTimeout(this.endTransientTimeout);

      this.grapher.endTransientState();
      this.grapher.redrawAllLayers();

      this.triggerViewportStable();
    };

    proto.animateTransformation = function (transformation) {
      var self = this;
      var currentTransformation = this.grapher.transformation;
      var targetTransformation = currentTransformation.compose(transformation);
      this.cancelAnimation();
      this.$animation.css('percent',0);
      this.$animation.animate( {'percent':100}, {

        duration: constants.ANIMATE_ZOOM_DURATION,

        step: function (percent) {
          self.setTransformation(
            currentTransformation.lerp(targetTransformation, percent/100.0)
          );
        }
      });
    };

    proto.cancelAnimation = function () {
      this.$animation.stop();
    };

    // this is simple enough to encapsulate everything in a single closure.
    proto.addMouseWheelEventHandler = function () {
      // Keep track of whether the user is currently scrolling the page with the
      // mousewheel. We don't want to prevent them from scrolling past the
      // calculator. Use the heuristic that if the user has not moved their
      // mouse more than 10px since the last mousewheel that caused a scroll,
      // then they are still scrolling and we should let mousewheel events
      // pass through.
      var scrolling = false;
      var clientX;
      var clientY;

      $(window).on('scroll', function (evt) { scrolling = true; });

      $(window).on('mousewheel', function (evt) {
        // NOTE: jQuery 1.9+ doesn't require .originalEvent here. Can
        // drop it if we upgrade. We're using 1.8.3 at the time of writing.
        clientX = evt.originalEvent.clientX;
        clientY = evt.originalEvent.clientY;
      });

      $(window).on('mousemove', function (evt) {
        if (!scrolling) return;

        var dx = evt.originalEvent.clientX - clientX;
        var dy = evt.originalEvent.clientY - clientY;
        var dsq = dx*dx + dy*dy;

        if (dsq < 100) return;
        scrolling = false;
      });

      var mousewheel_counter = 0;
      var onMouseWheel = function (evt, delta) {
        if (scrolling) return;

        evt.preventDefault();

        if (mousewheel_counter > 0) return;

        mousewheel_counter += 1;
        setTimeout(function () { mousewheel_counter-- }, 50);
        delta = (delta > 0 ? 1 : -1);

        var t = this.grapher.transformation;

        this.setTransformation(
          t.compose(ViewportTransformation(
            0,
            0,
            (delta > 0) ? constants.ZOOM_FACTOR : 1/constants.ZOOM_FACTOR
          ))
        );
      };

      this.$.mousewheel(onMouseWheel.bind(this));
    };

    proto.handleDoubleClick = function (evt) {
      if (this.graphSettings.config.disable_dblclick_zooming) return;
      if (evt.wasHandled()) return;
      evt.preventDefault();

      var pageOffset = this.$.offset();
      var screen = this.grapher.screen;
      var xOffset = evt.pageX - (pageOffset.left + 0.5*screen.width);
      var yOffset = evt.pageY - (pageOffset.top + 0.5*screen.height);
      var scale = constants.DOUBLETAP_ZOOM;

      // VT(dx*(1 - scale), dy*(1 - scale), scale) ===
      // VT(dx, dy, 1).VT(0, 0, scale).VT(-dx, -dy, 1);
      // Scales about the click point instead of the origin.
      this.animateTransformation(ViewportTransformation(
        xOffset*(1 - scale),
        yOffset*(1 - scale),
        scale
      ));
    };

    proto.applyPanTouchChanges = function (oldTouches, newTouches) {
      var dx = newTouches[0].x - oldTouches[0].x;
      var dy = newTouches[0].y - oldTouches[0].y;
      var transformation = this.grapher.transformation.compose(
        ViewportTransformation(dx, dy, 1)
      );
      this.setTransformation(transformation);
    };

    proto.applyScaleTouchChanges = function (oldTouches, newTouches, scaleAxis) {

      var panX = Distance.mean(
        newTouches[0].x - oldTouches[0].x,
        newTouches[1].x - oldTouches[1].x
      );

      var panY = Distance.mean(
        newTouches[0].y - oldTouches[0].y,
        newTouches[1].y - oldTouches[1].y
      );

      var screen = this.grapher.screen;
      var offset = this.grapher.$.offset();

      var x0 = Distance.mean(oldTouches[0].x, oldTouches[1].x) -
        (offset.left + 0.5*screen.width)
      ;
      var y0 = Distance.mean(oldTouches[0].y, oldTouches[1].y) -
        (offset.top + 0.5*screen.height)
      ;

      var dxNew = Math.abs(newTouches[1].x - newTouches[0].x);
      var dyNew = Math.abs(newTouches[1].y - newTouches[0].y);
      var dxOld = Math.abs(oldTouches[1].x - oldTouches[0].x);
      var dyOld = Math.abs(oldTouches[1].y - oldTouches[0].y);

      // Decide if this is an isotropic or anisotropic scaling.
      var xScale, yScale;

      // avoid very large or small scaling when fingers cross
      var thresh = 50; // px,
      if (scaleAxis === 'x') {
        yScale = 1;
        xScale = Math.max(thresh, dxNew)/Math.max(thresh, dxOld);
      } else if (scaleAxis === 'y') {
        xScale = 1;
        yScale = Math.max(thresh, dyNew)/Math.max(thresh, dyOld);
      } else {
        xScale = yScale = (
          Math.max(thresh, Distance.hypot(dxNew, dyNew)) /
          Math.max(thresh, Distance.hypot(dxOld, dyOld))
        );
      }

      // offset*(1 - scale) is a trick for scaling about a point other than
      // the origin. It's equivalent to translating back to the origin,
      // scaling there, then translating back to offset.
      var transformation = this.grapher.transformation.compose(
        ViewportTransformation(
          panX + x0*(1 - xScale),
          panY + y0*(1 - yScale),
          xScale,
          yScale
        )
      );

      this.setTransformation(transformation);
    };

    // a complete closure to all touch event related code
    proto.addTouchEventHandler = function () {

      var self = this;
      var touches = [];
      var isDragging = false;

      var beginDrag = function (evnt) {

        // must not have been handled already. The POI controller may handle
        // this tapStart for POI purposes and we may want to ignore it.
        if (evnt.wasHandled()) return;

        // must not already be dragging
        if (isDragging) return;

        // must not have a touch down anywhere else. Only want to start dragging
        // if this is the first touch and it's on the grapher
        if (evnt.touches.length !== evnt.changedTouches.length) return;

        // setup drag
        isDragging = true;
        $(document).on('tapmove.graphdrag', updateDrag);
        $(document).on('tapstart.graphdrag tapend.graphdrag tapcancel.graphdrag', updateTouches);
      };

      var _computeScaleAxis = function (touches) {
        if (touches.length < 2) return undefined;

        var projection = self.grapher.createProjection();
        var offset = self.grapher.$.offset();
        var ox = projection.mapx(0);
        var oy = projection.mapy(0);

        // Clamp to screen edges
        ox = Math.min(Math.max(0, ox), projection.screen.width) + offset.left;
        oy = Math.min(Math.max(0, oy), projection.screen.height) + offset.top;

        var xClose = function (x) {
          return 10*Math.abs(x - ox) < projection.screen.width;
        };

        var yClose = function (y) {
          return 10*Math.abs(y - oy) < projection.screen.height;
        };

        var dx = touches[1].x - touches[0].x;
        var dy = touches[1].y - touches[0].y;

        if (
          xClose(touches[0].x) &&
          xClose(touches[1].x) &&
          Math.abs(dy) > 3*Math.abs(dx)
        ) {
          return 'y';
        }

        if (
          yClose(touches[0].y) &&
          yClose(touches[1].y) &&
          Math.abs(dx) > 3*Math.abs(dy)
        ) {
          return 'x';
        }

        return 'both';
      };

      var updateScaleAxis = function (touches) {
        if (!self.grapher.scaleAxis) {
          self.grapher.scaleAxis = _computeScaleAxis(touches);
        }
        return self.grapher.scaleAxis;
      };

      var clearScaleAxis = function () {
        self.grapher.scaleAxis = undefined;
      };

      var updateDrag = function (evnt) {
        // must be dragging
        if (!isDragging) return;

        var newTouches = evnt.touches;

        if (touches.length === 2 && newTouches.length === 2) {
          // zoom and pan
          self.applyScaleTouchChanges(
            touches,
            newTouches,
            updateScaleAxis(newTouches)
          );
        } else {
          clearScaleAxis();
        }

        if (touches.length === 1) {
          // only option is to pan...
          self.applyPanTouchChanges(touches, newTouches);
        }

        touches = newTouches;
      };

      var updateTouches = function (evnt) {

        // must be dragging
        if (!isDragging) return;

        self.cancelAnimation();

        // save our touches so that when we move one we can
        // figure out how the touches have moved.
        touches = evnt.touches;

        // check if drag is over
        if (evnt.touches.length === 0) {
          isDragging = false;
          $(document).off('.graphdrag');
        }

        if (evnt.touches.length < 2) {
          clearScaleAxis();
        }

      };

      this.$.on('tapstart', beginDrag);
      this.$.on('dblclick', this.handleDoubleClick.bind(this));
    };

    proto.zoom = function (action) {
      if (action === 'in') {
        this.animateTransformation(
          ViewportTransformation(0, 0, 2)
        );
      } else if (action === 'out') {
        this.animateTransformation(
          ViewportTransformation(0, 0, 0.5)
        );
      } else if (action === 'default') {
        this.grapher.settings.setProperty('squareAxes', true);
        this.setViewport(this.grapher.computeDefaultViewport());
      }
    };

    proto.isZoomRestored = function () {
      return this.grapher.viewport.equals(this.grapher.computeDefaultViewport());
    };

    //executes a the axes squaring
    proto.enforceSquareAxes = function () {
      var settings = this.grapher.settings;

      if (!settings.squareAxes) return;

      var preserveDirection = settings.lastChangedAxis;

      var viewport = this.grapher.viewport.clone();
      if (preserveDirection == 'y') {
        viewport.squareXAxis(this.grapher.screen);
      } else {
        viewport.squareYAxis(this.grapher.screen);
      }
      viewport.round(this.grapher.screen);
      this.setViewport(viewport);
    };
  });

  return GraphController;
});

define('graphing/poicontroller',['require','jquery','math/distance','lib/rounding','graphing/graphmode','conditional_blur'],function(require){
  var $ = require('jquery');
  var Distance = require('math/distance');
  var Rounding = require('lib/rounding');
  var GRAPHMODE = require('graphing/graphmode');
  var conditionalBlur = require('conditional_blur');

function POIController (grapher, graphSettings) {
  this.manager = grapher;
  this.graphSettings = graphSettings;
  this.$ = this.manager.$;

  this.triggerMovePoint = function (id, screen_pt, projection) {};
  this.triggerSelectExpression = function (id) {};
  this.triggerStartMovingPoint = function () {};
  this.triggerStopMovingPoint = function () {};

  //don't hook up touchandlers for POIs if we don't have a graph paper
  if (!this.graphSettings.config.graphpaper || this.graphSettings.config.disableMouseInteractions) return;
  this.addTouchEventHandlers();
  this.addHoverEventHandler();
}

POIController.prototype.getToleranceByDevice = function (device) {
  return device === 'touch' ? 20 : 10;
};

POIController.prototype.addHoverEventHandler = function () {

  $(document).on('tapmove', function(evt){

    // only want this handler to proceed on mouse-based interactions
    if (evt.device === 'touch') return;

    var screen_pt = this.getMouseRelativeToGrapher(evt);
    var tolerance = this.getToleranceByDevice(evt.device);
    var realPointInfo = this.getPointUnderPoint(screen_pt, tolerance);
    var poi = null;
    var movableSketchId = null;

    // if there is a real point under the mouse, then don't show a POI hover
    if (realPointInfo) {
      var movable = realPointInfo.sketch.branches[realPointInfo.branch].graphMode === GRAPHMODE.XYPOINT_MOVABLE;
      movableSketchId = movable ? realPointInfo.sketch.id : null;
    } else {
      poi = this.getPOIUnderPoint(screen_pt, tolerance);
    }

    if (poi != this.manager.poiLabelsLayer.hoveredPOI) {
      this.manager.poiLabelsLayer.hoveredPOI = poi;
      this.manager.redrawPOILayer();
    }

    if (movableSketchId != this.manager.movablePointsLayer.hoveredSketchId) {
      this.manager.movablePointsLayer.hoveredSketchId = movableSketchId;
      this.manager.redrawMovablePointsLayer();
    }
  }.bind(this));
};

POIController.prototype.addTouchEventHandlers = function () {

  // hack to prevent dblclick zoom from working when on poi. Ideally, this
  // would happen more naturally. Maybe we wouldn't listen for dblclick within
  // the graphpaper. Only way that could happen is if we move these events
  // to click based instead of mousedown based.
  this.$.on('dblclick', function (evt){
      var screen_pt = this.getMouseRelativeToGrapher(evt);
      var tolerance = this.getToleranceByDevice(evt.device);
      if (
        this.getPointUnderPoint(screen_pt, tolerance) ||
        this.getPOIUnderPoint(screen_pt, tolerance) ||
        this.getBranchInfoUnderPoint(screen_pt, tolerance)
      ) {
        evt.preventDefault();
        evt.handle();
      }
  }.bind(this));

  this.$.on('tapstart', function (evt) {
      var screen_pt = this.getMouseRelativeToGrapher(evt);
      var tolerance = this.getToleranceByDevice(evt.device);
      conditionalBlur();

      // Cache offset during dragging.
      this.pageOffset = this.$.offset();
      // check if we're on a point list
      var pointInfoUnderMouse = this.getPointUnderPoint(screen_pt, tolerance);
      if (pointInfoUnderMouse) {
        this.triggerStartMovingPoint(pointInfoUnderMouse.id);
        this.startMovingPoint(pointInfoUnderMouse);
        evt.handle(); //prevents panning/zooming
        return;
      }

      // check if we're on a POI. If so, either open or close the POI under
      // the mouse.
      if (this.togglePOIUnderPoint(screen_pt, tolerance)) {
        evt.handle(); //prevents panning/zooming
        return;
      }

      // check if we're on a curve
      var branchInfoUnderMouse = this.getBranchInfoUnderPoint(screen_pt, tolerance);

      if (this.graphSettings.config.onlyTraceSelected) {
        if (branchInfoUnderMouse && branchInfoUnderMouse.sketch && branchInfoUnderMouse.sketch.selected) {
          this.startTracingBranch(branchInfoUnderMouse, screen_pt);
          evt.handle(); //prevents panning/zooming
          return;
        }
      } else {
        if (branchInfoUnderMouse) {
          this.triggerSelectExpression(branchInfoUnderMouse.id);
          this.startTracingBranch(branchInfoUnderMouse, screen_pt);
          evt.handle(); //prevents panning/zooming
          return;
        }
      }

      //select images / deselect only on full taps
      var self = this;
      this.$.on('tapmove.poicontroller', function() {
        self.$.off('.poicontroller');
      });
      this.$.on('tapend.poicontroller', function(evt) {
        self.$.off('.poicontroller');
        this.pageOffset = undefined;

        var branchInfoUnderMouse = self.getBranchInfoUnderPoint(screen_pt, tolerance);
        if (branchInfoUnderMouse && branchInfoUnderMouse.sketch && !branchInfoUnderMouse.sketch.selected) {
          // selects expression
          self.triggerSelectExpression(branchInfoUnderMouse.id);
          return;
        }

        var imgUnderMouse = self.getImgUnderMouse(screen_pt, tolerance);
        if (imgUnderMouse) {
          self.triggerSelectExpression(imgUnderMouse.id);
          return;
        }

        self.triggerSelectExpression(null);
      });

  }.bind(this));
};

POIController.prototype.getMouseRelativeToGrapher = function (evt) {
  var pageOffset = this.pageOffset || this.$.offset();
  var pt = evt.touches ? evt.touches[0] : evt;

  return {x: pt.pageX - pageOffset.left, y: pt.pageY - pageOffset.top};
};

//modified to give precedence to a MOVABLE POINT
POIController.prototype.getPointUnderPoint = function (screen_pt, tolerance) {
  var minDistance = tolerance;
  var pointInfo = null;
  var foundMovablePoint = false;
  var sketches = this.manager.graphSketches;
  var projection = this.manager.createProjection();
  for (var id in sketches) {
    var sketch = sketches[id];
    if(!sketch || !sketch.visible) continue;

    var branches = sketch.branches;
    if (!branches || !branches.length) continue;

    for (var i=0; i<branches.length; i++) {
      var isMovable = (branches[i].graphMode === GRAPHMODE.XYPOINT_MOVABLE);
      if (
        isMovable ||
        // only search non-movable branches if we haven't alread found a movable point
        (!foundMovablePoint && branches[i].graphMode === GRAPHMODE.XYPOINT)
      ) {
        var list = branches[i].segments[0];

        for (var j = 0; j < list.length; j++) {
          var pt = list[j];
          var mapped = projection.map_pt({x: pt[0], y: pt[1]});
          var dis = Distance.hypot(mapped.x - screen_pt.x, mapped.y - screen_pt.y);

          if (
            dis < minDistance ||
            !foundMovablePoint && isMovable && dis < tolerance
          ) {
            minDistance = dis;
            pointInfo = { id: id, branch: i, sketch: sketch, x: pt[0], y: pt[1]};
          }
        }
      }
    }
  }

  return pointInfo;
};

POIController.prototype.getPOIUnderPoint = function (screen_pt, tolerance) {
  var projection = this.manager.createProjection();
  var poi = this.manager.poiLabelsLayer.getDrawnPOI();
      poi = poi.concat(this.manager.poiDotsLayer.getDrawnPOI());

  if (!poi.length) return null;

  var test_poi = poi[0];
  var mapped_poi = projection.map_pt(test_poi);
  var closest_distance = tolerance;
  var closest_poi = null;

  var test_distance = Distance.hypot(mapped_poi.x-screen_pt.x, mapped_poi.y-screen_pt.y);
  if (test_distance < closest_distance) {
    closest_poi = test_poi;
    closest_distance = test_distance;
  }

  for (var i=1; i<poi.length; i++) {
    test_poi = poi[i];
    mapped_poi = projection.map_pt(test_poi);

    test_distance = Distance.hypot(mapped_poi.x-screen_pt.x, mapped_poi.y-screen_pt.y);
    if (test_distance < closest_distance) {
      closest_distance = test_distance;
      closest_poi = test_poi;
    }
  }
  return closest_poi;
};

// because a POI can be in both the poiLabelsLayer and in
// the poiDotsLayer, it's possible that this function returns
// an array with duplicate elements. But, opened points will
// be returned at the start. Could possibly clean this up,
// but not too important because this really has only 1 purpose.
// That purpose is to allow us to open all POI at the exact same
// location as another one. The functions that use this don't care
// if a specific POI is contained within the returned array more
// than once.
POIController.prototype.getAllPOIAtSameLocation = function (pt) {
  if (!pt) return [];

  var same_poi = [];
  var openedPOI = this.manager.poiLabelsLayer.getDrawnPOI();
  var unopenedPOI = this.manager.poiDotsLayer.getDrawnPOI();
  var all_poi = openedPOI.concat(unopenedPOI);

  if (!all_poi.length) return [];

  for (var i=0; i<all_poi.length; i++) {
    var poi = all_poi[i];

    // doesn't handle the case where x or y is NaN, but in that
    // case I don't think we'd be able to assume the POI are at
    // the same location. NaN means hole and there's no guarantee
    // that the hole is in the same spot. At this point, we don't
    // have information about if this is a discontinuity or not and
    // if it's a discontinuity, we definitely don't know where it is.
    if (poi.x === pt.x && poi.y === pt.y) {
      same_poi.push(poi);
    }
  }
  return same_poi;
};

POIController.prototype.togglePOIUnderPoint = function (screen_pt, tolerance) {
  var poiUnderMouse = this.getPOIUnderPoint(screen_pt, tolerance);
  var allPOIUnderMouse = this.getAllPOIAtSameLocation(poiUnderMouse);

  if (allPOIUnderMouse.length) {

    // want to set all poi under mouse to open or all to closed
    var isOpen = allPOIUnderMouse[0].isOpen();

    for (var i=0; i<allPOIUnderMouse.length; i++) {
      if (isOpen) {
        allPOIUnderMouse[i].close();

        // hide hovered poi
        this.manager.poiLabelsLayer.hoveredPOI = null;
      } else {
        allPOIUnderMouse[i].open();
      }
    }

    this.manager.redrawPOILayer();
    return true;
  } else {
    return false;
  }
};

POIController.prototype.getImgUnderMouse = function (screen_pt, tolerance) {
  var projection = this.manager.createProjection();
  var pt = projection.reverse_map_pt(screen_pt);

  var graphInfo = null;

  var isInside = function(val, center, width, padding) {
    return (
      (val < center + 0.5 * Math.abs(width) + padding) &&
      (val > center - 0.5 * Math.abs(width) + padding)
    );
  };

  for (var id in this.manager.graphImages) {
    var img = this.manager.graphImages[id];
    if (!img || img.hidden) continue;

    if (!isInside(pt.x, img.computed_x, img.computed_width, 0)) continue;
    if (!isInside(pt.y, img.computed_y, img.computed_height, 0)) continue;
    graphInfo = {id: id, img: img};
  }
  return graphInfo;
};

// TODO - cleanup
// returns an object containing the id, sketch, and the branch
POIController.prototype.getBranchInfoUnderPoint = function (screen_pt, tolerance) {

  var graphInfo = null;
  var minDis = tolerance;
  var projection = this.manager.createProjection();
  var pt = projection.reverse_map_pt(screen_pt);

  for (var id in this.manager.graphSketches) {
    var sketch = this.manager.graphSketches[id];
    if(!sketch || !sketch.visible) continue;

    var branches = sketch.branches;
    if (!branches || !branches.length) continue;

    for (var i=0; i<branches.length; i++) {
      var distance = POIController.calculateDistanceFromBranch(branches[i], pt, projection);
      if (distance < minDis) {
        minDis = distance;
        graphInfo = { id: id, branch: i, sketch: sketch };
      }
    }
  }

  return graphInfo;
};

POIController.calculateDistanceFromBranch = function(branch, pt, projection) {
  var distanceInfo = POIController.getBranchesDistanceInfo(branch, pt, projection);
  if (!distanceInfo) return Infinity;
  return distanceInfo.minDistance;
};

// Computes the closest point on branch to pt in screen space, along with some additional info
// that is useful for tracing.
//
// Returns an object
// {
//   closestPoint: { x: 1.0, y: 2.0},
//   minDistance: 3.0,
//   secondDistance: 4.0
// }
//
// Where the closest point coordinates are in math space, but the distances are measured in
// screen space.
//
// If the closest point on the branch lies to the left/right of pt, then secondDistance is the
// distance to the closest point to the right/left of pt respectively. This information is used
// by getBranchesTracePoint to interpolate between using the closest point and using a point
// directly above the mouse in order to avoid discontinuous jumps in the trace point when there
// is a discontinuous jump in the closest point on the curve.
POIController.getBranchesDistanceInfo = function (branch, pt, projection) {

  var xscale = projection.screen.width/(projection.viewport.xmax - projection.viewport.xmin);
  var yscale = projection.screen.height/(projection.viewport.ymax - projection.viewport.ymin);

  var x = pt.x;
  var y = pt.y;

  switch(branch.graphMode) {
    case GRAPHMODE.Y:
    break;

    case GRAPHMODE.X:
    var tmp_swap = x;
    x = y;
    y = tmp_swap;
    tmp_swap = xscale;
    xscale = yscale;
    yscale = tmp_swap;
    break;

    default:
    return null;
  }

  var minLeftDistance = Infinity;
  var minRightDistance = Infinity;
  var closestLeftPoint;
  var closestRightPoint;

  for (var i = 0; i < branch.segments.length; i++) {
    var segment = branch.segments[i];
    for (var j = 0; j < segment.length - 3; j += 2) {
      var x1 = segment[j];
      var y1 = segment[j + 1];
      var x2 = segment[j + 2];
      var y2 = segment[j + 3];
      var p = Distance.closestPointOnSegment(
        0, 0,
        (x1 - x)*xscale, (y1 - y)*yscale,
        (x2 - x)*xscale, (y2 - y)*yscale
      );
      var distance = Distance.hypot(p[0], p[1]);
      if (p[0] < 0) {
        if (distance < minLeftDistance) {
          minLeftDistance = distance;
          closestLeftPoint = p;
        }
      } else {
        if (distance < minRightDistance) {
          minRightDistance = distance;
          closestRightPoint = p;
        }
      }
    }
  }

  var closestPoint = (minLeftDistance < minRightDistance) ? closestLeftPoint : closestRightPoint;

  // Can happen if the branch has no segments, or if there is a segment with no points.
  if (!closestPoint) return null;

  var x_closest = closestPoint[0]/xscale + x;
  var y_closest = closestPoint[1]/yscale + y;

  return {
    closestPoint: {
      x: (branch.graphMode === GRAPHMODE.Y) ? x_closest : y_closest,
      y: (branch.graphMode === GRAPHMODE.Y) ? y_closest : x_closest
    },
    minDistance: Math.min(minLeftDistance, minRightDistance),
    secondDistance: Math.max(minLeftDistance, minRightDistance)
  };

};

// Picks a point on the curve that is close to pt for tracing.
//
// Considers the distance to the closest point on the curve that is to the left of pt and the
// closest point on the curve that is to the right of pt. If these distances are very different,
// uses the closest point on the curve. If these distances are similar, then a small change in the
// position of pt could cause a discontinuous jump in the closestPoint, so we smoothly switch to
// using a point directly above pt instead of the closest point.
//
// The two primary goals of this algorithm are to use the closest point on the curve when the mouse
// is near the curve, and to avoid discontinuous jumps of the trace point as the mouse is moved.
POIController.getBranchesTracePoint = function (branch, pt, projection) {
  // tables lack this, so we shouldn't don't try to see how close we are
  if (!branch || !branch.compiled || !branch.compiled.fn) return;
  var fn = branch.compiled.fn;

  var xscale = projection.screen.width/(projection.viewport.xmax - projection.viewport.xmin);
  var yscale = projection.screen.height/(projection.viewport.ymax - projection.viewport.ymin);

  var distanceInfo = this.getBranchesDistanceInfo(branch, pt, projection);

  if (!distanceInfo) return null;

  var aboveWeight = distanceInfo.minDistance/distanceInfo.secondDistance;

  // Exponent here is kind of a fudge factor. Higher exponents favor taking the closest point
  // over smoothly traversing the curve.
  aboveWeight = aboveWeight*aboveWeight;

  var dir = (branch.graphMode === GRAPHMODE.Y) ? 'x' : 'y';

  var x_weighted = (
    distanceInfo.closestPoint[dir]*(1 - aboveWeight) +
    pt[dir]*aboveWeight
  );

  // Want to find an x value with a nice decimal representation s.t.
  // x, f(x) lies within 1 pixel of x_weighted, f(x_weighted).
  // Evalutate function a half-pixel to the left and right of x_weighted,
  // and then linearly interpolate to restrict y values if necessary.
  var dx = 1/(2*xscale);
  var dy = 1/(2*yscale);

  var y_left = fn(x_weighted - dx);
  var y_mid = fn(x_weighted);
  var y_right = fn(x_weighted + dx);

  var dx_left = dx*Math.min(1, dy/Math.abs(y_left - y_mid));
  var dx_right = dx*Math.min(1, dy/Math.abs(y_right - y_mid));

  if (!isFinite(dx_left)) dx_left = dx;
  if (!isFinite(dx_right)) dx_right = dx;

  x_weighted = Rounding.shortestDecimalBetween(x_weighted - dx_left, x_weighted + dx_right);

  var above = POIController.fillHole(fn, x_weighted, xscale, yscale, pt.x, pt.y);

  return {
    x: (branch.graphMode === GRAPHMODE.Y) ? x_weighted : above,
    y: (branch.graphMode === GRAPHMODE.Y) ? above : x_weighted
  };
};

POIController.prototype.startMovingPoint = function (branchInfo) {
  var move_occured = false;
  var pt = {
    x: branchInfo.x,
    y: branchInfo.y
  };
  var id = branchInfo.id;
  var movable = branchInfo.sketch.branches[branchInfo.branch].graphMode === GRAPHMODE.XYPOINT_MOVABLE;

  this.manager.movablePointsLayer.pressedSketchId = movable ? branchInfo.sketch.id : null;
  this.manager.redrawMovablePointsLayer();

  $(document).on('tapmove.movepoint', function (evt) {
    move_occured = true;

    var projection = this.manager.createProjection();
    var screen_pt = this.getMouseRelativeToGrapher(evt);
    this.triggerMovePoint(id, screen_pt, projection);
  }.bind(this));

  $(document).on('tapend.movepoint tapcancel.movepoint', function (evt) {
    $(document).off('.movepoint');

    this.manager.movablePointsLayer.pressedSketchId = null;
    this.manager.redrawMovablePointsLayer();
    this.triggerStopMovingPoint(id);

    // if this was just a tap, then open a label for the point
    if (!move_occured) {
      var projection = this.manager.createProjection();
      var tolerance = this.getToleranceByDevice(evt.device);

      // figure out the exact location of the point on the screen
      var screen_pt = projection.map_pt({x: pt.x, y: pt.y});
      var sketch = this.manager.getGraphSketch(id);

      // save how many poi are open for this id
      var oldPOICount = sketch.openPOI.length;
      // toggle the poi
      this.togglePOIUnderPoint(screen_pt, tolerance);
      // check how many poi are open for this particular id now
      var newPOICount = sketch.openPOI.length;

      // notify that the point was clicked. If it was deselected, send null.
      if (newPOICount > oldPOICount) this.triggerSelectExpression(id);
    }
  }.bind(this));
};

// TODO - duplicating some code here
POIController.prototype.startTracingBranch = function (branchInfo, screen_pt) {
  this.last_screen_pt = screen_pt;
  var projection = this.manager.createProjection();
  var pt = projection.reverse_map_pt(screen_pt);

  var sketch = branchInfo.sketch;
  var branch = sketch.branches[branchInfo.branch];
  var tracePt = POIController.getBranchesTracePoint(branch, pt, projection);

  this.manager.traceLayer.traceInfo = {pt: tracePt, branchInfo: branchInfo};
  this.manager.redrawTraceLayer();

  $(document).on('tapmove.tracing', this.handleTraceUpdate.bind(this));
  $(document).on('tapend.tracing tapcancel.tracing', this.stopTracingBranch.bind(this));
};

POIController.prototype.stopTracingBranch = function (evt) {

  // if we're over an unopened hovered poi, open it
  var hoveredPOI = this.manager.poiLabelsLayer.hoveredPOI;
  if (hoveredPOI && !hoveredPOI.isOpen()) {
    hoveredPOI.open();
    this.manager.redrawPOILayer();
  }

  this.manager.traceLayer.traceInfo = null;
  this.manager.redrawTraceLayer();

  $(document).off('.tracing');
};

POIController.prototype.handleTraceUpdate = function(evt) {
  if(!this.manager.traceLayer.traceInfo) return;
  var projection = this.manager.createProjection();
  var screen_pt;
  if(evt){
    screen_pt = this.getMouseRelativeToGrapher(evt);
    this.last_screen_pt = screen_pt;
  } else {
    screen_pt = this.last_screen_pt;
  }
  var pt = projection.reverse_map_pt(screen_pt);
  var minDis = Infinity;
  var bestBranch = -1;

  var traceInfo = this.manager.traceLayer.traceInfo;
  var traceSketch = this.manager.graphSketches[traceInfo.branchInfo.sketch.id];
  traceInfo.branchInfo.sketch = traceSketch;
  var branches = traceInfo.branchInfo.sketch.branches;
  //Look up new branch each time

  // Loop through branches to find which we're closest too
  for(var i=0; i<branches.length; i++) {
    var branchDis = POIController.calculateDistanceFromBranch(branches[i], pt, projection);
    if(branchDis < minDis) {
      bestBranch = i;
      minDis = branchDis;
    }
  }

  var branch = branches[bestBranch];
  var tracePt = branch ? POIController.getBranchesTracePoint(branch, pt, projection) : null;

  this.manager.traceLayer.traceInfo.pt = tracePt;
  this.manager.redrawTraceLayer();
};

// TODO - might not belong here.. might be more appropriate in the math/poi.js
// TODO - probably better to be smarter about 'tiny offset'. should use a
//        dynmaic offset rather than always using 0.00000000001
POIController.fillHole = function(fn, x_val, xscale, yscale, x, y) {
  var y_val = fn(x_val);
  if (isFinite(y_val)) return y_val;

  var x_left =  x_val - 0.00000000001;
  var x_right = x_val + 0.00000000001;
  var y_left =  fn(x_left);
  var y_right = fn(x_right);

  if (isNaN(y_left) && isNaN(y_right)) return NaN;
  if (isNaN(y_left)) return y_right;
  if (isNaN(y_right)) return y_left;

  var dx_left = (x - x_left) * xscale;
  var dx_right = (x - x_right) * xscale;
  var dy_left = (y - y_left) * yscale;
  var dy_right = (y - y_right) * yscale;

  if (Distance.hypot(dx_left, dy_left) < Distance.hypot(dx_right, dy_right)) {
    return y_left;
  } else {
    return y_right;
  }
};

return POIController;
});

define('graphing/grapher',['require','jquery','browser','./viewport','./viewporttransformation','./screen','./poidotslayer','./poilabelslayer','./gridlayer','./graphsketch','./canvaslayer','./graphslayer','./imagelayer','./projection','./tracelayer','./movablepointslayer','math/poi','./viewportcontroller','./poicontroller'],function(require){
  var $ = require('jquery');
  var Browser = require('browser');
  var Viewport = require('./viewport');
  var ViewportTransformation = require('./viewporttransformation');
  var Screen = require('./screen');
  var POIDotsLayer = require('./poidotslayer');
  var POILabelsLayer = require('./poilabelslayer');
  var GridLayer = require('./gridlayer');
  var GraphSketch = require('./graphsketch');
  var CanvasLayer = require('./canvaslayer');
  var GraphsLayer = require('./graphslayer');
  var ImageLayer = require('./imagelayer');
  var Projection = require('./projection');
  var TraceLayer = require('./tracelayer');
  var MovablePointsLayer = require('./movablepointslayer');
  var POI = require('math/poi');
  var ViewportController = require('./viewportcontroller');
  var POIController = require('./poicontroller');

// This is the guy you talk to in order to allocate/deallocate graph layers.
// container is the <div> element that holds the graph area. Grapher handles resize automatically.
// onRecompute is the handler that should be called when a recompute is requested.
// onRecompute(viewport as Viewport, screen as Screen)
function Grapher(container, settings, $root) {
    this.container = container;
    this.$ = $(container);
    this.$root = $root;

    this.viewport = new Viewport();

    // a reference to an UnderscoreModel that we can ask for settings values
    this.settings = settings;

    // Warning, order matters here because both of these bind touch event
    // handlers, and we need tracing (poiController) to get priority over
    // dragging (viewportController).
    this.poiController = new POIController(this, settings);
    this.viewportController = ViewportController(this, settings);

    this.$.css('overflow', 'hidden');

    // image (canvas layer)
    this.imageLayer = ImageLayer();
    this.$.append( this.imageLayer.$ );
    // gridlines (canvas layer)
    this.gridLayer = GridLayer();
    this.$.append( this.gridLayer.$ );

    // poi dots (canvas layer)
    this.poiDotsLayer = POIDotsLayer();
    this.$.append( this.poiDotsLayer.$ );

    // graphs (canvas layer)
    this.graphsLayer = GraphsLayer();
    this.$.append( this.graphsLayer.$ );

    //movable points dom (DOM layer)
    this.movablePointsLayer = MovablePointsLayer(this.$root);
    this.movablePointsLayer.$.css('z-index', '0');
    this.$.append( this.movablePointsLayer.$ );

    // poi labels and opened dots (DOM layer)
    this.poiLabelsLayer = POILabelsLayer(this.$root);
    // some weird interaction with overflow:hidden requires a z-index to be
    // set for openpoi to not flicker.
    this.poiLabelsLayer.$.css('z-index', '0');
    this.$.append( this.poiLabelsLayer.$ );

    // trace layer (DOM layer)
    this.traceLayer = TraceLayer(this.$root);
    // some weird interaction with overflow:hidden requires a z-index to be
    // set for the tracing label to not flicker.
    this.traceLayer.$.css('z-index', '0');
    this.$.append( this.traceLayer.$ );

    // needed to tell IE9 that the layer should steal mouse events.
    if (Browser.IS_IE9) {
      this.traceLayer.$.addClass('dcg-transparent-bg');
    }

    this.transformation = new ViewportTransformation();

    // Which axes are currently being scaled. Managed by GraphController.
    // 'x', 'y', 'both', or undefined
    this.scaleAxis = undefined;

    this.__transient = false;
    this.graphSketches = {};
    this.graphImages = {};
    this.__sketchOrder = [];
    this.selectedId = null;
}

Grapher.prototype.setSketchOrder = function (drawOrder) {
  this.__sketchOrder = drawOrder;
  this.redrawGraphsLayer();
  this.redrawImageLayer();
};

Grapher.prototype.clear = function () {
  this.graphSketches = {};
  this.graphImages = {};
};

Grapher.prototype.getGraphSketch = function(graphId) {
  if (graphId in this.graphSketches) {
    return this.graphSketches[graphId];
  } else {
    return null;
  }
};

Grapher.prototype.addGraphSketch = function(sketch) {
  this.graphSketches[sketch.id] = sketch;
};

Grapher.prototype.removeGraphSketch = function(graphId) {
  delete this.graphSketches[graphId];
};

Grapher.prototype.addGraphImage = function(image) {
  this.graphImages[image.id] = image;
};
Grapher.prototype.removeGraphImage = function(imageId) {
  delete this.graphImages[imageId];
};

Grapher.prototype.createProjection = function () {
  var projection = new Projection(this.screen, this.viewport, this.settings);

  if (this.isInTransientState()) {
    return this.transformation.transformProjection(projection);
  } else {
    return projection;
  }
};

Grapher.prototype.computeDefaultViewport = function () {
  var viewport = new Viewport(-10, 10, -10, 10);
  viewport.squareYAxis(this.screen);
  viewport.round(this.screen);

  return viewport;
};

// Updates the screen sizes of all of the layers and requests a redraw, viewport stays the same.
Grapher.prototype.updateScreenSize = function(w, h) {
    if (w<=0 || h<=0) return;
    if (this.screen && this.screen.width === w && this.screen.height === h) return;
    this.$.width(w);

    var newScreen = new Screen(w, h);
    var newViewport;

    if (this.settings && this.settings.squareAxes) {

      // The following is used mainly in the API, for the case that the graphaper
      // starts off hidden or with zero size, and is later set to a finite size.
      if (!this.screen) {
        newViewport = this.viewport.clone();
        newViewport.squareYAxis(newScreen);
        newViewport.round(newScreen);
      } else {
        newViewport = this.createProjection().calculateViewportForScreen(newScreen);
      }
    } else {
      newViewport = this.viewport.clone();
    }

    this.screen = newScreen;

    this.viewportController.setViewport(newViewport);

    this.redrawAllLayers();
};

Grapher.prototype.beginTransientState = function() {
  if (this.isInTransientState()) return;

  var projection = this.createProjection();
  this.settings.isViewportTransient = true;
  this.graphsLayer.saveUnscaledCanvas(projection);

  this.__transient = true;
};

Grapher.prototype.endTransientState = function() {
  if (!this.isInTransientState()) return;
  var projection = this.createProjection();
  this.viewport = projection.viewport;
  this.viewport.round(projection.screen);
  this.settings.setProperty(
    'squareAxes',
    this.viewport.isSquare(projection.screen)
  );
  this.settings.isViewportTransient = false;
  this.transformation = new ViewportTransformation();
  this.graphsLayer.releaseUnscaledCanvas();
  this.__transient = false;
};

Grapher.prototype.isInTransientState = function () {
  return this.__transient;
};

Grapher.prototype.hide = function (id) {
  var sketch = this.getGraphSketch(id);
  if (sketch) sketch.visible = false;
};

Grapher.prototype.select = function (id) {
  var currentSketch = this.getGraphSketch(this.selectedId);
  if (currentSketch) currentSketch.selected = currentSketch.showPOI = currentSketch.showHighlight = false;
  var newSketch = this.getGraphSketch(id);
  if (newSketch) newSketch.selected = newSketch.showPOI = newSketch.showHighlight = true;
  this.selectedId = id;
};

Grapher.prototype.updateSketch = function (id, graphData) {
  //Pause updates while zooming, to stay in sync with cached canvas
  if(this.isInTransientState()) return;
  var currentSketch = this.getGraphSketch(id);

  //TODO When does this happen?
  if (!graphData.length) return this.hide(id);

  var newSketch = new GraphSketch(id, graphData);
  //TODO - handle differently-colored branches
  newSketch.color = graphData[0].color;
  newSketch.style = graphData[0].style;
  newSketch.updateFrom(currentSketch);
  newSketch.selected = newSketch.showPOI = newSketch.showHighlight = (String(id) === String(this.selectedId));
  this.addGraphSketch(newSketch);
};

Grapher.prototype.updateIntersections = function (id, intersections) {
  var sketch = this.getGraphSketch(id);
  if (sketch) sketch.updateIntersections(intersections);
};

Grapher.prototype.redrawAllLayers = function() {
  this.cancelRedrawSlowly();
  this.redrawGridLayer();
  this.redrawContentLayers();
};

Grapher.prototype.redrawContentLayers = function(){
  this.cancelRedrawSlowly();
  this.redrawGraphsLayer();
  this.redrawPOILayer();
  this.redrawTraceLayer();
  this.redrawMovablePointsLayer();
  this.redrawImageLayer();
};

Grapher.prototype.cancelRedrawSlowly = function(){
  clearTimeout(this.redraw_slowly_timeout);
  this.redraw_slowly_timeout = null;
};

Grapher.prototype.redrawSlowly = function(delay, step, n){
  //This is an intentional slow-down used on initial graph loads to give a line-by-line drawing effect.
  //It draws only the first n graphs, and calls itself repeatedly on a timeout until all layers are drawn
  //Every delay ms, it draws step more graphs
  if(typeof(delay) === 'undefined'){
    delay = 30;
  }
  if(typeof(step) === 'undefined'){
    step = 1;
  }
  if(typeof(n) === 'undefined'){
    this.cancelRedrawSlowly();
    n = 0;
  }

  this.redrawGridLayer(); //Always draw grid first
  var sketches_to_draw = {};
  var stopped_early = false;
  var i = 0;
  for(var id in this.graphSketches){
    if(i++ > n){
      stopped_early = true;
      break;
    }
    sketches_to_draw[id] = this.graphSketches[id];
  }
  this.graphsLayer.redraw(this.createProjection(), sketches_to_draw, this.__sketchOrder);

  if(stopped_early){
    var self = this;
    //Store timeout so that this can be interrupted
    this.redraw_slowly_timeout = setTimeout(function(){self.redrawSlowly(delay, step, n+step)}, delay);
  }
  else{
    //Only draw trace and POI if this was our last iteration
    this.redrawPOILayer();
    this.redrawTraceLayer();
    this.redrawMovablePointsLayer();

    this.redraw_slowly_timeout = null;
  }
};

Grapher.prototype.redrawGridLayer = function () {
  if (!this.screen) return;
  this.gridLayer.redraw(this.createProjection(), this.scaleAxis);
};

Grapher.prototype.redrawGraphsLayer = function () {
  if (!this.screen) return;
  if (!this.isInTransientState()) {
    this.graphsLayer.redraw(this.createProjection(), this.graphSketches, this.__sketchOrder);
  } else {
    this.graphsLayer.paintScaledCanvas(this.transformation);
  }
};

Grapher.prototype.redrawMovablePointsLayer = function () {
  if (!this.screen) return;
  this.movablePointsLayer.redraw(this.createProjection(), this.graphSketches);
};

Grapher.prototype.redrawPOILayer = function () {
  if (!this.screen) return;
  this.poiDotsLayer.redraw(this.createProjection(), this.graphSketches);
  this.poiLabelsLayer.redraw(this.createProjection(), this.graphSketches);
};

Grapher.prototype.redrawTraceLayer = function () {
  if (!this.screen) return;
  this.traceLayer.redraw(this.createProjection());
};

Grapher.prototype.redrawImageLayer = function () {
  if (!this.screen) return;
  this.imageLayer.redraw(this.createProjection(), this.graphImages, this.__sketchOrder);
};

Grapher.prototype.screenshot = function (width, height) {
  height = height || width || this.screen.height;
  width = width || this.screen.width;
  var screen = new Screen(width, height);

  var printLayer = CanvasLayer();
  printLayer.resize(width, height);
  var ctx = printLayer.ctx;

  var settings = this.settings.clone();
  if (width < 256 || height < 256) {
    settings.setProperty('xAxisNumbers', false);
    settings.setProperty('yAxisNumbers', false);
    settings.setProperty('polarNumbers', false);
  }

  var viewport = this.viewport.clone();

  if (viewport.isSquare(this.screen)) viewport.squareCrop(screen);

  var projection = new Projection(screen, viewport, settings);

  // Make a white background, since transparent backgrounds are funny in some
  // environments.
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, screen.width, screen.height);

  this.settings.takingScreenshot = true;
  this.imageLayer.redrawToCtx(ctx, projection, this.graphImages);
  this.gridLayer.redrawToCtx(ctx, projection);
  this.graphsLayer.redrawToCtx(ctx, projection, this.graphSketches);
  this.settings.takingScreenshot = false;

  return printLayer.canvas_node.get(0).toDataURL("image/png");
};

Grapher.prototype.thumbnail = Grapher.prototype.screenshot;

Grapher.prototype.getOpenIntersectionIds = function () {
  var openPOI;
  var hiddenOpenPOI;
  var i;

  var intersectIds = {};

  for (var id in this.graphSketches) {
    if (!this.graphSketches.hasOwnProperty(id)) continue;
    openPOI = this.graphSketches[id].openPOI;
    for (i = openPOI.length - 1; i >= 0; i--) {
      if (openPOI[i].type === POI.INTERSECTION) intersectIds[id] = true;
    }
    hiddenOpenPOI = this.graphSketches[id].hiddenOpenPOI;
    for (i = hiddenOpenPOI.length - 1; i >= 0; i--) {
      if (hiddenOpenPOI[i].type === POI.INTERSECTION) intersectIds[id] = true;
    }
  }

  return intersectIds;
};

Grapher.prototype.getSetting = function (setting, _default) {
  var value = this.settings.getProperty(setting);
  return value !== undefined ? value : _default;
};

Grapher.prototype.setSetting = function (setting, value, _default) {
  this.settings.setProperty(
    setting,
    value !== undefined ? value : _default
  );
};

Grapher.prototype.getState = function () {
  var state = {};
  var self = this;

  this.settings.stateProperties.forEach(function (prop) {
    state[prop] = self.getSetting(prop);
  });

  state.viewport = this.viewportController.getViewport().toObject();

  return state;
};

// TODO - Each one of these setSetting commands will update the grids
// layer. That's not terrible, but it might be nice to have control over
// that.
//
// Might be worth adding the observer in here rather than in
// graph_settings.js so that we can turn the observer off/on cleanly
// any time we do a batch update like this.
Grapher.prototype.setState = function (state) {
  this.setSetting('showGrid', state.showGrid, true);
  this.setSetting('polarMode', state.polarMode, false);
  this.setSetting('showXAxis', state.showXAxis, !!state.showAxes); // used to have a single showAxes option
  this.setSetting('showYAxis', state.showYAxis, !!state.showAxes); // used to have a single showAxes option
  this.setSetting('squareAxes', state.squareAxes, true);
  this.setSetting('xAxisStep', state.xAxisStep, state.labelXMode === 'pi' ? Math.PI : 0);
  this.setSetting('yAxisStep', state.yAxisStep, state.labelYMode === 'pi' ? Math.PI : 0);
  this.setSetting('degreeMode', state.degreeMode, false);
  this.setSetting('xAxisArrows', state.xAxisArrows, 'none');
  this.setSetting('yAxisArrows', state.yAxisArrows, 'none');
  this.setSetting('xAxisLabel', state.xAxisLabel, '');
  this.setSetting('yAxisLabel', state.yAxisLabel, '');
  this.setSetting('xAxisNumbers', state.xAxisNumbers, !!state.showLabels); //used to have a single showLabels option
  this.setSetting('yAxisNumbers', state.yAxisNumbers, !!state.showLabels); //used to have a single showLabels option
  this.setSetting('polarNumbers', state.polarNumbers, !!state.showLabels); //used to have a single showLabels option

  if ("viewport" in state) {
    var viewport = Viewport.fromObject(state.viewport);
    if (
      this.screen &&
      this.getSetting('squareAxes') &&
      !viewport.isSquare(this.screen)
    ) {
      viewport.squareYAxis(this.screen);
      viewport.round(this.screen);
    }

    this.viewportController.setViewport(viewport);
  }

};

return Grapher;
});

define('main/graph_settings',['require','pjs','underscore_model'],function(require){
  var P = require('pjs');
  var UnderscoreModel = require('underscore_model');

  /*
  * graph settings
  */

  var GraphSettings = P(UnderscoreModel, function (settings, _super) {

    //these are user-defined properties and can be saved in the state
    settings.init = function () {
      _super.init.call(this);
      this.stateProperties = [];

      //config holds properties of the individual API instance that
      //shouldn't be cloned (e.g. keyboardVisible). It has setProperty & getProperty
      //like any other underscore model
      this.config = new UnderscoreModel();

      // stored in state
      this.addStateProperty('showGrid', true);
      this.addStateProperty('polarMode', false);
      this.addStateProperty('showXAxis', true);
      this.addStateProperty('showYAxis', true);
      this.addStateProperty('xAxisStep', 0);
      this.addStateProperty('yAxisStep', 0);
      this.addStateProperty('degreeMode', false);
      this.addStateProperty('xAxisArrows', 'none');
      this.addStateProperty('yAxisArrows', 'none');
      this.addStateProperty('xAxisLabel', '');
      this.addStateProperty('yAxisLabel', '');
      this.addStateProperty('xAxisNumbers', true);
      this.addStateProperty('yAxisNumbers', true);
      this.addStateProperty('polarNumbers', true);
      this.addStateProperty('projectorMode', false);
      this.addStateProperty('squareAxes', true);

      // not stored in state
      this.computedStepSizes = {};
      this.squareAxes = true;

      //non computed -- these are the same for projectorMode and non-projector Mode
      this.labelHangingColor = 'rgba(150,150,150,1)';
      this.labelNormalColor = 'rgba(0,0,0,1)';

      //non-computed and not-stored in state. Just used for squaring Axes
      this.lastChangedAxis = 'x';

      // below here are properties that *are not* stored in the state and can,
      // right now, only be changed by toggling 'projectorMode'
      var self = this;
      function createProjectorProperty (property, offValue, onValue) {

        function computeProperty() {
          self.setProperty(property, self.projectorMode ? onValue : offValue);
        }

        self.observe('projectorMode', computeProperty);
        computeProperty();
      }

      function createHighlightProperty (property, off_off, off_on, on_off, on_on) {
        function computeProperty() {
          var value;
          if (self.projectorMode) {
            value = self.highlight ? on_on : on_off;
          } else {
            value = self.highlight ? off_on : off_off;
          }

          self.setProperty(property, value);
        }

        self.observe('projectorMode highlight', computeProperty);
        computeProperty();
      }

      //font size of labels
      createProjectorProperty('labelSize', 12, 16);
      //darker grid lines
      createProjectorProperty('majorAxisOpacity', 0.3, 0.5);

      //lighter grid lines
      createProjectorProperty('minorAxisOpacity', 0.12, 0.15);

      //main axes
      createProjectorProperty('axisOpacity', 0.7, 0.9);

      createProjectorProperty('axisLineWidth', 1, 2);

      //for antialiasing axes
      createProjectorProperty('axisLineOffset', 0.5, 0);

      //minimum separation between major axis lines
      createProjectorProperty('pixelsPerLabel', 70, 100);

      //line width for graphs
      createHighlightProperty('graphLineWidth', 2, 3, 6, 9);

      //line width for points
      createHighlightProperty('pointLineWidth', 7, 11, 15, 22);
    };

    settings.addStateProperty = function (prop, defaultValue) {
      this[prop] = defaultValue;
      this.stateProperties.push(prop);
    };

    settings.clone = function () {
      var newSettings = GraphSettings(this.grapher);

      var self = this;
      this.stateProperties.forEach(function (prop) {
        newSettings.setProperty(prop, self[prop]);
      });

      newSettings.setProperty('squareAxes', this.squareAxes);

      return newSettings;
    };

    settings.registerCallbacks = function (grapher, expressionsView, $rootElement) {

      var self = this;

      this.stateProperties.forEach(function (prop) {
        self.observe(prop, function () {
          grapher.redrawGridLayer();
        });
      });

      this.observe('squareAxes', function() {
        grapher.viewportController.enforceSquareAxes();
      });

      this.observe('projectorMode', function() {
        //set class on the body for POIs & trace -- see poi.css
        $rootElement.toggleClass('dcg-PROJECTOR-MODE', !!self.projectorMode);
        if (expressionsView) {
          expressionsView.onProjectorModeChange();
        }
        grapher.redrawAllLayers();
      });
    };
  });

  return GraphSettings;
});


define('expressions/abstractitem',['require','pjs','underscore_model'],function(require) {
  var P = require('pjs');
  var UnderscoreModel = require('underscore_model');

  var AbstractItemModel = P(UnderscoreModel, function (model, _super) {

    var nextItemId = 1;

    model.init = function (state, list) {
      _super.init.call(this);

      // TODO - these belong on view, not the model
      this.index = -1;
      this.selected = false;
      this.list = list;

      // Normalize ids to strings. Note that some legacy states are stored with integer ids.
      for (var property in state) {
        if (state.hasOwnProperty(property)) {
          if (property === 'id') {
            this[property] = '' + state[property];
          } else {
            this[property] = state[property];
          }
        }
      }

      if (!this.hasOwnProperty('id')) {
        this.id = '' + nextItemId++;
      } else if (parseInt(this.id, 10) >= nextItemId) {
        nextItemId = parseInt(this.id, 10) + 1;
      }

      this.observe('folder', this.updateFolder.bind(this));
      this.observe('selected', this.__onSelectedChange.bind(this));
    };

    model.eachLatex = function (fn) {}; // Not implemented

    model.onAddedToList = function () {};
    model.onRemovedFromList = function () {};

    // Record change for undo-redo
    model.onStateDidChange = function(prop) {
      var id = this.id;
      var oldValue = this.getOldProperty(prop);
      var newValue = this.getProperty(prop);

      var list = this.list;

      list.undoRedo.addTransaction({
        type: list.undoRedo.RESPONSE_TO_CHANGE,
        undo: function() {
          list.getItemById(id).setProperty(prop, oldValue);
        },
        redo: function () {
          list.getItemById(id).setProperty(prop, newValue);
        }
      });
    };

    model.updateCollapsed = function () {
      this.setProperty(
        'inCollapsedFolder',
        this.folder ? this.folder.collapsed : false
      );
    };

    model.updateFolder = function () {
      if (this.getOldProperty('folder')) {
        this.getOldProperty('folder').unobserve('.' + this.id);
      }
      if (this.folder) {
        this.folder.observe(
          'collapsed.' + this.id,
          this.updateCollapsed.bind(this)
        );
      }
      this.updateCollapsed();
    };

    // selecting an expression within a collapsed folder expands the folder.
    // this can happen by clicking the curve on the graphpaper
    model.__onSelectedChange = function () {
      // notify the list that the selectedItem has potentially changed. Putting this
      // as the very first handler to a selection change so that any calls (within this stack) to
      // list.getSelected() returns the correct thing.
      if (this.list) this.list.handleSelectionChange(this);

      // TODO - ideally the folder would be listening for this event on each of it's children, but the folder
      // doesn't have a reference to it's children. We should change that, but it's a potentially dangerous refactor.
      if (this.selected && this.inCollapsedFolder) {
        this.folder.updateSelectedHiddenChild();
      }
    };

  });

  return AbstractItemModel;
});

define('expressions/domain',['require','underscore_model','pjs'],function(require){
  var UnderscoreModel = require('underscore_model');
  var P = require('pjs');

var DomainModel = P(UnderscoreModel, function (model, _super) {
  model.init = function (min, max) {
    _super.init.call(this);
    this.min = min;
    this.max = max;
  };

  model.isValid = function () {
    return isFinite(this.min) && isFinite(this.max) && (this.max > this.min);
  };

  model.serialize = function () {
    return {min: this.min, max: this.max};
  };
});

DomainModel.deserialize = function (obj) {
  if (!obj) return DomainModel();
  else return DomainModel(obj.min, obj.max);
};

return DomainModel;
});

/* big.js v1.0.1 https://github.com/MikeMcl/big.js/LICENCE */
;(function ( global ) {


    /*
      big.js v1.0.1
      A small, fast Javascript library for arbitrary-precision arithmetic with decimal numbers.
      https://github.com/MikeMcl/big.js/
      Copyright (c) 2012 Michael Mclaughlin <M8ch88l@gmail.com>
      MIT Expat Licence
    */

    /****************************** EDITABLE DEFAULTS **********************************/


    // The default values below must be integers within the stated ranges (inclusive).

    /*
     * The maximum number of decimal places of the results of methods involving
     * division, i.e. 'div' and 'sqrt', and 'pow' with negative exponents.
     */
    Big['DP'] = 20;                                  // 0 to MAX_DP

    /*
     * The rounding mode used when rounding to the above decimal places.
     *
     * 0 Round towards zero (i.e. truncate, no rounding).               (ROUND_DOWN     )
     * 1 Round to nearest neighbour. If equidistant, round up.          (ROUND_HALF_UP  )
     * 2 Round to nearest neighbour. If equidistant, to even neighbour. (ROUND_HALF_EVEN)
     */
    Big['RM'] = 1;                                   // 0, 1 or 2

        // The maximum value of 'Big.DP'.
    var MAX_DP = 1E6,                                // 0 to 1e+6

        // The maximum magnitude of the exponent argument to the 'pow' method.
        MAX_POWER = 1E6,                             // 1 to 1e+6

        /*
         * The exponent value at and beneath which 'toString' returns exponential notation.
         * Javascript's Number type: -7
         * -1e+6 is the minimum recommended exponent value of a 'Big'.
         */
        TO_EXP_NEG = -7,                             // 0 to -1e+6

        /*
         * The exponent value at and above which 'toString' returns exponential notation.
         * Javascript's Number type: 21
         * 1e+6 is the maximum recommended exponent value of a 'Big', though there is no
         * enforcing or checking of a limit.
         */
        TO_EXP_POS = 21,                             // 0 to 1e+6


    /***********************************************************************************/

        P = Big.prototype,
        isValid = /^-?\d+(?:\.\d+)?(?:e[+-]?\d+)?$/i,
        ONE = new Big(1);


    // CONSTRUCTOR


    /*
     * The exported function.
     * Create and return a new instance of a 'Big' object.
     *
     * n {number|string|Big} A numeric value.
     */
    function Big( n ) {
        var i, j, nL,
            x = this;

        // Enable constructor usage without new.
        if ( !(x instanceof Big) ) {
            return new Big( n )
        }

        // Duplicate.
        if ( n instanceof Big ) {
            x['s'] = n['s'];
            x['e'] = n['e'];
            x['c'] = n['c'].slice();
            return
        }

        // Minus zero?
        if ( n === 0 && 1 / n < 0 ) {
            n = '-0'
        // Ensure 'n' is string and check validity.
        } else if ( !isValid.test(n += '') ) {
            throw NaN
        }

        // Determine sign.
        x['s'] = n.charAt(0) == '-' ? ( n = n.slice(1), -1 ) : 1;

        // Decimal point?
        if ( ( i = n.indexOf('.') ) > -1 ) {
            n = n.replace( '.', '' )
        }

        // Exponential form?
        if ( ( j = n.search(/e/i) ) > 0 ) {

            // Determine exponent.
            if ( i < 0 ) {
                i = j
            }
            i += +n.slice( j + 1 );
            n = n.substring( 0, j )

        } else if ( i < 0 ) {

            // Integer.
            i = n.length
        }

        // Determine leading zeros.
        for ( j = 0; n.charAt(j) == '0'; j++ ) {
        }

        if ( j == ( nL = n.length ) ) {

            // Zero.
            x['c'] = [ x['e'] = 0 ]
        } else {

            // Determine trailing zeros.
            for ( ; n.charAt(--nL) == '0'; ) {
            }

            x['e'] = i - j - 1;
            x['c'] = [];

            // Convert string to array of digits (without leading and trailing zeros).
            for ( i = 0; j <= nL; x['c'][i++] = +n.charAt(j++) ) {
            }
        }
    }


    // PRIVATE FUNCTIONS


    /*
     * Round 'Big' 'x' to a maximum of 'dp' decimal places using rounding mode
     * 'rm'. (Called by 'div', 'sqrt' and 'round'.)
     *
     * x {Big} The 'Big' to round.
     * dp {number} Integer, 0 to MAX_DP inclusive.
     * rm {number} 0, 1 or 2 ( ROUND_DOWN, ROUND_HALF_UP or ROUND_HALF_EVEN )
     * [more] {boolean} Whether the result of division was truncated.
     */
    function rnd( x, dp, rm, more ) {
        var xc = x['c'],
            i = x['e'] + dp + 1;

        if ( rm !== 0 && rm !== 1 && rm !== 2 ) {
            throw '!Big.RM!'
        }

        // 'xc[i]' is the digit after the digit that may be rounded up.
        rm = rm && ( xc[i] > 5 || xc[i] == 5 &&
          ( rm == 1 || more || i < 0 || xc[i + 1] != null || xc[i - 1] & 1 ) );

        if ( i < 1 || !xc[0] ) {
            x['c'] = rm
              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              ? ( x['e'] = -dp, [1] )
              // Zero.
              : [ x['e'] = 0 ];
        } else {

            // Remove any digits after the required decimal places.
            xc.length = i--;

            // Round up?
            if ( rm ) {

                // Rounding up may mean the previous digit has to be rounded up and so on.
                for ( ; ++xc[i] > 9; ) {
                    xc[i] = 0;

                    if ( !i-- ) {
                        ++x['e'];
                        xc.unshift(1)
                    }
                }
            }

            // Remove trailing zeros.
            for ( i = xc.length; !xc[--i]; xc.pop() ) {
            }
        }

        return x
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return
     * 1 if the value of this 'Big' is greater than the value of 'Big' 'y',
     * -1 if the value of this 'Big' is less than the value of 'Big' 'y', or
     * 0 if they have the same value,
     */
    P['cmp'] = function ( y ) {
        var xNeg,
            x = this,
            xc = x['c'],
            yc = ( y = new Big( y ) )['c'],
            i = x['s'],
            j = y['s'],
            k = x['e'],
            l = y['e'];

        // Either zero?
        if ( !xc[0] || !yc[0] ) {
            return !xc[0] ? !yc[0] ? 0 : -j : i
        }

        // Signs differ?
        if ( i != j ) {
            return i
        }
        xNeg = i < 0;

        // Compare exponents.
        if ( k != l ) {
            return k > l ^ xNeg ? 1 : -1
        }

        // Compare digit by digit.
        for ( i = -1,
              j = ( k = xc.length ) < ( l = yc.length ) ? k : l;
              ++i < j; ) {

            if ( xc[i] != yc[i] ) {
                return xc[i] > yc[i] ^ xNeg ? 1 : -1
            }
        }

        // Compare lengths.
        return k == l ? 0 : k > l ^ xNeg ? 1 : -1
    };


    /*
     * Return a new 'Big' whose value is the value of this 'Big' divided by the
     * value of 'Big' 'y', rounded, if necessary, to a maximum of 'Big.DP'
     * decimal places using rounding mode 'Big.RM'.
     */
    P['div'] = function ( y ) {
        var x = this,
            dvd = x['c'],
            dvs = ( y = new Big(y) )['c'],
            s = x['s'] == y['s'] ? 1 : -1,
            dp = Big['DP'];

        if ( dp !== ~~dp || dp < 0 || dp > MAX_DP ) {
            throw '!Big.DP!'
        }

        // Either 0?
        if ( !dvd[0] || !dvs[0] ) {

            // Both 0?
            if ( dvd[0] == dvs[0] ) {
                throw NaN
            }

            // 'dvs' is 0?
            if ( !dvs[0] ) {
                // Throw +-Infinity.
                throw s / 0
            }

            // 'dvd' is 0. Return +-0.
            return new Big( s * 0 )
        }


        var dvsL, dvsT, next, cmp, remI,
            dvsZ = dvs.slice(),
            dvdI = dvsL = dvs.length,
            dvdL = dvd.length,
            rem = dvd.slice( 0, dvsL ),
            remL = rem.length,
            quo = new Big(ONE),
            qc = quo['c'] = [],
            qi = 0,
            digits = dp + ( quo['e'] = x['e'] - y['e'] ) + 1;

        quo['s'] = s;
        s = digits < 0 ? 0 : digits;

        // Create version of divisor with leading zero.
        dvsZ.unshift(0);

        // Add zeros to make remainder as long as divisor.
        for ( ; remL++ < dvsL; rem.push(0) ) {
        }

        do {

            // 'next' is how many times the divisor goes into the current remainder.
            for ( next = 0; next < 10; next++ ) {

                // Compare divisor and remainder.
                if ( dvsL != ( remL = rem.length ) ) {
                    cmp = dvsL > remL ? 1 : -1
                } else {
                    for ( remI = -1, cmp = 0; ++remI < dvsL; ) {

                        if ( dvs[remI] != rem[remI] ) {
                            cmp = dvs[remI] > rem[remI] ? 1 : -1;
                            break
                        }
                    }
                }

                // Subtract divisor from remainder (if divisor < remainder).
                if ( cmp < 0 ) {

                    // Remainder cannot be more than one digit longer than divisor.
                    // Equalise lengths using divisor with extra leading zero?
                    for ( dvsT = remL == dvsL ? dvs : dvsZ; remL; ) {

                        if ( rem[--remL] < dvsT[remL] ) {

                            for ( remI = remL;
                                  remI && !rem[--remI];
                                  rem[remI] = 9 ) {
                            }
                            --rem[remI];
                            rem[remL] += 10
                        }
                        rem[remL] -= dvsT[remL]
                    }
                    for ( ; !rem[0]; rem.shift() ) {
                    }
                } else {
                    break
                }
            }

            // Add the 'next' digit to the result array.
            qc[qi++] = cmp ? next : ++next;

            // Update the remainder.
            rem[0] && cmp
              ? ( rem[remL] = dvd[dvdI] || 0 )
              : ( rem = [ dvd[dvdI] ] )

        } while ( ( dvdI++ < dvdL || rem[0] != null ) && s-- );

        // Leading zero? Do not remove if result is simply zero (qi == 1).
        if ( !qc[0] && qi != 1) {

            // There can't be more than one zero.
            qc.shift();
            quo['e']--;
        }

        // Round?
        if ( qi > digits ) {
            rnd( quo, dp, Big['RM'], rem[0] != null )
        }

        return quo
    }


    /*
     * Return a new 'Big' whose value is the value of this 'Big' minus the value
     * of 'Big' 'y'.
     */
    P['minus'] = function ( y ) {
        var d, i, j, xLTy,
            x = this,
            a = x['s'],
            b = ( y = new Big( y ) )['s'];

        // Signs differ?
        if ( a != b ) {
            return y['s'] = -b, x['plus'](y)
        }

        var xc = x['c'],
            xe = x['e'],
            yc = y['c'],
            ye = y['e'];

        // Either zero?
        if ( !xc[0] || !yc[0] ) {

            // 'y' is non-zero?
            return yc[0]
              ? ( y['s'] = -b, y )
              // 'x' is non-zero?
              : new Big( xc[0]
                ? x
                // Both are zero.
                : 0 )
        }

        // Determine which is the bigger number.
        // Prepend zeros to equalise exponents.
        if ( xc = xc.slice(), a = xe - ye ) {
            d = ( xLTy = a < 0 ) ? ( a = -a, xc ) : ( ye = xe, yc );

            for ( d.reverse(), b = a; b--; d.push(0) ) {
            }
            d.reverse()
        } else {

            // Exponents equal. Check digit by digit.
            j = ( ( xLTy = xc.length < yc.length ) ? xc : yc ).length;

            for ( a = b = 0; b < j; b++ ) {

                if ( xc[b] != yc[b] ) {
                    xLTy = xc[b] < yc[b];
                    break
                }
            }
        }

        // 'x' < 'y'? Point 'xc' to the array of the bigger number.
        if ( xLTy ) {
            d = xc, xc = yc, yc = d;
            y['s'] = -y['s']
        }

        /*
         * Append zeros to 'xc' if shorter. No need to add zeros to 'yc' if shorter
         * as subtraction only needs to start at 'yc.length'.
         */
        if ( ( b = -( ( j = xc.length ) - yc.length ) ) > 0 ) {

            for ( ; b--; xc[j++] = 0 ) {
            }
        }

        // Subtract 'yc' from 'xc'.
        for ( b = yc.length; b > a; ){

            if ( xc[--b] < yc[b] ) {

                for ( i = b; i && !xc[--i]; xc[i] = 9 ) {
                }
                --xc[i];
                xc[b] += 10
            }
            xc[b] -= yc[b]
        }

        // Remove trailing zeros.
        for ( ; xc[--j] == 0; xc.pop() ) {
        }

        // Remove leading zeros and adbust exponent accordingly.
        for ( ; xc[0] == 0; xc.shift(), --ye ) {
        }

        if ( !xc[0] ) {

            // Result must be zero.
            xc = [ye = 0]
        }

        return y['c'] = xc, y['e'] = ye, y
    };


    /*
     * Return a new 'Big' whose value is the value of this 'Big' modulo the
     * value of 'Big' 'y'.
     */
    P['mod'] = function ( y ) {
        y = new Big( y );
        var c,
            x = this,
            i = x['s'],
            j = y['s'];

        if ( !y['c'][0] ) {
            throw NaN
        }

        x['s'] = y['s'] = 1;
        c = y['cmp'](x) == 1;
        x['s'] = i, y['s'] = j;

        return c
          ? new Big(x)
          : ( i = Big['DP'], j = Big['RM'],
            Big['DP'] = Big['RM'] = 0,
              x = x['div'](y),
                Big['DP'] = i, Big['RM'] = j,
                  this['minus']( x['times'](y) ) )
    };


    /*
     * Return a new 'Big' whose value is the value of this 'Big' plus the value
     * of 'Big' 'y'.
     */
    P['plus'] = function ( y ) {
        var d,
            x = this,
            a = x['s'],
            b = ( y = new Big( y ) )['s'];

        // Signs differ?
        if ( a != b ) {
            return y['s'] = -b, x['minus'](y)
        }

        var xe = x['e'],
            xc = x['c'],
            ye = y['e'],
            yc = y['c'];

        // Either zero?
        if ( !xc[0] || !yc[0] ) {

            // 'y' is non-zero?
            return yc[0]
              ? y
              : new Big( xc[0]

                // 'x' is non-zero?
                ? x

                // Both are zero. Return zero.
                : a * 0 )
        }

        // Prepend zeros to equalise exponents.
        // Note: Faster to use reverse then do unshifts.
        if ( xc = xc.slice(), a = xe - ye ) {
            d = a > 0 ? ( ye = xe, yc ) : ( a = -a, xc );

            for ( d.reverse(); a--; d.push(0) ) {
            }
            d.reverse()
        }

        // Point 'xc' to the longer array.
        if ( xc.length - yc.length < 0 ) {
            d = yc, yc = xc, xc = d
        }

        /*
         * Only start adding at 'yc.length - 1' as the
         * further digits of 'xc' can be left as they are.
         */
        for ( a = yc.length, b = 0; a;
             b = ( xc[--a] = xc[a] + yc[a] + b ) / 10 ^ 0, xc[a] %= 10 ) {
        }

        // No need to check for zero, as +x + +y != 0 && -x + -y != 0

        if ( b ) {
            xc.unshift(b);
            ++ye
        }

         // Remove trailing zeros.
        for ( a = xc.length; xc[--a] == 0; xc.pop() ) {
        }

        return y['c'] = xc, y['e'] = ye, y
    };


    /*
     * Return a 'Big' whose value is the value of this 'Big' raised to the power
     * 'e'. If 'e' is negative, round, if necessary, to a maximum of 'Big.DP'
     * decimal places using rounding mode 'Big.RM'.
     *
     * e {number} Integer, -MAX_POWER to MAX_POWER inclusive.
     */
    P['pow'] = function ( e ) {
        var isNeg = e < 0,
            x = new Big(this),
            y = ONE;

        if ( e !== ~~e || e < -MAX_POWER || e > MAX_POWER ) {
            throw '!pow!'
        }

        for ( e = isNeg ? -e : e; ; ) {

            if ( e & 1 ) {
                y = y['times'](x)
            }
            e >>= 1;

            if ( !e ) {
                break
            }
            x = x['times'](x)
        }

        return isNeg ? ONE['div'](y) : y
    };


    /*
     * Return a new 'Big' whose value is the value of this 'Big' rounded, if
     * necessary, to a maximum of 'dp' decimal places using rounding mode 'rm'.
     * If 'dp' is not specified, round to 0 decimal places.
     * If 'rm' is not specified, use 'Big.RM'.
     *
     * [dp] {number} Integer, 0 to MAX_DP inclusive.
     * [rm] 0, 1 or 2 ( i.e. ROUND_DOWN, ROUND_HALF_UP or ROUND_HALF_EVEN )
     */
    P['round'] = function ( dp, rm ) {
        var x = new Big(this);

        if ( dp == null ) {
            dp = 0
        } else if ( dp !== ~~dp || dp < 0 || dp > MAX_DP ) {
            throw '!round!'
        }
        rnd( x, dp, rm == null ? Big['RM'] : rm );

        return x
    };


    /*
     * Return a new 'Big' whose value is the square root of the value of this
     * 'Big', rounded, if necessary, to a maximum of 'Big.DP' decimal places
     * using rounding mode 'Big.RM'.
     */
    P['sqrt'] = function () {
        var estimate, r, approx,
            x = this,
            xc = x['c'],
            i = x['s'],
            e = x['e'],
            half = new Big('0.5');

        // Zero?
        if ( !xc[0] ) {
            return new Big(x)
        }

        // Negative?
        if ( i < 0 ) {
            throw NaN
        }

        // Estimate.
        i = Math.sqrt( x.toString() );

        // Math.sqrt underflow/overflow?
        // Pass 'x' to Math.sqrt as integer, then adjust the exponent of the result.
        if ( i == 0 || i == 1 / 0 ) {
            estimate = xc.join('');

            if ( !( estimate.length + e & 1 ) ) {
                estimate += '0'
            }

            r = new Big( Math.sqrt(estimate).toString() );
            r['e'] = ( ( ( e + 1 ) / 2 ) | 0 ) - ( e < 0 || e & 1 )
        } else {
            r = new Big( i.toString() )
        }

        i = r['e'] + ( Big['DP'] += 4 );

        // Newton-Raphson loop.
        do {
            approx = r;
            r = half['times']( approx['plus']( x['div'](approx) ) )
        } while ( approx['c'].slice( 0, i ).join('') !==
                       r['c'].slice( 0, i ).join('') );

        rnd( r, Big['DP'] -= 4, Big['RM'] );

        return r
    };


    /*
     * Return a new 'Big' whose value is the value of this 'Big' times the value
     * of 'Big' 'y'.
     */
    P['times'] = function ( y ) {
        var c,
            x = this,
            xc = x['c'],
            yc = ( y = new Big( y ) )['c'],
            a = xc.length,
            b = yc.length,
            i = x['e'],
            j = y['e'];

        y['s'] = x['s'] == y['s'] ? 1 : -1;

        // Either 0?
        if ( !xc[0] || !yc[0] ) {

            return new Big( y['s'] * 0 )
        }

        y['e'] = i + j;

        if ( a < b ) {
            c = xc, xc = yc, yc = c, j = a, a = b, b = j
        }

        for ( j = a + b, c = []; j--; c.push(0) ) {
        }

        // Multiply!
        for ( i = b - 1; i > -1; i-- ) {

            for ( b = 0, j = a + i;
                  j > i;
                  b = c[j] + yc[i] * xc[j - i - 1] + b,
                  c[j--] = b % 10 | 0,
                  b = b / 10 | 0 ) {
            }

            if ( b ) {
                c[j] = ( c[j] + b ) % 10
            }
        }

        b && ++y['e'];

        // Remove any leading zero.
        !c[0] && c.shift();

        // Remove trailing zeros.
        for ( j = c.length; !c[--j]; c.pop() ) {
        }

        return y['c'] = c, y
    };


    /*
     * Return a string representing the value of this 'Big'.
     * Return exponential notation if this 'Big' has a positive exponent equal
     * to or greater than 'TO_EXP_POS', or a negative exponent equal to or less
     * than 'TO_EXP_NEG'.
     */
    P['toString'] = P['valueOf'] = function () {
        var x = this,
            e = x['e'],
            str = x['c'].join(''),
            strL = str.length;

        // Exponential notation?
        if ( e <= TO_EXP_NEG || e >= TO_EXP_POS ) {
            str = str.charAt(0) + ( strL > 1 ?  '.' + str.slice(1) : '' ) +
              ( e < 0 ? 'e' : 'e+' ) + e

        // Negative exponent?
        } else if ( e < 0 ) {

        // Prepend zeros.
            for ( ; ++e; str = '0' + str ) {
            }
            str = '0.' + str

        // Positive exponent?
        } else if ( e > 0 ) {

            if ( ++e > strL ) {

                // Append zeros.
                for ( e -= strL; e-- ; str += '0' ) {
                }
            } else if ( e < strL ) {
                str = str.slice( 0, e ) + '.' + str.slice(e)
            }

        // Exponent zero.
        } else if ( strL > 1 ) {
            str = str.charAt(0) + '.' + str.slice(1)
        }

        // Avoid '-0'
        return x['s'] < 0 && x['c'][0] ? '-' + str : str
    };


    /*
     ***************************************************************************
     *
     * If 'toExponential', 'toFixed', 'toPrecision' and 'format' are not
     * required they can safely be commented-out or deleted. No redundant code
     * will be left. 'format' is used only by 'toExponential', 'toFixed' and
     * 'toPrecision'.
     *
     ***************************************************************************
     */


    /*
     * PRIVATE FUNCTION
     *
     * Return a string representing the value of 'Big' 'x' in normal or
     * exponential notation to a fixed number of decimal places or significant
     * digits 'dp'.
     * (Called by toString, toExponential, toFixed and toPrecision.)
     *
     * x {Big} The 'Big' to format.
     * dp {number} Integer, 0 to MAX_DP inclusive.
     * toE {number} undefined (toFixed), 1 (toExponential) or 2 (toPrecision).
     */
    function format( x, dp, toE ) {
        // The index (in normal notation) of the digit that may be rounded up.
        var i = dp - ( x = new Big(x) )['e'],
            c = x['c'];

        // Round?
        if ( c.length > ++dp ) {
            rnd( x, i, Big['RM'] )
        }

        // Recalculate 'i' if toFixed as 'x.e' may have changed if value rounded up.
        i = !c[0] ? i + 1 : toE ? dp : ( c = x['c'], x['e'] + i + 1 );

        // Append zeros?
        for ( ; c.length < i; c.push(0) ) {
        }
        i = x['e'];

        /*
         * 'toPrecision' returns exponential notation if the number of
         * significant digits specified is less than the number of digits
         * necessary to represent the integer part of the value in normal
         * notation.
         */
        return toE == 1 || toE == 2 && ( dp <= i || i <= TO_EXP_NEG )

            // Exponential notation.
            ? ( x['s'] < 0 && c[0] ? '-' : '' ) + ( c.length > 1
              ? ( c.splice( 1, 0, '.' ), c.join('') )
              : c[0] ) + ( i < 0 ? 'e' : 'e+' ) + i

            // Normal notation.
            : x.toString()
    }


    /*
     * Return a string representing the value of this 'Big' in exponential
     * notation to 'dp' fixed decimal places and rounded, if necessary, using
     * 'Big.RM'.
     *
     * [dp] {number} Integer, 0 to MAX_DP inclusive.
     */
    P['toExponential'] = function ( dp ) {

        if ( dp == null ) {
            dp = this['c'].length - 1
        } else if ( dp !== ~~dp || dp < 0 || dp > MAX_DP ) {
            throw '!toExp!'
        }

        return format( this, dp, 1 )
    };


    /*
     * Return a string representing the value of this 'Big' in normal notation
     * to 'dp' fixed decimal places and rounded, if necessary, using 'Big.RM'.
     *
     * [dp] {number} Integer, 0 to MAX_DP inclusive.
     */
    P['toFixed'] = function ( dp ) {
        var str,
            x = this,
            neg = TO_EXP_NEG,
            pos = TO_EXP_POS;

        TO_EXP_NEG = -( TO_EXP_POS = 1 / 0 );

        if ( dp == null ) {
            str = x.toString()
        } else if ( dp === ~~dp && dp >= 0 && dp <= MAX_DP ) {
            str = format( x, x['e'] + dp );

            // (-0).toFixed() is '0', but (-0.1).toFixed() is '-0'.
            // (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
            if ( x['s'] < 0 && x['c'][0] && str.indexOf('-') < 0 ) {
                // As e.g. -0.5 if rounded to -0 will cause toString to omit the minus sign.
                str = '-' + str
            }
        }
        TO_EXP_NEG = neg, TO_EXP_POS = pos;

        if ( !str ) {
            throw '!toFix!'
        }

        return str
    };


    /*
     * Return a string representing the value of this 'Big' to 'sd' significant
     * digits and rounded, if necessary, using 'Big.RM'. If 'sd' is less than
     * the number of digits necessary to represent the integer part of the value
     * in normal notation, then use exponential notation.
     *
     * sd {number} Integer, 1 to MAX_DP inclusive.
     */
    P['toPrecision'] = function ( sd ) {

        if ( sd == null ) {
            return this.toString()
        } else if ( sd !== ~~sd || sd < 1 || sd > MAX_DP ) {
            throw '!toPre!'
        }

        return format( this, sd - 1, 2 )
    };


    // EXPORT


    // Node and other CommonJS-like environments that support module.exports.
    if ( typeof module !== 'undefined' && module.exports ) {
        module.exports = Big

    //AMD.
    } else if ( typeof define == 'function' && define.amd ) {
        define('vendor/big',[], function () {
            return Big
        })

    //Browser.
    } else {
        global['Big'] = Big
    }

})( this );

define('big',['require','vendor/big'],function(require){
  var Big = require('vendor/big');
  Big.prototype.equals = function (x) { return this.cmp(x) === 0; };
  return Big;
});

define('expressions/slider',['require','pjs','underscore_model','big','lib/rounding'],function(require) {
  var P = require('pjs');
  var UnderscoreModel = require('underscore_model');
  var Big = require('big');
  var Rounding = require('lib/rounding');

  var SliderModel = P(UnderscoreModel, function (model, _super) {

    model.DEFAULT_PERIOD = 8000; //8s

    model.init = function (options) {
      _super.init.call(this);
      if (!options) {
        options = {};
      }

      this.hardMin = !!options.hardMin;
      this.hardMax = !!options.hardMax;
      this.min = options.min === undefined ? -10 : options.min;
      this.max = options.max === undefined ? 10 : options.max;
      this.value = options.value !== undefined ? options.value : 0;
      this.step = options.step;
      this.animationPeriod = options.animationPeriod !== undefined ? options.animationPeriod : this.DEFAULT_PERIOD;
      this.playDirection = options.playDirection !== undefined ? options.playDirection : 1;
      this.isPlaying = options.isPlaying !== undefined ? options.isPlaying : false;
      this.observe('isPlaying', this.updateAnimationTargetValue.bind(this));
      this.observe('stepper isPlaying', this.updateObservedStepper.bind(this));
      this.observe('dragging isMoving isPlaying', this.setTransient.bind(this));

      this.observe('isPlaying', function () {
        if (this.isPlaying) {
          this.animationTargetValue = this.value; //Animate target value smoothly, and just round displayed value
        }
      }.bind(this));

      this.observe('isPlaying dragging isMoving', this.setTransient.bind(this));
      this.observe('stepper isPlaying', this.updateObservedStepper.bind(this));

      // a slider can start of with isPlaying=true, so the observer for 'isPlaying' won't fire. Call it
      // manually here.
      this.updateAnimationTargetValue();

      // a slider can start off with 'isPlaying' === true. Manually call the observers that
      // would be called if we pressed the play button.
      this.setTransient();
    };

    model.updateAnimationTargetValue = function () {
      if (this.isPlaying) {
        this.animationTargetValue = this.value; //Animate target value smoothly, and just round displayed value
      }
    };

    model.setTransient = function () {
      this.setProperty(
        'transient',
        this.dragging || this.isPlaying || this.isMoving
      );
    };

    model.updateObservedStepper = function () {
      var canPlayStep = this.isPlaying && this.stepper;
      var shouldUnobserve = (!canPlayStep || this.stepper !== this._observedStepper) && this._observedStepper;
      var shouldObserve = canPlayStep && this._observedStepper !== this.stepper;

      if (shouldUnobserve) {
        this._observedStepper.unobserve('playStep.' + this.guid);
        this._observedStepper = undefined;
      }

      if (shouldObserve ) {
        this._observedStepper = this.stepper;
        this._observedStepper.observe('playStep.' + this.guid, this.playStep.bind(this));
      }
    };

    model.playStep = function () {
      //PingPong behavior
      if (this.animationTargetValue >= this.max) {
        this.playDirection = -1;
      } else if (this.animationTargetValue <= this.min) {
        this.playDirection = +1;
      }

      var animationStep = (this.max - this.min) * ((1000 / this.stepper.stepHz) / this.animationPeriod);

      //Animate target without accumulating rounding error
      this.animationTargetValue += animationStep * this.playDirection;

      var newValue = this.computeSnappedValue(this.animationTargetValue); //Always snap to slider markers
      if(!this.step){
        //If no markers, snap to a reasonable decimal close to the animation target
        newValue = Rounding.shortestDecimalBetween(newValue - animationStep * 0.1, newValue + animationStep * 0.1);
      }

      //don't exceed the endpoints
      newValue = Math.max(this.min, Math.min(this.max, newValue));

      //commit the value change
      this.setProperty('value', newValue);
    };

    model.serialize = function () {
      return {
        min: this.min,
        max: this.max,
        hardMin: this.hardMin,
        hardMax: this.hardMax,
        step: this.step,
        value: this.value,
        playDirection: this.playDirection,
        animationPeriod: this.animationPeriod,
        isPlaying: this.isPlaying
      };
    };

    model.computeSnappedValue = function (val) {
      if (this.step) {
        var nsteps = Math.round((val - this.min)/this.step);
        // Use big.js to do exact decimal arithmetic to avoid rounding errors here.
        var snapped = (new Big(this.step)).times(nsteps).plus(this.min);
        // Turn back to Number
        val = parseFloat(snapped.toString());
      }

      // enforce hard limits
      if (this.hardMin && val < this.min) val = this.min;
      if (this.hardMax && val > this.max) val = this.max;

      return val;
    };

  });

  return SliderModel;
});

define('expressions/colors',['require'],function(require) {
  var RED = '#C0504D';
  var BLUE = '#4F81BD';
  var GREEN = '#9BBB59';
  var PURPLE = '#8064A2';
  var ORANGE = '#F79646';
  var BLACK = '#000000';
  var all = [ RED, BLUE, GREEN, PURPLE, ORANGE, BLACK ];
  var i = 0;

  function next () {
    var color = all[i];
    i = (i + 1) % all.length;
    return color;
  }

  function reset () {
    i = 0;
  }

  return {
    all: all,
    next: next,
    reset: reset,
    RED: RED,
    BLUE: BLUE,
    GREEN: GREEN,
    PURPLE: PURPLE,
    ORANGE: ORANGE,
    BLACK: BLACK
  };
});
define('expressions/expression',['require','pjs','./abstractitem','./domain','./slider','./colors'],function(require){
  var P = require('pjs');
  var AbstractItemModel = require('./abstractitem');
  var DomainModel = require('./domain');
  var SliderModel = require('./slider');
  var Colors = require('./colors');

  var ExpressionObject = P(AbstractItemModel, function(model, _super) {
    model.isExpression = true;

    model._computeNewLatex = function(latex, newValue) {
      //we know the expression will look like:
      // a bunch of stuff (we ignore this in the regex)
      // an "=" (doesn't slide if it's < or >)
      //
      // a bunch of stuff (spaces, parens, the rest of the le, ge, etc)  ($1)
      // the number we're trying to replace ($2)
      // a bunch more stuff (spaces, parens, etc.) (we ignore this in the regex)
      var regex = /=(.*?)([-\.0-9]+)/;

      //if they're typing something crazy like y=00001, we want to not overwrite their work
      var matches = latex.match(regex);
      if (parseFloat(matches[2]) === newValue) return latex;

      return latex.replace(regex, "=$1" + newValue);
    };

    model.isExpression = true;

    model.init = function (state, list) {
      _super.init.call(this, state, list);

      this.loading = true;
      // a default blank formula while we calculate the real one
      this.formula = {error:''};
      // Use to signifiy that a plotted expression has not been fully resolved by the plotter.
      this.unresolved = false;

      // TODO - this is very temporary. Eventually we'll want to save the
      // slider info in here, but there are some old states that have obsolete
      // values stored in there. We've repurposed the .slider variable on this
      // class to be a SliderModel. Because the .slider value is being set
      // on instantiation, we aren't overwriting it with a SliderModel. Then,
      // when the .slider property is expected to do things that a SliderModel
      // can, it throws an error. When we migrate old graph states to use this
      // property, we need to remove the next line.
      delete this.slider;
      // fill in a color if not specified
      if (!this.color) {
        this.color = Colors.next();
      }
      // convert old style of color definition to simpler new version
      else if (typeof this.color === 'object') {
        this.color = this.color.value;
      }
      if (this.style === undefined) {
        this.style = 'normal';
      }
      if (this.hidden === undefined) {
        // Check userRequestedGraphing for legacy states
        this.hidden = (this.userRequestedGraphing === 'never');
      }

      if (this.latex === undefined) this.latex = '';

      // convert raw domain object to a DomainModel Object
      var raw_domain = this.domain ? this.domain : {min: 0, max: 1};
      this.domain = DomainModel.deserialize(raw_domain);
      this.domain.observe('min max', function (property) {
        this.onExpressionDidChange();

        // handle undo/redo
        var id = this.id;
        var oldValue = this.domain.getOldProperty(property);
        var newValue = this.domain.getProperty(property);
        var list = this.list;

        list.undoRedo.addTransaction({
          type: list.undoRedo.RESPONSE_TO_CHANGE,
          undo: function()  { list.getItemById(id).domain.setProperty(property, oldValue); },
          redo: function () { list.getItemById(id).domain.setProperty(property, newValue); }
        });
      }.bind(this));

      if (!this.regressionParameters) this.regressionParameters = {};
      if (!this.residualVariable) this.residualVariable = '';

      this.computeShouldGraph();

      this.observe('formula', this.onFormulaUpdate.bind(this));
      this.observe('latex color hidden style', this.onStateDidChange.bind(this));
      this.observe('latex shouldGraph color style', this.onExpressionDidChange.bind(this));
      this.observe('hidden', this.computeShouldGraph.bind(this));
    };

    model.onStateDidChange = function (prop) {

      // ignore latex changes from transient slider
      if (prop === 'latex' && this.slider && this.slider.transient) {
        return;
      }

      // don't send to undo/redo if this is the first set
      if (prop === 'style' && this.getOldProperty('style') === undefined) {
        return;
      }

      _super.onStateDidChange.call(this, prop);
    };

    model.updateFolder = function () {
      _super.updateFolder.call(this);

      // TODO namespacing with the id seems kind of gross...
      if (this.getOldProperty('folder')) {
        this.getOldProperty('folder').unobserve('.' + this.id);
      }
      if (this.folder) {
        this.folder.observe(
          'hidden.' + this.id,
          this.computeShouldGraph.bind(this)
        );
      }
      this.computeShouldGraph();
    };

    model.computeShouldGraph = function () {
      if (this.folder && this.folder.hidden) {
        this.setProperty('shouldGraph', false);
        return;
      }
      this.setProperty('shouldGraph', !this.hidden);
    };

    model.onExpressionDidChange = function() {
      if (this.domain.isValid()) {
        this.requestParse();
      }
    };

    model.eachLatex = function (fn) {
      fn(this.latex);
      if (this.residualVariable) fn(this.residualVariable);
    };

    model.getParsableObject = function () {
      //Work-around for bug in Mathquill / expression list
      // where on deletion of an expression via back-space key, Mathquill fires both an UpwardDelete
      // and a Render event.  UpwardDelete causes the expressionList to delete, and Render causes
      // expression list to fire another add request for the already deleted expression, which comes
      // in with latex === undefined.
      if(this.latex === undefined){
        return undefined;
      }
      return {
        type: 'statement',
        id: this.id,
        latex: this.latex,
        domain: this.domain.serialize(),
        shouldGraph: this.shouldGraph,
        color: this.color,
        style: this.style,
        residualVariable: this.residualVariable,
        regressionParameters: this.regressionParameters
      };
    };

    model.requestParse = function () {
      this.list.triggerAddExp(this.getParsableObject());
    };

    model.requestUnparse = function () {
      this.list.triggerRemoveExp(this.id);
    };

    model.onAddedToList = function () {
      this.requestParse();
    };

    model.onRemovedFromList = function () {
      // turn slider off when deleted
      if (this.slider) {
        this.slider.setProperty('isPlaying', false);
      }

      this.requestUnparse();
    };

    model.getState = function() {
      /* jshint maxcomplexity:11 */
      var state = {
        id: this.id,
        latex: this.latex,
        domain: this.domain.serialize(),
        hidden: this.hidden,
        color: this.color,
        style: this.style,
        residualVariable: this.residualVariable,
        regressionParameters: this.regressionParameters
      };

     // TODO - change this to state.slider = this.slider.serialize() but can't
     // do that until we convert all previously saved graphs to have a slider
     // object rather than three global properties. We either need to do that
     // or we need to make the setState() function backwards compatible.
     if (this.slider) {
       state.sliderMin = this.slider.min;
       state.sliderMax = this.slider.max;
       state.sliderHardMin = this.slider.hardMin;
       state.sliderHardMax = this.slider.hardMax;
       state.sliderInterval = this.slider.step;
       state.sliderAnimationPeriod = this.slider.animationPeriod;
       state.sliderPlayDirection = this.slider.playDirection;
       state.sliderIsPlaying = this.slider.isPlaying;
     }

     // if we haven't been parsed yet, just return what we started
     // with. Gross, gross, gross!
     else if (this.loading) {
       if (this.hasOwnProperty('sliderMin')) state.sliderMin = this.sliderMin;
       if (this.hasOwnProperty('sliderMax')) state.sliderMax = this.sliderMax;
       if (this.hasOwnProperty('sliderHardMin')) state.sliderHardMin = this.sliderHardMin;
       if (this.hasOwnProperty('sliderHardMax')) state.sliderHardMax = this.sliderHardMax;
       if (this.hasOwnProperty('sliderInterval')) state.sliderInterval = this.sliderInterval;
       if (this.hasOwnProperty('sliderAnimationPeriod')) state.sliderAnimationPeriod = this.sliderAnimationPeriod;
       if (this.hasOwnProperty('sliderPlayDirection')) state.sliderPlayDirection = this.sliderPlayDirection;
       if (this.hasOwnProperty('sliderIsPlaying')) state.sliderIsPlaying = this.sliderIsPlaying;
     }

     return state;
    };

    model.onFormulaUpdate = function () {
      var formula = this.formula;

      this.setProperty('error', formula.error ? formula.error : '');
      this.setProperty('isGraphable', formula.is_graphable);
      this.setProperty('dependent', formula.assignment);
      this.setProperty('isTableable', formula.is_tableable);
      this.setProperty('unresolved', false);

      this.validateStyle();

      if (formula.is_slidable) {
        // delay instantiation of a slider for this expression until we need one.
        if (!this.slider) this.createSliderModel();
        // When we're in transient mode, the frontend is in charge of writes to the slider
        // so ignore updates from the worker
        if (!this.slider.transient) this.slider.setProperty('value', formula.constant_value);
      } else {
        this.slider = null;
      }

      if (formula.is_regression) {
        this.regressionParameters = formula.regression.parameters;
        this.residualVariable = formula.regression.residualVariable;
      } else {
        this.regressionParameters = {};
      }
    };

    model.validateStyle = function () {
      var formula = this.formula;
      if (formula.error) return;

      // When we default the style back to expression default we need the
      // onStateDidChange handler to know to not send the change to undo/redo.
      // This is part of a bigger change that'll automatically cause the style
      // to change. Without the self.style = undefined catch we'll get an
      // extra undo/redo transaction stored. That'll also mess up Toast on setState.
      var self = this;
      function defaultStyleTo (style) {
        if (self.style !== style) {
          self.style = undefined;
          self.setProperty('style', style);
        }
      }

      // If we have changed from a point to a function or vis a versa, we need to be
      // the default draw style for that type.
      if (formula.is_point_list) {
        if (!(this.style === 'point' || this.style === 'open' || this.style === 'cross')) {
          defaultStyleTo('point');
        }
      } else if (formula.is_inequality) {
        // Graphlayer will deal with making this dashed if the inequality requires it.
        defaultStyleTo('normal');
      } else {
        if (!(this.style === 'normal' || this.style === 'dashed')) {
          defaultStyleTo('normal');
        }
      }
    };

    model.createSliderModel = function () {
      // Once created, the slider object won't be destroyed. The slider instance sticks
      // around to save information about limits. They'd get reset each time if we didn't
      // keep the slider. Also, things that observe changes to the slider shouldn't have
      // to change observers from one slider object to another.
      if (this.__singleSliderInstance) {
        this.slider = this.__singleSliderInstance;
        return;
      }

      this.slider = this.__singleSliderInstance = SliderModel({
        min: this.sliderMin !== undefined ? this.sliderMin : -10,
        max: this.sliderMax !== undefined ? this.sliderMax : 10,
        hardMin: this.sliderHardMin,
        hardMax: this.sliderHardMax,
        animationPeriod: this.sliderAnimationPeriod,
        playDirection: this.sliderPlayDirection,
        isPlaying: this.sliderIsPlaying,
        step: this.sliderInterval,
        value: this.formula.constant_value
      });

      var id = this.id;
      var list = this.list;

      this.slider.observe('step', function () {
        // don't record changes in undo/redo while slider is transient.
        // this is handled elsewhere specially
        if (this.slider.transient) return;

        var oldStep = this.slider.getOldProperty('step');
        var newStep = this.slider.getProperty('step');

        list.undoRedo.addTransaction({
          type: list.undoRedo.RESPONSE_TO_CHANGE,
          undo: function() {
            list.getItemById(id).slider.setProperty('step', oldStep);
          },
          redo: function() {
            list.getItemById(id).slider.setProperty('step', newStep);
          }
        });
      }.bind(this));

      this.slider.observe('min', function () {
        // don't record changes in undo/redo while slider is transient.
        // this is handled elsewhere specially
        if (this.slider.transient) return;

        var oldMin = this.slider.getOldProperty('min');
        var newMin = this.slider.getProperty('min');
        var oldValue = this.slider.getProperty('value');
        var oldLatex = newMin > oldValue ? this.latex : null;
        var newLatex = newMin > oldValue ? this._computeNewLatex(oldLatex, newMin) : null;

        list.undoRedo.addTransaction({
          type: list.undoRedo.CAUSE_OF_CHANGE,
          undo: function () {
            var expression =  list.getItemById(id);
            expression.slider.setProperty('min', oldMin);
            if (oldLatex) {
              expression.setProperty('latex', oldLatex);
            }
          },
          redo: function () {
            var expression =  list.getItemById(id);
            expression.slider.setProperty('min', newMin);
            if (newLatex) {
              expression.setProperty('latex', newLatex);
            }
          }
        });
      }.bind(this));

      this.slider.observe('max', function () {
        // don't record changes in undo/redo while slider is transient.
        // this is handled elsewhere specially
        if (this.slider.transient) return;

        var oldMax = this.slider.getOldProperty('max');
        var newMax = this.slider.getProperty('max');
        var oldValue = this.slider.getProperty('value');
        var oldLatex = newMax < oldValue ? this.latex : null;
        var newLatex = newMax < oldValue ? this._computeNewLatex(oldLatex, newMax) : null;

        list.undoRedo.addTransaction({
          type: list.undoRedo.CAUSE_OF_CHANGE,
          undo: function () {
            var expression =  list.getItemById(id);
            expression.slider.setProperty('max', oldMax);
            if (oldLatex) {
              expression.setProperty('latex', oldLatex);
            }
          },
          redo: function () {
            var expression =  list.getItemById(id);
            expression.slider.setProperty('max', newMax);
            if (newLatex) {
              expression.setProperty('latex', newLatex);
            }
          }
        });
      }.bind(this));

      this.slider.observe('transient', function () {
        var wasTransient = this.slider.getOldProperty('transient');
        var isTransient = this.slider.getProperty('transient');

        // just turned transient
        if (!wasTransient && isTransient) {

          // this will be filled in when we end the transient state.
          var startingValues = this.slider.serialize();
          var endingValues = this.slider.serialize();

          // when undoing or redoing, pause the slider
          startingValues.isPlaying = false;
          endingValues.isPlaying = false;

          // keep a record to ending values so that we can update them when we end transient state
          this.transientEndingValues = endingValues;

          list.undoRedo.addTransaction({
            type: list.undoRedo.RESPONSE_TO_CHANGE,
            undo: function () {
              var expression =  list.getItemById(id);

              // set starting values
              for (var prop in startingValues) {
                if (startingValues.hasOwnProperty(prop)) {
                  expression.slider.setProperty(prop, startingValues[prop]);
                }
              }
            },
            redo: function () {
              var expression =  list.getItemById(id);

              // set ending values
              for (var prop in endingValues) {
                if (endingValues.hasOwnProperty(prop)) {
                  expression.slider.setProperty(prop, endingValues[prop]);
                }
              }
            }
          });
        }

        // just ended being transient
        else if (wasTransient && !isTransient && this.transientEndingValues) {
          var lastValues = this.slider.serialize();

          // update the values stored within the undo/redo transaction
          for (var prop in lastValues) {
            if (lastValues.hasOwnProperty(prop)) {
              this.transientEndingValues[prop] = lastValues[prop];
            }
          }
        }
      }.bind(this));

      this.slider.observe('value', function () {
        var newValue = this.slider.getProperty('value');

        // if slider value is smaller than min, decrease min to equal value
        if (newValue < this.slider.min) {
          this.slider.setProperty('min', newValue);
        }

        // if slider value is bigger than max, increase max to equal value
        if (newValue > this.slider.max) {
          this.slider.setProperty('max', newValue);
        }

        // compute and set what the new latex should be based on the value change
        var newLatex = this._computeNewLatex(this.latex, newValue);
        this.setProperty('latex', newLatex);
      }.bind(this));

      // the list is going to step the slider through its animation
      this.slider.setProperty('stepper', this.list);

      // let others know that we've created the slider model
      this.notifyPropertyChange('slider');
    };

    model.isEmpty = function() {
      var latex = this.latex;
      return !latex || latex.split(" ").join("") === "";
    };
  });

  return ExpressionObject;
});

define('expressions/text',['require','pjs','./abstractitem'],function(require) {
  var P = require('pjs');
  var AbstractItemModel = require('./abstractitem');

  var TextObject = P(AbstractItemModel, function(model, _super) {
    model.isText = true;

    model.init = function (state, list) {
      _super.init.call(this, state, list);

      if (!this.text) this.text = '';
      this.observe('text', this.onStateDidChange.bind(this));
    };

    model.isEmpty = function() {
      return this.text.split(" ").join("") === "";
    };

    model.getState = function() {
      return {
        id: this.id,
        text: this.text
      };
    };
  });

  return TextObject;
});

define('expressions/table',['require','underscore','pjs','underscore_model','graphing/columnmode','big','./abstractitem','./colors','graphing/label'],function(require) {
  var _ = require('underscore');
  var P = require('pjs');
  var UnderscoreModel = require('underscore_model');
  var COLUMNMODE = require('graphing/columnmode');
  var Big = require('big');
  var AbstractItemModel = require('./abstractitem');
  var Colors = require('./colors');
  var Label = require('graphing/label');

  var Cell = P(UnderscoreModel, function (cellModel, _super) {

    cellModel.init = function (column, state) {
      _super.init.call(this);

      this.column = column;

      if (state) {
        this.value = state.value;
        this.error = state.error;
      }
    };

    cellModel.isEmpty = function () {
      return this.value.split(' ').join("") === '';
    };
  });


  var Column = P(AbstractItemModel, function(colModel, _super) {

    colModel.init = function (table, index, state) {

      // backwards compatibility:
      // used to used showLine and showPoints
      // now we use hidden and columnMode
      if (state.showPoints !== undefined || state.showLine !== undefined) {
        state = JSON.parse(JSON.stringify(state)); // make copy so we don't modify passed in state

        if (state.showPoints && state.showLine) {
          state.columnMode = COLUMNMODE.POINTS_AND_LINES;
        } else if (state.showPoints) {
          state.columnMode = COLUMNMODE.POINTS;
        } else if (state.showLine) {
          state.columnMode = COLUMNMODE.LINES;
        } else {
          state.hidden = true;
          state.columnMode = COLUMNMODE.POINTS;
        }
      }

      // default values
      this.latex = '';
      this.hidden = false;
      this.columnMode = COLUMNMODE.POINTS;
      this.values = [];
      this.error = '';

      _super.init.call(this, state);

      if (!this.color) {
        this.color =  Colors.next();
      }

      if (!this.style) {
        this.style =  'point';
      }

      // any column other than the first should generate the correct number
      // of blank cells if none are passed in.
      if (index !== 0 && this.values.length === 0 && table.columns[0].cells) {
        this.values = []; // don't want to modify array passed in through 'state'
        var len = table.columns[0].cells.length;
        for (var i=0; i<len; i++) {
          this.values.push('');
        }
      }

      // map cells from raw values to objects
      var self = this;
      this.cells = this.values.map(function (value) {
        return Cell(self, {value: String(value)});
      });
      delete this.values;

      this.table = table;
      this.index = index;

      // first column can't be graphed
      if (index === 0) {
        this.hidden = true;
      }

      // observers
      this.isGraphable = !this.error;
      this.observe('error', function () {
        this.setProperty('isGraphable', !this.error);
      }.bind(this));
      this.observe('color columnMode hidden latex style', this.onStateChange.bind(this));

      // need to factor in whether the table is forcing the column hidden
      this.observe('hidden hiddenByTable', this.computeShouldGraph.bind(this));
      this.computeShouldGraph();
      this.observe('shouldGraph', this.table.requestParse.bind(this.table));
    };

    colModel.computeShouldGraph = function () {
      this.setProperty('shouldGraph', !this.hiddenByTable && !this.hidden);
    };

    colModel.onStateChange = function (property) {
      this.table.requestParse();

      var id = this.table.id;
      var index = this.index;
      var list = this.table.list;
      function getColumn () {
        return list.getItemById(id).columns[index];
      }

      var oldValue = this.getOldProperty(property);
      var newValue = this.getProperty(property);
      list.undoRedo.addTransaction({
        type: list.undoRedo.RESPONSE_TO_CHANGE,
        undo: function () { getColumn().setProperty(property, oldValue); },
        redo: function () { getColumn().setProperty(property, newValue); }
      });
    };

    colModel.isEmpty = function () {
      return this.latex.split(" ").join(" ") === "";
    };

    colModel.getValues = function () {
      var vals = [];
      var len = this.cells.length;
      for (var i=0; i < len; i++) {
        var val = this.cells[i].value;
        if (val === null || val === undefined) {
          vals.push('');
        } else {
          vals.push(String(val));
        }
      }

      return vals;
    };

    colModel.triggerRowChange = function () {};

    colModel.insertCell = function (index, value) {
      var cell = Cell(this, {value: value});
      this.cells.splice(index, 0, cell);

      // add blank independent value in this spot if need be
      if (this.independentValues) {
        this.independentValues.splice(index, 0, '');
      }
    };

    colModel.removeCell = function (index) {
      this.cells.splice(index, 1);

      // remove independent value in this spot if need be
      if (this.independentValues) {
        this.independentValues.splice(index, 1);
      }
    };

    function formatValuesForDisplay (values) {
      var vals = [];

      for (var i=0; i<values.length; i++) {
        var value = values[i];
        var val_str;
        if (!_.isNumber(value)) {
          val_str = '';
        } else if (!isFinite(value)) {
          val_str = "\\mathrm{undefined}";
        } else {
          //logic similar to multiple-answer output in evaluation.js
          if (Math.abs(value) < 1e-15) {
            val_str = '0';
          } else if (Math.abs(value) > 1e6 || Math.abs(value) < 1e-3) {
            val_str = Label.latexSciNote(value.toExponential(6));
          } else {
            val_str = Label.stripZeros(value.toPrecision(8));
          }
        }
        vals.push(val_str);
      }

      return vals;
    }

    colModel.setComputedValues = function (c_data) {

      // TODO - get the worker to pass back a blank array. It'll be important
      // for when we check that the size of the output matches the size of the
      // table. If there is a size mismatch, we must throw the computations
      // away because they are stale.

      // the worker thread doesn't pass back a list of values in this case.
      // we need to build list of null values
      if (c_data.values.length === 0 && c_data.error) {
        for (var i=0; i<this.cells.length-1; i++) {
          c_data.values[i] = null;
        }
      }


      this.setProperty('error', c_data.error);
      this.setProperty('discrete', c_data.discrete);
      this.setProperty('disabled', c_data.dependent);
      this.setErrors(c_data.values);

      if (c_data.dependent) {

        // if we haven't saved the independent values, save them now before
        // they get overwritten with the values sent back from the evaluator.
        if (!this.independentValues) {
          this.independentValues = this.getValues();
        }

        this.setValues(formatValuesForDisplay(c_data.values));
      } else if (this.independentValues) {

        // set the indepentedValues back.
        this.setValues(this.independentValues);

        // clear out the cached independent values.
        this.independentValues = null;

        // send the table back to the evaluator
        this.table.requestParse();
      }
    };

    colModel.setValues = function (values) {
      for (var i=0; i<this.cells.length; i++) {
        this.cells[i].setProperty('value', values[i]);
      }
    };

    colModel.setErrors = function (values) {
      // if the computed value is a string, then it's an error
      for (var i=0; i<values.length; i++) {
        if (typeof values[i] === "string") {
          this.cells[i].setProperty('error', values[i]);
        } else {
          this.cells[i].setProperty('error', '');
        }
      }
    };

    colModel.serialize = function () {
      return {
        values: this.getValues(),
        columnMode: this.columnMode,
        hidden: this.hidden,
        id: this.id,
        color: this.color,
        style: this.style,
        latex: this.latex
      };
    };

  });

  var TableObject = P(AbstractItemModel, function(model, _super) {

    model.isTable = true;

    model.init = function (state, list) {
      var r, c;
      _super.init.call(this, state, list);

      this.list = list;
      this.selectedCell = null;

      // TODO - get rid of this when we upgrade states in DB
      // what we used to call 'headings' is now 'columns'
      if (this.headings) {
        this.columns = this.headings;
        delete this.headings;
      }

      // TODO - get rid of this when we upgrade states in DB
      // what used to be 'rows' is now transposed and part of each column
      if (this.rows) {
        for (c=0; c<this.columns.length; c++) {
          var column = this.columns[c];
          column.values = [];

          for (r=0; r<this.rows.length; r++) {
            column.values.push(this.rows[r][c]);
          }
        }

        delete this.rows;
      }

      // map raw columns to Column objects
      var self = this;
      if (!this.columns) this.columns = [];
      this.columns = this.columns.map(function(col_state, index){
        return Column(self, index, col_state);
      });

      // add a column to the right
      this.columns.push(Column(this, this.columns.length, {disabled: true}));

      // add a bottom row of empty values
      var lastRow = this.columns[0].cells.length;
      _.each(this.columns, function (column) {
        column.insertCell(lastRow, '');
      });

      // observers
      this.observe('selected', this.onSelectedChange.bind(this));
      this.observe('formula', this.onFormulaUpdate.bind(this));
    };

    model.onFormulaUpdate = function () {
      this.setComputedValues(this.formula.column_data);
      this.setProperty('canAutoRegress', !!this.formula.can_auto_regress);
    };

    model.updateFolder = function () {
      _super.updateFolder.call(this);


      // TODO namespacing with the id seems kind of gross...
      if (this.getOldProperty('folder')) {
        this.getOldProperty('folder').unobserve('.' + this.id);
      }
      if (this.folder) {
        this.folder.observe(
          'hidden.' + this.id,
          this.computeColumnsHidden.bind(this)
        );
      }
      this.computeColumnsHidden();
    };

    model.computeColumnsHidden = function () {
      var hidden = this.folder && this.folder.hidden;

      _.each(this.columns, function (column) {
        column.setProperty('hiddenByTable', hidden);
      });
    };

    model.onSelectedChange = function () {
      if (!this.selected) {
        this.setProperty('selectedCell', null);
      }
    };

    model.insertColumn = function (index, column) {

      var id = this.id;
      var list = this.list;

      list.undoRedo.addTransaction({
        type: list.undoRedo.CAUSE_OF_CHANGE,
        undo: function () {
          var table = list.getItemById(id);
          table.__removeColumn(index);
        },

        redo: function () {
          var table = list.getItemById(id);
          table.__insertColumn(index, column);

          // need to update reference to heading so that
          // next time we press redo, we pass in the complete
          // heading info. This makes sure the next redo uses
          // the same color and id as the original column that
          // was later deleted and then restored.
          column = table.columns[index].serialize();
        }
      });

    };

    model.removeColumn = function (index) {

      var id = this.id;
      var column = this.columns[index].serialize();
      var list = this.list;
      list.undoRedo.addTransaction({
        type: list.undoRedo.CAUSE_OF_CHANGE,
        undo: function () {
          var table = list.getItemById(id);
          table.__insertColumn(index, column);
        },

        redo: function () {
          var table = list.getItemById(id);
          table.__removeColumn(index);
        }
      });
    };

    model.moveColumn = function (from, to) {
      var id = this.id;
      var list = this.list;

      list.undoRedo.addTransaction({
        type: list.undoRedo.CAUSE_OF_CHANGE,
        undo: function () {
          var table = list.getItemById(id);
          table.__moveColumn(to, from);
        },

        redo: function () {
          var table = list.getItemById(id);
          table.__moveColumn(from, to);
        }
      });
    };

    // this does the raw column insert. Called from the wrapper function that
    // makes it also work with undo redo.
    model.triggerColumnAdded = function (index) {};
    model.__insertColumn = function (index, columnData) {
      if (!columnData) {
        columnData = {};
      }

      // add column
      var column = Column(this, index, columnData);
      this.columns.splice(index, 0, column);

      // let every column after the insertion point know its new index
      for (var i=index+1; i<this.columns.length; i++) {
        this.columns[i].setProperty('index', i);
      }

      this.triggerColumnAdded(index);

      this.requestParse();
    };

    // this does the raw column remove. Called from the wrapper function that
    // makes it also work with undo redo.
    model.triggerColumnRemoved = function (index) {};
    model.__removeColumn = function (index) {

      // remove column
      this.requestUnparseColumn(index);
      this.columns.splice(index, 1);

      // let every column after the deletion point know its new index
      for (var i=index; i<this.columns.length; i++) {
        this.columns[i].setProperty('index', i);
      }

      this.triggerColumnRemoved(index);

      this.requestParse();
    };

    // this does the raw column move. Called from the wrapper function that
    // makes it also work with undo redo.
    model.triggerColumnMoved = function (from, to) {};
    model.__moveColumn = function(from, to) {
      if (from === to) return;

      var len = this.columns.length;
      var column = this.columns[from];

      // can't move the first or last columns
      if (from < 1 || to < 1 || from >= len-1 || to >= len-1) return;

      // remove from items
      this.columns.splice(from , 1);

      // insert back in correct spot
      this.columns.splice(to, 0, column);

      // insert index on each column
      for (var i=0; i<len; i++) {
        this.columns[i].setProperty('index', i);
      }

      // allow a view to tap into this
      this.triggerColumnMoved(from, to);
    };

    // Could try to recognize fractions and multiples of pi (or anything
    // really).
    model.getAutofillValues = function (index) {
      var i;
      var numberOfColumns = this.columns.length;
      var rowValues = [];
      for (i=0; i<numberOfColumns; i++) {
        rowValues.push('');
      }

      var firstColumn = this.columns[0].getValues();

      // Use big.js https://github.com/desmosinc/big.js to compute exact
      // differences and sums so that autofilling decimals works.
      // big.js will throw errors if improper input is used.
      //
      // this line just ensures that there is a constant offset between
      // each value in the first column starting from the beginning up
      // right before where we want to auto fill.
      var valDiff;
      try {
        if (index > 1) {
          valDiff = Big(firstColumn[1]).minus(firstColumn[0]);
        }

        for (i = 2; i<index && valDiff !== undefined; i++) {
          var nextDiff = Big(firstColumn[i]).minus(firstColumn[i-1]);
          if (!valDiff.equals(nextDiff)) {
            valDiff = undefined;
          }
        }
      } catch (e) {
        valDiff = undefined;
      }

      // add valDiff to the previous row to figure out what the autocomplete
      // value should be
      if (valDiff !== undefined) {
        rowValues[0] = valDiff.plus(firstColumn[index-1]).toString();
      }

      return rowValues;
    };

    model.setComputedValues = function (columns_data) {
      this.setProperty('changingMultipleCells', true);

      // there is mandatory empty cell at the end of columns, so
      // we subtract 1 for that.
      var currentRowCount = this.columns[0].cells.length - 1;

      // Find the column that wants to display the most values
      var i, maxRowCount = 0;
      for (i=0; i < columns_data.length; i++) {
        var numberOfRows = columns_data[i].values.length;
        if (numberOfRows > maxRowCount) {
          maxRowCount = numberOfRows;
        }
      }

      // TODO - figure out undo/redo for this. We are left with
      // an extra row because the added rows aren't insertted
      // into the undo/redo stream. Maybe automatically removing
      // rows when we don't need them will fix this?

      // Add as many rows as necessary so that the longest
      // column can be fully displayed
      for (i = maxRowCount - currentRowCount ; i > 0; i--) {
        this.__insertRow(currentRowCount);
        currentRowCount++;
      }

      for (i=0; i<columns_data.length; i++) {
        this.columns[i].setComputedValues(columns_data[i]);
      }

      this.setProperty('changingMultipleCells', false);
      this.triggerEvent('computedValuesSet');
    };

    model.triggerRowAdded = function (index){};
    model.__insertRow = function (index, values) {
      for (var i=0; i<this.columns.length; i++) {
        this.columns[i].insertCell(index, values ? values[i] : '');
      }
      this.triggerRowAdded(index);
    };
    model.insertRow = function (index, values) {
      this.__insertRow(index, values);

      var id = this.id;
      var list = this.list;
      list.undoRedo.addTransaction({
        type: list.undoRedo.RESPONSE_TO_CHANGE,
        undo: function () {
          list.getItemById(id).removeRow(index);
        },
        redo: function () {
          list.getItemById(id).insertRow(index, values);
        }
      });

      this.requestParse();
    };

    model.triggerRowRemoved = function (index) {};
    model.removeRow = function (index) {
      var values = [];

      //don't let the user delete a row if there's only one row (below the header)
      if (!this.columns.length || this.columns[0].cells.length <= 2) return;

      for (var i=0; i<this.columns.length; i++) {
        values.push(this.columns[i].cells[index].value);
        this.columns[i].removeCell(index);
      }

      this.triggerRowRemoved(index);

      var id = this.id;
      var list = this.list;
      list.undoRedo.addTransaction({
        type: list.undoRedo.RESPONSE_TO_CHANGE,
        undo: function () {
          list.getItemById(id).insertRow(index, values);
        },
        redo: function () {
          list.getItemById(id).removeRow(index);
        }
      });

      this.requestParse();
    };

    model.eachLatex = function (fn) {
      for (var i = 0; i < this.columns.length; i++) {
        var column = this.columns[i];
        fn(column.latex);
        for (var j = 0; j < column.cells.length; j++) {
          fn(column.cells[j].value);
        }
      }
    };

    model.getParsableObject = function () {

      var columns = this.columns.map(function (column){

        // serialize column to pure JSON
        var obj = column.serialize();

        // use shouldGraph rather than hidden when deciding if to graph
        obj.hidden = !column.shouldGraph;

        // pop off blank bottom row
        obj.values.pop();

        return obj;
      });

      // popoff blank right column
      columns.pop();

      return {
        type: 'table',
        id: this.id,
        columns: columns
      };
    };

    model.requestParse = function () {
      this.list.triggerAddExp(this.getParsableObject());
    };

    model.requestUnparse = function () {
      var ids = [this.id];
      for (var i=0; i<this.columns.length; i++) {
        ids.push(this.columns[i].id);
      }

      this.list.triggerRemoveExps(ids);
    };

    model.onAddedToList = function () {
      this.requestParse();
    };

    model.onRemovedFromList = function () {
      this.requestUnparse();
    };

    model.requestUnparseColumn = function (index) {
      this.list.triggerRemoveExp(this.columns[index].id);
    };

    model.getState = function() {

      // serialize each column
      var columns = this.columns.map(function(column) {
        var data = column.serialize();

        // pop off blank bottom row
        data.values.pop();

        // TODO - do we want to do this? Might be better for loadup if
        // we save the previous values along with wether or not the column
        // was disabled. If the evaluator ever changes, we can convert
        // old graph states or just let the new system overwrite the values like
        // it does now. The two big complaints I have is that computed columns
        // show up with an 'empty' underline temporarily and the table icon
        // flickers if the column is actually continuous rather than discrete.
        // if column is disabled, all values blanked
        // TODO - convert old graph states to have '' instead of null.
        if (column.disabled) {
          data.values = data.values.map(function(){return ''});
        }

        return data;
      });

      // pop off blank right column
      columns.pop();

      return {
        id: this.id,
        columns: columns
      };
    };

    model.isEmpty = function() {
      return false;
    };
  });

  return TableObject;
});

define('loadcss!css/folder', function(){});
define('expressions/folder',['require','loadcss!css/folder','pjs','underscore','./abstractitem'],function (require) {
  require('loadcss!css/folder');
  var P = require('pjs');
  var _ = require('underscore');
  var AbstractItemModel = require('./abstractitem');

  var FolderObject = P(AbstractItemModel, function(model, _super) {
    model.isFolder = true;

    model.init = function (state, list) {
      _super.init.call(this, state, list);

      if (!this.title) this.title = '';

      if (!this.memberIds) this.memberIds = {};
      this.hidden = !!this.hidden;
      this.collapsed = !!this.collapsed;

      this.updateCount();

      this.observe('selected collapsed', this.updateSelectedHiddenChild.bind(this));
      this.observe('title hidden', this.onStateDidChange.bind(this));
    };

    model.updateCount = function () {
      this.setProperty('count', _.size(this.memberIds));
    };

    model.getState = function () {
      return {
        id: this.id,
        type: 'folder',
        title: this.title,
        memberIds: this.memberIds,
        hidden: this.hidden,
        collapsed: this.collapsed
      };
    };

    model._addItem = function(itemId) {
      var list = this.list;
      var item = list.getItemById(itemId);

      this.memberIds[itemId] = true;
      if (item) item.setProperty('folder', this);

      this.updateCount();
    };

    model._removeItem = function(itemId) {
      var list = this.list;
      var item = list.getItemById(itemId);

      if (item) item.setProperty('folder', undefined);
      if (this.memberIds.hasOwnProperty(itemId)) {
        delete this.memberIds[itemId];
      }
      this.updateCount();
    };

    model.addItem = function (item) {
      var list = this.list;
      var id = this.id;
      var itemId = item.id;

      list.undoRedo.addTransaction({
        type: list.undoRedo.CAUSE_OF_CHANGE,
        redo: function(){
          list.getItemById(id)._addItem(itemId);
        },
        undo: function(){
          list.getItemById(id)._removeItem(itemId);
        }
      });
    };

    model.removeItem = function (item) {
      var list = this.list;
      var id = this.id;
      var itemId = item.id;

      list.undoRedo.addTransaction({
        type: list.undoRedo.CAUSE_OF_CHANGE,
        redo: function () {
          list.getItemById(id)._removeItem(itemId);
        },
        undo: function () {
          list.getItemById(id)._addItem(itemId);
        }
      });
    };

    model.updateSelectedHiddenChild = function () {
      var selectedItem = this.list.getSelected();

      if (this.collapsed) {
        // we are collapsed, and the selectedItem is a child ==> It's our selectedHiddenChild
        if (selectedItem && this.memberIds.hasOwnProperty(selectedItem.id)) {
          this.setProperty('selectedHiddenChild', selectedItem);
          this.setProperty('selected', true);
        }

        // we are collapsed, and we are not selected ==> We have no selectedHiddenChild
        else if (selectedItem !== this) {
          this.setProperty('selectedHiddenChild', null);
        }
      } else {
        // we are not collapsed, and we are selected, and we have a selectedHiddenChild ==> select it
        if (selectedItem === this && this.selectedHiddenChild) {
          this.selectedHiddenChild.setProperty('selected', true);
        }

        // no children are hidden
        this.setProperty('selectedHiddenChild', null);
      }
    };
  });

  return FolderObject;
});
define('expressions/helperexpression',['require','pjs','math/evaluationstate','./abstractitem','./slider'],function(require){
  var P = require('pjs');
  var EvaluationState = require('math/evaluationstate');
  var AbstractItemModel = require('./abstractitem');
  var SliderModel = require('./slider');

  var HelperExpressionObject = P(AbstractItemModel, function(model, _super) {

    model.isHelperExpression = true;

    model.init = function (state, list) {
      _super.init.call(this, state, list);

      this.hidden = !!this.hidden;
      this.is_slidable = false;

      this.formula = EvaluationState.default();
      this.observe('formula', this.onFormulaUpdate.bind(this));
      this.observe('latex hidden color', this.onExpressionDidChange.bind(this));
    };

    model.onExpressionDidChange = function() {
      this.requestParse();
    };

    model.getParsableObject = function () {
      return {
        type: 'statement',
        id: this.id,
        latex: this.latex,
        shouldGraph: !this.hidden,
        color: this.color
      };
    };

    model.requestParse = function () {
      this.list.triggerAddExp(this.getParsableObject());
    };

    model.requestUnparse = function () {
      this.list.triggerRemoveExp(this.id);
    };

    model.onAddedToList = function () {
      this.requestParse();
    };

    model.onRemovedFromList = function () {
      // turn slider off when deleted
      if (this.slider) {
        this.slider.setProperty('isPlaying', false);
      }

      this.requestUnparse();
    };

    model.getState = function() {
      var state = {
        id: this.id,
        latex: this.latex,
        color: this.color,
        hidden: this.hidden
      };

     // TODO - change this to state.slider = this.slider.serialize() but can't
     // do that until we convert all previously saved graphs to have a slider
     // object rather than three global properties. We either need to do that
     // or we need to make the setState() function backwards compatible.
     if (this.slider) {
       state.sliderMin = this.slider.min;
       state.sliderMax = this.slider.max;
       state.sliderHardMin = this.slider.hardMin;
       state.sliderHardMax = this.slider.hardMax;
       state.sliderInterval = this.slider.step;
       state.sliderAnimationPeriod = this.slider.animationPeriod;
       state.sliderPlayDirection = this.slider.playDirection;
       state.sliderIsPlaying = this.slider.isPlaying;
     }

     return state;
    };

    model.onFormulaUpdate = function () {
      var formula = this.formula;

      this.setProperty('error', formula.error ? formula.error : '');

      if (formula.is_slidable) {
        // delay instantiation of a slider for this expression until we need one.
        if (!this.slider) {
          this.createSliderModel();
        }

        this.slider.setProperty('value', formula.constant_value);
      } else {
        this.slider = null;
      }

      this.setProperty('is_slidable', formula.is_slidable);
    };

    model.createSliderModel = function () {
      // Once created, the slider object won't be destroyed. The slider instance sticks
      // around to save information about limits. They'd get reset each time if we didn't
      // keep the slider. Also, things that observe changes to the slider shouldn't have
      // to change observers from one slider object to another.
      if (this.__singleSliderInstance) {
        this.slider = this.__singleSliderInstance;
        return;
      }
      this.slider = this.__singleSliderInstance = SliderModel({
        min: this.sliderMin !== undefined ? this.sliderMin : -10,
        max: this.sliderMax !== undefined ? this.sliderMax : 10,
        hardMin: this.sliderHardMin,
        hardMax: this.sliderHardMax,
        animationPeriod: this.sliderAnimationPeriod,
        playDirection: this.sliderPlayDirecction,
        isPlaying: this.sliderIsPlaying,
        step: this.sliderInterval,
        value: this.formula.constant_value
      });

      // let others know that we've created the slider model
      this.notifyPropertyChange('slider');
    };

    model.isEmpty = function() {
      var latex = this.latex;
      return !latex || latex.split(" ").join("") === "";
    };
  });

  return HelperExpressionObject;
});

define('expressions/image',['require','pjs','./abstractitem','./helperexpression','i18n','underscore'],function(require) {
  var P = require('pjs');
  var AbstractItemModel = require('./abstractitem');
  var HelperExpressionObject = require('./helperexpression');
  var i18n = require('i18n');
  var _ = require('underscore');

  var ImageObject = P(AbstractItemModel, function(model, _super) {
    model.isImage = true;

    model.init = function (state, list) {
      _super.init.call(this, state, list);
      this.hidden = !!this.hidden;
      this.shouldGraph = !this.hidden;
      this.errors = {};
      this.helpers = {};
      this.alias_helpers = {};
      this.point_helpers = [];
      this.imageObj = new Image();

      this.observe('x y width height name opacity shouldGraph', this.onStateDidChange.bind(this));
      this.observe('hidden', this.onVisibilityChange.bind(this));
      this.observe('showPoints', this.onShowPointsChange.bind(this));
      this.observe('transient', this.onTransientChange.bind(this));
      this.observe('errors', this.onErrorsChange.bind(this));
      this.observe('image_url', this.loadImage.bind(this));

      function computeShowPoints () {
        this.setProperty('showPoints', this.shouldGraph && this.selected && this.loaded);
      }
      this.observe('shouldGraph selected loaded', computeShowPoints.bind(this));

      // parses inputs and computes values
      this.createInputHelper('x');
      this.createInputHelper('y');
      this.createInputHelper('width');
      this.createInputHelper('height');

      // the helpers that make static values slidable
      this.createAliasHelper('x');
      this.createAliasHelper('y');
      this.createAliasHelper('width');
      this.createAliasHelper('height');

      // the resize points
      this.createResizeHelper('left','top');
      this.createResizeHelper('left','middle');
      this.createResizeHelper('left','bottom');
      this.createResizeHelper('middle','bottom');
      this.createResizeHelper('right','bottom');
      this.createResizeHelper('right','middle');
      this.createResizeHelper('right','top');
      this.createResizeHelper('middle','top');

      // the center move point
      this.createMoveHelper();

      // check if any helper is transient (movable point being dragged)
      var self = this;
      this.point_helpers.forEach(function (helper) {
        helper.observe('transient', function () {
          self.computeTransient();
        });
      });

      this.computeTransient();

      // only load image if url is set
      if (this.image_url) {
        this.loadImage();
      }
    };
    model.computeShouldGraph = function () {
      var shouldGraph = (this.folder && this.folder.hidden ? false : !this.hidden);
      this.setProperty("shouldGraph", shouldGraph);
    };
    model.computeTransient = function () {
      var is_transient = false;
      this.point_helpers.forEach(function (helper) {
        is_transient = is_transient || helper.transient;
      });

      this.setProperty('transient', !!is_transient);
    };
    model.computeVariables = function () {
      var vars = _.flatten([
        this.helpers.x.formula.variables,
        this.helpers.y.formula.variables,
        this.helpers.width.formula.variables,
        this.helpers.height.formula.variables
      ]);

      var uniq_vars = _.uniq(vars);
      this.setProperty('variables', uniq_vars);
    };
    model.onErrorsChange = function () {
      var errorMessages = {
        x: i18n.t('Invalid x coordinate.'),
        y: i18n.t('Invalid y coordinate.'),
        width: i18n.t('Invalid width.'),
        height: i18n.t('Invalid height.')
      };

      var errors = [];
      for (var id in this.errors) {
        errors.push(errorMessages[id]);
      }

      // just picking first error for now. Showing all the erros is a matter of formatting.
      this.setProperty('error', errors[0] || '');
    };
    model.onTransientChange = function () {
      var id = this.id;
      var list = this.list;
      var wasTransient = this.getOldProperty('transient');
      var isTransient = this.getProperty('transient');

      // just turned transient
      if (!wasTransient && isTransient) {

        // this will be filled in when we end the transient state.
        var startingValues = {x: this.x , y: this.y, width: this.width, height: this.height};
        var endingValues   = {x: this.x , y: this.y, width: this.width, height: this.height};

        // keep a record to ending values so that we can update them when we end transient state
        this.transientEndingValues = endingValues;

        list.undoRedo.addTransaction({
          type: list.undoRedo.RESPONSE_TO_CHANGE,
          undo: function () {
            var expression =  list.getItemById(id);

            // set starting values
            for (var prop in startingValues) {
              if (startingValues.hasOwnProperty(prop)) {
                expression.setProperty(prop, startingValues[prop]);
              }
            }
          },
          redo: function () {
            var expression =  list.getItemById(id);

            // set ending values
            for (var prop in endingValues) {
              if (endingValues.hasOwnProperty(prop)) {
                expression.setProperty(prop, endingValues[prop]);
              }
            }
          }
        });
      }

      // just ended being transient
      else if (wasTransient && !isTransient) {
        var lastValues = {x: this.x , y: this.y, width: this.width, height: this.height};

        // update the values stored within the undo/redo transaction
        for (var prop in lastValues) {
          if (lastValues.hasOwnProperty(prop)) {
            this.transientEndingValues[prop] = lastValues[prop];
          }
        }
      }
    };

    model.updateFolder = function () {
      _super.updateFolder.call(this);

      if (this.getOldProperty('folder')) {
        this.getOldProperty('folder').unobserve('.' + this.guid);
      }
      if (this.folder) {
        this.folder.observe(
          'hidden.' + this.guid,
          this.computeShouldGraph.bind(this)
        );
      }
      this.computeShouldGraph();
    };

    model.createInputHelper = function (prop) {
      var self = this;
      var helper = HelperExpressionObject({hidden: true}, self.list);
      helper.id = helper.guid;
      self.helpers[prop] = helper;

      // update the computed value when helper is computed
      helper.observe('formula', function () {
        var value = NaN, error = '', formula = helper.formula;

        self.computeVariables();

        if (isFinite(formula.constant_value)) {
          value = formula.constant_value;
        } else if (formula.zero_values) {
          value = formula.zero_values[0].val;
        }

        if (isNaN(value)) {
          if (formula.error) {
            error = formula.error;
          } else {
            error = i18n.t('Does not compute to constant.');
          }

          // check if this error has changed
          if (self.errors[prop] !== error) {
            self.errors[prop] = error;
            self.notifyPropertyChange('errors');
          }
        }

        // had an error, but now it's gone
        else if (self.errors.hasOwnProperty(prop)) {
          delete self.errors[prop];
          self.notifyPropertyChange('errors');
        }

        self.setProperty('computed_' + prop, value);
        self.list.triggerRedrawImages();
      });

      function updateLatex () {
        helper.setProperty('latex', self[prop]);
      }

      self.observe(prop, updateLatex);
      updateLatex();
    };

    model.getAliasIdentifier = function (prop) {
      return 'a_{'+ prop + this.guid.split('_').join('') +'}';
    };

    /*
      when the inputs are simple numbers, we must use an alias expression
      to make them slidable.

      The point (1,2) is not slidable.

      This is slidable though:
      a = 1
      b = 2
      (a,b)

      These helpers define an expression in terms of the static value. The expression
      becomes slidable and we can drag the slider. When the slider is dragged, we update
      the original property.
    */
    model.createAliasHelper = function (prop) {
      var self = this;
      var helper = HelperExpressionObject({hidden: true}, self.list);
      helper.id = helper.guid;
      self.helpers['alias_' + prop] = helper;

      // wait for the slider to be created
      helper.observe('slider', function () {
        helper.slider.observe('value', function () {
          self.setProperty(prop, helper.slider.value.toString());
        });
      });

      // update the helper when property changes
      function updateLatex () {
        helper.setProperty('latex', self.getAliasIdentifier(prop) + '=' + self[prop]);
      }

      self.observe(prop, updateLatex);
      updateLatex();
      self.alias_helpers[prop] = helper;
    };

    model.createResizeHelper = function (xPos, yPos) {
      var self = this;
      var helper = HelperExpressionObject({color: '#4F81BD', hidden: true}, self.list);
      helper.id = helper.guid;
      self.helpers[xPos + '_' + yPos] = helper;

      function updateLatex () {
        var widthExpr;
        if (self.alias_helpers.width.is_slidable) {
          widthExpr = self.getAliasIdentifier('width');
        } else {
          widthExpr = self.width;
        }

        var heightExpr;
        if (self.alias_helpers.height.is_slidable) {
          heightExpr = self.getAliasIdentifier('height');
        } else {
          heightExpr = self.height;
        }

        var xOffsetExpr;
        if (xPos === 'left') {
          xOffsetExpr = '-(' + widthExpr + ')/2';
        } else if (xPos === 'right') {
          xOffsetExpr = '+(' + widthExpr + ')/2';
        } else {
          xOffsetExpr = '';
        }

        var yOffsetExpr;
        if (yPos === 'top') {
          yOffsetExpr = '+(' + heightExpr + ')/2';
        } else if (yPos === 'bottom') {
          yOffsetExpr = '-(' + heightExpr + ')/2';
        } else {
          yOffsetExpr = '';
        }

        // makes it so the xCenter is stationary and not draggable.
        var xCenterExpr = '\\left\\{1>0:'+ self.x + '\\right\\}';
        var yCenterExpr = '\\left\\{1>0:'+ self.y + '\\right\\}';

        helper.setProperty('latex','('+ xCenterExpr + xOffsetExpr +','+ yCenterExpr + yOffsetExpr +')');
      }

      function updateConstraint () {
        // don't update constraints while transient
        if (self.transient) return;

        // if width and height aren't simple, don't constrain the resize point
        if (!self.alias_helpers.width.is_slidable || !self.alias_helpers.height.is_slidable) {
          helper.constrainPt = null;
        }

        else {

          var heightToWidthRatio = self.computed_height / self.computed_width;
          var x_middle = self.computed_x;
          var y_middle = self.computed_y;

          helper.constrainPt = function (pt) {
            var x_offset = pt.x - x_middle;
            var y_offset = heightToWidthRatio * x_offset * (xPos === 'left' ? 1 : -1) * (yPos === 'top' ? -1 : 1);
            return {x: pt.x, y: y_middle + y_offset};
          };
        }
      }

      self.alias_helpers.width.observe('is_slidable', updateLatex);
      self.alias_helpers.height.observe('is_slidable', updateLatex);
      self.observe('x y width height', updateLatex);
      updateLatex();

      // only do this if it's a corner point
      if (xPos !== 'middle' && yPos !== 'middle') {
        self.alias_helpers.width.observe('is_slidable', updateConstraint);
        self.alias_helpers.height.observe('is_slidable', updateConstraint);
        self.observe('computed_x computed_y computed_width computed_height transient', updateConstraint);

        updateConstraint();
      }

      self.point_helpers.push(helper);
    };

    model.createMoveHelper = function () {
      var self = this;
      var helper = HelperExpressionObject({color: '#4F81BD', hidden: true}, self.list);
      helper.id = helper.guid;
      self.helpers.move = helper;

      function updateLatex () {
        var xExpr;
        if (self.alias_helpers.x.is_slidable) {
          xExpr = self.getAliasIdentifier('x');
        } else {
          xExpr = self.x;
        }

        var yExpr;
        if (self.alias_helpers.y.is_slidable) {
          yExpr = self.getAliasIdentifier('y');
        } else {
          yExpr = self.y;
        }

        helper.setProperty('latex', '('+ xExpr +','+ yExpr +')');
      }

      self.observe('x y', updateLatex);
      self.alias_helpers.x.observe('is_slidable', updateLatex);
      self.alias_helpers.y.observe('is_slidable', updateLatex);
      updateLatex();
      self.point_helpers.push(helper);
    };

    model.onShowPointsChange = function () {
      var hidden = !this.showPoints;

      // tell each point if it should be hidden
      this.point_helpers.forEach(function (helper){
        helper.setProperty('hidden', hidden);
      });
    };

    model.onVisibilityChange = function () {
      this.computeShouldGraph();
      this.list.triggerRedrawImages();
    };

    model.onAddedToList = function () {
      // add all helpers
      for (var i in this.helpers) {
        var helper = this.helpers[i];
        this.list.addHelperItem(helper);
      }

      this.list.triggerAddImage(this);
    };

    model.onRemovedFromList = function () {
      // remove all helpers
      for (var i in this.helpers) {
        var helper = this.helpers[i];
        this.list.removeHelperItem(helper.id);
      }

      this.list.triggerRemoveImage(this);

      // don't listen for the image to load
      this.imageObj.onload = null;
    };

    model.loadImage = function () {
      var self = this;
      this.imageObj.onload = function () {
        self.setProperty('loaded', true);
      };

      this.imageObj.src = this.image_url;
    };

    model.isEmpty = function() {
      return false;
    };

    model.getState = function() {
      return {
        id: this.id,
        image_url: this.image_url,
        originalFilename: this.originalFilename,
        name: this.name,
        hidden: this.hidden,
        height: this.height,
        width: this.width,
        x: this.x,
        y: this.y,
        opacity: this.opacity,
        type: 'image'
      };
    };

    // Record change for undo-redo
    model.onStateDidChange = function(prop) {

      // Ignore changes while transient
      if (this.transient || this.isUploading) return;

      var oldValue = this.getOldProperty(prop);
      var newValue = this.getProperty(prop);
      if (oldValue === undefined) return;
      var id = this.id;
      var list = this.list;

      list.undoRedo.addTransaction({
        type: list.undoRedo.RESPONSE_TO_CHANGE,
        undo: function() {
          list.getItemById(id).setProperty(prop, oldValue);
        },
        redo: function () {
          list.getItemById(id).setProperty(prop, newValue);
        }
      });

      list.triggerRedrawImages();
    };

  });
  return ImageObject;
});
define('expressions/list',['require','pjs','underscore','underscore_model','./expression','./text','./table','./folder','./image','lib/rounding'],function(require) {
  var P = require('pjs');
  var _ = require('underscore');
  var UnderscoreModel = require('underscore_model');
  var ExpressionObject = require('./expression');
  var TextObject = require('./text');
  var TableObject = require('./table');
  var FolderObject = require('./folder');
  var ImageObject = require('./image');
  var Rounding = require('lib/rounding');

  var ExpressionListModel = P(UnderscoreModel, function (model, _super) {

    model.init = function (undoRedo) {
      _super.init.call(this);
      var self = this;

      this.__items = [];
      this.__itemIds = {};
      this.__helperItemIds = {};
      this.drawOrder = [];

      // an optimization so that we don't compare entire items when changing
      // selectedItem property.
      this.setPropertyComparator('selectedItem', function (a,b) {
        return a === b;
      });

      this.undoRedo = undoRedo;

      // keep stepping sliders ever 40ms
      this.stepHz = 25;
      var stepSliders = function () {
        self.batchEvaluation(function () {
          self.notifyPropertyChange('playStep');
        });

        setTimeout(function () {
          stepSliders();
        }, 1000/self.stepHz);
      };
      stepSliders();
    };

    model.getItemByIndex = function (index) {
      return this.__items[index] || null;
    };

    model.getItemsByIndexRange = function (min, max) {
      min = Math.max(0, min);
      max = Math.min(this.getItemCount()-1 , max);

      var arr=[];
      for (var i=min; i<=max; i++) {
        arr.push(this.getItemByIndex(i));
      }
      return arr;
    };

    model.eachLatex = function (fn) {
      for (var i = 0; i < this.__items.length; i++) {
        this.__items[i].eachLatex(fn);
      }
    };

    model.onChange = function(changes) {
      var id, expression, formula;

      for (id in changes) {
        if (!changes.hasOwnProperty(id)) continue;

        expression = this.getItemById(id);
        formula = changes[id];
        if (!expression) continue;
        expression.setProperty('loading', false);
        expression.setProperty('formula', formula);
      }
    };

    model.onGraphComputed = function (id, graphData) {
      var item = this.getItemById(id);
      if (!item) return;

      var branchResolved = function (branch) {
        if (!branch.hasOwnProperty('resolved')) return true;
        return branch.resolved;
      };

      var unresolved = !graphData.every(branchResolved);
      item.setProperty('unresolved', unresolved);
    };

    model.updateDrawOrder = function () {
      var drawOrder = [];
      var listItems = _.sortBy(this.__itemIds, function (item) {return item.index});
      _.each(listItems, function(item) {
        if (item.hasOwnProperty('columns')) {
          _.each(item.columns, function (column) {
            drawOrder.push(column.id);
          });
        } else {
          drawOrder.push(item.id);
        }
      });
      this.setProperty('drawOrder', drawOrder);
    };

    model.getItemById = function(id) {
      return this.__itemIds[id] || this.__helperItemIds[id];
    };

    model._insertItemAt = function (index, item) {
      var item_id = String(item.id);
      if (this.__itemIds.hasOwnProperty(item_id)) {
        throw Error('Item with id \'' + item_id + '\' is already in list');
      }

      // add item to list
      this.__itemIds[item_id] = item;
      this.__items.splice(index, 0, item);

      item.index = index;

      if (item.selected) {
        this.handleSelectionChange(item);
      }

      // request that expressions get evaluated
      item.onAddedToList();
    };

    model.handleSelectionChange = function (item) {
      var selected = item.selected;
      if(!selected && this.selectedItem === item){
        this.setProperty('selectedItem', null);
      } else if (selected && !this.selectedItem) {
        this.setProperty('selectedItem', item);
      } else if (selected && this.selectedItem !== item) {
        this.selectedItem.setProperty('selected', false);
        this.setProperty('selectedItem', item);
      }
    };

    model.triggerItemInserted = function (index, item) {};
    model.insertItemAt = function (index, item) {

      // insert item
      this._insertItemAt(index, item);

      // allow view to tap into this
      this.triggerItemInserted(index, item);

      // add to undo/redo
      var self = this;
      var constructor = item.constructor;
      var state = item.getState();
      self.undoRedo.addTransaction({
        type: self.undoRedo.RESPONSE_TO_CHANGE,
        undo: function () {
          // save the state when we remove because some properties may have been filled in after
          // the initial creation. For example, images are created without a width, height, and image_url
          // initially, but then get filled in after the upload is complete.
          state = item.getState();
          self.removeItemAt(index);
        },
        redo: function () {
          self.insertItemAt(index, constructor(state, self));
        }
      });

      this.updateDrawOrder();
    };

    // Helper items are invisible items.
    model.addHelperItem = function (obj) {
      this.__helperItemIds[obj.id] = obj;
      obj.onAddedToList();
    };

    model.removeHelperItem = function (id) {
      var item = this.__helperItemIds[id];
      if (!item) return;

      item.onRemovedFromList();
      delete this.__helperItemIds[id];
    };

    model.addItem = function (obj) {
      var lastObject = this.getItemByIndex(this.getItemCount() - 1);
      // Replace empty expressions
      if (
        lastObject &&
        //TODO - remove headings after DB updated
        !(lastObject.text || lastObject.columns || lastObject.headings) &&
        lastObject.latex === ''
      ) {
        this.removeItemAt(this.getItemCount()-1); //pop off last
      }

      this.insertItemAt(this.getItemCount(), obj); //push to end
    };

    model.updateItemById = function (id, properties) {
      this.getItemById(id).setProperties(properties);
      this.updateDrawOrder();
    };

    model._removeItemAt = function (index) {
      var item = this.__items[index];
      if (!item) return;

      if (this.selectedItem === item) {
        this.setProperty('selectedItem', null);
      }

      var self = this;
      if (item.isFolder) {
        for (var id in item.memberIds) {
          self.removeItemAt(self.getItemById(id).index);
        }
      }

      this.__items.splice(index, 1);
      var item_id = String(item.id);
      delete this.__itemIds[item_id];

      item.onRemovedFromList();

      return item;
    };

    model._removeAllItems = function () {
      for (var i=0; i<this.__items.length; i++) {
        this.__items[i].onRemovedFromList();
      }

      for (var id in this.__helperItemIds) {
        if (this.__helperItemIds.hasOwnProperty(id)) {
          this.__helperItemIds[id].onRemovedFromList();
        }
      }

      this.__items = [];
      this.__itemIds = {};
      this.__helperItemIds = {};
      this.setProperty('selectedItem', false);
    };


    model.triggerItemRemoved = function (index, item) {};
    model.removeItemAt = function (index) {
      var self = this;

      self.undoRedo.oneTransaction(function () {

        var item = this._removeItemAt(index);

        // allow a view to tap into this
        this.triggerItemRemoved(index, item);

        var constructor = item.constructor;
        var state = item.getState();
        if (item.folder) item.folder.removeItem(item);

        self.undoRedo.addTransaction({
          type: self.undoRedo.RESPONSE_TO_CHANGE,
          undo: function () {
            var newItem = constructor(state, self);
            self.insertItemAt(index, newItem);
          },
          redo: function () {
            self.removeItemAt(index);
          }
        });
      }.bind(this));

      this.updateDrawOrder();
    };

    model.removeItemById = function (id) {
      var expression = this.getItemById(id);
      if (!expression) return;
      this.removeItemAt(expression.index);
    };

    model.triggerItemMoved = function (from, to){};
    model.moveItemTo = function(a, b) {
      var self = this;

      var manipulator = function (from, to) {
        if (from === to) return;

        var len = self.getItemCount();
        var item = self.__items[from];

        // check that the numbers are within range
        if (from < 0 || to < 0 || from >= len || to >= len) return;

        // remove from items
        self.__items.splice(from , 1);

        // insert back in correct spot
        self.__items.splice(to, 0, item);

        // allow a view to tap into this
        self.triggerItemMoved(from, to);

        self.updateDrawOrder();
      };

      // add to undo/redo
      self.undoRedo.addTransaction({
        type: self.undoRedo.CAUSE_OF_CHANGE,
        undo: function () {
          manipulator(b, a);
        },
        redo: function () {
          manipulator(a, b);
        }
      });
    };
    model.moveItemsTo = function(a, b, n){
      var self = this;

      self.undoRedo.oneTransaction(function () {
        var i;
        if (b >= a && b < a+n) return;
        if(a < b){
          for(i = 0; i < n; i++){
            self.moveItemTo(a, b);
          }
        } else{
          for(i = 0; i < n; i++){
            self.moveItemTo(a + i, b + i);
          }
        }
      });
    };

    model.getItemCount = function () {
      return this.__items.length;
    };

    model.getAllSliders = function () {
      var sliders = [];

      for (var i=0; i<this.__items.length; i++) {
        var item = this.__items[i];
        if (item.slider) {
          sliders.push(item.slider);
        }
      }

      return sliders;
    };

    model.getSelected = function() {
      return this.selectedItem;
    };

    model.setSelected = function(i) {
      var nextSelected = i;

      if (typeof i === 'number')  nextSelected = this.getItemByIndex(i);
      if (nextSelected) {
        nextSelected.setProperty('selected', true);
      } else {
        var selected = this.getSelected();
        if (selected) selected.setProperty('selected', false);
      }
    };

    model.onStartMovingPoint = function (id) {
      var movedExpr = this.getItemById(id);
      var moveIds = movedExpr && movedExpr.formula && movedExpr.formula.move_ids;
      if (!moveIds) return;

      if (movedExpr.isHelperExpression) {
        movedExpr.setProperty('transient', true);
      }

      // combine all changed sliders into a single transaction
      var self = this;
      self.undoRedo.oneTransaction(function () {
        for (var i = 0; i < moveIds.length; i++) {
          if (moveIds[i] === undefined) continue;
          var item = self.getItemById(moveIds[i]);
          if (!item) continue;

          item.slider.setProperty(
            'isMoving',
            true
          );
          item.slider.setProperty('dcg-isPlaying', false);
        }
      });


      // This might not be a failproof conditional in the future, but it works for now.
      // We ordinarily want to deselect expressions when we start dragging a point. But, we
      // don't want to deselect an image when we drag one of it's pull points. The pull points
      // are defined by helper expressions.
      if (!movedExpr.isHelperExpression) {
        this.setSelected(null);
      }
    };

    model.onStopMovingPoint = function (id) {
      var movedExpr = this.getItemById(id);
      var moveIds = movedExpr && movedExpr.formula && movedExpr.formula.move_ids;
      if (!moveIds) return;

      if (movedExpr.isHelperExpression) {
        movedExpr.setProperty('transient', false);
      }

      for (var i = 0; i < moveIds.length; i++) {
        if (moveIds[i] === undefined) continue;
        var item = this.getItemById(moveIds[i]);
        if (!item) continue;

        item.slider.setProperty(
          'isMoving',
          false
        );
      }
    };

    model.onMovePoint = function (id, screen_pt, projection) {
      var movedExpr = this.getItemById(id);
      var formula = movedExpr.formula;
      if (!formula) return;

      var moveIds = formula.move_ids;
      if (!moveIds) return;

      var moveMatrix = formula.move_matrix;
      if (!moveMatrix) return;

      // constrain your mouse to the viewport
      var screenTL = projection.map_pt({x: projection.viewport.xmin , y: projection.viewport.ymax});
      var screenBR = projection.map_pt({x: projection.viewport.xmax , y: projection.viewport.ymin});
      screen_pt.x = Math.min(Math.max(screen_pt.x, screenTL.x), screenBR.x);
      screen_pt.y = Math.min(Math.max(screen_pt.y, screenTL.y), screenBR.y);

      // further constrain the point if need be
      if (movedExpr.constrainPt) {
        var viewport_pt = projection.reverse_map_pt(screen_pt);
        screen_pt = projection.map_pt(movedExpr.constrainPt(viewport_pt));
      }

      // we are going to search within the square pixel around our mouse to
      // find the shortest decimal for x and for y. We get the topLeft and
      // bottomRight (in viewport units, not pixels) of that square pixel here.
      var tl = projection.reverse_map_pt({
        x: screen_pt.x - 0.5,
        y: screen_pt.y - 0.5
      });

      var br = projection.reverse_map_pt({
        x: screen_pt.x + 0.5,
        y: screen_pt.y + 0.5
      });

      // TODO - moved this here from somewhere else. Looks like the
      // code that depended on this was written to be a little more
      // general purpose (eg, valueLimits.length is referenced). Not sure
      // what was going on there, but we could simplify things.
      var valueLimits = [{min:tl.x, max:br.x}, {min:tl.y, max:br.y}];

      var min, max, value;
      var expr;

      //Option move matrix to allow offset, factors, and multi-variable
      //dependencies.  Does in-place modification of values array
      //Possibly we should actually use Numeric or something real here
      var self = this;
      self.undoRedo.oneTransaction(function () {
        for (var i = 0; i < moveIds.length; i++) {
          if (moveIds[i] === undefined) continue;
          min = moveMatrix[i][valueLimits.length];
          max = moveMatrix[i][valueLimits.length];
          for (var j = 0; j < valueLimits.length; j++) {
            var k = moveMatrix[i][j];
            min += k * (k > 0 ? valueLimits[j].min : valueLimits[j].max);
            max += k * (k > 0 ? valueLimits[j].max : valueLimits[j].min);
          }

          value = Rounding.shortestDecimalBetween(min, max);

          var moveId = moveIds[i];

          expr = self.getItemById(moveId);
          if (expr && expr.slider) {
            expr.slider.setProperty('value', expr.slider.computeSnappedValue(value));
          }
        }
      });
    };

    model.isEmpty = function() {
      var len = this.getItemCount();
      if ( len === 0) return true;
      if ( len > 1) return false;

      // TODO - maybe this should be this.getItemByIndex(0).isEmpty(). Only
      // problem I see there is that tables aren't ever considered empty. Not
      // sure if we consider expression list empty if it only contains an
      // empty text.
      return this.getItemByIndex(0).latex === '';
    };

    model.getState = function() {
      var list_state = [];
      var len = this.getItemCount();

      for (var i=0; i<len; i++) {
        list_state.push(this.getItemByIndex(i).getState());
      }

      return {list: list_state};
    };

    model.batchEvaluation = function(fn){
      fn();
    };
    model.triggerSetState = function (list) {};
    model.setState = function(state) {
      var i;
      var list_content = [];
      var folders = [];
      var obj;

      for (i=0; i<state.list.length; i++) {
        var expState = state.list[i];

        // Start rendering UI as shell until we know if it's on screen
        expState.renderShell = true;

        obj = this.fromState(expState);

        if (!obj) continue;

        if (obj.isFolder) folders.push(obj);

        list_content.push(obj);
      }

      // remove all items and then add the new ones in a single batch
      var self = this;
      this.batchEvaluation(function () {
        self._removeAllItems();

        for (i=0; i<list_content.length; i++) {
          self._insertItemAt(i, list_content[i]);
        }
      });

      // Tell expressions about their parent folders.
      folders.forEach(function (folder) {
        for (var id in folder.memberIds) {
          // defensive programming. see #3920 where memberIds contained a missing id
          var item = self.getItemById(id);
          if (item) {
            item.setProperty('folder', folder);
          } else {
            delete folder.memberIds[id];
          }
        }
      });

      // allow the view to tap into this
      this.triggerSetState(list_content);

      this.updateDrawOrder();
    };

    // Factory method for making a single expression object of the appropriate
    // type from a serialized state.
    model.fromState = function(itemState) {
      if (itemState.text !== undefined) {
        return TextObject(itemState, this);
      }
      if (itemState.columns !== undefined || itemState.headings !== undefined ) {
        // TODO - remove headings after DB updated
        return TableObject(itemState, this);
      }

      if (itemState.type === 'folder') return FolderObject(itemState, this);
      if (itemState.type === 'image') return ImageObject(itemState, this);

      // Handle legacy data about whether an expression should be hidden
      if (!itemState.hasOwnProperty('hidden')) {
        if (itemState.hasOwnProperty('graphed')) {
          itemState.hidden = !itemState.graphed;
        } else if (itemState.hasOwnProperty('userRequestedGraphing')) {
          itemState.hidden = (itemState.userRequestedGraphing === 'never');
        }
      }

      return ExpressionObject(itemState, this);
    };

    model.triggerRemoveExps = function () {};
    model.triggerRemoveExp = function () {};
    model.triggerAddExp = function () {};
  });


  return ExpressionListModel;
});

define('loadcss!css/expression_top_bar', function(){});
define('loadcss!css/expressions', function(){});
define('loadcss!css/expressions.icon', function(){});
define('expressions/dragdrop',['require','jquery','pjs','tipsy','jquery.handleevent'],function(require){
  var $ = require('jquery');
  var P = require('pjs');
  var Tipsy = require('tipsy');
  require('jquery.handleevent');

  var DragDrop = P(function(dragdrop){

    // methods to be filled in by subclass
    dragdrop.toggleStyling = function(isDragging) {};
    dragdrop.onDragStart = function (evt, view) {};
    dragdrop.onDragStop = function (evt) {};
    dragdrop.commitDragState = function(dragState) {};
    dragdrop.updateScroll = function () {};
    dragdrop.computeDragPosition = function (x,y) { return {x:x, y:y} };
    dragdrop.computeDragState = function (list, dragPosition) { return {} };
    dragdrop.previewDragState = function(dragState) {};
    dragdrop.buildDragList = function () {};

    dragdrop.init = function(expressionsView){
      this.expressionsView = expressionsView;
      this.active = false;
    };

    dragdrop.start = function(evt, view){
      if(evt.touches.length !== 1) return;
      if(evt.wasHandled('longhold')) return;
      this.active = true;
      this.exppanel = this.expressionsView.$('.dcg-exppanel');

      this.setupEventListeners(evt);
      this.onDragStart(evt, view);

      this.dragList = this.buildDragList();
      this.toggleStyling(true);
      this.drag(evt.touches[0].x, evt.touches[0].y); //Do first drag

      // disable tipsy while dragging
      Tipsy.addDisableLock();
    };

    dragdrop.setupEventListeners = function(evt){
      // save the touch identifier so that multitouch doesn't mess us up. Also
      // create a function that allows us to lookup the touch we care about.
      var touch_identifier = evt.touches[0].identifier;
      function getTouch (evt) {
        for (var i=0; i < evt.touches.length; i++) {
          var touch = evt.touches[i];
          if (touch.identifier === touch_identifier) {
            return touch;
          }
        }
      }

      var self = this;

      // listen for mouse movements and tell DragDrop about them.
      $(document).on('tapmove.dragdrop', function (evt) {
        // touch must still be around
        var touch = getTouch(evt);
        if (!touch) return;
        self.drag(touch.x, touch.y);
      });

      // listen for mouse ups and tell DragDrop about them.
      $(document).on('tapend.dragdrop', function (evt) {
        // touch must not be around
        var touch = getTouch(evt);
        if (touch) return;
        self.stop();
        evt.handle('dragdrop');
      });

      //add event listener on exppanel.scroll
      this.exppanel.on('scroll.dragdrop', this.drag.bind(this));
    };

    dragdrop.stop = function(evt){
      this.active = false;

      //Clear listeners
      $(document).off('.dragdrop');

      //Commit changes to model
      this.commitDragState(this.dragState);

      //Get rid of preview styling
      this.toggleStyling(false);

      this.onDragStop(evt);

      // reenable tipsy after dragging
      Tipsy.removeDisableLock();
    };

    dragdrop.drag = function(x, y){
      if (!this.active) return;

      //Need to cache mouse position for scroll-triggered udpates
      if (typeof(x) === 'number') this.mouseX = x;
      if (typeof(y) === 'number') this.mouseY = y;

      var self = this;
      setTimeout(function() {
        self.updateScroll();
      }, 1);

      var dragPosition = this.computeDragPosition(this.mouseX, this.mouseY);
      this.dragState = this.computeDragState(this.dragList, dragPosition);
      this.previewDragState(this.dragState);
    };
  });

  // TODO - any kind of user interaction (undo, typing, etc) should call
  // finishDrag to prevent us from getting in a weird state where we're dragging
  // an expression that doesn't exist.

  return DragDrop;
});
define('expressions/dragdrop_expressions',['require','underscore','browser','pjs','./dragdrop','conditional_blur'],function(require){
  var _ = require('underscore');
  var Browser = require('browser');
  var P = require('pjs');
  var DragDrop = require('./dragdrop');
  var conditionalBlur = require('conditional_blur');

  var DragDropExpressions = P(DragDrop, function(dragdrop, _super){

    dragdrop.toggleStyling = function(isDragging){
      this.exppanel.toggleClass('dcg-isDragging', isDragging);
      this.draggedView.$().toggleClass('dcg-dragging', isDragging);
      if(!isDragging){
        //Remove things that are set by preview code
        this.draggedView.$().removeClass('dcg-overFolder');
        this.expressionsView.$('.dcg-expressionitem').css('transform', 'none');
      }
    };

    dragdrop.onDragStart = function (evt, view) {
      this.expressionsView.model.setSelected(null);
      this.exppanel = this.expressionsView.$('.dcg-exppanel');

      conditionalBlur();
      evt.preventDefault();

      this.draggedView = view;
      this.draggedViewHeight = view.$().outerHeight() - 1; //because of the negative 1 margin

      this.panelTop = this.exppanel.offset().top;
      this.panelHeight = this.exppanel.height();
      this.panelBottom = this.panelTop + this.panelHeight;

      this.grabOffset = view.$().offset().top - evt.touches[0].y;
      this.grabY = this.computeDragPosition(evt.touches[0].x, evt.touches[0].y).y;
      this.grabIndex = view.model.index;
      this.draggedViewCount = 1;

      if(view.model.isFolder){
        this.draggedViewCount += _.size(view.model.memberIds);
        this.dropCollapsed = view.model.collapsed; //Cache whether folder is collapsed before collapsing
        view.model.setProperty('collapsed', true);
      }
    };

    dragdrop.onDragStop = function (evt) {
      clearTimeout(this.scrollTimeout);

      //Select the expression we just dragged
      this.expressionsView.model.setSelected(this.draggedView.model);
    };

    dragdrop.buildDragList = function(){
      var self = this;
      var expressions = this.expressionsView.model.getItemsByIndexRange(0, Infinity);

      var list = [{
        y: -Infinity,
        index: 0,
        folder: undefined
      }];

      var lastItem = [{
        y: Infinity,
        index: 0,
        folder: undefined
      }];

      expressions.forEach(function(expression){
        if(expression.id === self.draggedView.model.id) return;
        if(expression.folder && expression.folder.collapsed) return;
        if(expression.folder && self.draggedView.model.isFolder) return;

        //Figure out which expressions are included in this drag item
        var view = self.expressionsView.getItemView(expression.id);
        var belowGrabbedView = (expression.index > self.grabIndex);
        var elements = view.$();
        if (expression.isFolder && (expression.collapsed || self.draggedView.model.isFolder)){
          for (var id in expression.memberIds) {
            elements.push(self.expressionsView.getItemView(id).$()[0]);
          }
        }

        //Compute dimensions of the expression(s), removing draggedView from list
        var offset = (belowGrabbedView ? -self.draggedViewHeight : 0);
        var height = view.$().height();
        var top = view.$().position().top + offset;

        //Compute indexes for before and after the expression(s)
        var indexOffset = (belowGrabbedView ? -1 : 0); //-self.draggedViewCount : 0);
        var indexBefore = expression.index + indexOffset;
        var indexAfter = indexBefore + elements.length;

        //Compute folder insertion behavior
        var topFolder, midFolder;
        if(!self.draggedView.model.isFolder){
          topFolder = expression.folder;
          midFolder = (expression.isFolder ? expression : expression.folder);
        }

        //Record what happens when dragging past the top of the expression
        list.push({
          y: top,
          index: indexBefore,
          folder: topFolder
        });

        //Record what happens when dragging past the midpoint of the expression
        list.push({
          y: top + height / 2,
          index: indexAfter,
          folder: midFolder,

          elements: elements, //TODO - should include all elements dragged past
          offset: offset
        });

        //Record what happens when dragging past the bottom of the expression
        //Only appended to list if this was the last item
        lastItem = {
          y: top + height,
          index: indexAfter,
          folder: undefined
        };

      });
      list.push(lastItem);

      return list;
    };

    // allows expression list to scroll drag above or below it
    dragdrop.updateScroll = function() {
      clearTimeout(this.scrollTimeout);
      if(!this.active) return;
      var scrollSpeed = 0;

      //Use being over top of list (into header bar) as cue to start scrolling up
      scrollSpeed = Math.min(scrollSpeed, (this.mouseY - this.panelTop));

      //Use bottom 30 pixels as cue to start scrolling down  30px is smaller than one equation,
      //But still big enough to trigger easily
      scrollSpeed = Math.max(scrollSpeed, (this.mouseY - this.panelBottom + 30));

      //Adjust the speed based on the expressions list height.
      //A 30 pixel offset should get us to the other side in about 1 second of 30hz updates
      //30 pixels * 30 updates = 900
      scrollSpeed = (scrollSpeed * this.panelHeight / 900);

      if(scrollSpeed){
        this.exppanel.scrollTop(this.exppanel.scrollTop() + scrollSpeed);
      }
    };

    //Compute position of the dragged view in terms of the scrolled list
    dragdrop.computeDragPosition = function(x, y) {
      //Clamp effective mouse position to edges of panel
      y = Math.max(y, Math.min(y, this.panelBottom), this.panelTop);

      //Make position relative to the panel
      y -= this.panelTop;

      //Add offset for where element was grabbed
      y += this.grabOffset;

      //Compensate for scrolling
      return {x:NaN, y: y+this.exppanel.scrollTop()};
    };

    //Takes a list of states, which each includes the y value at which it starts,
    //as well as the index and the folder which the dragged item would have it it
    //is dropped below that line.
    dragdrop.computeDragState = function(list, dragPosition){
      function sortMethod (item) {
        return item.y;
      }

      var index = _.sortedIndex(list, {y:dragPosition.y}, sortMethod) - 1;//See where we would be inserted
      return {
        list: list,
        index: list[index].index,
        folder: list[index].folder,
        dragY: dragPosition.y
      };
    };

    //Update model to reflect new dragState
    dragdrop.commitDragState = function(dragState){
      var self = this;
      var list = this.expressionsView.model;

      list.undoRedo.oneTransaction(function(){
        var draggedModel = self.draggedView.model;

        //Update ordering
        list.moveItemsTo(self.grabIndex, dragState.index, self.draggedViewCount);

        //Update folder membership
        var newFolder = dragState.folder;
        var oldFolder = draggedModel.folder;
        if(newFolder !== oldFolder){
          if(oldFolder) oldFolder.removeItem(draggedModel);
          if(newFolder) newFolder.addItem(draggedModel);
        }

        //Restore folder collapsed state
        if(draggedModel.isFolder){
          draggedModel.setProperty('collapsed', self.dropCollapsed); //Restore collapsed state
        }
      });
    };

    //Display preview of dragState, but don't commit changes
    dragdrop.previewDragState = function(dragState){
      var self = this;

      //Preview height and folder membership of dragged item
      this.draggedView.$().css("transform", Browser.translateRule(0, dragState.dragY - this.grabY));
      this.draggedView.$().toggleClass('dcg-overFolder', !!dragState.folder);

      //Update transforms for items above and below dragged view
      _.each(dragState.list, function(item){
        if(item.elements){
          var offset = item.offset + (item.index > dragState.index ? self.draggedViewHeight : 0);
          item.elements.css('transform', Browser.translateRule(0, offset));
        }
      });
    };
  });

  return DragDropExpressions;
});
define('loadcss!css/add_expression', function(){});
define('template!add_expression', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="dcg-add-expression-dropdown dcg-popover dcg-bottom">\n  <div class="dcg-popover-interior">\n     ';
 if (expressions) {
;__p+='\n     <div class=\'dcg-new-item dcg-do-not-blur dcg-action-newexpression\'>\n        <i class=\'dcg-icon-new-expression dcg-expression-icon\'></i>\n        '+
( t('expression') )+
'\n     </div>\n     ';
 }
;__p+='\n    \n     ';
 if (texts) {
;__p+='\n     <div class=\'dcg-new-item dcg-do-not-blur dcg-action-newtext\'>\n       <i class=\'dcg-icon-new-text dcg-expression-icon\'></i>\n       '+
( t('note') )+
'\n     </div>\n     ';
 }
;__p+='\n\n     ';
 if (tables) {
;__p+='\n     <div class=\'dcg-new-item dcg-do-not-blur dcg-action-newtable\'>\n       <i class=\'dcg-icon-new-table dcg-expression-icon\'></i>\n       '+
( t('table') )+
'\n     </div>\n     ';
 }
;__p+='\n     \n     ';
 if (folders) {
;__p+='\n     <div class=\'dcg-new-item dcg-do-not-blur dcg-action-newfolder\'>\n       <i class=\'dcg-icon-new-folder dcg-expression-icon\'></i>\n       '+
( t('folder') )+
'\n     </div>\n     ';
 }
;__p+='\n\n     ';
 if (images) {
;__p+='\n     <div class=\'dcg-new-item dcg-do-not-blur dcg-action-newimage\'>\n       <i class=\'dcg-icon-new-image dcg-expression-icon\'></i>\n       '+
( t('image') )+
'\n       \n       ';
 // hiding the file input box. It's ugly. Our UI is prettier. We'll fake a click on it
          // when our UI is clicked
;__p+='\n       <input type="file" accept="image/*" style="display: none" />\n     </div>\n     ';
 }
;__p+='\n\n   </div>\n\n   <span class="dcg-arrow"></span>\n</div>\n';
}
return __p;
};});
/*
 * JavaScript Load Image 1.9.0
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint nomen: true */
/*global define, window, document, URL, webkitURL, Blob, File, FileReader */

(function ($) {


    // Loads an image for a given File object.
    // Invokes the callback with an img or optional canvas
    // element (if supported by the browser) as parameter:
    var loadImage = function (file, callback, options) {
            var img = document.createElement('img'),
                url,
                oUrl;
            img.onerror = callback;
            img.onload = function () {
                if (oUrl && !(options && options.noRevoke)) {
                    loadImage.revokeObjectURL(oUrl);
                }
                if (callback) {
                    callback(loadImage.scale(img, options));
                }
            };
            if (loadImage.isInstanceOf('Blob', file) ||
                    // Files are also Blob instances, but some browsers
                    // (Firefox 3.6) support the File API but not Blobs:
                    loadImage.isInstanceOf('File', file)) {
                url = oUrl = loadImage.createObjectURL(file);
                // Store the file type for resize processing:
                img._type = file.type;
            } else if (typeof file === 'string') {
                url = file;
                if (options && options.crossOrigin) {
                    img.crossOrigin = options.crossOrigin;
                }
            } else {
                return false;
            }
            if (url) {
                img.src = url;
                return img;
            }
            return loadImage.readFile(file, function (e) {
                var target = e.target;
                if (target && target.result) {
                    img.src = target.result;
                } else {
                    if (callback) {
                        callback(e);
                    }
                }
            });
        },
        // The check for URL.revokeObjectURL fixes an issue with Opera 12,
        // which provides URL.createObjectURL but doesn't properly implement it:
        urlAPI = (window.createObjectURL && window) ||
            (window.URL && URL.revokeObjectURL && URL) ||
            (window.webkitURL && webkitURL);

    loadImage.isInstanceOf = function (type, obj) {
        // Cross-frame instanceof check
        return Object.prototype.toString.call(obj) === '[object ' + type + ']';
    };

    // Transform image coordinates, allows to override e.g.
    // the canvas orientation based on the orientation option,
    // gets canvas, options passed as arguments:
    loadImage.transformCoordinates = function () {
        return;
    };

    // Returns transformed options, allows to override e.g.
    // coordinate and dimension options based on the orientation:
    loadImage.getTransformedOptions = function (options) {
        return options;
    };

    // Canvas render method, allows to override the
    // rendering e.g. to work around issues on iOS:
    loadImage.renderImageToCanvas = function (
        canvas,
        img,
        sourceX,
        sourceY,
        sourceWidth,
        sourceHeight,
        destX,
        destY,
        destWidth,
        destHeight
    ) {
        canvas.getContext('2d').drawImage(
            img,
            sourceX,
            sourceY,
            sourceWidth,
            sourceHeight,
            destX,
            destY,
            destWidth,
            destHeight
        );
        return canvas;
    };

    // This method is used to determine if the target image
    // should be a canvas element:
    loadImage.hasCanvasOption = function (options) {
        return options.canvas || options.crop;
    };

    // Scales and/or crops the given image (img or canvas HTML element)
    // using the given options.
    // Returns a canvas object if the browser supports canvas
    // and the hasCanvasOption method returns true or a canvas
    // object is passed as image, else the scaled image:
    loadImage.scale = function (img, options) {
        options = options || {};
        var canvas = document.createElement('canvas'),
            useCanvas = img.getContext ||
                (loadImage.hasCanvasOption(options) && canvas.getContext),
            width = img.naturalWidth || img.width,
            height = img.naturalHeight || img.height,
            destWidth = width,
            destHeight = height,
            maxWidth,
            maxHeight,
            minWidth,
            minHeight,
            sourceWidth,
            sourceHeight,
            sourceX,
            sourceY,
            tmp,
            scaleUp = function () {
                var scale = Math.max(
                    (minWidth || destWidth) / destWidth,
                    (minHeight || destHeight) / destHeight
                );
                if (scale > 1) {
                    destWidth = Math.ceil(destWidth * scale);
                    destHeight = Math.ceil(destHeight * scale);
                }
            },
            scaleDown = function () {
                var scale = Math.min(
                    (maxWidth || destWidth) / destWidth,
                    (maxHeight || destHeight) / destHeight
                );
                if (scale < 1) {
                    destWidth = Math.ceil(destWidth * scale);
                    destHeight = Math.ceil(destHeight * scale);
                }
            };
        if (useCanvas) {
            options = loadImage.getTransformedOptions(options);
            sourceX = options.left || 0;
            sourceY = options.top || 0;
            if (options.sourceWidth) {
                sourceWidth = options.sourceWidth;
                if (options.right !== undefined && options.left === undefined) {
                    sourceX = width - sourceWidth - options.right;
                }
            } else {
                sourceWidth = width - sourceX - (options.right || 0);
            }
            if (options.sourceHeight) {
                sourceHeight = options.sourceHeight;
                if (options.bottom !== undefined && options.top === undefined) {
                    sourceY = height - sourceHeight - options.bottom;
                }
            } else {
                sourceHeight = height - sourceY - (options.bottom || 0);
            }
            destWidth = sourceWidth;
            destHeight = sourceHeight;
        }
        maxWidth = options.maxWidth;
        maxHeight = options.maxHeight;
        minWidth = options.minWidth;
        minHeight = options.minHeight;
        if (useCanvas && maxWidth && maxHeight && options.crop) {
            destWidth = maxWidth;
            destHeight = maxHeight;
            tmp = sourceWidth / sourceHeight - maxWidth / maxHeight;
            if (tmp < 0) {
                sourceHeight = maxHeight * sourceWidth / maxWidth;
                if (options.top === undefined && options.bottom === undefined) {
                    sourceY = (height - sourceHeight) / 2;
                }
            } else if (tmp > 0) {
                sourceWidth = maxWidth * sourceHeight / maxHeight;
                if (options.left === undefined && options.right === undefined) {
                    sourceX = (width - sourceWidth) / 2;
                }
            }
        } else {
            if (options.contain || options.cover) {
                minWidth = maxWidth = maxWidth || minWidth;
                minHeight = maxHeight = maxHeight || minHeight;
            }
            if (options.cover) {
                scaleDown();
                scaleUp();
            } else {
                scaleUp();
                scaleDown();
            }
        }
        if (useCanvas) {
            canvas.width = destWidth;
            canvas.height = destHeight;
            loadImage.transformCoordinates(
                canvas,
                options
            );
            return loadImage.renderImageToCanvas(
                canvas,
                img,
                sourceX,
                sourceY,
                sourceWidth,
                sourceHeight,
                0,
                0,
                destWidth,
                destHeight
            );
        }
        img.width = destWidth;
        img.height = destHeight;
        return img;
    };

    loadImage.createObjectURL = function (file) {
        return urlAPI ? urlAPI.createObjectURL(file) : false;
    };

    loadImage.revokeObjectURL = function (url) {
        return urlAPI ? urlAPI.revokeObjectURL(url) : false;
    };

    // Loads a given File object via FileReader interface,
    // invokes the callback with the event object (load or error).
    // The result can be read via event.target.result:
    loadImage.readFile = function (file, callback, method) {
        if (window.FileReader) {
            var fileReader = new FileReader();
            fileReader.onload = fileReader.onerror = callback;
            method = method || 'readAsDataURL';
            if (fileReader[method]) {
                fileReader[method](file);
                return fileReader;
            }
        }
        return false;
    };

    if (typeof define === 'function' && define.amd) {
        define('vendor/load-image/load-image',[],function () {
            return loadImage;
        });
    } else {
        $.loadImage = loadImage;
    }
}(this));

/*
 * JavaScript Load Image Orientation 1.0.0
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*global define, window */

(function (factory) {

    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define('vendor/load-image/load-image-orientation',['./load-image'], factory);
    } else {
        // Browser globals:
        factory(window.loadImage);
    }
}(function (loadImage) {


    var originalHasCanvasOptionMethod = loadImage.hasCanvasOption;

    // This method is used to determine if the target image
    // should be a canvas element:
    loadImage.hasCanvasOption = function (options) {
        return originalHasCanvasOptionMethod(options) || options.orientation;
    };

    // Transform image orientation based on
    // the given EXIF orientation option:
    loadImage.transformCoordinates = function (canvas, options) {
        var ctx = canvas.getContext('2d'),
            width = canvas.width,
            height = canvas.height,
            orientation = options.orientation;
        if (!orientation) {
            return;
        }
        if (orientation > 4) {
            canvas.width = height;
            canvas.height = width;
        }
        switch (orientation) {
        case 2:
            // horizontal flip
            ctx.translate(width, 0);
            ctx.scale(-1, 1);
            break;
        case 3:
            // 180 rotate left
            ctx.translate(width, height);
            ctx.rotate(Math.PI);
            break;
        case 4:
            // vertical flip
            ctx.translate(0, height);
            ctx.scale(1, -1);
            break;
        case 5:
            // vertical flip + 90 rotate right
            ctx.rotate(0.5 * Math.PI);
            ctx.scale(1, -1);
            break;
        case 6:
            // 90 rotate right
            ctx.rotate(0.5 * Math.PI);
            ctx.translate(0, -height);
            break;
        case 7:
            // horizontal flip + 90 rotate right
            ctx.rotate(0.5 * Math.PI);
            ctx.translate(width, -height);
            ctx.scale(-1, 1);
            break;
        case 8:
            // 90 rotate left
            ctx.rotate(-0.5 * Math.PI);
            ctx.translate(-width, 0);
            break;
        }
    };

    // Transforms coordinate and dimension options
    // based on the given orientation option:
    loadImage.getTransformedOptions = function (options) {
        if (!options.orientation || options.orientation === 1) {
            return options;
        }
        var newOptions = {},
            i;
        for (i in options) {
            if (options.hasOwnProperty(i)) {
                newOptions[i] = options[i];
            }
        }
        switch (options.orientation) {
        case 2:
            // horizontal flip
            newOptions.left = options.right;
            newOptions.right = options.left;
            break;
        case 3:
            // 180 rotate left
            newOptions.left = options.right;
            newOptions.top = options.bottom;
            newOptions.right = options.left;
            newOptions.bottom = options.top;
            break;
        case 4:
            // vertical flip
            newOptions.top = options.bottom;
            newOptions.bottom = options.top;
            break;
        case 5:
            // vertical flip + 90 rotate right
            newOptions.left = options.top;
            newOptions.top = options.left;
            newOptions.right = options.bottom;
            newOptions.bottom = options.right;
            break;
        case 6:
            // 90 rotate right
            newOptions.left = options.top;
            newOptions.top = options.right;
            newOptions.right = options.bottom;
            newOptions.bottom = options.left;
            break;
        case 7:
            // horizontal flip + 90 rotate right
            newOptions.left = options.bottom;
            newOptions.top = options.right;
            newOptions.right = options.top;
            newOptions.bottom = options.left;
            break;
        case 8:
            // 90 rotate left
            newOptions.left = options.bottom;
            newOptions.top = options.left;
            newOptions.right = options.top;
            newOptions.bottom = options.right;
            break;
        }
        if (options.orientation > 4) {
            newOptions.maxWidth = options.maxHeight;
            newOptions.maxHeight = options.maxWidth;
            newOptions.minWidth = options.minHeight;
            newOptions.minHeight = options.minWidth;
            newOptions.sourceWidth = options.sourceHeight;
            newOptions.sourceHeight = options.sourceWidth;
        }
        return newOptions;
    };

}));

/*
 * JavaScript Load Image Meta 1.0.1
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Image meta data handling implementation
 * based on the help and contribution of
 * Achim Sthr.
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint continue:true */
/*global define, window, DataView, Blob, Uint8Array, console */

(function (factory) {

    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define('vendor/load-image/load-image-meta',['./load-image'], factory);
    } else {
        // Browser globals:
        factory(window.loadImage);
    }
}(function (loadImage) {


    var hasblobSlice = window.Blob && (Blob.prototype.slice ||
            Blob.prototype.webkitSlice || Blob.prototype.mozSlice);

    loadImage.blobSlice = hasblobSlice && function () {
        var slice = this.slice || this.webkitSlice || this.mozSlice;
        return slice.apply(this, arguments);
    };

    loadImage.metaDataParsers = {
        jpeg: {
            0xffe1: [] // APP1 marker
        }
    };

    // Parses image meta data and calls the callback with an object argument
    // with the following properties:
    // * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)
    // The options arguments accepts an object and supports the following properties:
    // * maxMetaDataSize: Defines the maximum number of bytes to parse.
    // * disableImageHead: Disables creating the imageHead property.
    loadImage.parseMetaData = function (file, callback, options) {
        options = options || {};
        var that = this,
            // 256 KiB should contain all EXIF/ICC/IPTC segments:
            maxMetaDataSize = options.maxMetaDataSize || 262144,
            data = {},
            noMetaData = !(window.DataView  && file && file.size >= 12 &&
                file.type === 'image/jpeg' && loadImage.blobSlice);
        if (noMetaData || !loadImage.readFile(
                loadImage.blobSlice.call(file, 0, maxMetaDataSize),
                function (e) {
                    // Note on endianness:
                    // Since the marker and length bytes in JPEG files are always
                    // stored in big endian order, we can leave the endian parameter
                    // of the DataView methods undefined, defaulting to big endian.
                    var buffer = e.target.result,
                        dataView = new DataView(buffer),
                        offset = 2,
                        maxOffset = dataView.byteLength - 4,
                        headLength = offset,
                        markerBytes,
                        markerLength,
                        parsers,
                        i;
                    // Check for the JPEG marker (0xffd8):
                    if (dataView.getUint16(0) === 0xffd8) {
                        while (offset < maxOffset) {
                            markerBytes = dataView.getUint16(offset);
                            // Search for APPn (0xffeN) and COM (0xfffe) markers,
                            // which contain application-specific meta-data like
                            // Exif, ICC and IPTC data and text comments:
                            if ((markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||
                                    markerBytes === 0xfffe) {
                                // The marker bytes (2) are always followed by
                                // the length bytes (2), indicating the length of the
                                // marker segment, which includes the length bytes,
                                // but not the marker bytes, so we add 2:
                                markerLength = dataView.getUint16(offset + 2) + 2;
                                if (offset + markerLength > dataView.byteLength) {
                                    console.log('Invalid meta data: Invalid segment size.');
                                    break;
                                }
                                parsers = loadImage.metaDataParsers.jpeg[markerBytes];
                                if (parsers) {
                                    for (i = 0; i < parsers.length; i += 1) {
                                        parsers[i].call(
                                            that,
                                            dataView,
                                            offset,
                                            markerLength,
                                            data,
                                            options
                                        );
                                    }
                                }
                                offset += markerLength;
                                headLength = offset;
                            } else {
                                // Not an APPn or COM marker, probably safe to
                                // assume that this is the end of the meta data
                                break;
                            }
                        }
                        // Meta length must be longer than JPEG marker (2)
                        // plus APPn marker (2), followed by length bytes (2):
                        if (!options.disableImageHead && headLength > 6) {
                            if (buffer.slice) {
                                data.imageHead = buffer.slice(0, headLength);
                            } else {
                                // Workaround for IE10, which does not yet
                                // support ArrayBuffer.slice:
                                data.imageHead = new Uint8Array(buffer)
                                    .subarray(0, headLength);
                            }
                        }
                    } else {
                        console.log('Invalid JPEG file: Missing JPEG marker.');
                    }
                    callback(data);
                },
                'readAsArrayBuffer'
            )) {
            callback(data);
        }
    };

}));

/*
 * JavaScript Load Image iOS scaling fixes 1.0.3
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * iOS image scaling fixes based on
 * https://github.com/stomita/ios-imagefile-megapixel
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint nomen: true, bitwise: true */
/*global define, window, document */

(function (factory) {

    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define('vendor/load-image/load-image-ios',['./load-image'], factory);
    } else {
        // Browser globals:
        factory(window.loadImage);
    }
}(function (loadImage) {


    // Only apply fixes on the iOS platform:
    if (!window.navigator || !window.navigator.platform ||
             !(/iP(hone|od|ad)/).test(window.navigator.platform)) {
        return;
    }

    var originalRenderMethod = loadImage.renderImageToCanvas;

    // Detects subsampling in JPEG images:
    loadImage.detectSubsampling = function (img) {
        var canvas,
            context;
        if (img.width * img.height > 1024 * 1024) { // only consider mexapixel images
            canvas = document.createElement('canvas');
            canvas.width = canvas.height = 1;
            context = canvas.getContext('2d');
            context.drawImage(img, -img.width + 1, 0);
            // subsampled image becomes half smaller in rendering size.
            // check alpha channel value to confirm image is covering edge pixel or not.
            // if alpha value is 0 image is not covering, hence subsampled.
            return context.getImageData(0, 0, 1, 1).data[3] === 0;
        }
        return false;
    };

    // Detects vertical squash in JPEG images:
    loadImage.detectVerticalSquash = function (img, subsampled) {
        var naturalHeight = img.naturalHeight || img.height,
            canvas = document.createElement('canvas'),
            context = canvas.getContext('2d'),
            data,
            sy,
            ey,
            py,
            alpha;
        if (subsampled) {
            naturalHeight /= 2;
        }
        canvas.width = 1;
        canvas.height = naturalHeight;
        context.drawImage(img, 0, 0);
        data = context.getImageData(0, 0, 1, naturalHeight).data;
        // search image edge pixel position in case it is squashed vertically:
        sy = 0;
        ey = naturalHeight;
        py = naturalHeight;
        while (py > sy) {
            alpha = data[(py - 1) * 4 + 3];
            if (alpha === 0) {
                ey = py;
            } else {
                sy = py;
            }
            py = (ey + sy) >> 1;
        }
        return (py / naturalHeight) || 1;
    };

    // Renders image to canvas while working around iOS image scaling bugs:
    // https://github.com/blueimp/JavaScript-Load-Image/issues/13
    loadImage.renderImageToCanvas = function (
        canvas,
        img,
        sourceX,
        sourceY,
        sourceWidth,
        sourceHeight,
        destX,
        destY,
        destWidth,
        destHeight
    ) {
        if (img._type === 'image/jpeg') {
            var context = canvas.getContext('2d'),
                tmpCanvas = document.createElement('canvas'),
                tileSize = 1024,
                tmpContext = tmpCanvas.getContext('2d'),
                subsampled,
                vertSquashRatio,
                tileX,
                tileY;
            tmpCanvas.width = tileSize;
            tmpCanvas.height = tileSize;
            context.save();
            subsampled = loadImage.detectSubsampling(img);
            if (subsampled) {
                sourceX /= 2;
                sourceY /= 2;
                sourceWidth /= 2;
                sourceHeight /= 2;
            }
            vertSquashRatio = loadImage.detectVerticalSquash(img, subsampled);
            if (subsampled || vertSquashRatio !== 1) {
                sourceY *= vertSquashRatio;
                destWidth = Math.ceil(tileSize * destWidth / sourceWidth);
                destHeight = Math.ceil(
                    tileSize * destHeight / sourceHeight / vertSquashRatio
                );
                destY = 0;
                tileY = 0;
                while (tileY < sourceHeight) {
                    destX = 0;
                    tileX = 0;
                    while (tileX < sourceWidth) {
                        tmpContext.clearRect(0, 0, tileSize, tileSize);
                        tmpContext.drawImage(
                            img,
                            sourceX,
                            sourceY,
                            sourceWidth,
                            sourceHeight,
                            -tileX,
                            -tileY,
                            sourceWidth,
                            sourceHeight
                        );
                        context.drawImage(
                            tmpCanvas,
                            0,
                            0,
                            tileSize,
                            tileSize,
                            destX,
                            destY,
                            destWidth,
                            destHeight
                        );
                        tileX += tileSize;
                        destX += destWidth;
                    }
                    tileY += tileSize;
                    destY += destHeight;
                }
                context.restore();
                return canvas;
            }
        }
        return originalRenderMethod(
            canvas,
            img,
            sourceX,
            sourceY,
            sourceWidth,
            sourceHeight,
            destX,
            destY,
            destWidth,
            destHeight
        );
    };

}));

/*
 * JavaScript Load Image Exif Parser 1.0.0
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint unparam: true */
/*global define, window, console */

(function (factory) {

    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define('vendor/load-image/load-image-exif',['./load-image', './load-image-meta'], factory);
    } else {
        // Browser globals:
        factory(window.loadImage);
    }
}(function (loadImage) {


    loadImage.ExifMap = function () {
        return this;
    };

    loadImage.ExifMap.prototype.map = {
        'Orientation': 0x0112
    };

    loadImage.ExifMap.prototype.get = function (id) {
        return this[id] || this[this.map[id]];
    };

    loadImage.getExifThumbnail = function (dataView, offset, length) {
        var hexData,
            i,
            b;
        if (!length || offset + length > dataView.byteLength) {
            console.log('Invalid Exif data: Invalid thumbnail data.');
            return;
        }
        hexData = [];
        for (i = 0; i < length; i += 1) {
            b = dataView.getUint8(offset + i);
            hexData.push((b < 16 ? '0' : '') + b.toString(16));
        }
        return 'data:image/jpeg,%' + hexData.join('%');
    };

    loadImage.exifTagTypes = {
        // byte, 8-bit unsigned int:
        1: {
            getValue: function (dataView, dataOffset) {
                return dataView.getUint8(dataOffset);
            },
            size: 1
        },
        // ascii, 8-bit byte:
        2: {
            getValue: function (dataView, dataOffset) {
                return String.fromCharCode(dataView.getUint8(dataOffset));
            },
            size: 1,
            ascii: true
        },
        // short, 16 bit int:
        3: {
            getValue: function (dataView, dataOffset, littleEndian) {
                return dataView.getUint16(dataOffset, littleEndian);
            },
            size: 2
        },
        // long, 32 bit int:
        4: {
            getValue: function (dataView, dataOffset, littleEndian) {
                return dataView.getUint32(dataOffset, littleEndian);
            },
            size: 4
        },
        // rational = two long values, first is numerator, second is denominator:
        5: {
            getValue: function (dataView, dataOffset, littleEndian) {
                return dataView.getUint32(dataOffset, littleEndian) /
                    dataView.getUint32(dataOffset + 4, littleEndian);
            },
            size: 8
        },
        // slong, 32 bit signed int:
        9: {
            getValue: function (dataView, dataOffset, littleEndian) {
                return dataView.getInt32(dataOffset, littleEndian);
            },
            size: 4
        },
        // srational, two slongs, first is numerator, second is denominator:
        10: {
            getValue: function (dataView, dataOffset, littleEndian) {
                return dataView.getInt32(dataOffset, littleEndian) /
                    dataView.getInt32(dataOffset + 4, littleEndian);
            },
            size: 8
        }
    };
    // undefined, 8-bit byte, value depending on field:
    loadImage.exifTagTypes[7] = loadImage.exifTagTypes[1];

    loadImage.getExifValue = function (dataView, tiffOffset, offset, type, length, littleEndian) {
        var tagType = loadImage.exifTagTypes[type],
            tagSize,
            dataOffset,
            values,
            i,
            str,
            c;
        if (!tagType) {
            console.log('Invalid Exif data: Invalid tag type.');
            return;
        }
        tagSize = tagType.size * length;
        // Determine if the value is contained in the dataOffset bytes,
        // or if the value at the dataOffset is a pointer to the actual data:
        dataOffset = tagSize > 4 ?
                tiffOffset + dataView.getUint32(offset + 8, littleEndian) : (offset + 8);
        if (dataOffset + tagSize > dataView.byteLength) {
            console.log('Invalid Exif data: Invalid data offset.');
            return;
        }
        if (length === 1) {
            return tagType.getValue(dataView, dataOffset, littleEndian);
        }
        values = [];
        for (i = 0; i < length; i += 1) {
            values[i] = tagType.getValue(dataView, dataOffset + i * tagType.size, littleEndian);
        }
        if (tagType.ascii) {
            str = '';
            // Concatenate the chars:
            for (i = 0; i < values.length; i += 1) {
                c = values[i];
                // Ignore the terminating NULL byte(s):
                if (c === '\u0000') {
                    break;
                }
                str += c;
            }
            return str;
        }
        return values;
    };

    loadImage.parseExifTag = function (dataView, tiffOffset, offset, littleEndian, data) {
        var tag = dataView.getUint16(offset, littleEndian);
        data.exif[tag] = loadImage.getExifValue(
            dataView,
            tiffOffset,
            offset,
            dataView.getUint16(offset + 2, littleEndian), // tag type
            dataView.getUint32(offset + 4, littleEndian), // tag length
            littleEndian
        );
    };

    loadImage.parseExifTags = function (dataView, tiffOffset, dirOffset, littleEndian, data) {
        var tagsNumber,
            dirEndOffset,
            i;
        if (dirOffset + 6 > dataView.byteLength) {
            console.log('Invalid Exif data: Invalid directory offset.');
            return;
        }
        tagsNumber = dataView.getUint16(dirOffset, littleEndian);
        dirEndOffset = dirOffset + 2 + 12 * tagsNumber;
        if (dirEndOffset + 4 > dataView.byteLength) {
            console.log('Invalid Exif data: Invalid directory size.');
            return;
        }
        for (i = 0; i < tagsNumber; i += 1) {
            this.parseExifTag(
                dataView,
                tiffOffset,
                dirOffset + 2 + 12 * i, // tag offset
                littleEndian,
                data
            );
        }
        // Return the offset to the next directory:
        return dataView.getUint32(dirEndOffset, littleEndian);
    };

    loadImage.parseExifData = function (dataView, offset, length, data, options) {
        if (options.disableExif) {
            return;
        }
        var tiffOffset = offset + 10,
            littleEndian,
            dirOffset,
            thumbnailData;
        // Check for the ASCII code for "Exif" (0x45786966):
        if (dataView.getUint32(offset + 4) !== 0x45786966) {
            // No Exif data, might be XMP data instead
            return;
        }
        if (tiffOffset + 8 > dataView.byteLength) {
            console.log('Invalid Exif data: Invalid segment size.');
            return;
        }
        // Check for the two null bytes:
        if (dataView.getUint16(offset + 8) !== 0x0000) {
            console.log('Invalid Exif data: Missing byte alignment offset.');
            return;
        }
        // Check the byte alignment:
        switch (dataView.getUint16(tiffOffset)) {
        case 0x4949:
            littleEndian = true;
            break;
        case 0x4D4D:
            littleEndian = false;
            break;
        default:
            console.log('Invalid Exif data: Invalid byte alignment marker.');
            return;
        }
        // Check for the TIFF tag marker (0x002A):
        if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002A) {
            console.log('Invalid Exif data: Missing TIFF marker.');
            return;
        }
        // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:
        dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian);
        // Create the exif object to store the tags:
        data.exif = new loadImage.ExifMap();
        // Parse the tags of the main image directory and retrieve the
        // offset to the next directory, usually the thumbnail directory:
        dirOffset = loadImage.parseExifTags(
            dataView,
            tiffOffset,
            tiffOffset + dirOffset,
            littleEndian,
            data
        );
        if (dirOffset && !options.disableExifThumbnail) {
            thumbnailData = {exif: {}};
            dirOffset = loadImage.parseExifTags(
                dataView,
                tiffOffset,
                tiffOffset + dirOffset,
                littleEndian,
                thumbnailData
            );
            // Check for JPEG Thumbnail offset:
            if (thumbnailData.exif[0x0201]) {
                data.exif.Thumbnail = loadImage.getExifThumbnail(
                    dataView,
                    tiffOffset + thumbnailData.exif[0x0201],
                    thumbnailData.exif[0x0202] // Thumbnail data length
                );
            }
        }
        // Check for Exif Sub IFD Pointer:
        if (data.exif[0x8769] && !options.disableExifSub) {
            loadImage.parseExifTags(
                dataView,
                tiffOffset,
                tiffOffset + data.exif[0x8769], // directory offset
                littleEndian,
                data
            );
        }
        // Check for GPS Info IFD Pointer:
        if (data.exif[0x8825] && !options.disableExifGps) {
            loadImage.parseExifTags(
                dataView,
                tiffOffset,
                tiffOffset + data.exif[0x8825], // directory offset
                littleEndian,
                data
            );
        }
    };

    // Registers the Exif parser for the APP1 JPEG meta data segment:
    loadImage.metaDataParsers.jpeg[0xffe1].push(loadImage.parseExifData);

    // Adds the following properties to the parseMetaData callback data:
    // * exif: The exif tags, parsed by the parseExifData method

    // Adds the following options to the parseMetaData method:
    // * disableExif: Disables Exif parsing.
    // * disableExifThumbnail: Disables parsing of the Exif Thumbnail.
    // * disableExifSub: Disables parsing of the Exif Sub IFD.
    // * disableExifGps: Disables parsing of the Exif GPS Info IFD.

}));

/*
 * JavaScript Load Image Exif Map 1.0.2
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Exif tags mapping based on
 * https://github.com/jseidelin/exif-js
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*global define, window */

(function (factory) {

    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define('vendor/load-image/load-image-exif-map',['./load-image', './load-image-exif'], factory);
    } else {
        // Browser globals:
        factory(window.loadImage);
    }
}(function (loadImage) {


    loadImage.ExifMap.prototype.tags = {
        // =================
        // TIFF tags (IFD0):
        // =================
        0x0100: 'ImageWidth',
        0x0101: 'ImageHeight',
        0x8769: 'ExifIFDPointer',
        0x8825: 'GPSInfoIFDPointer',
        0xA005: 'InteroperabilityIFDPointer',
        0x0102: 'BitsPerSample',
        0x0103: 'Compression',
        0x0106: 'PhotometricInterpretation',
        0x0112: 'Orientation',
        0x0115: 'SamplesPerPixel',
        0x011C: 'PlanarConfiguration',
        0x0212: 'YCbCrSubSampling',
        0x0213: 'YCbCrPositioning',
        0x011A: 'XResolution',
        0x011B: 'YResolution',
        0x0128: 'ResolutionUnit',
        0x0111: 'StripOffsets',
        0x0116: 'RowsPerStrip',
        0x0117: 'StripByteCounts',
        0x0201: 'JPEGInterchangeFormat',
        0x0202: 'JPEGInterchangeFormatLength',
        0x012D: 'TransferFunction',
        0x013E: 'WhitePoint',
        0x013F: 'PrimaryChromaticities',
        0x0211: 'YCbCrCoefficients',
        0x0214: 'ReferenceBlackWhite',
        0x0132: 'DateTime',
        0x010E: 'ImageDescription',
        0x010F: 'Make',
        0x0110: 'Model',
        0x0131: 'Software',
        0x013B: 'Artist',
        0x8298: 'Copyright',
        // ==================
        // Exif Sub IFD tags:
        // ==================
        0x9000: 'ExifVersion',                  // EXIF version
        0xA000: 'FlashpixVersion',              // Flashpix format version
        0xA001: 'ColorSpace',                   // Color space information tag
        0xA002: 'PixelXDimension',              // Valid width of meaningful image
        0xA003: 'PixelYDimension',              // Valid height of meaningful image
        0xA500: 'Gamma',
        0x9101: 'ComponentsConfiguration',      // Information about channels
        0x9102: 'CompressedBitsPerPixel',       // Compressed bits per pixel
        0x927C: 'MakerNote',                    // Any desired information written by the manufacturer
        0x9286: 'UserComment',                  // Comments by user
        0xA004: 'RelatedSoundFile',             // Name of related sound file
        0x9003: 'DateTimeOriginal',             // Date and time when the original image was generated
        0x9004: 'DateTimeDigitized',            // Date and time when the image was stored digitally
        0x9290: 'SubSecTime',                   // Fractions of seconds for DateTime
        0x9291: 'SubSecTimeOriginal',           // Fractions of seconds for DateTimeOriginal
        0x9292: 'SubSecTimeDigitized',          // Fractions of seconds for DateTimeDigitized
        0x829A: 'ExposureTime',                 // Exposure time (in seconds)
        0x829D: 'FNumber',
        0x8822: 'ExposureProgram',              // Exposure program
        0x8824: 'SpectralSensitivity',          // Spectral sensitivity
        0x8827: 'PhotographicSensitivity',      // EXIF 2.3, ISOSpeedRatings in EXIF 2.2
        0x8828: 'OECF',                         // Optoelectric conversion factor
        0x8830: 'SensitivityType',
        0x8831: 'StandardOutputSensitivity',
        0x8832: 'RecommendedExposureIndex',
        0x8833: 'ISOSpeed',
        0x8834: 'ISOSpeedLatitudeyyy',
        0x8835: 'ISOSpeedLatitudezzz',
        0x9201: 'ShutterSpeedValue',            // Shutter speed
        0x9202: 'ApertureValue',                // Lens aperture
        0x9203: 'BrightnessValue',              // Value of brightness
        0x9204: 'ExposureBias',                 // Exposure bias
        0x9205: 'MaxApertureValue',             // Smallest F number of lens
        0x9206: 'SubjectDistance',              // Distance to subject in meters
        0x9207: 'MeteringMode',                 // Metering mode
        0x9208: 'LightSource',                  // Kind of light source
        0x9209: 'Flash',                        // Flash status
        0x9214: 'SubjectArea',                  // Location and area of main subject
        0x920A: 'FocalLength',                  // Focal length of the lens in mm
        0xA20B: 'FlashEnergy',                  // Strobe energy in BCPS
        0xA20C: 'SpatialFrequencyResponse',
        0xA20E: 'FocalPlaneXResolution',        // Number of pixels in width direction per FPRUnit
        0xA20F: 'FocalPlaneYResolution',        // Number of pixels in height direction per FPRUnit
        0xA210: 'FocalPlaneResolutionUnit',     // Unit for measuring the focal plane resolution
        0xA214: 'SubjectLocation',              // Location of subject in image
        0xA215: 'ExposureIndex',                // Exposure index selected on camera
        0xA217: 'SensingMethod',                // Image sensor type
        0xA300: 'FileSource',                   // Image source (3 == DSC)
        0xA301: 'SceneType',                    // Scene type (1 == directly photographed)
        0xA302: 'CFAPattern',                   // Color filter array geometric pattern
        0xA401: 'CustomRendered',               // Special processing
        0xA402: 'ExposureMode',                 // Exposure mode
        0xA403: 'WhiteBalance',                 // 1 = auto white balance, 2 = manual
        0xA404: 'DigitalZoomRatio',             // Digital zoom ratio
        0xA405: 'FocalLengthIn35mmFilm',
        0xA406: 'SceneCaptureType',             // Type of scene
        0xA407: 'GainControl',                  // Degree of overall image gain adjustment
        0xA408: 'Contrast',                     // Direction of contrast processing applied by camera
        0xA409: 'Saturation',                   // Direction of saturation processing applied by camera
        0xA40A: 'Sharpness',                    // Direction of sharpness processing applied by camera
        0xA40B: 'DeviceSettingDescription',
        0xA40C: 'SubjectDistanceRange',         // Distance to subject
        0xA420: 'ImageUniqueID',                // Identifier assigned uniquely to each image
        0xA430: 'CameraOwnerName',
        0xA431: 'BodySerialNumber',
        0xA432: 'LensSpecification',
        0xA433: 'LensMake',
        0xA434: 'LensModel',
        0xA435: 'LensSerialNumber',
        // ==============
        // GPS Info tags:
        // ==============
        0x0000: 'GPSVersionID',
        0x0001: 'GPSLatitudeRef',
        0x0002: 'GPSLatitude',
        0x0003: 'GPSLongitudeRef',
        0x0004: 'GPSLongitude',
        0x0005: 'GPSAltitudeRef',
        0x0006: 'GPSAltitude',
        0x0007: 'GPSTimeStamp',
        0x0008: 'GPSSatellites',
        0x0009: 'GPSStatus',
        0x000A: 'GPSMeasureMode',
        0x000B: 'GPSDOP',
        0x000C: 'GPSSpeedRef',
        0x000D: 'GPSSpeed',
        0x000E: 'GPSTrackRef',
        0x000F: 'GPSTrack',
        0x0010: 'GPSImgDirectionRef',
        0x0011: 'GPSImgDirection',
        0x0012: 'GPSMapDatum',
        0x0013: 'GPSDestLatitudeRef',
        0x0014: 'GPSDestLatitude',
        0x0015: 'GPSDestLongitudeRef',
        0x0016: 'GPSDestLongitude',
        0x0017: 'GPSDestBearingRef',
        0x0018: 'GPSDestBearing',
        0x0019: 'GPSDestDistanceRef',
        0x001A: 'GPSDestDistance',
        0x001B: 'GPSProcessingMethod',
        0x001C: 'GPSAreaInformation',
        0x001D: 'GPSDateStamp',
        0x001E: 'GPSDifferential',
        0x001F: 'GPSHPositioningError'
    };

    loadImage.ExifMap.prototype.stringValues = {
        ExposureProgram: {
            0: 'Undefined',
            1: 'Manual',
            2: 'Normal program',
            3: 'Aperture priority',
            4: 'Shutter priority',
            5: 'Creative program',
            6: 'Action program',
            7: 'Portrait mode',
            8: 'Landscape mode'
        },
        MeteringMode: {
            0: 'Unknown',
            1: 'Average',
            2: 'CenterWeightedAverage',
            3: 'Spot',
            4: 'MultiSpot',
            5: 'Pattern',
            6: 'Partial',
            255: 'Other'
        },
        LightSource: {
            0: 'Unknown',
            1: 'Daylight',
            2: 'Fluorescent',
            3: 'Tungsten (incandescent light)',
            4: 'Flash',
            9: 'Fine weather',
            10: 'Cloudy weather',
            11: 'Shade',
            12: 'Daylight fluorescent (D 5700 - 7100K)',
            13: 'Day white fluorescent (N 4600 - 5400K)',
            14: 'Cool white fluorescent (W 3900 - 4500K)',
            15: 'White fluorescent (WW 3200 - 3700K)',
            17: 'Standard light A',
            18: 'Standard light B',
            19: 'Standard light C',
            20: 'D55',
            21: 'D65',
            22: 'D75',
            23: 'D50',
            24: 'ISO studio tungsten',
            255: 'Other'
        },
        Flash: {
            0x0000: 'Flash did not fire',
            0x0001: 'Flash fired',
            0x0005: 'Strobe return light not detected',
            0x0007: 'Strobe return light detected',
            0x0009: 'Flash fired, compulsory flash mode',
            0x000D: 'Flash fired, compulsory flash mode, return light not detected',
            0x000F: 'Flash fired, compulsory flash mode, return light detected',
            0x0010: 'Flash did not fire, compulsory flash mode',
            0x0018: 'Flash did not fire, auto mode',
            0x0019: 'Flash fired, auto mode',
            0x001D: 'Flash fired, auto mode, return light not detected',
            0x001F: 'Flash fired, auto mode, return light detected',
            0x0020: 'No flash function',
            0x0041: 'Flash fired, red-eye reduction mode',
            0x0045: 'Flash fired, red-eye reduction mode, return light not detected',
            0x0047: 'Flash fired, red-eye reduction mode, return light detected',
            0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',
            0x004D: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',
            0x004F: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',
            0x0059: 'Flash fired, auto mode, red-eye reduction mode',
            0x005D: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',
            0x005F: 'Flash fired, auto mode, return light detected, red-eye reduction mode'
        },
        SensingMethod: {
            1: 'Undefined',
            2: 'One-chip color area sensor',
            3: 'Two-chip color area sensor',
            4: 'Three-chip color area sensor',
            5: 'Color sequential area sensor',
            7: 'Trilinear sensor',
            8: 'Color sequential linear sensor'
        },
        SceneCaptureType: {
            0: 'Standard',
            1: 'Landscape',
            2: 'Portrait',
            3: 'Night scene'
        },
        SceneType: {
            1: 'Directly photographed'
        },
        CustomRendered: {
            0: 'Normal process',
            1: 'Custom process'
        },
        WhiteBalance: {
            0: 'Auto white balance',
            1: 'Manual white balance'
        },
        GainControl: {
            0: 'None',
            1: 'Low gain up',
            2: 'High gain up',
            3: 'Low gain down',
            4: 'High gain down'
        },
        Contrast: {
            0: 'Normal',
            1: 'Soft',
            2: 'Hard'
        },
        Saturation: {
            0: 'Normal',
            1: 'Low saturation',
            2: 'High saturation'
        },
        Sharpness: {
            0: 'Normal',
            1: 'Soft',
            2: 'Hard'
        },
        SubjectDistanceRange: {
            0: 'Unknown',
            1: 'Macro',
            2: 'Close view',
            3: 'Distant view'
        },
        FileSource: {
            3: 'DSC'
        },
        ComponentsConfiguration: {
            0: '',
            1: 'Y',
            2: 'Cb',
            3: 'Cr',
            4: 'R',
            5: 'G',
            6: 'B'
        },
        Orientation: {
            1: 'top-left',
            2: 'top-right',
            3: 'bottom-right',
            4: 'bottom-left',
            5: 'left-top',
            6: 'right-top',
            7: 'right-bottom',
            8: 'left-bottom'
        }
    };

    loadImage.ExifMap.prototype.getText = function (id) {
        var value = this.get(id);
        switch (id) {
        case 'LightSource':
        case 'Flash':
        case 'MeteringMode':
        case 'ExposureProgram':
        case 'SensingMethod':
        case 'SceneCaptureType':
        case 'SceneType':
        case 'CustomRendered':
        case 'WhiteBalance':
        case 'GainControl':
        case 'Contrast':
        case 'Saturation':
        case 'Sharpness':
        case 'SubjectDistanceRange':
        case 'FileSource':
        case 'Orientation':
            return this.stringValues[id][value];
        case 'ExifVersion':
        case 'FlashpixVersion':
            return String.fromCharCode(value[0], value[1], value[2], value[3]);
        case 'ComponentsConfiguration':
            return this.stringValues[id][value[0]] +
                this.stringValues[id][value[1]] +
                this.stringValues[id][value[2]] +
                this.stringValues[id][value[3]];
        case 'GPSVersionID':
            return value[0] + '.' + value[1]  + '.' + value[2]  + '.' + value[3];
        }
        return String(value);
    };

    (function (exifMapPrototype) {
        var tags = exifMapPrototype.tags,
            map = exifMapPrototype.map,
            prop;

        // Map the tag names to tags:
        for (prop in tags) {
            if (tags.hasOwnProperty(prop)) {
                map[tags[prop]] = prop;
            }
        }
    }(loadImage.ExifMap.prototype));

    loadImage.ExifMap.prototype.getAll = function () {
        var map = {},
            prop,
            id;
        for (prop in this) {
            if (this.hasOwnProperty(prop)) {
                id = this.tags[prop];
                if (id) {
                    map[id] = this.getText(id);
                }
            }
        }
        return map;
    };

}));

define('loadImage',['require','vendor/load-image/load-image-orientation','vendor/load-image/load-image-meta','vendor/load-image/load-image-ios','vendor/load-image/load-image-exif','vendor/load-image/load-image-exif-map','vendor/load-image/load-image'],function (require) {
  require('vendor/load-image/load-image-orientation');
  require('vendor/load-image/load-image-meta');
  require('vendor/load-image/load-image-ios');
  require('vendor/load-image/load-image-exif');
  require('vendor/load-image/load-image-exif-map');
  var loadImage = require('vendor/load-image/load-image');

  return loadImage;
});
define('expressions/add_expression',['require','loadcss!css/add_expression','jquery','pjs','main/popover_view','graphing/label','template!add_expression','./expression','./table','./text','./folder','./image','browser','i18n','loadImage','conditional_blur'],function(require){
  require('loadcss!css/add_expression');

  var $ = require('jquery');
  var P = require('pjs');
  var PopoverView = require('main/popover_view');
  var Label = require('graphing/label');
  var template = require('template!add_expression');
  var ExpressionObject = require('./expression');
  var TableObject = require('./table');
  var TextObject = require('./text');
  var FolderObject = require('./folder');
  var ImageObject = require('./image');
  var Browser = require('browser');
  var i18n = require('i18n');
  var LoadImage = require('loadImage');
  var conditionalBlur = require('conditional_blur');

  var UPLOAD_SUPPORTED = !!window.FileReader;
  var isShittyIos8 = (
    Browser.IS_IPAD &&
    Browser.IOS_VERSION &&
    Browser.IOS_VERSION[0] === 8 &&
    Browser.IOS_VERSION[1] === 0 &&
    Browser.IOS_VERSION[2] === 0
  );
  var AddExpressionView = P(PopoverView, function(view, _super){

    view.template = template;
    view.direction = 'bottom';

    view.init = function (listView, $root, graphSettings, toastView) {
      _super.init.call(this);

      this.$root = $root;
      this.listView = listView;
      this.list = listView.model;
      this.graphSettings = graphSettings;
      this.toastView = toastView;
    };

    view.getTemplateParams = function(){
      var params = _super.getTemplateParams();

      params.expressions = true;
      params.texts = true;
      params.tables = true;
      params.folders = this.graphSettings.config.folders;
      params.images = this.graphSettings.config.images;

      return params;
    };

    view.didCreateElement = function () {
      _super.didCreateElement.call(this);

      if (Browser.IS_IPAD && Browser.IS_IN_IFRAME) {
        // prevents mobile safari from getting into a bad
        // state where the next tap on the screen defocuses
        // whatever is selected.
        // see #3106
        this.$().on('tapstart', function (evt) {
          evt.preventDefault();
        });
      }

      this.$('.dcg-action-newexpression').on('tap', this.newExpression.bind(this));
      this.$('.dcg-action-newtext').on('tap', this.newText.bind(this));
      this.$('.dcg-action-newfolder').on('tap', this.newFolder.bind(this));
      this.$('.dcg-action-newtable').on('tap', this.newTableFromTap.bind(this));
      this.$('.dcg-action-newimage').on('tap', this.selectImage.bind(this));

      if (UPLOAD_SUPPORTED && !isShittyIos8) {
        this.initFilePicker();
      }

      // prevent dropping file from changing url. Also enables the drop event.
      $(document).on('dragstart drag dragend dragenter dragover dragleave drop', function (evt) {
        evt.preventDefault();
        evt.stopPropagation();
      });

      var $root = this.$root;

      var collection = $();
      function removeFileDraggedClass () {
        $root.removeClass('dcg-filedraggedover');
        collection = $();
        $root.off('.filedraggedover');
      }

      $root.on('dragenter', function (evt) {
        if (collection.size() === 0) {
          $root.addClass('dcg-filedraggedover');
          $root.on('tapstart.filedraggedover', removeFileDraggedClass);
        }
        collection = collection.add(evt.target);
      }).on('dragleave', function (evt) {
          collection = collection.not(evt.target);
          if (collection.size() === 0) {
            removeFileDraggedClass();
          }
      }).on('drop', removeFileDraggedClass);

      var self = this;
      this.listView.$().on('drop', function (evt) {
        var files = evt.originalEvent.dataTransfer && evt.originalEvent.dataTransfer.files;
        if (files) {
          for (var i=0; i<files.length; i++) {
            self.insertFile(files[i]);
          }
        }
      });
    };

    view.insertFile = function (file) {
      if (!file) {
        alert(i18n.t('You did not select a file'));
        return;
      }

      if (!file.type.match('image/*')) {
        alert(i18n.t('The file "__file__" is not an image', {file: file.name}));
        return;
      }

      var imageObject = ImageObject({
        originalFilename: file.name,
        name: file.name,
        image_url: null,
        visible: true,
        selected: true,
        width: '0',
        height: '0',
        x: '0',
        y: '0',
        opacity: 1,
        isUploading: true
      }, this.list);

      this.newImage(imageObject);

      LoadImage.parseMetaData(file, function (data) {

        var orientation;
        if (data.exif) {
          orientation = data.exif.get('Orientation');
        }

        var loadImageOptions = {
          orientation: orientation,
          canvas: true,
          maxWidth: 2000,
          maxHeight: 2000
        };

        LoadImage(file, function (canvas) {
          var width = canvas.width;
          var height = canvas.height;
          var ratio = Math.max(width, height) / Math.min(width, height);
          var maxFileSize = 50000;

          if (width < height) {
            height = 10;
            width = Math.round(10 * height / ratio) / 10;
          } else {
            width = 10;
            height = Math.round(10 * width / ratio) / 10;
          }

          // if it's a jpeg, kick in a little compression from the start. Prevents 1MB images from growing to 7MB
          // simply because of a difference in compression algorithms.
          var compressedDataURL;
          if (file.type === 'image/jpeg') {
            compressedDataURL = canvas.toDataURL('image/jpeg', 0.99);
          } else {
            compressedDataURL = canvas.toDataURL();
          }

          // if the file is too big, we scale the image down in width and height to scale the file size.
          // simply dropping the resolution of the image should do a pretty good job of dropping our
          // image size down. we allow three rounds of compression to hone in on a file that's just under
          // the maxFileSize.  The first attempt usually gets us within 2*maxFileSize. The second attempt
          // usually gets us to within 1.1*maxFileSize. I haven't found an image that the third attempt
          // doesn't get us right under the maxFileSize.
          var compressionAttempts = 0;
          var fileSize = compressedDataURL.length;

          while (compressionAttempts < 3 && fileSize > maxFileSize) {
            var scaleFactor = Math.sqrt(maxFileSize/fileSize);
            var scaledWidth = Math.round(scaleFactor * canvas.width);
            var scaledHeight = Math.round(scaleFactor * canvas.height);

            var scaledCanvas = $('<canvas width="'+ scaledWidth +'" height="'+ scaledHeight +'" ></canvas>')[0];
            var ctx = scaledCanvas.getContext('2d');
            ctx.drawImage(canvas, 0, 0, scaledWidth, scaledHeight);

            if (file.type === 'image/jpeg') {
              compressedDataURL = scaledCanvas.toDataURL('image/jpeg', 0.99);
            } else {
              compressedDataURL = scaledCanvas.toDataURL();
            }

            fileSize = compressedDataURL.length;
            canvas = scaledCanvas;
            scaledCanvas = null;
            compressionAttempts++;
          }


          // finalize image data
          imageObject.setProperty('width', width.toString());
          imageObject.setProperty('height', height.toString());
          imageObject.setProperty('image_url', compressedDataURL);
          imageObject.setProperty('isUploading', false);

        }, loadImageOptions);
      },
      {
        maxMetaDataSize: 262144,
        disableImageHead: false
      });
    };

    view.renderIsVisible = function () {
      if (this.isVisible) {
        if (this.direction === 'bottom' && this.listView.calcIsNarrow) {
          this.direction = 'right';
          this.$().addClass('dcg-right').removeClass('dcg-bottom');
        } else if (this.direction !== 'bottom' && !this.listView.calcIsNarrow) {
          this.direction = 'bottom';
          this.$().addClass('dcg-bottom').removeClass('dcg-right');
        }
      }
      _super.renderIsVisible.call(this);
    };

    view.initFilePicker = function () {
      var self = this;

      // create the filepicker
      this.$filepicker = this.$('input[type=file]');

      this.$filepicker.on('change', function (evt) {
        self.setProperty('isVisible', false);
        self.insertFile(evt.target.files[0]);
        self.$filepicker.val(''); // clear out selected file so we can reselect the file
      });
    };

    view.newExpression = function() {
      this.insertItem(ExpressionObject({selected: true, latex: ''}, this.list));
    };

    view.newText = function() {
      this.insertItem(TextObject({selected: true, text: ''}, this.list));
    };

    view.newFolder = function () {
      this.insertItem(FolderObject({selected: true}, this.list));
    };

    //filter through so that we're not mixing data & jQuery events
    view.newTableFromTap = function (e) {
      this.newTable();
    };

    view.newTable = function(data) {
      var properties = {selected: !data, latex:''};

      // Choose an unused subscript for table entries
      var subscripts = [];
      this.list.eachLatex(function (latex) {
        var subscriptRe = new RegExp(/_(\d)|_\{(?:\s|\\space)(\d+)(?:\s|\\space)\}/g);
        while (true) {
          var match = subscriptRe.exec(latex);
          if (!match) break;
          subscripts.push(parseInt(match[1], 10));
        }
      });
      subscripts.sort(function (a, b) { return a - b; });

      var subscript = 1;
      for (var i = 0; i < subscripts.length; i++) {
        if (subscripts[i] === subscript) subscript++;
      }

      //TODO: support pasting in tables with more than 2 columns? It's supported by parse_data
      //what should we choose for headers?
      properties.columns = [
        {
          latex: Label.identifierToLatex('x_' + subscript),
          values:(data ? data[0] : [1, 2, 3, 4, 5])
        },
        {
          latex: Label.identifierToLatex('y_' + subscript),
          values:(data ? data[1] : ['','','','',''])
        }
      ];

      // create a new expression and populate it
      var obj = TableObject(properties, this.list);
      this.insertItem(obj);
      if (!data) {
        this.listView.getSelectedView().addFocus('cell', 1, 1);
      }
    };

    view.selectImage = function () {
      conditionalBlur();

      if (isShittyIos8) {
        this.toastView.show(
          "iOS 8.0 has temporarily broken image upload. So sorry!",
          {hideAfter: 10000}
        );
        this.$('.dcg-action-newimage').addClass('dcg-disabled');
      } else if (UPLOAD_SUPPORTED) {
        this.$filepicker[0].click();
      } else {
        this.toastView.show(
          i18n.t("Image upload is not supported in this browser."),
          {hideAfter: 10000}
        );
        this.$('.dcg-action-newimage').addClass('dcg-disabled');
      }
    };

    view.newImage = function(imageObject) {
      var self = this;
      var list = this.list;

      list.undoRedo.oneTransaction(function(){
        self.insertItem(imageObject);
      });
    };

    //rules for insertItem (the + button at the top)
    //
    // overarching:
    //  (1) pressing that button should always have a visible result (i.e. never a no-op)
    //  (2) a folder can never be inserted inside of another folder
    //  (3) if an item's is a blank expression convert instead of creating a new one (unless that violates #1 or #2)
    //      (unless that violates 1 or 2)
    //  (4) insert below current expression where that's possible (below the folder where necessary)
    //  (5) insert at the highest visible point that's not in a folder

    view.insertItem = function(obj){
      /* jshint maxcomplexity:15 */

      // close the popover
      this.setProperty('isVisible', false);

      //collect up some useful globals
      var list = this.list;
      var item = list.getSelected();

      //case 1: current empty expression needs to be replaced and is outside a folder
      //  only applies if:
      //  item.isExpression and item is empty
      //  obj is not an expression

      if (item && item.isExpression && !item.latex && !item.folder && !obj.isExpression) {

        list.undoRedo.oneTransaction(function () {
          list.insertItemAt(item.index + 1, obj);
          list.removeItemAt(item.index);
        });

        if (obj.selected) this.listView.getSelectedView().addFocus();
        return;
      }

      //case 2: current empty expression needs to be replaced and is inside a folder
      // only applies if:
      // item.isExpression and item is empty
      // obj is not an expression, obj is not a folder

      if (item && item.isExpression && !item.latex && item.folder && !obj.isExpression && !obj.isFolder) {
        list.undoRedo.oneTransaction(function () {
          list.insertItemAt(item.index + 1, obj);
          item.folder.addItem(obj);
          list.removeItemAt(item.index);
        });
        if (obj.selected) this.listView.getSelectedView().addFocus();
        return;
      }

      //case 3: current is outside of a folder: insert right below where we are,
      // no funny business
      if (item && !item.folder && !item.isFolder) {
        this.list.insertItemAt(item.index + 1, obj);
        if (obj.selected) this.listView.getSelectedView().addFocus();
        return;
      }

      //case 4: current item is inside a folder, and we're not inserting a new folder
      // insert right below us, but inside of the folder
      if (item && item.folder && !obj.isFolder) {

        list.undoRedo.oneTransaction(function () {
          list.insertItemAt(item.index + 1, obj);
          item.folder.addItem(obj);
        });
        if (obj.selected) this.listView.getSelectedView().addFocus();
        return;
      }

      //case 5: insert into an existing folder
      if (item && item.isFolder && !item.collapsed && !obj.isFolder) {
        list.undoRedo.oneTransaction(function () {
          list.insertItemAt(item.index + 1, obj);
          item.addItem(obj);
        });
        if (obj.selected) this.listView.getSelectedView().addFocus();
        return;
      }

      //case 5: we need to seek downward from here and insert when we're ready.
      //this is either because nothing is selected, or because we're a folder
      //inside of a folder. in either case, seek downward until the first chance
      //that we have that's not inside of a folder.

      if (!item) item = this.listView.getFirstVisibleItem();
      // can't insert a folder right after the starting folder
      //(fixes problem if you try to insert a folder while in a folder)
      if (item.isFolder) item = this.list.getItemByIndex(item.index + 1);
      //after this, we search for the first non-foldered item, and insert right before it.
      while(item && item.folder) {
        item = this.list.getItemByIndex(item.index + 1);
      }

      var index = (item ? item.index : this.list.getItemCount());
      this.list.insertItemAt(index, obj);
      if (obj.selected) this.listView.getSelectedView().addFocus();
    };

  });

  return AddExpressionView;
});

define('scroll_helpers',['require'],function (require) {
  //this ensures that innerEl is visible inside of outerEl by scrolling outerEl
  //padding is the space we want to enforce on either side, if available
  //
  //note: innerEl and outerEl are expected to be jQuery objects.
  var scrollVisible = function(innerEl, outerEl, padding) {
    var outerHeight = outerEl.height();
    var innerHeight = innerEl.height();

    var scrollTop = outerEl[0].scrollTop;
    //innerTop relative to the container (compensate for scroll and offset of container)
    var innerTop = innerEl.offset().top + scrollTop - outerEl.offset().top;

    // {padding}px from the top means innerTop - scrollTop = padding
    var maxScrollTop = innerTop - padding;
    // {padding}px from the bottom means outerHeight+scrollTop = innerHeight + innerTop + padding
    var minScrollTop = innerHeight + innerTop + padding - outerHeight;

    if (maxScrollTop >= minScrollTop) {
      //clamp value between the max and min scrollTop
      outerEl[0].scrollTop = Math.min(Math.max(scrollTop, minScrollTop), maxScrollTop);
    } else {
      //if we can't fit everything, just match padding on both sides by splitting the difference
      outerEl[0].scrollTop = 0.5*(maxScrollTop + minScrollTop);
    }
  };

  return {scrollVisible: scrollVisible};
});

define('loadcss!css/new_expression', function(){});
define('template!new_expression', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="dcg-expressionitem dcg-new-expression dcg-opened">\n  <div class=\'dcg-new-math-div dcg-do-not-blur dcg-action-newmath\'>\n    <div class=\'dcg-new-expression-fade\'></div>\n  </div>\n\n  <span\n     class="dcg-tab"\n  >\n     <span class=\'dcg-num dcg-variable-index\'>2</span>\n     <div class=\'dcg-tab-interior\'></div>\n  </span>\n\n</div>\n';
}
return __p;
};});
define('expressions/new_expression',['require','loadcss!css/new_expression','pjs','underscore_view','template!new_expression','./expression'],function(require){
  require('loadcss!css/new_expression');

  var P = require('pjs');
  var UnderscoreView = require('underscore_view');
  var template = require('template!new_expression');
  var ExpressionObject = require('./expression');

  var NewExpressionView = P(UnderscoreView, function(view, _super){

    view.template = template;

    view.init = function (listView) {
      _super.init.call(this);
      this.observe('index', this.updateIndex.bind(this));
      this.listView = listView;
    };

    view.didInsertElement = function() {
      // update the index now and observe any changes
      this.updateIndex();

      this.$('.dcg-action-newmath').on('tap', this.newMath.bind(this));
    };

    view.updateIndex = function () {
      this.$('.dcg-variable-index').text(this.index);
    };

    view.newMath = function() {
      var constructor = ExpressionObject;
      var properties = {selected:true, latex:''};
      var obj = constructor(properties, this.listView.model);
      this.listView.model.insertItemAt(this.listView.model.getItemCount(), obj);
      this.listView.getSelectedView().addFocus();
    };

  });

  return NewExpressionView;
});

define('expressions/abstract_icon',['require','jquery','underscore_view','pjs','keys','i18n'],function(require){
  var $ = require('jquery');
  var UnderscoreView = require('underscore_view');
  var P = require('pjs');
  var Keys = require('keys');
  var i18n = require('i18n');

  var icon_count = 0;

  var AbstractIconView = P(UnderscoreView, function (view, _super) {

    view.init = function (parentView) {
      this.parentView = parentView;
      this.model = parentView.model;

      _super.init.call(this);
      this.optionsmenu_guid = (++icon_count);

      // model.error is a message; this.error is boolean whether we care about
      // the error. One time we don't care is if the model is empty.
      this.model.observe('error.iconview', this.renderErrorTooltip.bind(this));
      this.observe('error', this.renderErrorTooltip.bind(this));

      this.observe('error errorStable', this.computeErrorShown.bind(this));
      this.observe('errorShown', this.renderErrorShown.bind(this));
    };

    view.destruct = function () {
      this.model.unobserve('.iconview');
    };

    view.computeErrorShown = function () {
      this.setProperty('errorShown', this.error && this.errorStable);
    };

    view.renderErrorTooltip = function () {
      var error = this.error ? i18n.unpack(this.model.error) : '';
      this.$().closest('.dcg-variable-errortooltip').attr('tooltip', error);
    };

    view.renderErrorShown = function () {
      this.$().toggleClass('dcg-error', !!this.errorShown);
    };

    view.didInsertElement = function () {
      this.renderErrorShown();
      this.renderErrorTooltip();
    };

    // defined in subclass
    view.createOptionsMenuView = function () {};

    view.toggleOptions = function() {
      if (this.error) {
        this.hideOptions();
        return;
      }
      if (this.optionsShown) {
        this.hideOptions();
        return;
      }

      this.optionsShown = true;

      // Add options menu to .dcg-main. workaround bug with "-webkit-scrolling-overflow: touch" and child "position:
      // relative" elements not respecting z-index
      // see: "-webkit-overflow-scrolling: touch is messing up z-index stacking"
      // [http://code.google.com/p/chromium/issues/detail?id=128325]
      this.optionsMenu = this.createOptionsMenuView(); //defined in subclass

      var id = this.optionsmenu_guid;

      // ipad sends out a scroll event when you tapstart on the button that
      // opens the context menu. We want that first scroll event to be
      // ignored, so we add the listener after a slight timeout to give the
      // first scroll event time to pass through.
      setTimeout(function(){
        //make sure options menu hasn't closed before the timeout fires
        if (this.optionsShown) {
          this.getListView$().on("scroll.options-menu-" + id, function(evt) {
            this.hideOptions();
          }.bind(this));
        }
      }.bind(this), 0);

      $(document).on("keydown.options-menu-" + id, function (e) {
        if (Keys.lookup(e) === Keys.ESCAPE) {
          this.hideOptions();
        }
      }.bind(this));

      $(document).on("tapstart.options-menu-" + id, function (e) {

        // close this unless:
        // * we click on the icon again (will handle that separately)
        // * we click insde the context-menu (that's been moved to the body)

        // we click inside the context menu (but not on the "close" button)
        if ($(e.target).closest('.dcg-options-menu').length) return;

        // we click within this view again
        if ( $(e.target).closest(this.$()).length) return;

        this.hideOptions();

      }.bind(this));
    };

    view.getListView$ = function () {
      return this.$().closest('.dcg-tap-container').find('.dcg-exppanel');
    };

    view.hideOptions = function() {
      if (!this.optionsShown && !this.optionsMenu) return;
      this.optionsShown = false;

      var id = this.optionsmenu_guid;
      $(document).off("tapstart.options-menu-" + id);
      $(document).off("keydown.options-menu-" + id);
      this.getListView$().off("scroll.options-menu-" + id);

      if (this.optionsMenu) {
        this.optionsMenu.remove();
        this.optionsMenu = null;
      }
    },

    view.onDisplayChange = function () {
      var error = this.model.error ? true : false;
      if (this.model.isEmpty()) error = false;

      //next sequence of code will only add the errorStable property
      //if the error value hasn't changed within the last 500ms
      if (error !== this.error) {
        this.setProperty('errorStable',false);
        this.__errorTime = new Date().getTime();
        setTimeout(this.onDisplayChange.bind(this), 100);
      } else if (this.__errorTime + 500 < new Date().getTime()) {
        this.setProperty('errorStable', true);
      } else if (!this.errorStable) {
        setTimeout(this.onDisplayChange.bind(this), 100);
      }

      this.setProperty('error', error);
    };

  });

  return AbstractIconView;
});
define('template!expression_options_menu', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class=\'dcg-exp-options-menu dcg-options-menu ';
 if (styles.length === 0) {
;__p+='dcg-colors-only';
 }
;__p+='\'>\n  <div class=\'dcg-triangle\'></div>\n  ';
 if (styles.length > 0) {
;__p+='\n    <div class=\'dcg-styles-div\'>\n      <div class=\'dcg-styles-menu\'>\n        <div class=\'dcg-title\'>style:</div>\n        <div class=\'dcg-styles-menu\'>\n        ';
 _.each(styles, function (style) {
;__p+='\n          <span class="dcg-style-option dcg-graph-icon dcg-graph-'+
( style )+
'"\n            draw-style="'+
( style )+
'"\n            style=""\n            handleevent="true">\n          </span>\n        ';
 })
;__p+='\n        </div>\n      </div>\n    </div>\n  ';
 }
;__p+='\n  <div class=\'dcg-colors-div\'>\n    <div class=\'dcg-title\'>color:</div>\n    <div class="template-colorsview"></div>\n  </div>\n</div>\n';
}
return __p;
};});
define('loadcss!css/color_menu', function(){});
define('template!color_menu', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="dcg-color-menu dcg-do-not-blur">\n  ';
 _.each(colors, function (color) {
;__p+='\n    <span class="dcg-color-option"\n          color="'+
( color )+
'"\n          style="background: '+
( color )+
'"\n          handleevent="true">\n          <i class=\'dcg-icon-check\'></i>\n    </span>\n  ';
 })
;__p+='\n</div>';
}
return __p;
};});
define('expressions/color_menu_view',['require','loadcss!css/color_menu','jquery','pjs','underscore_view','./colors','template!color_menu'],function(require){
  require('loadcss!css/color_menu');

  var $ = require('jquery');
  var P = require('pjs');
  var UnderscoreView = require('underscore_view');
  var Colors = require('./colors');

  var template = require('template!color_menu');

  var ExpressionColorsView = P(UnderscoreView, function (view, _super) {
    view.template = template,

    view.init = function (expression) {
      _super.init.call(this);
      this.expression = expression;
      this.expression.observe('color.colorview', this.renderSelectedColor.bind(this));
      this.expression.observe('hidden.colorview', this.renderSelectedColor.bind(this));
    };

    view.destruct = function () {
      this.expression.unobserve('.colorview');
    };

    view.renderSelectedColor = function () {
      var color = this.expression.color;
      this.$('.dcg-color-option').removeClass('dcg-selected');
      this.$('.dcg-color-option[color="'+color+'"]').addClass('dcg-selected');
    };

    view.didInsertElement = function () {
      this.$().on('tap tapstart', '.dcg-color-option', this.onSelectColor.bind(this));
      this.renderSelectedColor();
    };

    view.getTemplateParams = function () {
      return {
        colors: Colors.all
      };
    };

    view.onSelectColor = function (evt) {
      // when using mouse, fire on 'tapStart' and when on touch we
      // fire on the 'tap' event.
      if (evt.type === 'tap' && evt.device === 'mouse') return;
      if (evt.type === 'tapstart' && evt.device === 'touch') return;
      var color = $(evt.target).closest('.dcg-color-option').attr('color');
      this.expression.setProperty('color', color);

      //show expression (and its folder) if it was hidden
      this.expression.setProperty('hidden', false);
      if (this.expression.folder) this.expression.folder.setProperty('hidden', false);
    };

  });

  return ExpressionColorsView;
});

define('expressions/expression_options_view',['require','pjs','jquery','underscore','underscore_view','template!expression_options_menu','./colors','./color_menu_view'],function(require){
  var P = require('pjs');
  var $ = require('jquery');
  var _ = require('underscore');
  var UnderscoreView = require('underscore_view');
  var template = require('template!expression_options_menu');
  var Colors = require('./colors');
  var ColorMenuView = require('./color_menu_view');

  var ExpressionOptionsMenuView = P(UnderscoreView, function (view, _super) {
    view.template = template;

    view.init = function (expression) {
      this.expression = expression;
      this.expression.observe('color.colorview', this.renderSelectedColor.bind(this));
      this.expression.observe('hidden style shouldGraph', this.renderSelectedStyle.bind(this));
    };

    view.destruct = function () {
      if (this.colorsView) {
        this.colorsView.remove();
        this.colorsView = null;
      }
    };

    view.getTemplateParams = function () {
      var params = {colors: Colors.all, styles: []};
      if (this.expression.formula.is_point_list && !this.expression.formula.move_ids) {
        params.styles = ['point', 'open'];
      } else if (!this.expression.table && !this.expression.formula.move_ids) {
        if (!this.expression.formula.is_inequality) {
          params.styles = ['normal', 'dashed'];
        }
      }
      return params;
    };

    view.renderSelectedColor = function () {
      var color = this.expression.color;
      _.each(this.$('.dcg-style-option'), function (option) {
        $(option).css('background', color);
      });
    };

    view.onSelectStyle = function (evt) {
      // when using mouse, fire on 'tapStart' and when on touch we
      // fire on the 'tap' event.
      if (evt.type === 'tap' && evt.device === 'mouse') return;
      if (evt.type === 'tapstart' && evt.device === 'touch') return;

      var style = $(evt.target).closest('.dcg-style-option').attr('draw-style');
      this.expression.setProperty('hidden', false);
      this.expression.setProperty('style', style);

      //if we're in a folder, show it.
      if (this.expression.folder) this.expression.folder.setProperty('hidden', false);
    };

    view.renderSelectedStyle = function () {
      var style = this.expression.style;
      this.$('.dcg-style-option').removeClass('dcg-selected');
      if (this.expression.shouldGraph) {
        this.$('.dcg-style-option[draw-style="'+style+'"]').addClass('dcg-selected');
      }
    };

    view.didInsertElement = function () {
      // this view has a nested template. We instantiate the color picker
      // and replace a placeholder element within the html.
      this.colorsView = ColorMenuView(this.expression);
      this.colorsView.replace(this.$('.template-colorsview'));
      this.$().on('tap tapstart', '.dcg-style-option', this.onSelectStyle.bind(this));
      this.renderSelectedColor();
      this.renderSelectedStyle();
    };

  });

  return ExpressionOptionsMenuView;
});
define('template!expression_icon', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<span class="dcg-icon dcg-graph-icon dcg-variable-colorcss dcg-variable-errortooltip tipsy-sticky">\n\t<i class=\'dcg-icon-play\'></i>\n\t<i class=\'dcg-icon-pause\'></i>\n\t<i class=\'dcg-icon-hidden\'></i>\n</span>\n';
}
return __p;
};});
define('expressions/expression_icon_view',['require','pjs','expressions/abstract_icon','./expression_options_view','math/comparators','template!expression_icon','jquery.handleevent'],function(require){
  var P = require('pjs');
  var AbstractIconView = require('expressions/abstract_icon');
  var ExpressionOptionsMenuView = require('./expression_options_view');
  var Comparators = require('math/comparators');
  var template = require('template!expression_icon');
  require('jquery.handleevent');

  var ExpressionIconView = P(AbstractIconView, function (view, _super) {
    view.template = template;

    view.init = function (parentView) {
      _super.init.call(this, parentView);
      this.expression = this.model;

      // wait for the slider to be created. Then observe the isPlaying property on it
      this.expression.observe('slider.iconview', function () {
        this.expression.slider.observe('isPlaying.iconview', this.onDisplayChange.bind(this));
      }.bind(this));

      this.expression.observe('formula.iconview', this.onDisplayChange.bind(this));
      this.expression.observe('shouldGraph.iconview', this.onDisplayChange.bind(this));
      this.expression.observe('isGraphable.iconview', this.renderUngraphable.bind(this));
      this.expression.observe('loading.iconview', this.renderLoading.bind(this));
      this.expression.observe('color.iconview', this.renderColorCSS.bind(this));
      this.expression.observe('style.iconview', this.onDisplayChange.bind(this));

      this.parentView.observeEvent('hideContextMenu.iconview', this.hideOptions.bind(this));
    };

    view.destruct = function () {
      _super.destruct.call(this);

      this.expression.unobserve('.iconview');
      if (this.expression.slider) {
        this.expression.slider.unobserve('.iconview');
      }

      this.parentView.unobserve('.iconview');
    };

    view.renderUngraphable = function () {
      this.$().toggleClass('dcg-ungraphable', !this.expression.isGraphable);
    };

    view.renderLoading = function () {
      this.$().toggleClass('dcg-loading', !!this.expression.loading);
    };

    view.renderColorCSS = function() {
      this.$('.dcg-variable-colorcss').css({
        'border-color' : this.expression.color,
        'background' : this.expression.color
      });
    };

    view.didInsertElement = function () {
      var self = this;
      _super.didInsertElement.call(this);

      this.renderLoading();
      this.renderUngraphable();
      this.renderColorCSS();
      this.onDisplayChange();

      this.$icon = this.$('.dcg-icon');

      var handleIconTapped = function(evt, device){
        if(evt.wasHandled('dragdrop')) return; //Don't toggle if we were handled by dragdrop
        if(evt.wasLongheld()) return;
        if(evt.device !== device) return;

        if (self.optionsShown) {
          self.toggleOptions();
          return false;
        }

        if (self.parentView.listView.editListMode) {
          if (self.expression.isGraphable) {
            self.toggleOptions();
          }
        } else if (self.expression.formula.is_animatable) {
          self.toggleSliderIsPlaying();
        } else {
          self.toggleGraphShown();
        }
      };

      var handleIconLongHold = function(evt, device) {
        if(evt.device !== device) return;
        if (!self.model.isGraphable) return;

        evt.handle('longhold');
        self.toggleOptions();
      };

      this.$().closest('.dcg-action-icon-mouse').on('tap', function(evt){
        handleIconTapped(evt, 'mouse');
      });

      this.$().closest('.dcg-action-icon-touch').on('tap', function(evt){
        handleIconTapped(evt, 'touch');
      });

      this.$().closest('.dcg-action-icon-mouse').on('longhold', function(evt){
        handleIconLongHold(evt, 'mouse');
      });

      this.$().closest('.dcg-action-icon-touch').on('longhold', function(evt){
        handleIconLongHold(evt, 'touch');
      });
    };

    view.isGraphShown = function () {
      return this.expression.shouldGraph;
    };

    view.toggleSliderIsPlaying = function () {
      var slider = this.expression.slider;
      if (slider) {
        slider.setProperty('isPlaying', !slider.isPlaying);
      }
    };

    view.toggleGraphShown = function() {
      if (!this.model.isGraphable) return;
      if (this.errorShown) return;

      //note: if this expression is in a hidden folder this line will always fire, since
      //isGraphShown will be false. It'll be a no-op if the graph was shown when
      //the folder was hidden. That doesn't matter, because later on we turn on the folder
      //which will recalculate isGraphShown, so we'll recompute the icon anyway
      this.expression.setProperty('hidden', this.isGraphShown());

      //always show the folder if we're inside one
      if (this.expression.folder) this.expression.folder.setProperty('hidden', false);
    };

    view.createOptionsMenuView = function () {
      var listView = this.parentView.listView;
      var optionsView = ExpressionOptionsMenuView(this.expression);
      optionsView.appendTo(listView.$());

      // putting the ExpressionOptionsView at the topLeft of the .dcg-icon
      // it's up to the ExpressionOptionsView's css to position it beyond that
      var placeholder = this.$('.dcg-icon');
      var placeholderOffset = placeholder.offset();
      var listViewOffset = listView.$().offset();
      optionsView.$().css({
        position: 'absolute',
        top: placeholderOffset.top - listViewOffset.top + 'px',
        left: placeholderOffset.left - listViewOffset.left + 'px',
        display: 'block' //wait until we know where it is to show it. fixes #3154
      });
      return optionsView;
    };

    view.onDisplayChange = function () {
      /* jshint maxcomplexity:20 */
      _super.onDisplayChange.call(this);
      if (!this.$icon) return;

      var formula = this.expression.formula;
      var icon_class = '';

      if (formula.is_animatable) {
        if (this.expression.slider.isPlaying) {
          icon_class = 'dcg-animate-pause';
        } else {
          icon_class = 'dcg-animate-play';
        }
      } else if (this.error || !formula.is_graphable) {
        icon_class = '';
      } else {

        var shouldGraph = this.expression.shouldGraph;
        var style = this.expression.style;
        var operator = formula.operator;
        var shaded = Comparators.table[operator].direction !== 0;
        var dotted = Comparators.table[operator].inclusive === false;
        if (!shouldGraph) {
          icon_class = 'dcg-graph-hidden';
        } else if (formula.move_ids) {
          icon_class = 'dcg-graph-movable-point';
        } else if (formula.is_point_list) {
          if (style === 'open') {
            icon_class = 'dcg-graph-open';
          } else if (style === 'cross') {
            icon_class = 'dcg-graph-cross';
          } else {
            icon_class = 'dcg-graph-point';
          }
        } else if (formula.is_shade_between) {
          // TODO - missing icon for this
          icon_class = 'dcg-graph-shaded-inequality';
        } else if (!dotted && !shaded) {
          if (style === 'normal') {
            icon_class = 'dcg-graph-normal';
          } else if (style === 'dashed') {
            icon_class = 'dcg-graph-dashed';
          }
        } else if (!dotted && shaded) {
          // TODO - missing icon for this
          icon_class = 'dcg-graph-shaded-inequality';
        } else if (dotted && !shaded) {
          icon_class = 'graph-inequality';
        } else if (dotted && shaded) {
          icon_class = 'dcg-graph-shaded-inequality';
        }
      }

      // efficently changes the class of the icon
      if (this.rendered_icon_class === icon_class) return;
      if (this.rendered_icon_class) {
        this.$icon.removeClass(this.rendered_icon_class);
      }
      this.rendered_icon_class = icon_class;
      if (icon_class) {
        this.$icon.addClass(icon_class);
      }

    };
  });

  return ExpressionIconView;
});

define('template!evaluation_view', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div>\n  <div class="dcg-evaluation dcg-do-blur" handleEvent="true">\n    <table>\n      <tr>\n        <th class="dcg-action-selectevaluation">\n          <span class="dcg-template-dependentlabelhtml"></span>\n          <span class="dcg-equals">=</span>\n        </th>\n        <td class="dcg-text-selectable template-evaluationshtml"></td>\n      </tr>\n    </table>\n  </div>\n  <div class="dcg-clear"></div>\n</div>';
}
return __p;
};});

define('expressions/evaluation',['require','pjs','underscore_view','template!evaluation_view','i18n','graphing/label'],function(require){
  var P = require('pjs');
  var UnderscoreView = require('underscore_view');
  var template = require('template!evaluation_view');
  var i18n = require('i18n');
  var Label = require('graphing/label');

  var EvaluationView = P(UnderscoreView, function (view, _super) {
    view.template = template;

    view.init = function (domain) {
      _super.init.call(this);
      this.evaluations = [];

      this.observe('dependentLabel', this.renderDependent.bind(this));
      this.observe('evaluations', this.renderEvaluations.bind(this));
    };

    view.renderDependent = function () {
      this.$('.dcg-template-dependentlabelhtml').html(this.dependentLabel);
    };

    view.renderEvaluations = function () {
      /* jshint maxcomplexity:12 */
      var vals = this.evaluations;
      var vals_str = [];

      for (var i=0; i<vals.length; i++) {
        var f_val = vals[i];
        if (f_val.val === false) {
          f_val.val = 'false';
        } else if (Array.isArray(f_val.val)) {
          f_val.val = f_val.val.length + " element list";
        } else if (isNaN(f_val.val)) {
          f_val.val = 'undefined';
        } else if (f_val.val === true) {
          f_val.val = 'true';
        } else if (Math.abs(f_val.val) < 1e-15) {
          f_val.val = 0;
        //shrink output if there are 2 solutions
        } else if (vals.length > 1) {
          if (Math.abs(f_val.val) > 1e6 || Math.abs(f_val.val) < 1e-3) {
            f_val.val = Label.htmlSciNote(f_val.val.toExponential(6));
          } else {
            f_val.val = Number(f_val.val.toPrecision(8));
          }
        } else {
          if (Math.abs(f_val.val) > 1e9 || Math.abs(f_val.val) < 1e-6) {
            f_val.val = Label.htmlSciNote(f_val.val.toExponential(8));
          } else {
            f_val.val = Number(f_val.val.toPrecision(12));
          }
        }

        vals_str.push(f_val.val);
      }

      if (vals_str.length === 0) return;
      if (vals_str.length === 1) {
        // skipping jQuery because this happens in the inner loop of sliders
        // and draggable points.
        var elt = this.$evaluationContainer[0];
        elt.innerHTML = vals_str[0];
      } else {
        var output = vals_str.join('<span class="dcg-or">'+ i18n.t('or') + '</span>');
        this.$evaluationContainer.html(output);
      }

    };

    view.didInsertElement = function () {
      this.$evaluationContainer = this.$('.template-evaluationshtml');
      this.renderDependent();
      this.renderEvaluations();

      this.$('.dcg-action-selectevaluation').on('tap', this.onSelectEvaluation.bind(this));
    };


    view.onSelectEvaluation = function () {
      var numberElement = this.$('td')[0];
      var range = document.createRange();
      range.selectNodeContents(numberElement);
      window.getSelection().removeAllRanges();
      window.getSelection().addRange(range);
    };

  });
  return EvaluationView;
});

define('template!unresolved_view', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="dcg-unresolved">\n  <i class="dcg-icon-error" /> This function contains fine detail that has not been fully resolved.\n  <a href="http://support.desmos.com/entries/29577773-Unresolved-Detail-In-Plotted-Functions" target="_blank">Learn more.</a>\n</div>';
}
return __p;
};});
define('expressions/unresolved',['require','pjs','underscore_view','template!unresolved_view'],function(require){
  var P = require('pjs');
  var UnderscoreView = require('underscore_view');
  var template = require('template!unresolved_view');

  return P(UnderscoreView, function (view, _super) {
    view.template = template;
  });
});

define('template!domain_view', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="dcg-domain dcg-do-blur" handleEvent="true">\n  \n  <div class="dcg-edit-domain dcg-variable-invalid dcg-desmos-input-container">\n    <table>\n      <tr>\n        <td>\n          <span class="dcg-before-input"></span>\n          <input type="number" limit="min" />\n          <span class="dcg-after-input"></span>\n        </td>\n        <td class="dcg-text"></td>\n        <td class="dcg-text">t</td>\n        <td class="dcg-text"></td>\n        <td>\n          <span class="dcg-before-input"></span>\n          <input type="number" limit="max" />\n          <span class="dcg-after-input"></span>\n        </td>\n      </tr>\n    </table>\n  </div>\n  \n  <div class="dcg-display-domain">\n    <span class="dcg-variable-min"></span>  t  <span class="dcg-variable-max"></span>    \n  </div>\n\n</div>';
}
return __p;
};});
define('expressions/domain_view',['require','jquery','underscore_view','pjs','template!domain_view','keys','conditional_blur'],function(require){
  var $ = require('jquery');
  var UnderscoreView = require('underscore_view');
  var P = require('pjs');
  var template = require('template!domain_view');
  var Keys = require('keys');
  var conditionalBlur = require('conditional_blur');

var DomainView = P(UnderscoreView, function (view, _super) {
  view.template = template;

  view.init = function (domain) {
    _super.init.call(this);

    this.domain = domain;

    this.domain.observe('min.domainview', this.renderMin.bind(this));
    this.domain.observe('max.domainview', this.renderMax.bind(this));
    this.setProperty('editing', false);
    this.setProperty('invalid', !this.domain.isValid());
    this.observe('invalid', this.renderInvalid.bind(this));
    this.observe('editing', this.renderEditing.bind(this));
    this.storeLastValidDomain();
  };

  view.checkInvalid = function () {
    var min = parseFloat(this.$('input[limit=min]').attr('value'));
    var max = parseFloat(this.$('input[limit=max]').attr('value'));

    var invalid = ( !isFinite(min) || !isFinite(max) || min>=max);
    this.setProperty('invalid', invalid);
  };

  view.destruct = function () {
    this.domain.unobserve('.domainview');
  };

  view.storeLastValidDomain = function () {
    if (this.domain.isValid()) {
      this.lastValidDomain = this.domain.serialize();
    }
  };

  view.renderInvalid = function () {
    this.$('.dcg-edit-domain').toggleClass('dcg-invalid', !!this.invalid);
  };

  view.renderEditing = function () {
    var editing = this.getProperty('editing');
    this.$().toggleClass('dcg-editing-domain', !!editing);
  };

  view.renderMin = function () {
    var min = this.domain.min;
    this.$('input[limit=min]').val(min);
    this.$('.dcg-variable-min').text(min);
  };

  view.renderMax = function () {
    var max = this.domain.max;
    this.$('input[limit=max]').val(max);
    this.$('.dcg-variable-max').text(max);
  };

  view.didInsertElement = function () {
    this.$('input').on('focusin', this.focusIn.bind(this))
                   .on('focusout', this.focusOut.bind(this))
                   .on('keydown keyup keypress', this.handleUserInput.bind(this));
    this.$('.dcg-display-domain').on('tap', this.onEditLimit.bind(this));
    this.renderEditing();
    this.renderMin();
    this.renderMax();
  };

  view.onEditLimit = function (evt) {
    evt.preventDefault();
    var $target = $(evt.toElement);
    this.setProperty('editing', true);
    if ($target.hasClass('dcg-variable-max')) {
      this.$('input[limit="max"]').focus().select();
    } else {
      this.$('input[limit="min"]').focus().select();
    }
  };

  view.stopEditing = function () {
    if (!this.domain.isValid() && this.lastValidDomain) {
      this.domain.setProperty('min', this.lastValidDomain.min);
      this.domain.setProperty('max', this.lastValidDomain.max);
    }
    this.setProperty('editing', false);
  };

  // blur input when enter pressed
  view.handleUserInput = function(evt) {
     if (Keys.lookup(evt) === Keys.ENTER) {
      conditionalBlur();
    } else {
      this.checkInvalid();

      // save the domain now so that it redraws
      if (!this.invalid) {
        this.save(evt.target);
      }
    }
  };

  // went straight into a focus, so don't save
  view.focusIn = function(evt) {
    clearTimeout(this.saveAfterBlurTimeout);
    this.checkInvalid();
  };

  // if we don't focus into one of the other boxes really soon,
  // we'll just act like the save button was pressed. This is
  // a sideeffect of focusin being fired AFTER focusout. Temporarily,
  // nothing is focused and we can't tell if focus is about to be
  // placed or not.
  view.focusOut = function(evt) {
    var self = this;
    this.save(evt.target);
    this.saveAfterBlurTimeout = setTimeout(function() {
      clearTimeout(self.saveAfterBlurTimeout);
      self.stopEditing();
    }, 1);
    this.checkInvalid();
  };

  view.save = function(node) {
    if (node) {
      var target = $(node);
      var value = parseFloat(target.attr('value'));

      if (target.attr('limit') === 'min') {
        // set the new min
        if (value < this.domain.max) {
          this.domain.setProperty('min', value);
        // reset the value since it's invalid
        } else {
          target.attr('value', this.domain.min);
        }
      } else if (target.attr('limit') === 'max') {
        // set the new max
        if (value > this.domain.min) {
          this.domain.setProperty('max', value);
        // reset the value since it's invalid
        } else {
          target.attr('value', this.domain.max);
        }
      }
      this.storeLastValidDomain();
    }
  };
});

return DomainView;
});

define('loadcss!css/regression', function(){});
define('template!regression_view', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="dcg-regression-container">\n  <div class="dcg-handle-event" handleEvent="true">\n    <div class="dcg-statistics">\n      <div class="dcg-regression-title dcg-residuals-title">\n        '+
( t('Statistics') )+
'\n        <a class="dcg-regression-about-link" target="_blank">\n          <i class="dcg-icon-question-sign"></i>\n        </a>\n      </div>\n\n      <span class="dcg-statistics-value"></span>\n    </div>\n    <div class="dcg-residuals">\n      <div class="dcg-regression-title dcg-residuals-title">\n        '+
( t('Residuals') )+
'\n      </div>\n      <span class="dcg-residuals-variable"></span>\n      <span class="dcg-residual-suggestion dcg-action-plot-residual dcg-btn">\n        plot\n      </span>\n    </div>\n\n    <div class="dcg-parameters-container">\n      <div class="dcg-regression-title dcg-parameters-title">\n        '+
( t('Parameters') )+
'\n      </div>\n      <div class="dcg-parameters">\n      </div>\n    </div>\n\n    <div class="dcg-clear"></div>\n  </div>\n</div>';
}
return __p;
};});
define('expressions/regression_view',['require','loadcss!css/regression','underscore_view','template!regression_view','pjs','jquery','underscore','graphing/label'],function (require) {
  require('loadcss!css/regression');
  var UnderscoreView = require('underscore_view');
  var template = require('template!regression_view');
  var P = require('pjs');
  var $ = require('jquery');
  var _ = require('underscore');
  var Label = require('graphing/label');

  return P(UnderscoreView, function (view, _super) {
    view.template = template;

    view.init = function (regression, listView) {
      _super.init.call(this);
      this.listView = listView;
      this.setProperty('regression', regression);
    };

    view.didCreateElement = function () {
      _super.didCreateElement.call(this);
      this.$statistics = this.$('.dcg-statistics-value');
      this.$residuals = this.$('.dcg-residuals-variable');
      this.$residualSuggestion = this.$('.dcg-residual-suggestion');
      this.$parameters = this.$('.dcg-parameters');
      this.$parametersContainer = this.$('.dcg-parameters-container');
      this.$regressionAboutLink = this.$('.dcg-regression-about-link');
      this.observeAndSync('regression', this.renderRegression.bind(this));

      this.$residualSuggestion.on('tap', this.plotResiduals.bind(this));
    };

    view.plotResiduals = function (evt) {
      var id = this.regression.residualSuggestionId;
      if (!id) return;
      var table = this.listView.model.getItemById(id);
      if (!table) return;

      table.insertColumn(table.columns.length - 1, {
        latex: Label.identifierToLatex(this.regression.residualVariable)
      });
    };

    view.getRoundedValue = function(val, digits, zeroCutoff) {
      if (Math.abs(val) < zeroCutoff) return 0;

      if (Math.abs(val) > 1e9 || Math.abs(val) < 1e-6) {
        return Label.latexSciNote(val.toExponential(digits - 1));
      }
      return Number(val.toPrecision(digits));
    };

    view.getRoundedParam = function(param, digits) {
      return this.getRoundedValue(this.regression.parameters[param], digits, 1e-15);
    };

    view.renderStats = function () {
      this.renderAboutLink();

      //render r value: https://github.com/desmosinc/knox/issues/4337
      if (this.regression.statistics.hasOwnProperty('r')) {
        var rVal = this.getRoundedValue(this.regression.statistics.r, 3, 1e-15);
        var $r = $('<span>').text('r=' + rVal).mathquill();
        this.$statistics.html($r);
        return;
      }

      if (this.regression.statistics.hasOwnProperty('Rsquared')) {
        var rsquaredVal = this.getRoundedValue(this.regression.statistics.Rsquared, 3, 1e-15);
        var rsquared = $('<span>').text('R^2=' + rsquaredVal).mathquill();
        this.$statistics.html(rsquared);
        return;
      }

      if (this.regression.statistics.hasOwnProperty('RMSE')) {
        var RMSE = this.getRoundedValue(this.regression.statistics.RMSE, 4, 1e-8);
        var $RMSE = $('<span>').text('RMSE=' + RMSE).mathquill();
        this.$statistics.html($RMSE);
        return;
      }
    };

    view.renderAboutLink = function () {
      //show regression warning only if R^2 is negative. should link to a help page
      if (this.regression.statistics.hasOwnProperty('RMSE')) {
        this.$regressionAboutLink[0].href = 'http://support.desmos.com/entries/60176149-What-is-RMSE-';
        this.$regressionAboutLink.show();
      } else if (this.regression.statistics.Rsquared < 0) {
        this.$regressionAboutLink[0].href =
          'http://support.desmos.com/entries/60460125-Why-am-I-seeing-a-negative-R-2-value-'
        ;
        this.$regressionAboutLink.show();
      } else {
        this.$regressionAboutLink.hide();
      }
    };

    view.renderRegression = function () {
      this.renderStats();

      //render residual variable
      var residualVariable = $('<span>').text(this.regression.residualVariable).mathquill();
      this.$residuals.html(residualVariable);

      this.$residualSuggestion.toggleClass('dcg-visible', !!this.regression.residualSuggestionId);

      //render parameters
      this.$parameters.html('');
      this.$parametersContainer.toggle(_.size(this.regression.parameters) > 0);
      for (var p in this.regression.parameters) {
        var eq = $('<span>').addClass('dcg-parameter')
                            .text(p + '=' + this.getRoundedParam(p, 3))
                            .mathquill();
        this.$parameters.append(eq);
      }
    };
  });
});
define('loadcss!css/slider', function(){});
define('template!slider_view', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<span class="dcg-slider-container" tapboundary="true">\n\n  <div class="dcg-do-blur dcg-slider" handleEvent="true">\n    <div class="dcg-minLabel dcg-template-minlabelhtml">\n    </div>\n    <div class="dcg-maxLabel">\n      <span class="dcg-template-maxlabelhtml"></span>\n    </div>\n    <div class="dcg-track dcg-action-moveslider">\n      <div class="dcg-ticks dcg-template-tickmarkhtml"></div>\n      <div class="dcg-graphic"></div>\n    </div>\n    <div class="dcg-zeroMarker dcg-action-moveslider">\n      <div class="dcg-graphic"></div>\n    </div>\n    <div class="dcg-thumb dcg-action-startdragging" disablescroll="true">\n      <div class="dcg-graphic"></div>\n      <div class="dcg-center"></div>\n    </div>\n  </div>\n\n  <div class="dcg-slider_menu dcg-do-blur dcg-desmos-input-container" handleEvent="true">\n    <table>\n      <tr>\n        <td>\n          <span class="dcg-before-input"></span>\n            <input class="dcg-slider_min" limit="min" type="number">\n          <span class="dcg-after-input"></span>\n    ';
 /*
      Need to be careful with unescaped html insertion. This html is generated
      from user input by mathquill, so we"re relying on mathquill to escape
      html as necessary.
    */
;__p+='\n        </td>\n        <td class="dcg-text">\n          \n        </td>\n        <td class="dcg-template-dependentlabelhtml dcg-text"></td>\n        <td class="dcg-text"></td>\n        <td>\n          <span class="dcg-before-input"></span>\n            <input class="dcg-slider_max" limit="max" type="number">\n          <span class="dcg-after-input"></span>\n        </td>\n        <td class="dcg-step dcg-text">'+
( t('step:') )+
'</td>\n        <td>\n          <span class="dcg-before-input"></span>\n            <input class="dcg-slider_interval" limit="step" type="number">\n          <span class="dcg-after-input"></span>\n        </td>\n      </tr>\n    </table>\n  </div>\n  \n</span>';
}
return __p;
};});
define('expressions/slider_view',['require','loadcss!css/slider','jquery','pjs','lib/rounding','underscore_view','template!slider_view','underscore','keys','conditional_blur'],function(require) {
  require('loadcss!css/slider');

  var $ = require('jquery');
  var P = require('pjs');
  var Rounding = require('lib/rounding');
  var UnderscoreView = require('underscore_view');
  var template = require('template!slider_view');
  var _ = require('underscore');
  var Keys = require('keys');
  var conditionalBlur = require('conditional_blur');

  var label2html = function(num) {
    var onum=num;
    var str = String(num).split("-").join("");

    if (str.length > 4 || str.indexOf("e") != -1) {
      // size of input
      var digits = Math.floor(Math.log(Math.abs(num))/Math.LN10);

      // move the decimial over to the unit's place
      num = num/Math.pow(10, digits);

      // round to 1 sig figs
      num = Math.round(num);

      if (Math.abs(num) >= 10) {
        digits++;
        if (num < 0) {
          num = -1;
        } else {
          num = 1;
        }
      }

      if (digits >= -3 && digits <= 3) {
        str = String(onum);
        if (str.indexOf("0.") === 0) {
          str = str.substr(1);
        } else if (str.indexOf("-0.") === 0) {
          str = "-" + str.substr(2);
        }

        return str.substr(0, 5);
      }

      var coef;
      if (num === 1) {
        coef = '';
      } else if (num === -1) {
        coef = '-';
      } else {
        coef = num + "<span class='dcg-cross'>\u00D7</span>";
      }

      return coef + "10<span class='dcg-sup'>" + digits + "</span> ";
    } else {
      return String(num);
    }
  };

  var SliderView = P(UnderscoreView, function(view, _super) {
    view.template = template;
    view.animationSpeeds = [0.05, 0.1, 0.15, 0.2, 0.35, 0.5, 0.75, 1, 1.5, 2, 3.5, 5, 7.5, 10, 15, 20];

    view.init = function (slider, parentView) {
      _super.init.call(this);
      this.slider = slider;
      this.parentView = parentView;

      // we hold a local copy of the slider's value. this allows us to
      // throttle how quickly we set the value back to the slider.
      this.value = this.slider.value;

      // if the slider's value changes, we immediately overwrite our local
      // copy of the variable with the new official value.
      this.slider.observe('value', function () {
        this.setProperty('value', this.slider.value);
      }.bind(this));

      this.editing = false;

      // Watch changes to the properties while we edit the slider.
      this.slider.observe('min.sliderview max.sliderview', this.renderThumbPosition.bind(this));
      this.observe('value', this.renderThumbPosition.bind(this));

      this.slider.observe('min.sliderview max.sliderview', this.renderZeroMarker.bind(this));
      this.slider.observe('min.sliderview max.sliderview step.sliderview', this.renderTickMarks.bind(this));
      this.slider.observe('min.sliderview hardMin.sliderview', this.renderMin.bind(this));
      this.slider.observe('max.sliderview hardMax.sliderview', this.renderMax.bind(this));
      this.slider.observe('step.sliderview', this.renderStep.bind(this));
      this.observe('dependentLabel', this.renderDependent.bind(this));
      this.observe('editing', this.renderEditing.bind(this));
      this.observe('editing', function () {
        this.slider.setProperty('isPlaying', false);
      }.bind(this));
      this.observe('invalid', this.renderInvalid.bind(this));
      this.slider.observe('dragging.sliderview', this.renderDragging.bind(this));
      this.slider.observe('isPlaying.sliderview', this.renderIsPlaying.bind(this));
      this.slider.observe('animationPeriod', this.renderAnimationPeriod.bind(this));
    };

    view.renderAnimationPeriod = function () {
      var speed = this.computeSpeed();
      var text = speed + 'x';
      this.parentView.$('.dcg-variable-speed').text(text);
      this.parentView.$('.dcg-action-slower').toggleClass('dcg-disabled', _.min(this.animationSpeeds) >= speed);
      this.parentView.$('.dcg-action-faster').toggleClass('dcg-disabled', _.max(this.animationSpeeds) <= speed);
    };

    view.destruct = function () {
      this.slider.unobserve('.sliderview');
    };

    view.renderDependent = function () {
      this.$('.dcg-template-dependentlabelhtml').html(this.dependentLabel);
    };

    view.renderDragging = function () {
      this.$thumb.toggleClass('dcg-down', !!this.slider.dragging);
    };

    view.renderStep = function () {
      if (this.slider.step === undefined) {
        this.$('input[limit=step]').val('');
      } else {
        this.$('input[limit=step]').val(this.slider.step);
      }
    };

    view.renderMin = function () {
      this.$('.dcg-template-minlabelhtml').html(label2html(this.slider.min));
      this.$('input[limit=min]').val(this.slider.hardMin ? this.slider.min : '');
    };

    view.renderMax = function () {
      this.$('.dcg-template-maxlabelhtml').html(label2html(this.slider.max));
      this.$('input[limit=max]').val(this.slider.hardMax ? this.slider.max : '');
    };

    view.renderEditing = function () {
      this.$().toggleClass('dcg-editing-limits', this.editing);
    };

    view.renderInvalid = function () {
      this.$('.dcg-slider_menu').toggleClass('dcg-invalid', !!this.invalid);
    };

    view.renderThumbPosition = function() {

      //TODO: this is for api usage with expressions: false.
      //Ideally, this method should never be reached if we have no expression views
      if (!this.$thumb) return;

      var left;
      var min = this.slider.min;
      var max = this.slider.max;
      var val = this.value;

      if (val <= min) {
        left = 0;
      } else if (val >= max) {
        left = 100;
      } else {
        left = (val - min)/(max - min) * 100;
      }

      // TODO would like to use translateX here, but percentages are
      // referenced to the element, not its parent. Could put the thumb
      // in a container that is width: 100%.
      this.$thumb.css('left', left + "%");
    };

    view.renderZeroMarker = function() {
      var t = (0 - this.slider.min)/(this.slider.max - this.slider.min);
      var css = {};
      if (t >= 0 && t <= 1) {
        var left = t*100;
        css.display = "block";
        css.left = left + '%';
      } else {
        css.display = "none";
      }

      this.$('.dcg-zeroMarker').css(css);
    };

    view.renderTickMarks = function() {
      var step = this.slider.step;
      var min = this.slider.min;
      var max = this.slider.max;

      var percent = 100*step/(max - min);
      if (percent < 3) percent = 0; // don't draw too many ticks

      var html = "";
      if (percent > 0 && percent < 100) {
        for (var i=percent; i<100; i += percent) {
          html += '<div class="dcg-tick" style="left:' + i + '%"></div>';
        }
      }

      this.$('.dcg-template-tickmarkhtml').html(html);
    };

    view.getDimensions = function() {
      var track = this.$('.dcg-track');
      var trackLeft = track.offset().left;
      var trackRight = trackLeft + track.width();
      return {
        trackLeft: trackLeft,
        trackRight: trackRight
      };
    };

    view.computeSpeed = function () {
      var speed = this.slider.DEFAULT_PERIOD / this.slider.animationPeriod;
          speed = Number(speed.toFixed(3)); // in case the speed isn't very precise
      return speed;
    };

    view.setPeriodFromSpeed = function (speed) {
      var period = this.slider.DEFAULT_PERIOD / speed;
      this.slider.setProperty('animationPeriod', period);
    };

    view.animateSlower = function () {
      var speed = this.computeSpeed();
      var slowers = _.filter(this.animationSpeeds, function (val) { return val<speed; });
      if (slowers.length === 0) return;

      this.setPeriodFromSpeed(_.max(slowers));
    };

    view.animateFaster = function () {
      var speed = this.computeSpeed();
      var fasters = _.filter(this.animationSpeeds, function (val) { return val>speed; });
      if (fasters.length === 0) return;

      this.setPeriodFromSpeed(_.min(fasters));
    };

    view.didInsertElement = function() {
      this.$thumb = this.$('.dcg-thumb');

      // setup event handlers
      this.$('.dcg-action-startdragging').on('tapstart', this.onStartDragging.bind(this));
      this.$('.dcg-action-moveslider').on('tap', function (evt) {
        var touch = evt.changedTouches[0];
        this.slider.setProperty('isPlaying', false);
        this.setValueByTouch(touch);
        this.commitSliderValue();
      }.bind(this));

      this.$().on('focusout', this.focusOut.bind(this));
      this.$().on('focusin', this.focusIn.bind(this));
      this.$().on('keydown', this.keyDown.bind(this));
      this.$('input[limit]').on('keypress keydown keyup', this.checkInvalid.bind(this));

      this.$('.dcg-action-play').on('tap', function () {
        this.slider.setProperty('isPlaying', true);
      }.bind(this));

      //Editing from main view - only active when using mouse
      this.$().on('tap', '.dcg-minLabel', this.onEditMin.bind(this));
      this.$().on('tap', '.dcg-maxLabel', this.onEditMax.bind(this));

      this.renderTickMarks();
      this.renderThumbPosition();
      this.renderZeroMarker();
      this.renderDependent();
      this.renderMin();
      this.renderMax();
      this.renderStep();
      this.renderAnimationPeriod();
      this.renderIsPlaying();

      this.checkInvalid();
    };

    view.setValueByTouch = function (touch) {

      // properties of the slider
      var min = this.slider.min;
      var max = this.slider.max;

      // figures out where the slider is located on the screen.
      var dimensions = this.getDimensions();

      var left = dimensions.trackLeft;
      var right = dimensions.trackRight;
      var width = right - left;
      var pixel_units = (max-min)/width;

      // figures out the percent 0%-100% of the thumbs position
      var t = Math.min(1, Math.max(0,(touch.pageX - left)/width));

      var val = min*(1 - t) + max*t;

      // round to a pretty number
      val = Rounding.shortestDecimalBetween(val - pixel_units, val + pixel_units);

      // snap to the step interval
      val = this.slider.computeSnappedValue(val);

      val = Math.max(min, Math.min(max, val));

      this.setProperty('value', val);
    };

    view.onStartDragging = function(evt) {

      // only start dragging if this is the first touch
      if (evt.touches.length !== 1) return;

      // updated by eli. On Android it's especially noticeable, but in general
      // it feels like we want to defocus expressions we're sliding a slider
      // unintended positive side effect:
      // also improves performance, since we don't need to stream POIs while sliding
      this.parentView.clearListFocus();

      var self = this;

      // Stop any slider animation
      this.slider.setProperty('isPlaying', false);

      var getTouchByIdentifier = function (evt, identifier) {
        var touches = evt.touches;
        var touch = null;

        for (var i=0; i<touches.length; i++) {
          if (touches[i].identifier === identifier) {
            touch = touches[i];
          }
        }

        return touch;
      };
      var throttleInterval = 30;
      var commitSliderValueThrottled = _.throttle(self.commitSliderValue.bind(self), throttleInterval);

      self.slider.setProperty('dragging', true);

      var touchIdentifier = evt.changedTouches[0].identifier;
      var onMouseMove = function(evt) {

        // lookup the touch that started this
        var touch = getTouchByIdentifier(evt, touchIdentifier);
        if (!touch) return;

        self.setValueByTouch(touch);

        // We commit the slider's value manually here instead of using an
        // observer on 'value' because we need precise control of when the
        // value is committed. When the user types in mathquill, that causes
        // a change in the sliders value. We don't want that change to get
        // routed back into commitSliderValue(). If it did, the user would never
        // be able to type decimals. When they typed "a=1.", the
        // commitSliderValue() function would turn that into "a=1" again.
        commitSliderValueThrottled();
      };

      var stopDragging = function () {
        $(document).off('tapmove', onMouseMove);
        $(document).off('tapend tapcancel', onMouseUp);

        self.slider.setProperty('dragging', false);
      };

      var onMouseUp = function(evt) {

        // checks if the touch that started the slider is still around. If so,
        // don't do anything here. A different touch must have lifted.
        var touch = getTouchByIdentifier(evt, touchIdentifier);
        if (touch) return;

        stopDragging();
        self.commitSliderValue();
      };

      $(document).on('tapmove', onMouseMove);
      $(document).on('tapend tapcancel', onMouseUp);
    };

    view.commitSliderValue = function() {
      this.slider.setProperty('value', this.value);
    };

    view.checkInvalid = function () {
      var min = this.$('input[limit=min]').attr('value');
      if (min === '') {
        min = this.slider.min;
      } else {
        min = parseFloat(min);
      }

      var max = this.$('input[limit=max]').attr('value');
      if (max === '') {
        max = this.slider.max;
      } else {
        max = parseFloat(max);
      }

      var step = this.$('input[limit=step]').attr('value');
      if (step === '') {
        step = 0;
      } else {
        step = parseFloat(step);
      }

      var invalid = ( !isFinite(min) || !isFinite(max) || min>=max || step < 0 || step > (max-min));
      this.setProperty('invalid', invalid);
    };

    // blur input when enter pressed
    view.keyDown = function(evt) {
      if (Keys.lookup(evt) === Keys.ENTER) {
        conditionalBlur();
      } else {
        this.checkInvalid();
      }
    },

    // went straight into a focus, so don't save
    view.focusIn = function(evt) {
      this.slider.setProperty('isPlaying', false);
      clearTimeout(this.saveAfterBlurTimeout);
      this.checkInvalid();
    },

    // if we don't focus into one of the other boxes really soon,
    // we'll just act like the save button was pressed. This is
    // a sideeffect of focusin being fired AFTER focusout. Temporarily,
    // nothing is focused and we can't tell if focus is about to be
    // placed or not.
    view.focusOut = function(evt) {
      var self = this;
      this.save(evt.target);

      this.saveAfterBlurTimeout = setTimeout(function() {
        clearTimeout(self.saveAfterBlurTimeout);
        self.onClose();
      }, 1);

      this.checkInvalid();
    },

    view.save = function(node) {
      /* jshint maxcomplexity:12 */
      if (node) {
        var target = $(node);
        var value = target.attr('value');
        if (value === '') {
          value = undefined;
        } else {
          value = parseFloat(value);
        }

        var step = (this.$('.dcg-slider_interval').attr('value') === '') ? 0 : this.slider.step;

        if (target.hasClass('dcg-slider_min')) {

          // turn min soft
          if (value === undefined) {
            this.slider.setProperty('hardMin', false);
          }

          // set the new min
          else if (value < this.slider.max && this.slider.max - value >= step) {
            this.slider.setProperty('min', value);
            this.slider.setProperty('hardMin', true);

          // revert the min value
          } else {
            this.renderMin();
          }

        } else if (target.hasClass('dcg-slider_max')) {

          // set max as soft
          if (value === undefined) {
            this.slider.setProperty('hardMax', false);
          }

          // set the new min
          if (value > this.slider.min && value - this.slider.min >= step) {
            this.slider.setProperty('max', value);
            this.slider.setProperty('hardMax', true);

          // revert the max value
          } else {
            this.renderMax();
          }

        } else if (target.hasClass('dcg-slider_interval')) {

          // clear the step value
          if (value === undefined) {
            this.slider.setProperty('step', undefined);
          }

          // set the new step interval
          else if (value >= 0 && value <= this.slider.max - this.slider.min) {
            this.slider.setProperty('step', value);

          // revert the slider step
          } else {
            this.renderStep();
          }
        }
      }
    };

    view.onClose = function() {
      this.setProperty('editing', false);
    };

    view.onEditMin = function(evt) {
      this.setProperty('editing', true);
      evt.preventDefault();
      this.$('.dcg-slider_min').focus().select();
    };

    view.onEditMax = function(evt) {
      this.setProperty('editing', true);
      evt.preventDefault();
      this.$('.dcg-slider_max').focus().select();
    };

    view.renderIsPlaying = function () {
      if (this.slider.step < 0) {
        this.slider.setProperty('isPlaying', false);
        return;
      }
      this.parentView.$().toggleClass('dcg-isPlaying', !!this.slider.isPlaying);
    };

  });

  return SliderView;
});

define('template!prompt_sliders', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="dcg-create_sliders dcg-action-createslider" handleEvent="true">\n  <span class="dcg-msg">'+
( t('add slider:') )+
'</span>\n  <span class="btns">\n    ';
 _.each(variables, function (variable) {
;__p+='\n      <div class="dcg-slider_btn_container" var_name="'+
( variable.name )+
'" >\n        <div class="dcg-btn dcg-btn-small '+
( (variables.length === 1 ? 'dcg-btn-blue' : 'dcg-btn-gray') )+
'">'+
( variable.label )+
'</div>\n      </div>\n    ';
 })
;__p+='\n\n    ';
 if (variables.length > 1) {
;__p+='\n      <div class="dcg-slider_btn_container dcg-all">\n        <div class="dcg-btn dcg-btn-small dcg-btn-blue">'+
( t('all') )+
'</div>\n      </div>\n    ';
 }
;__p+='\n  </span>\n</div>';
}
return __p;
};});
define('expressions/promptslider_view',['require','jquery','pjs','underscore_view','template!prompt_sliders','./expression'],function(require) {
  var $ = require('jquery');
  var P = require('pjs');
  var UnderscoreView = require('underscore_view');
  var template = require('template!prompt_sliders');
  var ExpressionObject = require('./expression');

  var PromptSliderView = P(UnderscoreView, function (view, _super) {

    view.template = template;

    view.init = function (expressionView) {
      _super.init.call(this);

      this.variables = [];
      this.expressionView = expressionView;
      this.observe('variables', this.rerender.bind(this));
    };

    view.didInsertElement = function () {
      this.$('.dcg-action-createslider').on('tap', this.onCreateSlider.bind(this));
    };

    view.getTemplateParams = function () {
      var vars = this.variables;
      var formattedVariables = [];
      for (var i=0; i<4 && i<vars.length; i++) {
        var v = vars[i];
        var vName, vHtml = v.split('{').join('').split('}').join('').split('_');

        if (vHtml.length > 1) {
          vName = vHtml[0] + "_{" + vHtml[1] + "}";
          vHtml = vHtml[0] + "<sub>" + vHtml[1] + "</sub>";
        } else {
          vName = vHtml[0];
          vHtml = vHtml[0];
        }

        formattedVariables.push({ name:vName, label:vHtml });
      }

      return {variables: formattedVariables};
    };

    view.onCreateSlider = function(evt) {

      // this action feels like it should defocus expressions
      this.expressionView.clearListFocus();

      var dom = $(evt.target).closest('.dcg-slider_btn_container');
      if (!dom.length) return;

      var vars;
      if (dom.hasClass('dcg-all')) {
        vars = this.variables.map(function (raw_variable) {
          var split = raw_variable.split('{').join('').split('}').join('').split('_');
          if (split.length === 1) {
            return raw_variable;
          } else {
            return split[0] + "_{" + split[1] + "}";
          }
        });
      } else {
        vars = [dom.attr('var_name')];
      }

      if (!vars.length) return;

      this.createSliders(vars);
    };

    view.createSliders = function (vars) {
      var expressionView = this.expressionView;
      var expressionModel = this.expressionView.model;

      // build the list of states
      // this is important, because the first time, it will generate
      // an id for us automatically. If we undo then redo, we need to
      // reusue the generated ids.
      // set slider min/max so that they don't
      // get set automatically and messup undo/redo
      var var_states = [];
      for (var i=0; i<vars.length; i++) {
        var_states.push({
          latex: vars[i] + '=1',
          sliderMin: -10, // TODO - combine this lines into:
          sliderMax: 10,  // slider: {min: -10, max: 10}
          hidden: true //don't show a circle when we create an r= slider
        });
      }

      var index = expressionModel.index;
      var folder = expressionModel.folder;
      var next_index = index + 1;

      var list = expressionModel.list;
      list.undoRedo.addTransaction({
        type: list.undoRedo.CAUSE_OF_CHANGE,

        undo: function() {
          for (var i=0; i<vars.length; i++) {
            list.removeItemAt(next_index);
          }
        },

        redo: function() {
          for (var i = var_states.length - 1; i >= 0; i--) {
            var obj = ExpressionObject(var_states[i], list);
            var_states[i].id = obj.id; // store the generated id for next time
            list.insertItemAt(next_index, obj);
            if (folder) folder.addItem(obj);
          }
        }
      });

      // temporarily disables animation while slider is created
      expressionView.setProperty('doAnimate', false);
      clearTimeout(expressionView.restoreAnimationTimeout);
      expressionView.restoreAnimationTimeout = setTimeout(function() {
        expressionView.setProperty('doAnimate', true);
      }, 500);
    };
  });

  return PromptSliderView;
});

define('loadcss!vendor_css/mathquill/mathquill', function(){});
/**
 * Copyleft 2010-2011 Jay and Han (laughinghan@gmail.com)
 *   under the GNU Lesser General Public License
 *     http://www.gnu.org/licenses/lgpl.html
 * Project Website: http://mathquill.com
 */

(function() {

var $ = jQuery,
  undefined,
  _, //temp variable of prototypes
  mqCmdId = 'mathquill-command-id',
  mqBlockId = 'mathquill-block-id',
  min = Math.min,
  max = Math.max;

var __slice = [].slice;

function noop() {}

/**
 * sugar to make defining lots of commands easier.
 * TODO: rethink this.
 */
function bind(cons /*, args... */) {
  var args = __slice.call(arguments, 1);
  return function() {
    return cons.apply(this, args);
  };
}

/**
 * a development-only debug method.  This definition and all
 * calls to `pray` will be stripped from the minified
 * build of mathquill.
 *
 * This function must be called by name to be removed
 * at compile time.  Do not define another function
 * with the same name, and only call this function by
 * name.
 */
function pray(message, cond) {
  if (!cond) throw new Error('prayer failed: '+message);
}
var P = (function(prototype, ownProperty, undefined) {
  // helper functions that also help minification
  function isObject(o) { return typeof o === 'object'; }
  function isFunction(f) { return typeof f === 'function'; }

  function P(_superclass /* = Object */, definition) {
    // handle the case where no superclass is given
    if (definition === undefined) {
      definition = _superclass;
      _superclass = Object;
    }

    // C is the class to be returned.
    // There are three ways C will be called:
    //
    // 1) We call `new C` to create a new uninitialized object.
    //    The behavior is similar to Object.create, where the prototype
    //    relationship is set up, but the ::init method is not run.
    //    Note that in this case we have `this instanceof C`, so we don't
    //    spring the first trap. Also, `args` is undefined, so the initializer
    //    doesn't get run.
    //
    // 2) A user will simply call C(a, b, c, ...) to create a new object with
    //    initialization.  This allows the user to create objects without `new`,
    //    and in particular to initialize objects with variable arguments, which
    //    is impossible with the `new` keyword.  Note that in this case,
    //    !(this instanceof C) springs the return trap at the beginning, and
    //    C is called with the `new` keyword and one argument, which is the
    //    Arguments object passed in.
    //
    // 3) For internal use only, if new C(args) is called, where args is an
    //    Arguments object.  In this case, the presence of `new` means the
    //    return trap is not sprung, but the initializer is called if present.
    //
    //    You can also call `new C([a, b, c])`, which is equivalent to `C(a, b, c)`.
    //
    //  TODO: the Chrome inspector shows all created objects as `C` rather than `Object`.
    //        Setting the .name property seems to have no effect.  Is there a way to override
    //        this behavior?
    function C(args) {
      var self = this;
      if (!(self instanceof C)) return new C(arguments);
      if (args && isFunction(self.init)) self.init.apply(self, args);
    }

    // set up the prototype of the new class
    // note that this resolves to `new Object`
    // if the superclass isn't given
    var proto = C[prototype] = new _superclass();

    // other variables, as a minifier optimization
    var _super = _superclass[prototype];
    var extensions;

    // set the constructor property on the prototype, for convenience
    proto.constructor = C;

    C.mixin = function(def) {
      C[prototype] = P(C, def)[prototype];
      return C;
    }

    return (C.open = function(def) {
      extensions = {};

      if (isFunction(def)) {
        // call the defining function with all the arguments you need
        // extensions captures the return value.
        extensions = def.call(C, proto, _super, C, _superclass);
      }
      else if (isObject(def)) {
        // if you passed an object instead, we'll take it
        extensions = def;
      }

      // ...and extend it
      if (isObject(extensions)) {
        for (var ext in extensions) {
          if (ownProperty.call(extensions, ext)) {
            proto[ext] = extensions[ext];
          }
        }
      }

      // if there's no init, we assume we're inheriting a non-pjs class, so
      // we default to applying the superclass's constructor.
      if (!isFunction(proto.init)) {
        proto.init = function() { _superclass.apply(this, arguments); };
      }

      return C;
    })(definition);
  }

  // ship it
  return P;

  // as a minifier optimization, we've closured in a few helper functions
  // and the string 'prototype' (C[p] is much shorter than C.prototype)
})('prototype', ({}).hasOwnProperty);
/*************************************************
 * Textarea Manager
 *
 * An abstraction layer wrapping the textarea in
 * an object with methods to manipulate and listen
 * to events on, that hides all the nasty cross-
 * browser incompatibilities behind a uniform API.
 *
 * Design goal: This is a *HARD* internal
 * abstraction barrier. Cross-browser
 * inconsistencies are not allowed to leak through
 * and be dealt with by event handlers. All future
 * cross-browser issues that arise must be dealt
 * with here, and if necessary, the API updated.
 *
 * Organization:
 * - key values map and stringify()
 * - manageTextarea()
 *    + defer() and flush()
 *    + event handler logic
 *    + attach event handlers and export methods
 *
 * We put focus into a span[tabindex=0] by default.
 * This prevents virtual keyboards from opening on
 * touch-enabled devices. But, that has the effect
 * of disabling real keyboards. Focus is shifted
 * from the span[tabindex=0] to a textarea the
 * moment a keydown event is fired. The side-effect
 * of the keydown still takes place within the
 * textarea. The textarea is used from that moment
 * on until the textarea is blurred. At that point
 * we disable the textarea again until the next
 * keydown event.
 ************************************************/

// TODO - create the textarea and spanarea within the
// textarea manager in order to better enforce the
// *HARD* internal abstraction barrier.

var manageTextarea = (function() {

  var NONE = 0;
  var SPANAREA = 1;
  var TEXTAREA = 2;

  // The following [key values][1] map was compiled from the
  // [DOM3 Events appendix section on key codes][2] and
  // [a widely cited report on cross-browser tests of key codes][3],
  // except for 10: 'Enter', which I've empirically observed in Safari on iOS
  // and doesn't appear to conflict with any other known key codes.
  //
  // [1]: http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#keys-keyvalues
  // [2]: http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#fixed-virtual-key-codes
  // [3]: http://unixpapa.com/js/key.html
  var KEY_VALUES = {
    8: 'Backspace',
    9: 'Tab',

    10: 'Enter', // for Safari on iOS

    13: 'Enter',

    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    20: 'CapsLock',

    27: 'Esc',

    32: 'Spacebar',

    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',

    37: 'Left',
    38: 'Up',
    39: 'Right',
    40: 'Down',

    45: 'Insert',

    46: 'Del',

    144: 'NumLock'
  };

  function stopEvent (evt) {
    evt.stopPropagation();
    evt.stopImmediatePropagation();
  }

  // To the extent possible, create a normalized string representation
  // of the key combo (i.e., key code and modifier keys).
  function stringify(evt) {
    var which = evt.which || evt.keyCode;
    var keyVal = KEY_VALUES[which];
    var key;
    var modifiers = [];

    if (evt.ctrlKey) modifiers.push('Ctrl');
    if (evt.originalEvent && evt.originalEvent.metaKey) modifiers.push('Meta');
    if (evt.altKey) modifiers.push('Alt');
    if (evt.shiftKey) modifiers.push('Shift');

    key = keyVal || String.fromCharCode(which);

    if (!modifiers.length && !keyVal) return key;

    modifiers.push(key);
    return modifiers.join('-');
  }

  // A global listener that's attached once. It monitors for keydown events.
  // Whenever one occurs, it checks if the currently active element has
  // permission to enable the physical keyboard for a mathquill. If so,
  // it calls the closured function to do so. When that mathquill loses focus
  // it will automatically disable the keyboard again. This means that a
  // bluetooh keyboard can be added and removed throught a session and we'll
  // update the mathquills accordingly. The only edge case is if you remove
  // a keyboard while editing a mathquill. In that case, the virtual keypad
  // will popup.
  $(document).on('keydown', function () {
    var activeElement = document.activeElement;
    var enableKeyboard = $(activeElement).data('enablePhysicalKeyboard')
    if (enableKeyboard) {
      enableKeyboard();
    }
  });

  // Sets up the listeners to automatically switch between spanarea and
  // the textarea. This allows us to use the physical keyboard wihtout
  // bringing up a native virtual keyboard when a physical keyboard is
  // not present. Should only be used when there is a user supplied
  // keypad present.
  //
  // We enable physical keyboards when this mathquill's spanara is
  // focused and we observe a native 'keydown' event. We assume
  // that command came from a physical keyboard. We JIT switch
  // focus to a real textarea in order to catch the keypress.
  function autoSwitchTextarea (spanarea, textarea, exports) {
    var focusedElement = NONE;

    function disablePhysicalKeyboard () {
      spanarea.attr('tabindex', '0');

      // must actively blur textarea before setting to disabled.
      // IE does some funny thing where it changes focus to somewhere
      // else.
      textarea.blur();
      textarea.attr('disabled', 'true');
    }

    function enablePhysicalKeyboard () {
      focusedElement = TEXTAREA;
      spanarea.removeAttr('tabindex');
      textarea.removeAttr('disabled');
      textarea.focus();
      textarea.select();
    }

    exports.focus = function () {
      if (focusedElement === NONE) {
        spanarea.focus();
      }
    };

    exports.blur = function () {
      if (focusedElement === TEXTAREA) {
        textarea.blur();
      }
      if (focusedElement === SPANAREA) {
        spanarea.blur();
      }
    };

    // we do some work to make sure that focusin and focusout
    // events are only fired once and are fired only when they
    // should be. The transition from spanarea being focused to
    // textarea being focused needs to happen silently. This
    // code makes sure that happens. It also eliminates multiple
    // focusin and focusout events from being fired in IE.
    spanarea.on('focusin', function (evt) {
      if (focusedElement !== NONE) {
        stopEvent(evt);
      } else {
        focusedElement = SPANAREA;
        exports.onFocus();
      }
    }).on('focusout', function (evt) {
      if (focusedElement !== SPANAREA) {
        stopEvent(evt);
      } else {
        focusedElement = NONE;
        exports.onBlur();
      }
    });

    textarea.on('focusin', function (evt) {
      stopEvent(evt);
      // enablePhysicalKeyboard will set
      // focusedElement = TEXTAREA
    }).on('focusout', function (evt) {
      if (focusedElement !== TEXTAREA) {
        stopEvent(evt);
      } else {
        focusedElement = NONE;
        disablePhysicalKeyboard();
        exports.onBlur();
      }
    });

    // if we get a keydown event while this element is active, we'll
    // enable the physical physical keyboard.
    spanarea.data('enablePhysicalKeyboard', enablePhysicalKeyboard);

    // start off with spanarea enabled
    disablePhysicalKeyboard();
  }

  // this defaults to how mathquill normally works. We always back
  // the textareaManager with a real textarea. This is the effect of
  // always bringing up the native virtual keyboard on devices that
  // do not have a physical keyboard attached.
  function alwaysUseTextarea (spanarea, textarea, exports) {
    var focusedElement = NONE;

    exports.focus = function () {
      if (focusedElement === NONE) {
        textarea.focus();
      }
    };

    exports.blur = function () {
      if (focusedElement === TEXTAREA) {
        textarea.blur();
      }
    };

    // we do some work to make sure that focusin and focusout
    // events are only fired once and are fired only when they
    // should be. The transition from spanarea being focused to
    // textarea being focused needs to happen silently. This
    // code makes sure that happens. It also eliminates multiple
    // focusin and focusout events from being fired in IE.
    textarea.on('focusin', function (evt) {
      if (focusedElement !== NONE) {
        stopEvent(evt);
      } else {
        focusedElement = TEXTAREA;
        exports.onFocus();
      }
    }).on('focusout', function (evt) {
      if (focusedElement !== TEXTAREA) {
        stopEvent(evt);
      } else {
        focusedElement = NONE;
        exports.onBlur();
      }
    });
  }


  // create a textarea manager that calls callbacks at useful times
  // and exports useful public methods
  return function manageTextarea(textarea, spanarea, opts) {
    var exports = {}
    var keydown = null;
    var keypress = null;

    if (!opts) opts = {};
    var textCallback = opts.text || noop;
    var keyCallback = opts.key || noop;
    var pasteCallback = opts.paste || noop;
    var onCut = opts.cut || noop;

    var target = $(opts.container || textarea);

    // defer() runs fn immediately after the current thread.
    // flush() will run it even sooner, if possible.
    // flush always needs to be called before defer, and is called a
    // few other places besides.
    var timeout, deferredFn;

    function defer(fn) {
      timeout = setTimeout(fn);
      deferredFn = fn;
    }

    function flush() {
      if (timeout) {
        clearTimeout(timeout);
        timeout = undefined;
        deferredFn();
      }
    }

    // -*- public methods -*- //
    exports.onFocus = function () {}
    exports.onBlur = function () {}

    exports.select = function (text) {
      flush();

      textarea.val(text);

      // IE throws error if you try to select an unfocused textarea
      if (text && document.activeElement === textarea[0]) {
        textarea[0].select();
      }
    }

    if (window.overrideNativeOnscreenKeypad) {
      autoSwitchTextarea(spanarea, textarea, exports);
    } else {
      alwaysUseTextarea(spanarea, textarea, exports);
    }

    target.bind('keydown keypress input keyup focusout paste', flush);

    // -*- helper subroutines -*- //

    // Determine whether there's a selection in the textarea.
    // This will always return false in IE < 9, which don't support
    // HTMLTextareaElement::selection{Start,End}.
    function hasSelection() {
      var dom = textarea[0];

      if (!('selectionStart' in dom)) return false;
      return dom.selectionStart !== dom.selectionEnd;
    }

    function popText(callback) {
      var text = textarea.val();
      textarea.val('');
      if (text) callback(text);
    }

    function handleKey() {
      keyCallback(stringify(keydown), keydown);
    }

    // -*- event handlers -*- //
    function onKeydown(e) {
      keydown = e;
      keypress = null;

      handleKey();
    }

    function onKeypress(e) {
      // call the key handler for repeated keypresses.
      // This excludes keypresses that happen directly
      // after keydown.  In that case, there will be
      // no previous keypress, so we skip it here
      if (keydown && keypress) handleKey();

      keypress = e;

      defer(function() {
        // If there is a selection, the contents of the textarea couldn't
        // possibly have just been typed in.
        // This happens in browsers like Firefox and Opera that fire
        // keypress for keystrokes that are not text entry and leave the
        // selection in the textarea alone, such as Ctrl-C.
        // Note: we assume that browsers that don't support hasSelection()
        // also never fire keypress on keystrokes that are not text entry.
        // This seems reasonably safe because:
        // - all modern browsers including IE 9+ support hasSelection(),
        //   making it extremely unlikely any browser besides IE < 9 won't
        // - as far as we know IE < 9 never fires keypress on keystrokes
        //   that aren't text entry, which is only as reliable as our
        //   tests are comprehensive, but the IE < 9 way to do
        //   hasSelection() is poorly documented and is also only as
        //   reliable as our tests are comprehensive
        // If anything like #40 or #71 is reported in IE < 9, see
        // b1318e5349160b665003e36d4eedd64101ceacd8

        //updated by Eli
        //in Safari, when text is selected inside of the textarea
        //and then a key is pressed, there's a brief moment where
        //the new text is selected. This circumvents that problem, by
        //trying again a moment later
        //this should be a no-op except in Safari
        //NOTE / TODO: this still seems to introduce a problem with vertical
        //alignment. In DCG, try:
        // * type "1"
        // * highlight the "1"
        // * type "/"
        // note that vertical alignment of the icon is broken
        // it's only fixed when another action is taken that changes
        // vertical alignment (i.e. a division inside of one of the
        // division signs)
        if (hasSelection()) {
          setTimeout(function() {
            if (!hasSelection())
              popText(textCallback);
          });
        } else {
          popText(textCallback);
        }

        if (hasSelection()) return;

        popText(textCallback);
      });
    }

    function onBlur() { keydown = keypress = null; }

    function onPaste(e) {
      // browsers are dumb.
      //
      // In Linux, middle-click pasting causes onPaste to be called,
      // when the textarea is not necessarily focused.  We focus it
      // here to ensure that the pasted text actually ends up in the
      // textarea.
      //
      // It's pretty nifty that by changing focus in this handler,
      // we can change the target of the default action.  (This works
      // on keydown too, FWIW).
      //
      // And by nifty, we mean dumb (but useful sometimes).
      textarea.focus();

      defer(function() {
        popText(pasteCallback);
      });
    }

    // -*- attach event handlers -*- //
    target.bind({
      keydown: onKeydown,
      keypress: onKeypress,
      focusout: onBlur,
      cut: onCut,
      paste: onPaste
    });

    // -*- export public methods -*- //
    return exports;
  };
}());
var Parser = P(function(_, _super, Parser) {
  // The Parser object is a wrapper for a parser function.
  // Externally, you use one to parse a string by calling
  //   var result = SomeParser.parse('Me Me Me! Parse Me!');
  // You should never call the constructor, rather you should
  // construct your Parser from the base parsers and the
  // parser combinator methods.

  function parseError(stream, message) {
    if (stream) {
      stream = "'"+stream+"'";
    }
    else {
      stream = 'EOF';
    }

    throw 'Parse Error: '+message+' at '+stream;
  }

  _.init = function(body) { this._ = body; };

  _.parse = function(stream) {
    return this.skip(eof)._(stream, success, parseError);

    function success(stream, result) { return result; }
  };

  // -*- primitive combinators -*- //
  _.or = function(alternative) {
    pray('or is passed a parser', alternative instanceof Parser);

    var self = this;

    return Parser(function(stream, onSuccess, onFailure) {
      return self._(stream, onSuccess, failure);

      function failure(newStream) {
        return alternative._(stream, onSuccess, onFailure);
      }
    });
  };

  _.then = function(next) {
    var self = this;

    return Parser(function(stream, onSuccess, onFailure) {
      return self._(stream, success, onFailure);

      function success(newStream, result) {
        var nextParser = (next instanceof Parser ? next : next(result));
        pray('a parser is returned', nextParser instanceof Parser);
        return nextParser._(newStream, onSuccess, onFailure);
      }
    });
  };

  // -*- optimized iterative combinators -*- //
  _.many = function() {
    var self = this;

    return Parser(function(stream, onSuccess, onFailure) {
      var xs = [];
      while (self._(stream, success, failure));
      return onSuccess(stream, xs);

      function success(newStream, x) {
        stream = newStream;
        xs.push(x);
        return true;
      }

      function failure() {
        return false;
      }
    });
  };

  _.times = function(min, max) {
    if (arguments.length < 2) max = min;
    var self = this;

    return Parser(function(stream, onSuccess, onFailure) {
      var xs = [];
      var result = true;
      var failure;

      for (var i = 0; i < min; i += 1) {
        result = self._(stream, success, firstFailure);
        if (!result) return onFailure(stream, failure);
      }

      for (; i < max && result; i += 1) {
        result = self._(stream, success, secondFailure);
      }

      return onSuccess(stream, xs);

      function success(newStream, x) {
        xs.push(x);
        stream = newStream;
        return true;
      }

      function firstFailure(newStream, msg) {
        failure = msg;
        stream = newStream;
        return false;
      }

      function secondFailure(newStream, msg) {
        return false;
      }
    });
  };

  // -*- higher-level combinators -*- //
  _.result = function(res) { return this.then(succeed(res)); };
  _.atMost = function(n) { return this.times(0, n); };
  _.atLeast = function(n) {
    var self = this;
    return self.times(n).then(function(start) {
      return self.many().map(function(end) {
        return start.concat(end);
      });
    });
  };

  _.map = function(fn) {
    return this.then(function(result) { return succeed(fn(result)); });
  };

  _.skip = function(two) {
    return this.then(function(result) { return two.result(result); });
  };

  // -*- primitive parsers -*- //
  var string = this.string = function(str) {
    var len = str.length;
    var expected = "expected '"+str+"'";

    return Parser(function(stream, onSuccess, onFailure) {
      var head = stream.slice(0, len);

      if (head === str) {
        return onSuccess(stream.slice(len), head);
      }
      else {
        return onFailure(stream, expected);
      }
    });
  };

  var regex = this.regex = function(re) {
    pray('regexp parser is anchored', re.toString().charAt(1) === '^');

    var expected = 'expected '+re;

    return Parser(function(stream, onSuccess, onFailure) {
      var match = re.exec(stream);

      if (match) {
        var result = match[0];
        return onSuccess(stream.slice(result.length), result);
      }
      else {
        return onFailure(stream, expected);
      }
    });
  };

  var succeed = Parser.succeed = function(result) {
    return Parser(function(stream, onSuccess) {
      return onSuccess(stream, result);
    });
  };

  var fail = Parser.fail = function(msg) {
    return Parser(function(stream, _, onFailure) {
      return onFailure(stream, msg);
    });
  };

  var letter = Parser.letter = regex(/^[a-z]/i);
  var letters = Parser.letters = regex(/^[a-z]*/i);
  var digit = Parser.digit = regex(/^[0-9]/);
  var digits = Parser.digits = regex(/^[0-9]*/);
  var whitespace = Parser.whitespace = regex(/^\s+/);
  var optWhitespace = Parser.optWhitespace = regex(/^\s*/);

  var any = Parser.any = Parser(function(stream, onSuccess, onFailure) {
    if (!stream) return onFailure(stream, 'expected any character');

    return onSuccess(stream.slice(1), stream.charAt(0));
  });

  var all = Parser.all = Parser(function(stream, onSuccess, onFailure) {
    return onSuccess('', stream);
  });

  var eof = Parser.eof = Parser(function(stream, onSuccess, onFailure) {
    if (stream) return onFailure(stream, 'expected EOF');

    return onSuccess(stream, stream);
  });
});
/*************************************************
 * Base classes of the MathQuill virtual DOM tree
 *
 * Only doing tree node manipulation via these
 * adopt/ disown methods guarantees well-formedness
 * of the tree.
 ************************************************/

/**
 * MathQuill virtual-DOM tree-node abstract base class
 */
var Node = P(function(_) {
  _.prev = 0;
  _.next = 0;
  _.parent = 0;
  _.firstChild = 0;
  _.lastChild = 0;

  _.children = function() {
    return Fragment(this.firstChild, this.lastChild);
  };

  _.eachChild = function(fn) {
    return this.children().each(fn);
  };

  _.foldChildren = function(fold, fn) {
    return this.children().fold(fold, fn);
  };

  _.adopt = function(parent, prev, next) {
    Fragment(this, this).adopt(parent, prev, next);
    return this;
  };

  _.disown = function() {
    Fragment(this, this).disown();
    return this;
  };
});

/**
 * An entity outside the virtual tree with one-way pointers (so it's only a
 * "view" of part of the tree, not an actual node/entity in the tree) that
 * delimits a doubly-linked list of sibling nodes.
 * It's like a fanfic love-child between HTML DOM DocumentFragment and the Range
 * classes: like DocumentFragment, its contents must be sibling nodes
 * (unlike Range, whose contents are arbitrary contiguous pieces of subtrees),
 * but like Range, it has only one-way pointers to its contents, its contents
 * have no reference to it and in fact may still be in the visible tree (unlike
 * DocumentFragment, whose contents must be detached from the visible tree
 * and have their 'parent' pointers set to the DocumentFragment).
 */
var Fragment = P(function(_) {
  _.first = 0;
  _.last = 0;

  _.init = function(first, last) {
    pray('no half-empty fragments', !first === !last);

    if (!first) return;

    pray('first node is passed to Fragment', first instanceof Node);
    pray('last node is passed to Fragment', last instanceof Node);
    pray('first and last have the same parent',
         first.parent === last.parent);

    this.first = first;
    this.last = last;
  };

  function prayWellFormed(parent, prev, next) {
    pray('a parent is always present', parent);
    pray('prev is properly set up', (function() {
      // either it's empty and next is the first child (possibly empty)
      if (!prev) return parent.firstChild === next;

      // or it's there and its next and parent are properly set up
      return prev.next === next && prev.parent === parent;
    })());

    pray('next is properly set up', (function() {
      // either it's empty and prev is the last child (possibly empty)
      if (!next) return parent.lastChild === prev;

      // or it's there and its next and parent are properly set up
      return next.prev === prev && next.parent === parent;
    })());
  }

  _.adopt = function(parent, prev, next) {
    prayWellFormed(parent, prev, next);

    var self = this;
    self.disowned = false;

    var first = self.first;
    if (!first) return this;

    var last = self.last;

    if (prev) {
      // NB: this is handled in the ::each() block
      // prev.next = first
    } else {
      parent.firstChild = first;
    }

    if (next) {
      next.prev = last;
    } else {
      parent.lastChild = last;
    }

    self.last.next = next;

    self.each(function(el) {
      el.prev = prev;
      el.parent = parent;
      if (prev) prev.next = el;

      prev = el;
    });

    return self;
  };

  _.disown = function() {
    var self = this;
    var first = self.first;

    // guard for empty and already-disowned fragments
    if (!first || self.disowned) return self;

    self.disowned = true;

    var last = self.last;
    var parent = first.parent;

    prayWellFormed(parent, first.prev, first);
    prayWellFormed(parent, last, last.next);

    if (first.prev) {
      first.prev.next = last.next;
    } else {
      parent.firstChild = last.next;
    }

    if (last.next) {
      last.next.prev = first.prev;
    } else {
      parent.lastChild = first.prev;
    }

    return self;
  };

  _.each = function(fn) {
    var self = this;
    var el = self.first;
    if (!el) return self;

    for (;el !== self.last.next; el = el.next) {
      if (fn.call(self, el) === false) break;
    }

    return self;
  };

  _.fold = function(fold, fn) {
    this.each(function(el) {
      fold = fn.call(this, fold, el);
    });

    return fold;
  };
});
/*************************************************
 * Abstract classes of math blocks and commands.
 ************************************************/

var uuid = (function() {
  var id = 0;

  return function() { return id += 1; };
})();

/**
 * Math tree node base class.
 * Some math-tree-specific extensions to Node.
 * Both MathBlock's and MathCommand's descend from it.
 */
var MathElement = P(Node, function(_) {
  _.init = function(obj) {
    this.id = uuid();
    MathElement[this.id] = this;
  };

  _.toString = function() {
    return '[MathElement '+this.id+']';
  };

  _.bubble = function(event /*, args... */) {
    var args = __slice.call(arguments, 1);

    for (var ancestor = this; ancestor; ancestor = ancestor.parent) {
      var res = ancestor[event] && ancestor[event].apply(ancestor, args);
      if (res === false) break;
    }

    return this;
  };

  _.postOrder = function(fn /*, args... */) {
    if (typeof fn === 'string') {
      var methodName = fn;
      fn = function(el) {
        if (methodName in el) el[methodName].apply(el, arguments);
      };
    }

    (function recurse(desc) {
      desc.eachChild(recurse);
      fn(desc);
    })(this);
  };

  _.jQ = $();
  _.jQadd = function(jQ) { this.jQ = this.jQ.add(jQ); };

  this.jQize = function(html) {
    // Sets the .jQ of the entire math subtree rooted at this command.
    // Expects .createBlocks() to have been called already, since it
    // calls .html().
    var jQ = $(html);

    function jQadd(el) {
      if (el.getAttribute) {
        var cmdId = el.getAttribute('mathquill-command-id');
        var blockId = el.getAttribute('mathquill-block-id');
        if (cmdId) MathElement[cmdId].jQadd(el);
        if (blockId) MathElement[blockId].jQadd(el);
      }
    }
    function traverse(el) {
      for (el = el.firstChild; el; el = el.nextSibling) {
        jQadd(el);
        if (el.firstChild) traverse(el);
      }
    }

    for (var i = 0; i < jQ.length; i += 1) {
      jQadd(jQ[i]);
      traverse(jQ[i]);
    }
    return jQ;
  };

  _.finalizeInsert = function() {
    var self = this;
    self.postOrder('finalizeTree');

    // note: this order is important.
    // empty elements need the empty box provided by blur to
    // be present in order for their dimensions to be measured
    // correctly in redraw.
    self.postOrder('blur');

    // adjust context-sensitive spacing
    self.postOrder('respace');
    if (self.next.respace) self.next.respace();
    if (self.prev.respace) self.prev.respace();

    self.postOrder('redraw');
    self.bubble('redraw');
    self.bubble('redraw');
  };

  _.seek = function(cursor, clientX, clientY, root, clientRect) {
    var frontier = [];
    function popClosest() {
      var iClosest, minSqDist = Infinity;
      for (var i = 0; i < frontier.length; i += 1) {
        if (!frontier[i]) continue;
        var sqDist = frontier[i].sqDist;
        if (sqDist < minSqDist) iClosest = i, minSqDist = sqDist;
      }
      var closest = frontier[iClosest];
      frontier[iClosest] = null;
      return closest;
    }
    function seekPoint(node) {
      var pt = node.seekPoint(clientX, clientY, clientRect);
      if (!pt) return;
      var dx = clientX - pt.x, dy = clientY - pt.y;
      frontier.push({ point: pt, sqDist: dx*dx + dy*dy });
    }
    function addNode(node) {
      if (!node) return;
      var rect = clientRect(node);
      var closestX = max(rect.left, min(rect.right, clientX));
      var closestY = max(rect.top, min(rect.bottom, clientY));
      var dx = clientX - closestX, dy = clientY - closestY;
      frontier.push({ node: node, sqDist: dx*dx + dy*dy });
    }
    function addContainer(node) {
      if (node === root) return; // no potential Points outside root container
      var rect = clientRect(node);
      var dist = max(0, min(clientX - rect.left, clientY - rect.top,
                            rect.right - clientX, rect.bottom - clientY));
      frontier.push({ container: node, sqDist: dist * dist });
    }

    seekPoint(this);
    this.eachChild(addNode);
    addContainer(this);
    for (var closest = popClosest(); !closest.point; closest = popClosest()) {
      if (closest.container) {
        var container = closest.container, outer = container.parent;
        seekPoint(outer);
        outer.eachChild(function(n) { if (n !== container) addNode(n); });
        addContainer(outer);
      }
      else {
        seekPoint(closest.node);
        closest.node.eachChild(addNode);
      }
    }
    if (closest.point.next) cursor.insertBefore(closest.point.next)
    else cursor.appendTo(closest.point.parent);
  };
});

/**
 * Commands and operators, like subscripts, exponents, or fractions.
 * Descendant commands are organized into blocks.
 */
var MathCommand = P(MathElement, function(_, _super) {
  _.init = function(ctrlSeq, htmlTemplate, textTemplate) {
    var cmd = this;
    _super.init.call(cmd);

    if (!cmd.ctrlSeq) cmd.ctrlSeq = ctrlSeq;
    if (htmlTemplate) cmd.htmlTemplate = htmlTemplate;
    if (textTemplate) cmd.textTemplate = textTemplate;
  };

  // obvious methods
  _.replaces = function(replacedFragment) {
    replacedFragment.disown();
    this.replacedFragment = replacedFragment;
  };
  _.isEmpty = function() {
    return this.foldChildren(true, function(isEmpty, child) {
      return isEmpty && child.isEmpty();
    });
  };

  _.parser = function() {
    var block = latexMathParser.block;
    var self = this;

    return block.times(self.numBlocks()).map(function(blocks) {
      self.blocks = blocks;

      for (var i = 0; i < blocks.length; i += 1) {
        blocks[i].adopt(self, self.lastChild, 0);
      }

      return self;
    });
  };

  // createBefore(cursor) and the methods it calls
  _.createBefore = function(cursor) {
    var cmd = this;
    var replacedFragment = cmd.replacedFragment;

    cmd.createBlocks();
    MathElement.jQize(cmd.html());
    if (replacedFragment) {
      replacedFragment.adopt(cmd.firstChild, 0, 0);
      replacedFragment.jQ.appendTo(cmd.firstChild.jQ);
    }

    cursor.jQ.before(cmd.jQ);
    cursor.prev = cmd.adopt(cursor.parent, cursor.prev, cursor.next);

    cmd.finalizeInsert(cursor);

    cmd.placeCursor(cursor);
  };
  _.createBlocks = function() {
    var cmd = this,
      numBlocks = cmd.numBlocks(),
      blocks = cmd.blocks = Array(numBlocks);

    for (var i = 0; i < numBlocks; i += 1) {
      var newBlock = blocks[i] = MathBlock();
      newBlock.adopt(cmd, cmd.lastChild, 0);
    }
  };
  _.respace = noop; //placeholder for context-sensitive spacing
  _.placeCursor = function(cursor) {
    //append the cursor to the first empty child, or if none empty, the last one
    cursor.appendTo(this.foldChildren(this.firstChild, function(prev, child) {
      return prev.isEmpty() ? prev : child;
    }));
  };

  _.seekPoint = noop;
  _.expectedCursorYNextTo = function(clientRect) {
    return this.firstChild.expectedCursorYInside(clientRect);
  };

  // remove()
  _.remove = function() {
    this.disown()
    this.jQ.remove();

    this.postOrder(function(el) { delete MathElement[el.id]; });

    return this;
  };

  // methods involved in creating and cross-linking with HTML DOM nodes
  /*
    They all expect an .htmlTemplate like
      '<span>&0</span>'
    or
      '<span><span>&0</span><span>&1</span></span>'

    See html.test.js for more examples.

    Requirements:
    - For each block of the command, there must be exactly one "block content
      marker" of the form '&<number>' where <number> is the 0-based index of the
      block. (Like the LaTeX \newcommand syntax, but with a 0-based rather than
      1-based index, because JavaScript because C because Dijkstra.)
    - The block content marker must be the sole contents of the containing
      element, there can't even be surrounding whitespace, or else we can't
      guarantee sticking to within the bounds of the block content marker when
      mucking with the HTML DOM.
    - The HTML not only must be well-formed HTML (of course), but also must
      conform to the XHTML requirements on tags, specifically all tags must
      either be self-closing (like '<br/>') or come in matching pairs.
      Close tags are never optional.

    Note that &<number> isn't well-formed HTML; if you wanted a literal '&123',
    your HTML template would have to have '&amp;123'.
  */
  _.numBlocks = function() {
    var matches = this.htmlTemplate.match(/&\d+/g);
    return matches ? matches.length : 0;
  };
  _.html = function() {
    // Render the entire math subtree rooted at this command, as HTML.
    // Expects .createBlocks() to have been called already, since it uses the
    // .blocks array of child blocks.
    //
    // See html.test.js for example templates and intended outputs.
    //
    // Given an .htmlTemplate as described above,
    // - insert the mathquill-command-id attribute into all top-level tags,
    //   which will be used to set this.jQ in .jQize().
    //   This is straightforward:
    //     * tokenize into tags and non-tags
    //     * loop through top-level tokens:
    //         * add #cmdId attribute macro to top-level self-closing tags
    //         * else add #cmdId attribute macro to top-level open tags
    //             * skip the matching top-level close tag and all tag pairs
    //               in between
    // - for each block content marker,
    //     + replace it with the contents of the corresponding block,
    //       rendered as HTML
    //     + insert the mathquill-block-id attribute into the containing tag
    //   This is even easier, a quick regex replace, since block tags cannot
    //   contain anything besides the block content marker.
    //
    // Two notes:
    // - The outermost loop through top-level tokens should never encounter any
    //   top-level close tags, because we should have first encountered a
    //   matching top-level open tag, all inner tags should have appeared in
    //   matching pairs and been skipped, and then we should have skipped the
    //   close tag in question.
    // - All open tags should have matching close tags, which means our inner
    //   loop should always encounter a close tag and drop nesting to 0. If
    //   a close tag is missing, the loop will continue until i >= tokens.length
    //   and token becomes undefined. This will not infinite loop, even in
    //   production without pray(), because it will then TypeError on .slice().

    var cmd = this;
    var blocks = cmd.blocks;
    var cmdId = ' mathquill-command-id=' + cmd.id;
    var tokens = cmd.htmlTemplate.match(/<[^<>]+>|[^<>]+/g);

    pray('no unmatched angle brackets', tokens.join('') === this.htmlTemplate);

    // add cmdId to all top-level tags
    for (var i = 0, token = tokens[0]; token; i += 1, token = tokens[i]) {
      // top-level self-closing tags
      if (token.slice(-2) === '/>') {
        tokens[i] = token.slice(0,-2) + cmdId + '/>';
      }
      // top-level open tags
      else if (token.charAt(0) === '<') {
        pray('not an unmatched top-level close tag', token.charAt(1) !== '/');

        tokens[i] = token.slice(0,-1) + cmdId + '>';

        // skip matching top-level close tag and all tag pairs in between
        var nesting = 1;
        do {
          i += 1, token = tokens[i];
          pray('no missing close tags', token);
          // close tags
          if (token.slice(0,2) === '</') {
            nesting -= 1;
          }
          // non-self-closing open tags
          else if (token.charAt(0) === '<' && token.slice(-2) !== '/>') {
            nesting += 1;
          }
        } while (nesting > 0);
      }
    }
    return tokens.join('').replace(/>&(\d+)/g, function($0, $1) {
      return ' mathquill-block-id=' + blocks[$1].id + '>' + blocks[$1].join('html');
    });
  };

  // methods to export a string representation of the math tree
  _.latex = function() {
    return this.foldChildren(this.ctrlSeq, function(latex, child) {
      return latex + '{' + (child.latex() || ' ') + '}';
    });
  };
  _.textTemplate = [''];
  _.text = function() {
    var i = 0;
    return this.foldChildren(this.textTemplate[i], function(text, child) {
      i += 1;
      var child_text = child.text();
      if (text && this.textTemplate[i] === '('
          && child_text[0] === '(' && child_text.slice(-1) === ')')
        return text + child_text.slice(1, -1) + this.textTemplate[i];
      return text + child.text() + (this.textTemplate[i] || '');
    });
  };
});

/**
 * Lightweight command without blocks or children.
 */
var Symbol = P(MathCommand, function(_, _super) {
  _.init = function(ctrlSeq, html, text) {
    if (!text) text = ctrlSeq && ctrlSeq.length > 1 ? ctrlSeq.slice(1) : ctrlSeq;

    _super.init.call(this, ctrlSeq, html, [ text ]);
  };

  _.parser = function() { return Parser.succeed(this); };
  _.numBlocks = function() { return 0; };

  _.replaces = function(replacedFragment) {
    replacedFragment.remove();
  };
  _.createBlocks = noop;

  _.seek = function(cursor, clientX, clientY, root, clientRect) {
    var rect = clientRect(this), left = rect.left, right = rect.right;
    // insert at whichever side the click was closer to
    if (clientX - left < right - clientX) cursor.insertBefore(this);
    else cursor.insertAfter(this);
  };
  _.expectedCursorYNextTo = function(clientRect) {
    return (clientRect(this).top + clientRect(this).bottom)/2;
  };

  _.latex = function(){ return this.ctrlSeq; };
  _.text = function(){ return this.textTemplate; };
  _.placeCursor = noop;
  _.isEmpty = function(){ return true; };
});

/**
 * Children and parent of MathCommand's. Basically partitions all the
 * symbols and operators that descend (in the Math DOM tree) from
 * ancestor operators.
 */
var MathBlock = P(MathElement, function(_) {
  _.join = function(methodName) {
    return this.foldChildren('', function(fold, child) {
      return fold + child[methodName]();
    });
  };
  _.latex = function() { return this.join('latex'); };
  _.text = function() {
    return this.firstChild === this.lastChild ?
      this.firstChild.text() :
      '(' + this.join('text') + ')'
    ;
  };
  _.isEmpty = function() {
    return this.firstChild === 0 && this.lastChild === 0;
  };
  _.seekPoint = function(clientX, clientY, clientRect) {
    if (!this.firstChild) {
      var pt = { next: 0, x: (clientRect(this).left + clientRect(this).right)/2 };
    }
    else {
      function pointLeftOf(n) { return { next: n, x: clientRect(n).left }; }
      var pt = pointLeftOf(this.firstChild);
      if (clientX > pt.x) {
        pt = pointLeftOf(this.lastChild);
        var rightwardPt = { next: 0, x: clientRect(pt.next).right };
        while (clientX < pt.x) rightwardPt = pt, pt = pointLeftOf(pt.next.prev);
        if (rightwardPt.x - clientX < clientX - pt.x) pt = rightwardPt;
      }
    }
    return { parent: this, next: pt.next,
             x: pt.x, y: this.expectedCursorYInside(clientRect) };
  };
  _.expectedCursorYInside = function(clientRect) {
    if (this.firstChild) return this.firstChild.expectedCursorYNextTo(clientRect);
    else return (clientRect(this).top + clientRect(this).bottom)/2;
  };
  _.focus = function() {
    this.jQ.addClass('mq-hasCursor');
    this.jQ.removeClass('mq-empty');

    return this;
  };
  _.blur = function() {
    this.jQ.removeClass('mq-hasCursor');
    if (this.isEmpty())
      this.jQ.addClass('mq-empty');

    return this;
  };
});

/**
 * Math tree fragment base class.
 * Some math-tree-specific extensions to Fragment.
 */
var MathFragment = P(Fragment, function(_, _super) {
  _.init = function(first, last) {
    // just select one thing if only one argument
    _super.init.call(this, first, last || first);
    this.jQ = this.fold($(), function(jQ, child){ return child.jQ.add(jQ); });
  };
  _.latex = function() {
    return this.fold('', function(latex, el){ return latex + el.latex(); });
  };
  _.remove = function() {
    this.jQ.remove();

    this.each(function(el) {
      el.postOrder(function(desc) {
        delete MathElement[desc.id];
      });
    });

    return this.disown();
  };
});
/*********************************************
 * Root math elements with event delegation.
 ********************************************/

function createRoot(container, root, textbox, editable) {
  var contents = container.contents().detach();

  if (!textbox) {
    container.addClass('mathquill-rendered-math');
  }

  root.jQ = $('<span class="mathquill-root-block"/>').appendTo(container.attr(mqBlockId, root.id));
  root.revert = function() {
    container.empty().unbind('.mathquill')
      .removeClass('mathquill-rendered-math mathquill-editable mathquill-textbox')
      .append(contents);
  };

  root.cursor = Cursor(root);

  root.renderLatex(contents.text());
}
function setupTextarea(editable, container, root, cursor) {
  var textareaSpan = root.textarea = $('<span class="mq-textarea"></span>');
  textarea = $(document.createElement('textarea')).appendTo(textareaSpan)
  spanarea = $(document.createElement('span')).appendTo(textareaSpan)

  /******
   * TODO [Han]: Document this
   */
  var textareaSelectionTimeout;
  root.selectionChanged = function() {
    if (textareaSelectionTimeout === undefined) {
      textareaSelectionTimeout = setTimeout(setTextareaSelection);
    }
    forceIERedraw(container[0]);
  };
  function setTextareaSelection() {
    textareaSelectionTimeout = undefined;
    var latex = cursor.selection ? '$'+cursor.selection.latex()+'$' : '';
    root.textareaManager.select(latex);
    root.triggerSpecialEvent('selectionChanged');
  }

  // TODO - this causes issues with IE. I don't think we need it
  // since we prevent text selection with css. Would be best
  // to figure out how to fix this.
  /*
  //prevent native selection except textarea
  container.bind('selectstart.mathquill', function(e) {
    if (e.target !== textarea[0] && e.target !== spanarea[0]) e.preventDefault();
    e.stopPropagation();
  });*/

  hookUpTextarea(editable, container, root, cursor, textarea, spanarea, textareaSpan, setTextareaSelection);
}

function mouseEvents(ultimateRootjQ) {
  //drag-to-select event handling
  ultimateRootjQ.bind('mousedown.mathquill', function(e) {
    e.preventDefault();

    var container = $(e.target);
    if (!container.hasClass('mathquill-editable')) {
      container = container.closest('.mathquill-root-block').parent();
    }
    var root = MathElement[container.attr(mqBlockId) || ultimateRootjQ.attr(mqBlockId)];
    var cursor = root.cursor, blink = cursor.blink;
    var textareaSpan = root.textarea;

    if (root.ignoreMousedownTimeout !== undefined) {
      clearTimeout(root.ignoreMousedownTimeout);
      root.ignoreMousedownTimeout = undefined;
      return;
    }

    var cachedClientRect = cachedClientRectFnForNewCache();
    function mousemove(e) {
      cursor.seek($(e.target), e.clientX, e.clientY, cachedClientRect);

      if (cursor.prev !== anticursor.prev
          || cursor.parent !== anticursor.parent) {
        cursor.selectFrom(anticursor);
      }

      e.preventDefault();
    }

    // docmousemove is attached to the document, so that
    // selection still works when the mouse leaves the window.
    function docmousemove(e) {
      // [Han]: i delete the target because of the way seek works.
      // it will not move the mouse to the target, but will instead
      // just seek those X and Y coordinates.  If there is a target,
      // it will try to move the cursor to document, which will not work.
      // cursor.seek needs to be refactored.
      delete e.target;

      return mousemove(e);
    }

    function mouseup(e) {
      anticursor = undefined;
      cursor.blink = blink;
      if (!cursor.selection) {
        if (root.editable) {
          cursor.show();
        }
        else {
          textareaSpan.detach();
        }
      }

      // delete the mouse handlers now that we're not dragging anymore
      container.unbind('mousemove', mousemove);
      $(e.target.ownerDocument).unbind('mousemove', docmousemove).unbind('mouseup', mouseup);
    }

    cursor.blink = noop;
    cursor.hideHandle().seek($(e.target), e.clientX, e.clientY, cachedClientRect);

    var anticursor = {parent: cursor.parent, prev: cursor.prev, next: cursor.next};

    if (!root.editable && root.blurred) container.prepend(textareaSpan);
    root.textareaManager.focus();
    root.blurred = false;

    container.mousemove(mousemove);
    $(e.target.ownerDocument).mousemove(docmousemove).mouseup(mouseup);
  });
}

function setupTouchHandle(editable, root, cursor) {
  // event handling for touch-draggable handle
  /**
   * Usage:
   * jQ.on('touchstart', firstFingerOnly(function(touchstartCoords) {
   *   return { // either of these are optional:
   *     touchmove: function(touchmoveCoords) {},
   *     touchend: function(touchendCoords) {}
   *   };
   * });
   */
  function firstFingerOnly(ontouchstart) {
    return function(e) {
      e.preventDefault();
      var e = e.originalEvent, target = $(e.target);
      if (e.changedTouches.length < e.touches.length) return; // not first finger
      var touchstart = e.changedTouches[0];
      var handlers = ontouchstart(touchstart) || 0;
      if (handlers.touchmove) {
        target.bind('touchmove', function(e) {
          var touchmove = e.originalEvent.changedTouches[0];
          if (touchmove.id !== touchstart.id) return;
          handlers.touchmove.call(this, touchmove);
        });
      }
      target.bind('touchend', function(e) {
        var touchend = e.originalEvent.changedTouches[0];
        if (touchend.id !== touchstart.id) return;
        if (handlers.touchend) handlers.touchend.call(this, touchend);
        target.unbind('touchmove touchend');
      });
    };
  }
  var blink = cursor.blink;
  cursor.handle.on('touchstart', firstFingerOnly(function(e) {
    cursor.blink = noop;
    var cursorRect = cursor.jQ[0].getBoundingClientRect();
    var offsetX = e.clientX - cursorRect.left;
    var offsetY = e.clientY - (cursorRect.top + cursorRect.bottom)/2;
    var cachedClientRect = cachedClientRectFnForNewCache();
    var onAnimationEnd;
    root.onAnimationEnd = function() { onAnimationEnd(); };
    return {
      touchmove: function(e) {
        var adjustedX = e.clientX - offsetX, adjustedY = e.clientY - offsetY;
        cursor.seek(elAtPt(adjustedX, adjustedY, root), adjustedX, adjustedY, cachedClientRect, true);
        visualHapticFeedback();
        onAnimationEnd = visualHapticFeedback;

        function visualHapticFeedback() {
          var cursorRect = cursor.jQ[0].getBoundingClientRect();
          cursor.repositionHandle(cursorRect);

          var dx = adjustedX - cursorRect.left;
          var dy = adjustedY - (cursorRect.top + cursorRect.bottom)/2;
          var dist = Math.sqrt(dx*dx + dy*dy);
          var weight = (Math.log(dist)+1)/dist;
          var skewX = Math.atan2(weight*dx, offsetY);
          var scaleY = (weight*dy + offsetY)/offsetY;
          var steeperScale = 2*(scaleY - 1) + 1;
          cursor.handle.css({
            WebkitTransform: 'translateX(.5px) skewX('+skewX+'rad) scaleY('+scaleY+')',
            opacity: 1 - steeperScale*.5
          });
        }
      },
      touchend: function(e) {
        cursor.handle.css({ WebkitTransform: '', opacity: '' });
        cursor.blink = blink;
        cursor.show(true);
        onAnimationEnd = function() {
          cursor.repositionHandle(cursor.jQ[0].getBoundingClientRect());
          cursor.handle.css({ WebkitTransform: '', opacity: '' });
          delete root.onAnimationEnd;
        };
      }
    };
  }));
}

function hookUpTextarea(editable, container, root, cursor, textarea, spanarea, textareaSpan, setTextareaSelection) {
  if (!editable) {
    root.blurred = true;
    root.textareaManager = manageTextarea(textarea, spanarea, { container: container });
    container.bind('copy', setTextareaSelection)
      .prepend('<span class="mq-selectable">$'+root.latex()+'$</span>');
    textarea.bind('cut paste', false).blur(function() {
      cursor.clearSelection();
      setTimeout(detach); //detaching during blur explodes in WebKit
    });
    function detach() {
      textareaSpan.detach();
      root.blurred = true;
    }
    return;
  }

  root.textareaManager = manageTextarea(textarea, spanarea, {
    container: container,
    key: function(key, evt) {
      cursor.parent.bubble('onKey', key, evt);
    },
    text: function(text) {
      cursor.parent.bubble('onText', text);
    },
    cut: function(e) {
      if (cursor.selection) {
        setTimeout(function() {
          cursor.prepareEdit();
          cursor.parent.bubble('redraw');
          root.triggerSpecialEvent('render');
        });
      }

      e.stopPropagation();
      root.triggerSpecialEvent('render');
    },
    paste: function(text) {
      // FIXME HACK the parser in RootTextBlock needs to be moved to
      // Cursor::writeLatex or something so this'll work with
      // MathQuill textboxes
      if (text.slice(0,1) === '$' && text.slice(-1) === '$') {
        text = text.slice(1, -1);
      }

      cursor.writeLatex(text).show();
      root.triggerSpecialEvent('render');
    }
  });

  container.prepend(textareaSpan);
}

function rootCSSClasses(container, textbox) {
  container.addClass('mathquill-editable');
  if (textbox)
    container.addClass('mathquill-textbox');
}

function focusBlurEvents(root, cursor) {
  root.textareaManager.onFocus = function () {
    root.blurred = false;
    if (!cursor.parent)
      cursor.appendTo(root);
    cursor.parent.jQ.addClass('mq-hasCursor');
    if (cursor.selection) {
      cursor.selection.jQ.removeClass('mq-blur');
      setTimeout(root.selectionChanged); //re-select textarea contents after tabbing away and back
    }
    else {
      cursor.show();
    }
  };

  root.textareaManager.onBlur = function () {
    root.blurred = true;
    cursor.hide().parent.blur();
    if (cursor.selection) {
      cursor.selection.jQ.addClass('mq-blur');
    }
  };

  root.textareaManager.onBlur()
}

function desmosCustomEvents(container, root, cursor) {
  container.bind('select_all', function(e) {
    cursor.prepareMove().appendTo(root);
    while (cursor.prev) cursor.selectLeft();
  })
  .bind('custom_paste', function(e, text) {
    if (text.slice(0,1) === '$' && text.slice(-1) === '$') {
      text = text.slice(1, -1);
    }

    cursor.writeLatex(text).show();
    root.triggerSpecialEvent('render');
  });
}

function elAtPt(clientX, clientY, root) {
  var el = document.elementFromPoint(clientX, clientY);
  return $.contains(root.jQ[0], el) ? $(el) : root.jQ;
}
function cachedClientRectFnForNewCache() {
  var cache = {};
  function elById(el, id) {
    if (!cache[id]) {
      pray('only called within Cursor::seek', 'scrollLeft' in cachedClientRect);
      var rect = el.getBoundingClientRect(), dx = cachedClientRect.scrollLeft;
      cache[id] = { top: rect.top, right: rect.right + dx,
                    bottom: rect.bottom, left: rect.left + dx };
    }
    return cache[id];
  };
  function cachedClientRect(node) { return elById(node.jQ[0], node.id); };
  cachedClientRect.elById = elById;
  return cachedClientRect;
}

var RootMathBlock = P(MathBlock, function(_, _super) {
  _.latex = function() {
    return _super.latex.call(this).replace(/(\\[a-z]+) (?![a-z])/ig,'$1');
  };
  _.text = function() {
    return this.foldChildren('', function(text, child) {
      return text + child.text();
    });
  };
  _.renderLatex = function(latex) {
    var all = Parser.all;
    var eof = Parser.eof;

    var block = latexMathParser.skip(eof).or(all.result(false)).parse(latex);
    this.firstChild = this.lastChild = 0;
    if (block) {
      block.children().adopt(this, 0, 0);
    }

    var jQ = this.jQ;

    if (block) {
      var html = block.join('html');
      jQ.html(html);
      MathElement.jQize(jQ);
      this.focus().finalizeInsert();
    }
    else {
      jQ.empty();
    }

    this.cursor.appendTo(this);
  };
  _.renderSliderLatex = function(latex) {
    function makeCmd(ch) {
      var cmd;
      var code = ch.charCodeAt(0);
      if ((65 <= code && code <= 90) || (97 <= code && code <= 122))
        cmd = Variable(ch);
      else {
        if (CharCmds[ch] || LatexCmds[ch])
          cmd = (CharCmds[ch] || LatexCmds[ch])(ch);
        else {
          cmd = VanillaSymbol(ch);
        }
      }
      return cmd;
    }

    // valid assignment left-hand-sides: https://github.com/desmosinc/knox/blob/27709c6066a544f160123a6bd775829ec8cd7080/frontend/desmos/publicgrapher/jison/latex.jison#L13-L15
    var matches = /^([a-z])(?:_([a-z0-9]|\{[a-z0-9]+\}))?=([-0-9.]+)$/i.exec(latex);

    pray('valid restricted slider LaTeX', matches);
    var letter = matches[1];
    var subscript = matches[2];
    var value = matches[3];

    this.firstChild = this.lastChild = 0;

    letter = Variable(letter);

    if (subscript) {
      var sub = LatexCmds._('_');
      var subBlock = MathBlock().adopt(sub, 0, 0);
      sub.blocks = [ subBlock ];
      if (subscript.length === 1) {
        makeCmd(subscript).adopt(subBlock, subBlock.lastChild, 0);
      }
      else {
        for (var i = 1; i < subscript.length - 1; i += 1) {
          makeCmd(subscript.charAt(i)).adopt(subBlock, subBlock.lastChild, 0);
        }
      }
    }

    letter.adopt(this, this.lastChild, 0);
    if (sub) sub.adopt(this, this.lastChild, 0);
    LatexCmds['=']('=').adopt(this, this.lastChild, 0);
    for (var i = 0, l = value.length; i < l; i += 1) {
      var ch = value.charAt(i);
      var cmd = makeCmd(ch);
      cmd.adopt(this, this.lastChild, 0);
    }

    var jQ = this.jQ;

    var html = this.join('html');
    jQ.html(html);
    MathElement.jQize(jQ);
    //this.finalizeInsert();

    this.cursor.parent = this;
    this.cursor.prev = this.lastChild;
    this.cursor.next = 0;
  };
  _.up = function() { this.triggerSpecialEvent('upPressed'); };
  _.down = function() { this.triggerSpecialEvent('downPressed'); };
  _.moveOutOf = function(dir) { this.triggerSpecialEvent(dir+'Pressed'); };
  _.onKey = function(key, e) {
    switch (key) {
    case 'Ctrl-Shift-Backspace':
    case 'Ctrl-Backspace':
      while (this.cursor.prev || this.cursor.selection) {
        this.cursor.backspace();
      }
      break;

    case 'Shift-Backspace':
    case 'Backspace':
      this.cursor.backspace();
      this.triggerSpecialEvent('render');
      break;

    // Tab or Esc -> go one block right if it exists, else escape right.
    case 'Esc':
    case 'Tab':
      var parent = this.cursor.parent;
      // cursor is in root editable, continue default
      if (parent === this.cursor.root) return;

      this.cursor.prepareMove();
      if (parent.next) {
        // go one block right
        this.cursor.prependTo(parent.next);
      } else {
        // get out of the block
        this.cursor.insertAfter(parent.parent);
      }
      break;

    // Shift-Tab -> go one block left if it exists, else escape left.
    case 'Shift-Tab':
    case 'Shift-Esc':
      var parent = this.cursor.parent;
      //cursor is in root editable, continue default
      if (parent === this.cursor.root) return;

      this.cursor.prepareMove();
      if (parent.prev) {
        // go one block left
        this.cursor.appendTo(parent.prev);
      } else {
        //get out of the block
        this.cursor.insertBefore(parent.parent);
      }
      break;

    // Prevent newlines from showing up
    case 'Enter': this.triggerSpecialEvent('enterPressed'); break;


    // End -> move to the end of the current block.
    case 'End':
      this.cursor.prepareMove().appendTo(this.cursor.parent);
      break;

    // Ctrl-End -> move all the way to the end of the root block.
    case 'Ctrl-End':
      this.cursor.prepareMove().appendTo(this);
      break;

    // Shift-End -> select to the end of the current block.
    case 'Shift-End':
      while (this.cursor.next) {
        this.cursor.selectRight();
      }
      break;

    // Ctrl-Shift-End -> select to the end of the root block.
    case 'Ctrl-Shift-End':
      while (this.cursor.next || this.cursor.parent !== this) {
        this.cursor.selectRight();
      }
      break;

    // Home -> move to the start of the root block or the current block.
    case 'Home':
      this.cursor.prepareMove().prependTo(this.cursor.parent);
      break;

    // Ctrl-Home -> move to the start of the current block.
    case 'Ctrl-Home':
      this.cursor.prepareMove().prependTo(this);
      break;

    // Shift-Home -> select to the start of the current block.
    case 'Shift-Home':
      while (this.cursor.prev) {
        this.cursor.selectLeft();
      }
      break;

    // Ctrl-Shift-Home -> move to the start of the root block.
    case 'Ctrl-Shift-Home':
      while (this.cursor.prev || this.cursor.parent !== this) {
        this.cursor.selectLeft();
      }
      break;

    case 'Left': this.cursor.moveLeft(); break;
    case 'Shift-Left': this.cursor.selectLeft(); break;
    case 'Ctrl-Left': break;
    case 'Meta-Left': break;

    case 'Right': this.cursor.moveRight(); break;
    case 'Shift-Right': this.cursor.selectRight(); break;
    case 'Ctrl-Right': break;
    case 'Meta-Right': break;

    case 'Up': this.cursor.moveUp(); break;
    case 'Down': this.cursor.moveDown(); break;

    case 'Shift-Up':
      if (this.cursor.prev) {
        while (this.cursor.prev) this.cursor.selectLeft();
      } else {
        this.cursor.selectLeft();
      }

    case 'Shift-Down':
      if (this.cursor.next) {
        while (this.cursor.next) this.cursor.selectRight();
      }
      else {
        this.cursor.selectRight();
      }

    case 'Ctrl-Up': break;
    case 'Meta-Up': break;
    case 'Ctrl-Down': break;
    case 'Meta-Down': break;

    case 'Ctrl-Shift-Del':
    case 'Ctrl-Del':
      while (this.cursor.next || this.cursor.selection) {
        this.cursor.deleteForward();
      }
      this.triggerSpecialEvent('render');
      break;

    case 'Shift-Del':
    case 'Del':
      this.cursor.deleteForward();
      this.triggerSpecialEvent('render');
      break;

    case 'Meta-A':
    case 'Ctrl-A':
      //so not stopPropagation'd at RootMathCommand
      if (this !== this.cursor.root) return;

      this.cursor.prepareMove().appendTo(this);
      while (this.cursor.prev) this.cursor.selectLeft();
      break;

    default:
      this.scrollHoriz();
      return false;
    }
    e.preventDefault();
    this.scrollHoriz();
    return false;
  };
  _.onText = function(ch) {
    this.cursor.write(ch);
    this.triggerSpecialEvent('render');
    this.scrollHoriz();
    return false;
  };
  _.scrollHoriz = function() {
    var cursor = this.cursor, seln = cursor.selection;
    var rootRect = this.jQ[0].getBoundingClientRect();
    if (!seln) {
      if (!cursor.jQ[0]) return;
      var x = cursor.jQ[0].getBoundingClientRect().left;
      if (x > rootRect.right - 20) var scrollBy = x - (rootRect.right - 20);
      else if (x < rootRect.left + 20) var scrollBy = x - (rootRect.left + 20);
      else return;
    }
    else {
      var rect = seln.jQ[0].getBoundingClientRect();
      var overLeft = rect.left - (rootRect.left + 20);
      var overRight = rect.right - (rootRect.right - 20);
      if (seln.first === cursor.next) {
        if (overLeft < 0) var scrollBy = overLeft;
        else if (overRight > 0) {
          if (rect.left - overRight < rootRect.left + 20) var scrollBy = overLeft;
          else var scrollBy = overRight;
        }
        else return;
      }
      else {
        if (overRight > 0) var scrollBy = overRight;
        else if (overLeft < 0) {
          if (rect.right - overLeft > rootRect.right - 20) var scrollBy = overRight;
          else var scrollBy = overLeft;
        }
        else return;
      }
    }
    this.jQ.stop().animate({ scrollLeft: '+=' + scrollBy }, 100, this.onAnimationEnd);
  };

  //triggers a special event occured:
  //  1) pressed up and was at 'top' of equation
  //  2) pressed down and was at 'bottom' of equation
  //  3) pressed backspace and equation was empty
  //  4) the equation was rendered
  //  5) etc
  _.triggerSpecialEvent = function(eventName) {
    var jQ = this.jQ;
    setTimeout(function(){ jQ.trigger(eventName); }, 1);
  };
});

var RootMathCommand = P(MathCommand, function(_, _super) {
  _.init = function(cursor) {
    _super.init.call(this, '$');
    this.cursor = cursor;
  };
  _.htmlTemplate = '<span class="mathquill-rendered-math">&0</span>';
  _.createBlocks = function() {
    this.firstChild =
    this.lastChild =
      RootMathBlock();

    this.blocks = [ this.firstChild ];

    this.firstChild.parent = this;

    var cursor = this.firstChild.cursor = this.cursor;
    this.firstChild.onText = function(ch) {
      if (ch !== '$' || cursor.parent !== this)
        cursor.write(ch);
      else if (this.isEmpty()) {
        cursor.insertAfter(this.parent).backspace()
          .insertNew(VanillaSymbol('\\$','$')).show();
      }
      else if (!cursor.next)
        cursor.insertAfter(this.parent);
      else if (!cursor.prev)
        cursor.insertBefore(this.parent);
      else
        cursor.write(ch);

      return false;
    };
  };
  _.latex = function() {
    return '$' + this.firstChild.latex() + '$';
  };
});

var RootTextBlock = P(MathBlock, function(_) {
  _.renderLatex = function(latex) {
    var self = this
    var cursor = self.cursor;
    self.jQ.children().slice(1).remove();
    self.firstChild = self.lastChild = 0;
    cursor.show().appendTo(self);

    var regex = Parser.regex;
    var string = Parser.string;
    var eof = Parser.eof;
    var all = Parser.all;

    // Parser RootMathCommand
    var mathMode = string('$').then(latexMathParser)
      // because TeX is insane, math mode doesn't necessarily
      // have to end.  So we allow for the case that math mode
      // continues to the end of the stream.
      .skip(string('$').or(eof))
      .map(function(block) {
        // HACK FIXME: this shouldn't have to have access to cursor
        var rootMathCommand = RootMathCommand(cursor);

        rootMathCommand.createBlocks();
        var rootMathBlock = rootMathCommand.firstChild;
        block.children().adopt(rootMathBlock, 0, 0);

        return rootMathCommand;
      })
    ;

    var escapedDollar = string('\\$').result('$');
    var textChar = escapedDollar.or(regex(/^[^$]/)).map(VanillaSymbol);
    var latexText = mathMode.or(textChar).many();
    var commands = latexText.skip(eof).or(all.result(false)).parse(latex);

    if (commands) {
      for (var i = 0; i < commands.length; i += 1) {
        commands[i].adopt(self, self.lastChild, 0);
      }

      var html = self.join('html');
      MathElement.jQize(html).appendTo(self.jQ);

      this.finalizeInsert();
    }
  };
  _.onKey = RootMathBlock.prototype.onKey;
  _.onText = function(ch) {
    this.cursor.prepareEdit();
    if (ch === '$')
      this.cursor.insertNew(RootMathCommand(this.cursor));
    else
      this.cursor.insertNew(VanillaSymbol(ch));

    return false;
  };
  _.scrollHoriz = RootMathBlock.prototype.scrollHoriz;
});
/***************************
 * Commands and Operators.
 **************************/

var CharCmds = {}, LatexCmds = {}; //single character commands, LaTeX commands

var scale, // = function(jQ, x, y) { ... }
//will use a CSS 2D transform to scale the jQuery-wrapped HTML elements,
//or the filter matrix transform fallback for IE 5.5-8, or gracefully degrade to
//increasing the fontSize to match the vertical Y scaling factor.

//ideas from http://github.com/louisremi/jquery.transform.js
//see also http://msdn.microsoft.com/en-us/library/ms533014(v=vs.85).aspx

  forceIERedraw = noop,
  div = document.createElement('div'),
  div_style = div.style,
  transformPropNames = {
    transform:1,
    WebkitTransform:1,
    MozTransform:1,
    OTransform:1,
    msTransform:1
  },
  transformPropName;

for (var prop in transformPropNames) {
  if (prop in div_style) {
    transformPropName = prop;
    break;
  }
}

if (transformPropName) {
  scale = function(jQ, x, y) {
    jQ.css(transformPropName, 'scale('+x+','+y+')');
  };
}
else if ('filter' in div_style) { //IE 6, 7, & 8 fallback, see https://github.com/laughinghan/mathquill/wiki/Transforms
  forceIERedraw = function(el){ el.className = el.className; };
  scale = function(jQ, x, y) { //NOTE: assumes y > x
    x /= (1+(y-1)/2);
    jQ.css('fontSize', y + 'em');
    if (!jQ.hasClass('mq-matrixed-container')) {
      jQ.addClass('mq-matrixed-container')
      .wrapInner('<span class="mq-matrixed"></span>');
    }
    var innerjQ = jQ.children()
    .css('filter', 'progid:DXImageTransform.Microsoft'
        + '.Matrix(M11=' + x + ",SizingMethod='auto expand')"
    );
    function calculateMarginRight() {
      jQ.css('marginRight', (innerjQ.width()-1)*(x-1)/x + 'px');
    }
    calculateMarginRight();
    var intervalId = setInterval(calculateMarginRight);
    $(window).load(function() {
      clearTimeout(intervalId);
      calculateMarginRight();
    });
  };
}
else {
  scale = function(jQ, x, y) {
    jQ.css('fontSize', y + 'em');
  };
}

var Style = P(MathCommand, function(_, _super) {
  _.init = function(ctrlSeq, tagName, attrs) {
    _super.init.call(this, ctrlSeq, '<'+tagName+' '+attrs+'>&0</'+tagName+'>');
  };
});

//fonts
LatexCmds.mathrm = bind(Style, '\\mathrm', 'span', 'class="mq-roman mq-font"');
LatexCmds.mathit = bind(Style, '\\mathit', 'i', 'class="mq-font"');
LatexCmds.mathbf = bind(Style, '\\mathbf', 'b', 'class="mq-font"');
LatexCmds.mathsf = bind(Style, '\\mathsf', 'span', 'class="mq-sans-serif mq-font"');
LatexCmds.mathtt = bind(Style, '\\mathtt', 'span', 'class="mq-monospace mq-font"');
//text-decoration
LatexCmds.underline = bind(Style, '\\underline', 'span', 'class="mq-non-leaf mq-underline"');
LatexCmds.overline = LatexCmds.bar = bind(Style, '\\overline', 'span', 'class="mq-non-leaf mq-overline"');

var SupSub = P(MathCommand, function(_, _super) {
  _.init = function(ctrlSeq, tag, text) {
    _super.init.call(this, ctrlSeq, '<'+tag+' class="mq-non-leaf"><span class="mq-non-leaf mq-'+tag+'">&0</span></'+tag+'>', [ text ]);
  };
  _.finalizeTree = function() {
    //TODO: use inheritance
    pray('SupSub is only _ and ^',
      this.ctrlSeq === '^' || this.ctrlSeq === '_'
    );

    if (this.ctrlSeq === '_') {
      this.down = this.firstChild;
      this.firstChild.up = insertBeforeUnlessAtEnd;
    }
    else {
      this.up = this.firstChild;
      this.firstChild.down = insertBeforeUnlessAtEnd;
    }
  };
  function insertBeforeUnlessAtEnd(cursor) {
    // cursor.insertBefore(cmd), unless cursor at the end of block, and every
    // ancestor cmd is at the end of every ancestor block
    var cmd = this.parent, ancestorCmd = cursor;
    do {
      if (ancestorCmd.next) {
        cursor.insertBefore(cmd);
        return false;
      }
      ancestorCmd = ancestorCmd.parent.parent;
    } while (ancestorCmd !== cmd);
    cursor.insertAfter(cmd);
    return false;
  }
  _.latex = function() {
    if (this.ctrlSeq === '_' && this.respaced) return '';

    var latex = '';

    if (this.ctrlSeq === '^' && this.next.respaced) {
      var block = this.next.firstChild.latex();
      if (block.length === 1) latex += '_' + block;
      else latex += '_{' + block + '}';
    }

    var block = this.firstChild.latex();
    if (block.length === 1) latex += this.ctrlSeq + block;
    else latex += this.ctrlSeq + '{' + (block || ' ') + '}';

    return latex;
  };
  _.redraw = function() {
    if (this.prev)
      this.prev.respace();
    //SupSub::respace recursively calls respace on all the following SupSubs
    //so if prev is a SupSub, no need to call respace on this or following nodes
    if (!(this.prev instanceof SupSub)) {
      this.respace();
      //and if next is a SupSub, then this.respace() will have already called
      //this.next.respace()
      if (this.next && !(this.next instanceof SupSub))
        this.next.respace();
    }
  };
  _.respace = function() {
    if (
      this.prev.ctrlSeq === '\\int ' || (
        this.prev instanceof SupSub && this.prev.ctrlSeq != this.ctrlSeq
        && this.prev.prev && this.prev.prev.ctrlSeq === '\\int '
      )
    ) {
      if (!this['int']) {
        this['int'] = true;
        this.jQ.addClass('mq-int');
      }
    }
    else {
      if (this['int']) {
        this['int'] = false;
        this.jQ.removeClass('mq-int');
      }
    }

    this.respaced = this.prev instanceof SupSub && this.prev.ctrlSeq != this.ctrlSeq && !this.prev.respaced;
    if (this.respaced) {
      var fontSize = +this.jQ.css('fontSize').slice(0,-2),
        prevWidth = this.prev.jQ.outerWidth(),
        thisWidth = this.jQ.outerWidth();
      this.jQ.css({
        left: (this['int'] && this.ctrlSeq === '_' ? -.25 : 0) - prevWidth/fontSize + 'em',
        marginRight: .1 - min(thisWidth, prevWidth)/fontSize + 'em'
          //1px extra so it doesn't wrap in retarded browsers (Firefox 2, I think)
      });
    }
    else if (this['int'] && this.ctrlSeq === '_') {
      this.jQ.css({
        left: '-.25em',
        marginRight: ''
      });
    }
    else {
      this.jQ.css({
        left: '',
        marginRight: ''
      });
    }

    if (this.respaced) {
      if (this.ctrlSeq === '^') this.down = this.firstChild.down = this.prev.firstChild;
      else this.up = this.firstChild.up = this.prev.firstChild;
    }
    else if (this.next.respaced) {
      if (this.ctrlSeq === '_') this.up = this.firstChild.up = this.next.firstChild;
      else this.down = this.firstChild.down = this.next.firstChild;
    }
    else {
      if (this.ctrlSeq === '_') {
        delete this.up;
        this.firstChild.up = insertBeforeUnlessAtEnd;
      }
      else {
        delete this.down;
        this.firstChild.down = insertBeforeUnlessAtEnd;
      }
    }

    if (this.next instanceof SupSub)
      this.next.respace();

    return this;
  };

  _.onKey = function(key, e) {
    if (this.getCursor().parent.parent !== this) return;

    switch (key) {
    case 'Tab':
      if (this.next.respaced) {
        this.getCursor().prepareMove().prependTo(this.next.firstChild);
        e.preventDefault();
        return false;
      }
      break;
    case 'Shift-Tab':
      if (this.respaced) {
        this.getCursor().prepareMove().appendTo(this.prev.firstChild);
        e.preventDefault();
        return false;
      }
      break;
    case 'Left':
      if (!this.getCursor().prev && this.respaced) {
        this.getCursor().prepareMove().insertBefore(this.prev);
        return false;
      }
      break;
    case 'Right':
      if (!this.getCursor().next && this.next.respaced) {
        this.getCursor().prepareMove().insertAfter(this.next);
        return false;
      }
    }
  };
  _.getCursor = function() {
    var cursor;
    for (var ancestor = this.parent; !cursor; ancestor = ancestor.parent) {
      cursor = ancestor.cursor;
    }
    this.getCursor = function() { return cursor; };
    return this.getCursor();
  };
  _.expectedCursorYNextTo = function(clientRect) {
    // superscripts and subscripts are vertical-align-ed +/- 0.5em, so
    // their bottom or top edge almost perfectly aligns with the
    // cursor's center
    if (this.ctrlSeq === '_') return clientRect(this).top;
    else return clientRect(this).bottom;
  };
});

LatexCmds.subscript =
LatexCmds._ = bind(SupSub, '_', 'sub', '_');

LatexCmds.superscript =
LatexCmds.supscript =
LatexCmds['^'] = bind(SupSub, '^', 'sup', '**');

var BigSymbol = P(MathCommand, function(_, _super) {
  _.init = function(ch, html) {
    var htmlTemplate =
        '<span class="mq-large-operator mq-non-leaf">'
      +   '<span class="mq-to"><span>&1</span></span>'
      +   '<big>'+html+'</big>'
      +   '<span class="mq-from"><span>&0</span></span>'
      + '</span>'
    ;
    Symbol.prototype.init.call(this, ch, htmlTemplate);
  };
  _.placeCursor = function(cursor) {
    cursor.appendTo(this.firstChild).writeLatex('n=').show();
  };
  _.latex = function() {
    function simplify(latex) {
      return latex.length === 1 ? latex : '{' + (latex || ' ') + '}';
    }
    return this.ctrlSeq + '_' + simplify(this.firstChild.latex()) +
      '^' + simplify(this.lastChild.latex());
  };
  _.parser = function() {
    var string = Parser.string;
    var optWhitespace = Parser.optWhitespace;
    var succeed = Parser.succeed;
    var block = latexMathParser.block;

    var self = this;
    var blocks = self.blocks = [ MathBlock(), MathBlock() ];
    for (var i = 0; i < blocks.length; i += 1) {
      blocks[i].adopt(self, self.lastChild, 0);
    }

    return optWhitespace.then(string('_').or(string('^'))).then(function(supOrSub) {
      var child = blocks[supOrSub === '_' ? 0 : 1];
      return block.then(function(block) {
        block.children().adopt(child, child.lastChild, 0);
        return succeed(self);
      });
    }).many().result(self);
  };
  _.finalizeTree = function() {
    this.down = this.firstChild;
    this.firstChild.up = insertAfterUnlessAtBeginning;
    this.up = this.lastChild;
    this.lastChild.down = insertAfterUnlessAtBeginning;
  };
  function insertAfterUnlessAtBeginning(cursor) {
    // cursor.insertAfter(cmd), unless cursor at the beginning of block, and every
    // ancestor cmd is at the beginning of every ancestor block
    var cmd = this.parent, ancestorCmd = cursor;
    do {
      if (ancestorCmd.prev) {
        cursor.insertAfter(cmd);
        return false;
      }
      ancestorCmd = ancestorCmd.parent.parent;
    } while (ancestorCmd !== cmd);
    cursor.insertBefore(cmd);
    return false;
  }
});
LatexCmds['\u2211'] = LatexCmds.sum = LatexCmds.summation = LatexCmds.Sigma = bind(BigSymbol,'\\sum ','&sum;');
LatexCmds['\u220F'] = LatexCmds.prod = LatexCmds.product = LatexCmds.Pi = bind(BigSymbol,'\\prod ','&prod;');

var Fraction =
LatexCmds.frac =
LatexCmds.dfrac =
LatexCmds.cfrac =
LatexCmds.fraction = P(MathCommand, function(_, _super) {
  _.ctrlSeq = '\\frac';
  _.htmlTemplate =
      '<span class="mq-fraction mq-non-leaf">'
    +   '<span class="mq-numerator">&0</span>'
    +   '<span class="mq-denominator">&1</span>'
    +   '<span style="display:inline-block;width:0;overflow:hidden">&nbsp;</span>'
    + '</span>'
  ;
  _.textTemplate = ['(', '/', ')'];
  _.finalizeTree = function() {
    this.up = this.lastChild.up = this.firstChild;
    this.down = this.firstChild.down = this.lastChild;
  };
  _.expectedCursorYNextTo = function(clientRect) {
    // vertical-align-ed -0.5em, so the top edge of the span that sets
    // the baseline almost perfectly aligns with the cursor's center
    return clientRect.elById(this.jQ[0].lastChild, this.id+.5).top;
  };
});

var LiveFraction =
LatexCmds.over =
CharCmds['/'] = P(Fraction, function(_, _super) {
  _.createBefore = function(cursor) {
    if (!this.replacedFragment) {
      var prev = cursor.prev;
      if (prev instanceof TextBlock || prev instanceof Fraction) {
        prev = prev.prev;
      }
      else {
        while (prev &&
          !(
            prev instanceof BinaryOperator ||
            prev instanceof TextBlock ||
            prev instanceof BigSymbol ||
            prev instanceof Fraction ||
            prev.ctrlSeq === ',' ||
            prev.ctrlSeq === ':' ||
            prev.ctrlSeq === '\\space '
          ) //lookbehind for operator
        )
          prev = prev.prev;

        if (prev instanceof BigSymbol && prev.next instanceof SupSub) {
          prev = prev.next;
          if (prev.next instanceof SupSub && prev.next.ctrlSeq != prev.ctrlSeq)
            prev = prev.next;
        }
      }

      if (prev !== cursor.prev) {
        this.replaces(MathFragment(prev.next || cursor.parent.firstChild, cursor.prev));
        cursor.prev = prev;
      }
    }
    _super.createBefore.call(this, cursor);
  };
});

var SquareRoot =
LatexCmds.sqrt =
LatexCmds[''] = P(MathCommand, function(_, _super) {
  _.ctrlSeq = '\\sqrt';
  _.htmlTemplate =
      '<span class="mq-non-leaf">'
    +   '<span class="mq-scaled mq-sqrt-prefix">&radic;</span>'
    +   '<span class="mq-non-leaf mq-sqrt-stem">&0</span>'
    + '</span>'
  ;
  _.textTemplate = ['sqrt(', ')'];
  _.parser = function() {
    return latexMathParser.optBlock.then(function(optBlock) {
      return latexMathParser.block.map(function(block) {
        var nthroot = NthRoot();
        nthroot.blocks = [ optBlock, block ];
        optBlock.adopt(nthroot, 0, 0);
        block.adopt(nthroot, optBlock, 0);
        return nthroot;
      });
    }).or(_super.parser.call(this));
  };
  _.redraw = function() {
    var block = this.lastChild.jQ;
    scale(block.prev(), 1, block.innerHeight()/+block.css('fontSize').slice(0,-2) - .1);
  };
});


var NthRoot =
LatexCmds.nthroot = P(SquareRoot, function(_, _super) {
  _.htmlTemplate =
      '<sup class="mq-nthroot mq-non-leaf">&0</sup>'
    + '<span class="mq-scaled">'
    +   '<span class="mq-sqrt-prefix mq-scaled">&radic;</span>'
    +   '<span class="mq-sqrt-stem mq-non-leaf">&1</span>'
    + '</span>'
  ;
  _.textTemplate = ['sqrt[', '](', ')'];
  _.latex = function() {
    return '\\sqrt['+this.firstChild.latex()+']{'+this.lastChild.latex()+'}';
  };
  _.onKey = function(key, e) {
    if (this.getCursor().parent.parent !== this) return;

    switch (key) {
    case 'Right':
      if (this.getCursor().next) return;
    case 'Tab':
      if (this.getCursor().parent === this.firstChild) {
        this.getCursor().prepareMove().prependTo(this.lastChild);
        e.preventDefault();
        return false;
      }
      break;
    case 'Left':
      if (this.getCursor().prev) return;
    case 'Shift-Tab':
      if (this.getCursor().parent === this.lastChild) {
        this.getCursor().prepareMove().appendTo(this.firstChild);
        e.preventDefault();
        return false;
      }
    }
  };
  _.getCursor = SupSub.prototype.getCursor;
  _.expectedCursorYNextTo = function(clientRect) {
    // superscripts are vertical-align-ed 0.5em, so their bottom edge
    // almost perfectly aligns with the cursor's center
    return clientRect.elById(this.jQ[0], this.id+.5).bottom;
  };
});

// Round/Square/Curly/Angle Brackets (aka Parens/Brackets/Braces)
var Bracket = P(MathCommand, function(_, _super) {
  _.init = function(open, close, ctrlSeq, end) {
    _super.init.call(this, '\\left'+ctrlSeq,
        '<span class="mq-non-leaf">'
      +   '<span class="mq-scaled mq-paren">'+open+'</span>'
      +   '<span class="mq-non-leaf">&0</span>'
      +   '<span class="mq-scaled mq-paren">'+close+'</span>'
      + '</span>',
      [open, close]);
    this.end = '\\right'+end;
  };
  _.jQadd = function() {
    _super.jQadd.apply(this, arguments);
    var jQ = this.jQ;
    this.bracketjQs = jQ.children(':first').add(jQ.children(':last'));
  };
  //When typed, auto-expand paren to end of block
  _.finalizeTree = function() {
    if (this.firstChild.isEmpty() && this.next) {
      var nextAll = MathFragment(this.next, this.parent.lastChild).disown();
      nextAll.adopt(this.firstChild, 0, 0);
      nextAll.jQ.appendTo(this.firstChild.jQ);
    }
  };
  _.placeCursor = function(cursor) {
    cursor.prependTo(this.firstChild);
  };
  _.latex = function() {
    return this.ctrlSeq + this.firstChild.latex() + this.end;
  };
  _.redraw = function() {
    var blockjQ = this.firstChild.jQ;

    var height = blockjQ.outerHeight()/+blockjQ.css('fontSize').slice(0,-2);

    scale(this.bracketjQs, min(1 + .2*(height - 1), 1.2), 1.05*height);
  };
});

LatexCmds.left = P(MathCommand, function(_) {
  _.parser = function() {
    var regex = Parser.regex;
    var string = Parser.string;
    var regex = Parser.regex;
    var succeed = Parser.succeed;
    var block = latexMathParser.block;
    var optWhitespace = Parser.optWhitespace;

    return optWhitespace.then(regex(/^(?:[([|]|\\\{)/))
      .then(function(open) {
        if (open.charAt(0) === '\\') open = open.slice(1);

        var cmd = CharCmds[open]();

        return latexMathParser
          .map(function (block) {
            cmd.blocks = [ block ];
            block.adopt(cmd, 0, 0);
          })
          .then(string('\\right'))
          .skip(optWhitespace)
          .then(regex(/^(?:[\])|]|\\\})/))
          .then(function(close) {
            if (close.slice(-1) !== cmd.end.slice(-1)) {
              return Parser.fail('open doesn\'t match close');
            }

            return succeed(cmd);
          })
        ;
      })
    ;
  };
});

LatexCmds.right = P(MathCommand, function(_) {
  _.parser = function() {
    return Parser.fail('unmatched \\right');
  };
});

LatexCmds.lbrace =
CharCmds['{'] = bind(Bracket, '{', '}', '\\{', '\\}');
LatexCmds.langle =
LatexCmds.lang = bind(Bracket, '&lang;','&rang;','\\langle ','\\rangle ');

// Closing bracket matching opening bracket above
var CloseBracket = P(Bracket, function(_, _super) {
  _.createBefore = function(cursor) {
    // if I'm replacing a selection fragment, just wrap in parens
    if (this.replacedFragment) return _super.createBefore.call(this, cursor);

    // elsewise, if my parent is a matching open-paren, then close it here,
    // i.e. move everything after me in the open-paren to after the parens
    var openParen = cursor.parent.parent;
    if (openParen.ctrlSeq === this.ctrlSeq) {
      if (cursor.next) {
        var nextAll = MathFragment(cursor.next, openParen.firstChild.lastChild).disown();
        nextAll.adopt(openParen.parent, openParen, openParen.next);
        nextAll.jQ.insertAfter(openParen.jQ);
        if (cursor.next.respace) cursor.next.respace();
      }
      cursor.insertAfter(openParen);
      openParen.bubble('redraw');
    }
    // or if not, make empty paren group and put cursor inside it
    // (I think this behavior is weird - Han)
    else {
      _super.createBefore.call(this, cursor);
      cursor.appendTo(this.firstChild); // FIXME HACK
    }
  };
  _.finalizeTree = noop;
  _.placeCursor = function(cursor) {
    this.firstChild.blur();
    cursor.insertAfter(this);
  };
});

LatexCmds.rbrace =
CharCmds['}'] = bind(CloseBracket, '{','}','\\{','\\}');
LatexCmds.rangle =
LatexCmds.rang = bind(CloseBracket, '&lang;','&rang;','\\langle ','\\rangle ');

var parenMixin = function(_, _super) {
  _.init = function(open, close) {
    _super.init.call(this, open, close, open, close);
  };
};

var Paren = P(Bracket, parenMixin);

LatexCmds.lparen =
CharCmds['('] = bind(Paren, '(', ')');
LatexCmds.lbrack =
LatexCmds.lbracket =
CharCmds['['] = bind(Paren, '[', ']');

var CloseParen = P(CloseBracket, parenMixin);

LatexCmds.rparen =
CharCmds[')'] = bind(CloseParen, '(', ')');
LatexCmds.rbrack =
LatexCmds.rbracket =
CharCmds[']'] = bind(CloseParen, '[', ']');

var Pipes =
LatexCmds.lpipe =
LatexCmds.rpipe =
CharCmds['|'] = P(Paren, function(_, _super) {
  _.init = function() {
    _super.init.call(this, '|', '|');
  }

  _.createBefore = function(cursor) {
    if (!cursor.next && cursor.parent.parent && cursor.parent.parent.end === this.end && !this.replacedFragment)
      cursor.insertAfter(cursor.parent.parent);
    else
      MathCommand.prototype.createBefore.call(this, cursor);
  };
  _.finalizeTree = noop;
});

// DISABLED in DCG
var TextBlock =
LatexCmds.text =
LatexCmds.textnormal =
LatexCmds.textrm =
LatexCmds.textup =
LatexCmds.textmd = P(MathCommand, function(_, _super) {
  _.ctrlSeq = '\\text';
  _.htmlTemplate = '<span class="mq-text">&0</span>';
  _.replaces = function(replacedText) {
    if (replacedText instanceof MathFragment)
      this.replacedText = replacedText.remove().jQ.text();
    else if (typeof replacedText === 'string')
      this.replacedText = replacedText;
  };
  _.textTemplate = ['"', '"'];
  _.parser = function() {
    // TODO: correctly parse text mode
    var string = Parser.string;
    var regex = Parser.regex;
    var optWhitespace = Parser.optWhitespace;
    return optWhitespace
      .then(string('{')).then(regex(/^[^}]*/)).skip(string('}'))
      .map(function(text) {
        var cmd = TextBlock();
        cmd.createBlocks();
        var block = cmd.firstChild;
        for (var i = 0; i < text.length; i += 1) {
          var ch = VanillaSymbol(text.charAt(i));
          ch.adopt(block, block.lastChild, 0);
        }
        return cmd;
      })
    ;
  };
  _.createBlocks = function() {
    //FIXME: another possible Law of Demeter violation, but this seems much cleaner, like it was supposed to be done this way
    this.firstChild =
    this.lastChild =
      InnerTextBlock();

    this.blocks = [ this.firstChild ];

    this.firstChild.parent = this;
  };
  _.finalizeInsert = function() {
    //FIXME HACK blur removes the TextBlock
    this.firstChild.blur = function() { delete this.blur; return this; };
    _super.finalizeInsert.call(this);
  };
  _.createBefore = function(cursor) {
    _super.createBefore.call(this, this.cursor = cursor);

    if (this.replacedText)
      for (var i = 0; i < this.replacedText.length; i += 1)
        this.write(this.replacedText.charAt(i));
  };
  _.write = function(ch) {
    this.cursor.insertNew(VanillaSymbol(ch));
  };
  _.onKey = function(key, e) {
    //backspace and delete and ends of block don't unwrap
    if (!this.cursor.selection &&
      (
        (key === 'Backspace' && !this.cursor.prev) ||
        (key === 'Del' && !this.cursor.next)
      )
    ) {
      if (this.isEmpty())
        this.cursor.insertAfter(this);

      return false;
    }
  };
  _.onText = function(ch) {
    this.cursor.prepareEdit();
    if (ch !== '$')
      this.write(ch);
    else if (this.isEmpty())
      this.cursor.insertAfter(this).backspace().insertNew(VanillaSymbol('\\$','$'));
    else if (!this.cursor.next)
      this.cursor.insertAfter(this);
    else if (!this.cursor.prev)
      this.cursor.insertBefore(this);
    else { //split apart
      var next = TextBlock(MathFragment(this.cursor.next, this.firstChild.lastChild));
      next.placeCursor = function(cursor) { //FIXME HACK: pretend no prev so they don't get merged
        this.prev = 0;
        delete this.placeCursor;
        this.placeCursor(cursor);
      };
      next.firstChild.focus = function(){ return this; };
      this.cursor.insertAfter(this).insertNew(next);
      next.prev = this;
      this.cursor.insertBefore(next);
      delete next.firstChild.focus;
    }
    this.cursor.root.triggerSpecialEvent('render');
    return false;
  };
});

var InnerTextBlock = P(MathBlock, function(_, _super) {
  _.blur = function() {
    this.jQ.removeClass('mq-hasCursor');
    if (this.isEmpty()) {
      var textblock = this.parent, cursor = textblock.cursor;
      if (cursor.parent === this)
        this.jQ.addClass('mq-empty');
      else {
        cursor.hide();
        textblock.remove();
        if (cursor.next === textblock)
          cursor.next = textblock.next;
        else if (cursor.prev === textblock)
          cursor.prev = textblock.prev;

        cursor.show().parent.bubble('redraw');
      }
    }
    return this;
  };
  _.focus = function() {
    _super.focus.call(this);

    var textblock = this.parent;
    if (textblock.next.ctrlSeq === textblock.ctrlSeq) { //TODO: seems like there should be a better way to move MathElements around
      var innerblock = this,
        cursor = textblock.cursor,
        next = textblock.next.firstChild;

      next.eachChild(function(child){
        child.parent = innerblock;
        child.jQ.appendTo(innerblock.jQ);
      });

      if (this.lastChild)
        this.lastChild.next = next.firstChild;
      else
        this.firstChild = next.firstChild;

      next.firstChild.prev = this.lastChild;
      this.lastChild = next.lastChild;

      next.parent.remove();

      if (cursor.prev)
        cursor.insertAfter(cursor.prev);
      else
        cursor.prependTo(this);

      cursor.parent.bubble('redraw');
    }
    else if (textblock.prev.ctrlSeq === textblock.ctrlSeq) {
      var cursor = textblock.cursor;
      if (cursor.prev)
        textblock.prev.firstChild.focus();
      else
        cursor.appendTo(textblock.prev.firstChild);
    }
    return this;
  };
});


function makeTextBlock(latex, tagName, attrs) {
  return P(TextBlock, {
    ctrlSeq: latex,
    htmlTemplate: '<'+tagName+' '+attrs+'>&0</'+tagName+'>'
  });
}

LatexCmds.em = LatexCmds.italic = LatexCmds.italics =
LatexCmds.emph = LatexCmds.textit = LatexCmds.textsl =
  makeTextBlock('\\textit', 'i', 'class="mq-text"');
LatexCmds.strong = LatexCmds.bold = LatexCmds.textbf =
  makeTextBlock('\\textbf', 'b', 'class="mq-text"');
LatexCmds.sf = LatexCmds.textsf =
  makeTextBlock('\\textsf', 'span', 'class="mq-sans-serif mq-text"');
LatexCmds.tt = LatexCmds.texttt =
  makeTextBlock('\\texttt', 'span', 'class="mq-monospace mq-text"');
LatexCmds.textsc =
  makeTextBlock('\\textsc', 'span', 'style="font-variant:small-caps" class="mq-text"');
LatexCmds.uppercase =
  makeTextBlock('\\uppercase', 'span', 'style="text-transform:uppercase" class="mq-text"');
LatexCmds.lowercase =
  makeTextBlock('\\lowercase', 'span', 'style="text-transform:lowercase" class="mq-text"');

// input box to type a variety of LaTeX commands beginning with a backslash
// DISABLED in DCG
var LatexCommandInput =
P(MathCommand, function(_, _super) {
  _.ctrlSeq = '\\';
  _.replaces = function(replacedFragment) {
    this._replacedFragment = replacedFragment.disown();
    this.isEmpty = function() { return false; };
  };
  _.htmlTemplate = '<span class="mq-latex-command-input mq-non-leaf">\\<span>&0</span></span>';
  _.textTemplate = ['\\'];
  _.createBlocks = function() {
    _super.createBlocks.call(this);
    this.firstChild.focus = function() {
      this.parent.jQ.addClass('mq-hasCursor');
      if (this.isEmpty())
        this.parent.jQ.removeClass('mq-empty');

      return this;
    };
    this.firstChild.blur = function() {
      this.parent.jQ.removeClass('mq-hasCursor');
      if (this.isEmpty())
        this.parent.jQ.addClass('mq-empty');

      return this;
    };
  };
  _.createBefore = function(cursor) {
    _super.createBefore.call(this, cursor);
    this.cursor = cursor.appendTo(this.firstChild);
    if (this._replacedFragment) {
      var el = this.jQ[0];
      this.jQ =
        this._replacedFragment.jQ.addClass('mq-blur').bind(
          'mousedown mousemove', //FIXME: is monkey-patching the mousedown and mousemove handlers the right way to do this?
          function(e) {
            $(e.target = el).trigger(e);
            return false;
          }
        ).insertBefore(this.jQ).add(this.jQ);
    }
  };
  _.latex = function() {
    return '\\' + this.firstChild.latex() + ' ';
  };
  _.onKey = function(key, e) {
    if (key === 'Tab' || key === 'Enter') {
      this.renderCommand();
      this.cursor.root.triggerSpecialEvent('render');
      e.preventDefault();
      return false;
    }
  };
  _.onText = function(ch) {
    if (ch.match(/[a-z]/i)) {
      this.cursor.prepareEdit();
      this.cursor.insertNew(VanillaSymbol(ch));
      return false;
    }
    this.renderCommand();
    if (ch === ' ' || (ch === '\\' && this.firstChild.isEmpty())) {
      this.cursor.root.triggerSpecialEvent('render');
      return false;
    }
  };
  _.renderCommand = function() {
    this.jQ = this.jQ.last();
    this.remove();
    if (this.next) {
      this.cursor.insertBefore(this.next);
    } else {
      this.cursor.appendTo(this.parent);
    }

    var latex = this.firstChild.latex(), cmd;
    if (!latex) latex = 'backslash';
    this.cursor.insertCmd(latex, this._replacedFragment);
  };
});

var Binomial =
LatexCmds.binom =
LatexCmds.binomial = P(MathCommand, function(_, _super) {
  _.ctrlSeq = '\\binom';
  _.htmlTemplate =
      '<span class="mq-paren mq-scaled">(</span>'
    + '<span class="mq-non-leaf">'
    +   '<span class="mq-array mq-non-leaf">'
    +     '<span>&0</span>'
    +     '<span>&1</span>'
    +   '</span>'
    + '</span>'
    + '<span class="mq-paren mq-scaled">)</span>'
  ;
  _.textTemplate = ['choose(',',',')'];
  _.redraw = function() {
    var blockjQ = this.jQ.eq(1);

    var height = blockjQ.outerHeight()/+blockjQ.css('fontSize').slice(0,-2);

    var parens = this.jQ.filter('.mq-paren');
    scale(parens, min(1 + .2*(height - 1), 1.2), 1.05*height);
  };
  // vertical-align: middle, so
  _.expectedCursorYNextTo = Symbol.prototype.expectedCursorYNextTo;
});

var Choose =
LatexCmds.choose = P(Binomial, function(_) {
  _.createBefore = LiveFraction.prototype.createBefore;
});

var Vector =
LatexCmds.vector = P(MathCommand, function(_, _super) {
  _.ctrlSeq = '\\vector';
  _.htmlTemplate = '<span class="mq-array"><span>&0</span></span>';
  _.latex = function() {
    return '\\begin{matrix}' + this.foldChildren([], function(latex, child) {
      latex.push(child.latex());
      return latex;
    }).join('\\\\') + '\\end{matrix}';
  };
  _.text = function() {
    return '[' + this.foldChildren([], function(text, child) {
      text.push(child.text());
      return text;
    }).join() + ']';
  }
  _.createBefore = function(cursor) {
    _super.createBefore.call(this, this.cursor = cursor);
  };
  _.onKey = function(key, e) {
    var currentBlock = this.cursor.parent;

    if (currentBlock.parent === this) {
      if (key === 'Enter') { //enter
        var newBlock = MathBlock();
        newBlock.parent = this;
        newBlock.jQ = $('<span></span>')
          .attr(mqBlockId, newBlock.id)
          .insertAfter(currentBlock.jQ);
        if (currentBlock.next)
          currentBlock.next.prev = newBlock;
        else
          this.lastChild = newBlock;

        newBlock.next = currentBlock.next;
        currentBlock.next = newBlock;
        newBlock.prev = currentBlock;
        this.bubble('redraw').cursor.appendTo(newBlock);

        e.preventDefault();
        return false;
      }
      else if (key === 'Tab' && !currentBlock.next) {
        if (currentBlock.isEmpty()) {
          if (currentBlock.prev) {
            this.cursor.insertAfter(this);
            delete currentBlock.prev.next;
            this.lastChild = currentBlock.prev;
            currentBlock.jQ.remove();
            this.bubble('redraw');

            e.preventDefault();
            return false;
          }
          else
            return;
        }

        var newBlock = MathBlock();
        newBlock.parent = this;
        newBlock.jQ = $('<span></span>').attr(mqBlockId, newBlock.id).appendTo(this.jQ);
        this.lastChild = newBlock;
        currentBlock.next = newBlock;
        newBlock.prev = currentBlock;
        this.bubble('redraw').cursor.appendTo(newBlock);

        e.preventDefault();
        return false;
      }
      else if (e.which === 8) { //backspace
        if (currentBlock.isEmpty()) {
          if (currentBlock.prev) {
            this.cursor.appendTo(currentBlock.prev)
            currentBlock.prev.next = currentBlock.next;
          }
          else {
            this.cursor.insertBefore(this);
            this.firstChild = currentBlock.next;
          }

          if (currentBlock.next)
            currentBlock.next.prev = currentBlock.prev;
          else
            this.lastChild = currentBlock.prev;

          currentBlock.jQ.remove();
          if (this.isEmpty())
            this.cursor.deleteForward();
          else
            this.bubble('redraw');

          e.preventDefault();
          return false;
        }
        else if (!this.cursor.prev) {
          e.preventDefault();
          return false;
        }
      }
    }
  };
  // vertical-align: middle, so
  _.expectedCursorYNextTo = Binomial.prototype.expectedCursorYNextTo;
});

LatexCmds.MathQuillMathField = P(MathCommand, function(_, _super) {
  _.ctrlSeq = '\\MathQuillMathField';
  _.htmlTemplate = '<span class="mathquill-editable">&0</span>';
  _.parser = function() {
    var self = this
    var string = Parser.string, regex = Parser.regex, succeed = Parser.succeed;
    // Note regex that whitelists of valid CSS classname characters:
    // https://github.com/mathquill/mathquill/pull/191#discussion_r4327442
    return string('[').then(regex(/^[-\w\s\\\xA0-\xFF]*/)).skip(string(']'))
      .map(function(classnames) { self.classnames = classnames; })
      .or(succeed()).then(_super.parser.call(self));
  };
  _.finalizeTree = function() {
    // parsed \MathQuillMathField{contents}, `this` is this MathCommand,
    // replace its sole child MathBlock with a RootMathBlock
    var self = this, rootBlock = RootMathBlock();

    delete MathElement[rootBlock.id];
    rootBlock.id = self.firstChild.id;
    MathElement[rootBlock.id] = rootBlock;

    self.firstChild.children().disown().adopt(rootBlock, 0, 0);
    rootBlock.parent = self;
    self.firstChild = self.lastChild = rootBlock;
    self.blocks = [ rootBlock ];

    rootBlock.jQ = self.jQ.wrapInner('<span class="mathquill-root-block"/>').children();

    rootBlock.editable = true;
    var cursor = rootBlock.cursor = Cursor(rootBlock).appendTo(rootBlock);
    setupTextarea(true, self.jQ, rootBlock, cursor);
    setupTouchHandle(true, rootBlock, cursor);
    focusBlurEvents(rootBlock, cursor);
    desmosCustomEvents(self.jQ, rootBlock, cursor);
    self.jQ.addClass(self.classnames);
  };

  _.latex = function(){ return this.firstChild.latex(); };
  _.text = function(){ return this.firstChild.text(); };
});
/**********************************
 * Symbols and Special Characters
 *********************************/

var Variable = P(Symbol, function(_, _super) {
  _.init = function(ch, html) {
    _super.init.call(this, ch, '<var>'+(html || ch)+'</var>');
  }
  _.createBefore = function(cursor) {
    //want the longest possible autocommand, so assemble longest series of letters (Variables) first
    var ctrlSeq = this.ctrlSeq;
    for (var i = 0, prev = cursor.prev; i < MAX_AUTOCMD_LEN - 1 && prev && prev instanceof Variable; i += 1, prev = prev.prev)
      ctrlSeq = prev.ctrlSeq + ctrlSeq;
    //then test if there's an autocommand here, starting with the longest possible and slicing
    while (ctrlSeq.length) {
      if (AutoCmds.hasOwnProperty(ctrlSeq)) {
        for (var i = 1; i < ctrlSeq.length; i += 1) cursor.backspace();
        cursor.insertNew(LatexCmds[ctrlSeq](ctrlSeq));
        return;
      }
      ctrlSeq = ctrlSeq.slice(1);
    }
    _super.createBefore.apply(this, arguments);
  };
  _.respace =
  _.finalizeTree = function() {
    //TODO: in better architecture, should be done in createBefore and backspace
    //respace is called too often, inefficient

    //want the longest possible autocommand, so assemble longest series of letters (Variables)
    var ctrlSeq = this.ctrlSeq;
    if (ctrlSeq.length > 1) return;
    for (var prev = this.prev; prev instanceof Variable && prev.ctrlSeq.length === 1; prev = prev.prev)
      ctrlSeq = prev.ctrlSeq + ctrlSeq;
    for (var next = this.next; next instanceof Variable && next.ctrlSeq.length === 1; next = next.next)
      ctrlSeq += next.ctrlSeq;

    this.isVariable = true;

    //removeClass from all the things before figuring out what's an autocmd, if any
    MathFragment(prev.next || this.parent.firstChild, next.prev || this.parent.lastChild)
    .each(function(el) {
      el.jQ.removeClass('mq-un-italicized mq-last');
      delete el.isFirstLetter;
      delete el.isLastLetter;
    });

    //test if there's an autocommand here, going through substrings from longest to shortest
    outer: for (var i = 0, first = prev.next || this.parent.firstChild; i < ctrlSeq.length; i += 1, first = first.next) {
      for (var len = min(MAX_UNITALICIZED_LEN, ctrlSeq.length - i); len > 0; len -= 1) {
        if (UnItalicizedCmds.hasOwnProperty(ctrlSeq.slice(i, i + len))) {
          first.isFirstLetter = true;
          for (var j = 0, letter = first; j < len; j += 1, letter = letter.next) {
            letter.jQ.addClass('mq-un-italicized');
            letter.isVariable = false;
            var last = letter;
          }
          last.isLastLetter = true;
          if (!(last.next instanceof SupSub || last.next instanceof Bracket))
            last.jQ.addClass('mq-last');
          i += len - 1;
          first = last;
          continue outer;
        }
      }
    }
  };
  _.latex = function() {
    return (
      this.isFirstLetter ? '\\' + this.ctrlSeq :
      this.isLastLetter ? this.ctrlSeq + ' ' :
      this.ctrlSeq
    );
  };
  _.text = function() {
    var text = this.ctrlSeq;
    if (this.prev && !(this.prev instanceof Variable)
        && !(this.prev instanceof BinaryOperator))
      text = '*' + text;
    if (this.next && !(this.next instanceof BinaryOperator)
        && !(this.next.ctrlSeq === '^'))
      text += '*';
    return text;
  };
});

var UnItalicized = P(Symbol, function(_, _super) {
  _.init = function(fn) {
    this.ctrlSeq = fn;
  };
  _.createBefore = function(cursor) {
    cursor.writeLatex(this.ctrlSeq).show();
  };
  _.parser = function() {
    var fn = this.ctrlSeq;
    var block = MathBlock();
    for (var i = 0; i < fn.length; i += 1) {
      Variable(fn.charAt(i)).adopt(block, block.lastChild, 0);
    }
    return Parser.succeed(block.children());
  };
});

//backslashless commands, words where adjacent letters (Variables)
//that form them automatically are turned into commands
var UnItalicizedCmds = {
  mean: 1,
  ln: 1,
  log: 1,
  min: 1,
  nCr: 1,
  nPr: 1,
  gcd: 1,
  lcm: 1,
  mcm: 1,
  mcd: 1,
  ceil: 1,
  exp: 1,
  abs: 1,
  max: 1,
  mod: 1,
  gcf: 1,
  exp: 1,
  floor: 1,
  sign: 1,
  signum: 1,
  round: 1,
  length: 1,
  stdev: 1,
  stddev: 1,
  stdDev: 1,
  stdevp: 1,
  stddevp: 1,
  stdDevP: 1,
  total: 1,
  'var': 1,
  variance: 1
}, MAX_UNITALICIZED_LEN = 9, AutoCmds = {
  sqrt: 1,
  nthroot: 1,
  sum: 1,
  prod: 1,
  pi: 1,
  Pi: 1,
  phi: 1,
  Sigma: 1,
  tau: 1,
  Gamma: 1,
  theta: 1/*,
  int: 1*/
}, MAX_AUTOCMD_LEN = 7;

(function() {
  var trigs = { sin: 1, cos: 1, tan: 1, sec: 1, cosec: 1, csc: 1, cotan: 1, cot: 1, ctg: 1 };
  for (var trig in trigs) {
    UnItalicizedCmds[trig] =
    UnItalicizedCmds['arc'+trig] =
    UnItalicizedCmds[trig+'h'] =
    UnItalicizedCmds['arc'+trig+'h'] = 1;
  }

  for (var fn in UnItalicizedCmds)
    LatexCmds[fn] = UnItalicized;
}());

var VanillaSymbol = P(Symbol, function(_, _super) {
  _.init = function(ch, html) {
    _super.init.call(this, ch, '<span>'+(html || ch)+'</span>');
  };
});

CharCmds[' '] = bind(VanillaSymbol, '\\space ', ' ');

LatexCmds.prime = CharCmds["'"] = bind(VanillaSymbol, "'", '&prime;');

// does not use Symbola font
var NonSymbolaSymbol = P(Symbol, function(_, _super) {
  _.init = function(ch, html) {
    _super.init.call(this, ch, '<span class="mq-nonSymbola">'+(html || ch)+'</span>');
  };
});

LatexCmds['@'] = NonSymbolaSymbol;
LatexCmds['&'] = bind(NonSymbolaSymbol, '\\&', '&amp;');
LatexCmds['%'] = bind(NonSymbolaSymbol, '\\%', '%');

//the following are all Greek to me, but this helped a lot: http://www.ams.org/STIX/ion/stixsig03.html

//lowercase Greek letter variables
LatexCmds.alpha =
LatexCmds.beta =
LatexCmds.gamma =
LatexCmds.delta =
LatexCmds.zeta =
LatexCmds.eta =
LatexCmds.theta =
LatexCmds.iota =
LatexCmds.kappa =
LatexCmds.mu =
LatexCmds.nu =
LatexCmds.xi =
LatexCmds.rho =
LatexCmds.sigma =
LatexCmds.tau =
LatexCmds.chi =
LatexCmds.psi =
LatexCmds.omega = P(Variable, function(_, _super) {
  _.init = function(latex) {
    _super.init.call(this,'\\'+latex+' ','&'+latex+';');
  };
});

//why can't anybody FUCKING agree on these
LatexCmds.phi = //W3C or Unicode?
  bind(Variable,'\\phi ','&#981;');

LatexCmds.phiv = //Elsevier and 9573-13
LatexCmds.varphi = //AMS and LaTeX
  bind(Variable,'\\varphi ','&phi;');

LatexCmds.epsilon = //W3C or Unicode?
  bind(Variable,'\\epsilon ','&#1013;');

LatexCmds.epsiv = //Elsevier and 9573-13
LatexCmds.varepsilon = //AMS and LaTeX
  bind(Variable,'\\varepsilon ','&epsilon;');

LatexCmds.piv = //W3C/Unicode and Elsevier and 9573-13
LatexCmds.varpi = //AMS and LaTeX
  bind(Variable,'\\varpi ','&piv;');

LatexCmds.sigmaf = //W3C/Unicode
LatexCmds.sigmav = //Elsevier
LatexCmds.varsigma = //LaTeX
  bind(Variable,'\\varsigma ','&sigmaf;');

LatexCmds.thetav = //Elsevier and 9573-13
LatexCmds.vartheta = //AMS and LaTeX
LatexCmds.thetasym = //W3C/Unicode
  bind(Variable,'\\vartheta ','&thetasym;');

LatexCmds.upsilon = //AMS and LaTeX and W3C/Unicode
LatexCmds.upsi = //Elsevier and 9573-13
  bind(Variable,'\\upsilon ','&upsilon;');

//these aren't even mentioned in the HTML character entity references
LatexCmds.gammad = //Elsevier
LatexCmds.Gammad = //9573-13 -- WTF, right? I dunno if this was a typo in the reference (see above)
LatexCmds.digamma = //LaTeX
  bind(Variable,'\\digamma ','&#989;');

LatexCmds.kappav = //Elsevier
LatexCmds.varkappa = //AMS and LaTeX
  bind(Variable,'\\varkappa ','&#1008;');

LatexCmds.rhov = //Elsevier and 9573-13
LatexCmds.varrho = //AMS and LaTeX
  bind(Variable,'\\varrho ','&#1009;');

//Greek constants, look best in un-italicised Times New Roman
LatexCmds.pi = LatexCmds['\u03C0'] = bind(NonSymbolaSymbol,'\\pi ','&pi;');
LatexCmds.theta = LatexCmds['\u03B8'] = bind(NonSymbolaSymbol,'\\theta ','&theta;');
LatexCmds.lambda = bind(NonSymbolaSymbol,'\\lambda ','&lambda;');

//uppercase greek letters

LatexCmds.Upsilon = //LaTeX
LatexCmds.Upsi = //Elsevier and 9573-13
LatexCmds.upsih = //W3C/Unicode "upsilon with hook"
LatexCmds.Upsih = //'cos it makes sense to me
  bind(Symbol,'\\Upsilon ','<var style="font-family: serif">&upsih;</var>'); //Symbola's 'upsilon with a hook' is a capital Y without hooks :(

//other symbols with the same LaTeX command and HTML character entity reference
LatexCmds.Gamma =
LatexCmds.Delta =
LatexCmds.Theta =
LatexCmds.Lambda =
LatexCmds.Xi =
LatexCmds.Phi =
LatexCmds.Psi =
LatexCmds.Omega =
LatexCmds.forall = P(VanillaSymbol, function(_, _super) {
  _.init = function(latex) {
    _super.init.call(this,'\\'+latex+' ','&'+latex+';');
  };
});

// symbols that aren't a single MathCommand, but are instead a whole
// Fragment. Creates the Fragment from a LaTeX string
var LatexFragment = P(MathCommand, function(_) {
  _.init = function(latex) { this.latex = latex; };
  _.createBefore = function(cursor) { cursor.writeLatex(this.latex); };
  _.parser = function() {
    var frag = latexMathParser.parse(this.latex).children();
    return Parser.succeed(frag);
  };
});

// for what seems to me like [stupid reasons][1], Unicode provides
// subscripted and superscripted versions of all ten Arabic numerals,
// as well as [so-called "vulgar fractions"][2].
// Nobody really cares about most of them, but some of them actually
// predate Unicode, dating back to [ISO-8859-1][3], apparently also
// known as "Latin-1", which among other things [Windows-1252][4]
// largely coincides with, so Microsoft Word sometimes inserts them
// and they get copy-pasted into MathQuill.
//
// (Irrelevant but funny story: Windows-1252 is actually a strict
// superset of the "closely related but distinct"[3] "ISO 8859-1" --
// see the lack of a dash after "ISO"? Completely different character
// set, like elephants vs elephant seals, or "Zombies" vs "Zombie
// Redneck Torture Family". What kind of idiot would get them confused.
// People in fact got them confused so much, it was so common to
// mislabel Windows-1252 text as ISO-8859-1, that most modern web
// browsers and email clients treat the MIME charset of ISO-8859-1
// as actually Windows-1252, behavior now standard in the HTML5 spec.)
//
// [1]: http://en.wikipedia.org/wiki/Unicode_subscripts_and_superscripts
// [2]: http://en.wikipedia.org/wiki/Number_Forms
// [3]: http://en.wikipedia.org/wiki/ISO/IEC_8859-1
// [4]: http://en.wikipedia.org/wiki/Windows-1252
LatexCmds['\u00b9'] = bind(LatexFragment, '^1');
LatexCmds['\u00b2'] = bind(LatexFragment, '^2');
LatexCmds['\u00b3'] = bind(LatexFragment, '^3');
LatexCmds['\u00bc'] = bind(LatexFragment, '\\frac14');
LatexCmds['\u00bd'] = bind(LatexFragment, '\\frac12');
LatexCmds['\u00be'] = bind(LatexFragment, '\\frac34');
LatexCmds['\u2152'] = bind(LatexFragment, '\\frac{1}{10}');
LatexCmds['\u2153'] = bind(LatexFragment, '\\frac13');
LatexCmds['\u2154'] = bind(LatexFragment, '\\frac23');


var BinaryOperator = P(Symbol, function(_, _super) {
  _.init = function(ctrlSeq, html, text) {
    _super.init.call(this,
      ctrlSeq, '<span class="mq-binary-operator">'+html+'</span>', text
    );
  };
  _.createBefore = function(cursor) {
    var ctrlSeq = cursor.prev.ctrlSeq + this.ctrlSeq;
    if (ctrlSeq === '<=')
      cursor.backspace().insertNew(BinaryOperator('\\le ', '&le;'));
    else if (ctrlSeq === '>=')
      cursor.backspace().insertNew(BinaryOperator('\\ge ', '&ge;'));
    else
      _super.createBefore.apply(this, arguments);
  };
});

var PlusMinus = P(BinaryOperator, function(_) {
  _.init = VanillaSymbol.prototype.init;

  _.respace = function() {
    if (!this.prev) {
      this.jQ[0].className = '';
    }
    else if (
      this.prev instanceof BinaryOperator &&
      this.next && !(this.next instanceof BinaryOperator)
    ) {
      this.jQ[0].className = 'mq-unary-operator';
    }
    else {
      this.jQ[0].className = 'mq-binary-operator';
    }
    return this;
  };
});

LatexCmds['+'] = bind(PlusMinus, '+', '+');
//yes, these are different dashes, I think one is an en dash and the other is a hyphen
LatexCmds['\u2013'] = LatexCmds['\u2212'] = LatexCmds['-'] = bind(PlusMinus, '-', '&minus;');
LatexCmds['\u00B1'] = LatexCmds.pm = LatexCmds.plusmn = LatexCmds.plusminus =
  bind(PlusMinus,'\\pm ','&plusmn;');
LatexCmds.mp = LatexCmds.mnplus = LatexCmds.minusplus =
  bind(PlusMinus,'\\mp ','&#8723;');

CharCmds['*'] = LatexCmds.sdot = LatexCmds.cdot =
  bind(BinaryOperator, '\\cdot ', '&middot;');
//semantically should be &sdot;, but &middot; looks better

LatexCmds['='] = bind(BinaryOperator, '=', '=');
LatexCmds['<'] = bind(BinaryOperator, '<', '&lt;');
LatexCmds['>'] = bind(BinaryOperator, '>', '&gt;');
LatexCmds['~'] = bind(BinaryOperator, '~', '~');

LatexCmds.notin =
LatexCmds.sim =
LatexCmds.cong =
LatexCmds.equiv =
LatexCmds.oplus =
LatexCmds.otimes = P(BinaryOperator, function(_, _super) {
  _.init = function(latex) {
    _super.init.call(this, '\\'+latex+' ', '&'+latex+';');
  };
});

LatexCmds.times = bind(BinaryOperator, '\\times ', '&times;', '[x]');

LatexCmds['\u00F7'] = LatexCmds.div = LatexCmds.divide = LatexCmds.divides =
  bind(BinaryOperator,'\\div ','&divide;', '[/]');

LatexCmds['\u2260'] = LatexCmds.ne = LatexCmds.neq = bind(BinaryOperator,'\\ne ','&ne;');

LatexCmds.ast = LatexCmds.star = LatexCmds.loast = LatexCmds.lowast =
  bind(BinaryOperator,'\\ast ','&lowast;');
  //case 'there4 = // a special exception for this one, perhaps?
LatexCmds.therefor = LatexCmds.therefore =
  bind(BinaryOperator,'\\therefore ','&there4;');

LatexCmds.cuz = // l33t
LatexCmds.because = bind(BinaryOperator,'\\because ','&#8757;');

LatexCmds.prop = LatexCmds.propto = bind(BinaryOperator,'\\propto ','&prop;');

LatexCmds['\u2248'] = LatexCmds.asymp = LatexCmds.approx = bind(BinaryOperator,'\\approx ','&asymp;');

LatexCmds.lt = bind(BinaryOperator,'<','&lt;');

LatexCmds.gt = bind(BinaryOperator,'>','&gt;');

LatexCmds['\u2264'] = LatexCmds.le = LatexCmds.leq = bind(BinaryOperator,'\\le ','&le;');

LatexCmds['\u2265'] = LatexCmds.ge = LatexCmds.geq = bind(BinaryOperator,'\\ge ','&ge;');

LatexCmds.isin = LatexCmds['in'] = bind(BinaryOperator,'\\in ','&isin;');

LatexCmds.ni = LatexCmds.contains = bind(BinaryOperator,'\\ni ','&ni;');

LatexCmds.notni = LatexCmds.niton = LatexCmds.notcontains = LatexCmds.doesnotcontain =
  bind(BinaryOperator,'\\not\\ni ','&#8716;');

LatexCmds.sub = LatexCmds.subset = bind(BinaryOperator,'\\subset ','&sub;');

LatexCmds.sup = LatexCmds.supset = LatexCmds.superset =
  bind(BinaryOperator,'\\supset ','&sup;');

LatexCmds.nsub = LatexCmds.notsub =
LatexCmds.nsubset = LatexCmds.notsubset =
  bind(BinaryOperator,'\\not\\subset ','&#8836;');

LatexCmds.nsup = LatexCmds.notsup =
LatexCmds.nsupset = LatexCmds.notsupset =
LatexCmds.nsuperset = LatexCmds.notsuperset =
  bind(BinaryOperator,'\\not\\supset ','&#8837;');

LatexCmds.sube = LatexCmds.subeq = LatexCmds.subsete = LatexCmds.subseteq =
  bind(BinaryOperator,'\\subseteq ','&sube;');

LatexCmds.supe = LatexCmds.supeq =
LatexCmds.supsete = LatexCmds.supseteq =
LatexCmds.supersete = LatexCmds.superseteq =
  bind(BinaryOperator,'\\supseteq ','&supe;');

LatexCmds.nsube = LatexCmds.nsubeq =
LatexCmds.notsube = LatexCmds.notsubeq =
LatexCmds.nsubsete = LatexCmds.nsubseteq =
LatexCmds.notsubsete = LatexCmds.notsubseteq =
  bind(BinaryOperator,'\\not\\subseteq ','&#8840;');

LatexCmds.nsupe = LatexCmds.nsupeq =
LatexCmds.notsupe = LatexCmds.notsupeq =
LatexCmds.nsupsete = LatexCmds.nsupseteq =
LatexCmds.notsupsete = LatexCmds.notsupseteq =
LatexCmds.nsupersete = LatexCmds.nsuperseteq =
LatexCmds.notsupersete = LatexCmds.notsuperseteq =
  bind(BinaryOperator,'\\not\\supseteq ','&#8841;');

/*

//the canonical sets of numbers
LatexCmds.N = LatexCmds.naturals = LatexCmds.Naturals =
  bind(VanillaSymbol,'\\mathbb{N}','&#8469;');

LatexCmds.P =
LatexCmds.primes = LatexCmds.Primes =
LatexCmds.projective = LatexCmds.Projective =
LatexCmds.probability = LatexCmds.Probability =
  bind(VanillaSymbol,'\\mathbb{P}','&#8473;');

LatexCmds.Z = LatexCmds.integers = LatexCmds.Integers =
  bind(VanillaSymbol,'\\mathbb{Z}','&#8484;');

LatexCmds.Q = LatexCmds.rationals = LatexCmds.Rationals =
  bind(VanillaSymbol,'\\mathbb{Q}','&#8474;');

LatexCmds.R = LatexCmds.reals = LatexCmds.Reals =
  bind(VanillaSymbol,'\\mathbb{R}','&#8477;');

LatexCmds.C =
LatexCmds.complex = LatexCmds.Complex =
LatexCmds.complexes = LatexCmds.Complexes =
LatexCmds.complexplane = LatexCmds.Complexplane = LatexCmds.ComplexPlane =
  bind(VanillaSymbol,'\\mathbb{C}','&#8450;');

LatexCmds.H = LatexCmds.Hamiltonian = LatexCmds.quaternions = LatexCmds.Quaternions =
  bind(VanillaSymbol,'\\mathbb{H}','&#8461;');

//spacing
LatexCmds.quad = LatexCmds.emsp = bind(VanillaSymbol,'\\quad ','    ');
LatexCmds.qquad = bind(VanillaSymbol,'\\qquad ','        ');
spacing special characters, gonna have to implement this in LatexCommandInput::onText somehow
case ',':
  return VanillaSymbol('\\, ',' ');
case ':':
  return VanillaSymbol('\\: ','  ');
case ';':
  return VanillaSymbol('\\; ','   ');
case '!':
  return Symbol('\\! ','<span style="margin-right:-.2em"></span>');

//binary operators
LatexCmds.diamond = bind(VanillaSymbol, '\\diamond ', '&#9671;');
LatexCmds.bigtriangleup = bind(VanillaSymbol, '\\bigtriangleup ', '&#9651;');
LatexCmds.ominus = bind(VanillaSymbol, '\\ominus ', '&#8854;');
LatexCmds.uplus = bind(VanillaSymbol, '\\uplus ', '&#8846;');
LatexCmds.bigtriangledown = bind(VanillaSymbol, '\\bigtriangledown ', '&#9661;');
LatexCmds.sqcap = bind(VanillaSymbol, '\\sqcap ', '&#8851;');
LatexCmds.triangleleft = bind(VanillaSymbol, '\\triangleleft ', '&#8882;');
LatexCmds.sqcup = bind(VanillaSymbol, '\\sqcup ', '&#8852;');
LatexCmds.triangleright = bind(VanillaSymbol, '\\triangleright ', '&#8883;');
LatexCmds.odot = bind(VanillaSymbol, '\\odot ', '&#8857;');
LatexCmds.bigcirc = bind(VanillaSymbol, '\\bigcirc ', '&#9711;');
LatexCmds.dagger = bind(VanillaSymbol, '\\dagger ', '&#0134;');
LatexCmds.ddagger = bind(VanillaSymbol, '\\ddagger ', '&#135;');
LatexCmds.wr = bind(VanillaSymbol, '\\wr ', '&#8768;');
LatexCmds.amalg = bind(VanillaSymbol, '\\amalg ', '&#8720;');

//relationship symbols
LatexCmds.models = bind(VanillaSymbol, '\\models ', '&#8872;');
LatexCmds.prec = bind(VanillaSymbol, '\\prec ', '&#8826;');
LatexCmds.succ = bind(VanillaSymbol, '\\succ ', '&#8827;');
LatexCmds.preceq = bind(VanillaSymbol, '\\preceq ', '&#8828;');
LatexCmds.succeq = bind(VanillaSymbol, '\\succeq ', '&#8829;');
LatexCmds.simeq = bind(VanillaSymbol, '\\simeq ', '&#8771;');
LatexCmds.mid = bind(VanillaSymbol, '\\mid ', '&#8739;');
LatexCmds.ll = bind(VanillaSymbol, '\\ll ', '&#8810;');
LatexCmds.gg = bind(VanillaSymbol, '\\gg ', '&#8811;');
LatexCmds.parallel = bind(VanillaSymbol, '\\parallel ', '&#8741;');
LatexCmds.bowtie = bind(VanillaSymbol, '\\bowtie ', '&#8904;');
LatexCmds.sqsubset = bind(VanillaSymbol, '\\sqsubset ', '&#8847;');
LatexCmds.sqsupset = bind(VanillaSymbol, '\\sqsupset ', '&#8848;');
LatexCmds.smile = bind(VanillaSymbol, '\\smile ', '&#8995;');
LatexCmds.sqsubseteq = bind(VanillaSymbol, '\\sqsubseteq ', '&#8849;');
LatexCmds.sqsupseteq = bind(VanillaSymbol, '\\sqsupseteq ', '&#8850;');
LatexCmds.doteq = bind(VanillaSymbol, '\\doteq ', '&#8784;');
LatexCmds.frown = bind(VanillaSymbol, '\\frown ', '&#8994;');
LatexCmds.vdash = bind(VanillaSymbol, '\\vdash ', '&#8870;');
LatexCmds.dashv = bind(VanillaSymbol, '\\dashv ', '&#8867;');

//arrows
LatexCmds.longleftarrow = bind(VanillaSymbol, '\\longleftarrow ', '&#8592;');
LatexCmds.longrightarrow = bind(VanillaSymbol, '\\longrightarrow ', '&#8594;');
LatexCmds.Longleftarrow = bind(VanillaSymbol, '\\Longleftarrow ', '&#8656;');
LatexCmds.Longrightarrow = bind(VanillaSymbol, '\\Longrightarrow ', '&#8658;');
LatexCmds.longleftrightarrow = bind(VanillaSymbol, '\\longleftrightarrow ', '&#8596;');
LatexCmds.updownarrow = bind(VanillaSymbol, '\\updownarrow ', '&#8597;');
LatexCmds.Longleftrightarrow = bind(VanillaSymbol, '\\Longleftrightarrow ', '&#8660;');
LatexCmds.Updownarrow = bind(VanillaSymbol, '\\Updownarrow ', '&#8661;');
LatexCmds.mapsto = bind(VanillaSymbol, '\\mapsto ', '&#8614;');
LatexCmds.nearrow = bind(VanillaSymbol, '\\nearrow ', '&#8599;');
LatexCmds.hookleftarrow = bind(VanillaSymbol, '\\hookleftarrow ', '&#8617;');
LatexCmds.hookrightarrow = bind(VanillaSymbol, '\\hookrightarrow ', '&#8618;');
LatexCmds.searrow = bind(VanillaSymbol, '\\searrow ', '&#8600;');
LatexCmds.leftharpoonup = bind(VanillaSymbol, '\\leftharpoonup ', '&#8636;');
LatexCmds.rightharpoonup = bind(VanillaSymbol, '\\rightharpoonup ', '&#8640;');
LatexCmds.swarrow = bind(VanillaSymbol, '\\swarrow ', '&#8601;');
LatexCmds.leftharpoondown = bind(VanillaSymbol, '\\leftharpoondown ', '&#8637;');
LatexCmds.rightharpoondown = bind(VanillaSymbol, '\\rightharpoondown ', '&#8641;');
LatexCmds.nwarrow = bind(VanillaSymbol, '\\nwarrow ', '&#8598;');

//Misc
*/
LatexCmds.space = bind(VanillaSymbol, '\\space ', '&nbsp;');
/*
LatexCmds.ldots = bind(VanillaSymbol, '\\ldots ', '&#8230;');
LatexCmds.cdots = bind(VanillaSymbol, '\\cdots ', '&#8943;');
LatexCmds.vdots = bind(VanillaSymbol, '\\vdots ', '&#8942;');
LatexCmds.ddots = bind(VanillaSymbol, '\\ddots ', '&#8944;');
LatexCmds.surd = bind(VanillaSymbol, '\\surd ', '&#8730;');
LatexCmds.triangle = bind(VanillaSymbol, '\\triangle ', '&#9653;');
LatexCmds.ell = bind(VanillaSymbol, '\\ell ', '&#8467;');
LatexCmds.top = bind(VanillaSymbol, '\\top ', '&#8868;');
LatexCmds.flat = bind(VanillaSymbol, '\\flat ', '&#9837;');
LatexCmds.natural = bind(VanillaSymbol, '\\natural ', '&#9838;');
LatexCmds.sharp = bind(VanillaSymbol, '\\sharp ', '&#9839;');
LatexCmds.wp = bind(VanillaSymbol, '\\wp ', '&#8472;');
LatexCmds.bot = bind(VanillaSymbol, '\\bot ', '&#8869;');
LatexCmds.clubsuit = bind(VanillaSymbol, '\\clubsuit ', '&#9827;');
LatexCmds.diamondsuit = bind(VanillaSymbol, '\\diamondsuit ', '&#9826;');
LatexCmds.heartsuit = bind(VanillaSymbol, '\\heartsuit ', '&#9825;');
LatexCmds.spadesuit = bind(VanillaSymbol, '\\spadesuit ', '&#9824;');

//variable-sized
LatexCmds.oint = bind(VanillaSymbol, '\\oint ', '&#8750;');
LatexCmds.bigcap = bind(VanillaSymbol, '\\bigcap ', '&#8745;');
LatexCmds.bigcup = bind(VanillaSymbol, '\\bigcup ', '&#8746;');
LatexCmds.bigsqcup = bind(VanillaSymbol, '\\bigsqcup ', '&#8852;');
LatexCmds.bigvee = bind(VanillaSymbol, '\\bigvee ', '&#8744;');
LatexCmds.bigwedge = bind(VanillaSymbol, '\\bigwedge ', '&#8743;');
LatexCmds.bigodot = bind(VanillaSymbol, '\\bigodot ', '&#8857;');
LatexCmds.bigotimes = bind(VanillaSymbol, '\\bigotimes ', '&#8855;');
LatexCmds.bigoplus = bind(VanillaSymbol, '\\bigoplus ', '&#8853;');
LatexCmds.biguplus = bind(VanillaSymbol, '\\biguplus ', '&#8846;');

//delimiters
LatexCmds.lfloor = bind(VanillaSymbol, '\\lfloor ', '&#8970;');
LatexCmds.rfloor = bind(VanillaSymbol, '\\rfloor ', '&#8971;');
LatexCmds.lceil = bind(VanillaSymbol, '\\lceil ', '&#8968;');
LatexCmds.rceil = bind(VanillaSymbol, '\\rceil ', '&#8969;');
LatexCmds.slash = bind(VanillaSymbol, '\\slash ', '&#47;');
LatexCmds.opencurlybrace = bind(VanillaSymbol, '\\opencurlybrace ', '&#123;');
LatexCmds.closecurlybrace = bind(VanillaSymbol, '\\closecurlybrace ', '&#125;');

//various symbols

LatexCmds.caret = bind(VanillaSymbol,'\\caret ','^');
LatexCmds.underscore = bind(VanillaSymbol,'\\underscore ','_');
LatexCmds.backslash = bind(VanillaSymbol,'\\backslash ','\\');
LatexCmds.vert = bind(VanillaSymbol,'|');
LatexCmds.perp = LatexCmds.perpendicular = bind(VanillaSymbol,'\\perp ','&perp;');
LatexCmds.nabla = LatexCmds.del = bind(VanillaSymbol,'\\nabla ','&nabla;');
LatexCmds.hbar = bind(VanillaSymbol,'\\hbar ','&#8463;');

LatexCmds.AA = LatexCmds.Angstrom = LatexCmds.angstrom =
  bind(VanillaSymbol,'\\text\\AA ','&#8491;');

LatexCmds.ring = LatexCmds.circ = LatexCmds.circle =
  bind(VanillaSymbol,'\\circ ','&#8728;');

LatexCmds.bull = LatexCmds.bullet = bind(VanillaSymbol,'\\bullet ','&bull;');

LatexCmds.setminus = LatexCmds.smallsetminus =
  bind(VanillaSymbol,'\\setminus ','&#8726;');

LatexCmds.not = //bind(Symbol,'\\not ','<span class="not">/</span>');
LatexCmds[''] = LatexCmds.neg = bind(VanillaSymbol,'\\neg ','&not;');

LatexCmds[''] = LatexCmds.dots = LatexCmds.ellip = LatexCmds.hellip =
LatexCmds.ellipsis = LatexCmds.hellipsis =
  bind(VanillaSymbol,'\\dots ','&hellip;');

LatexCmds.converges =
LatexCmds.darr = LatexCmds.dnarr = LatexCmds.dnarrow = LatexCmds.downarrow =
  bind(VanillaSymbol,'\\downarrow ','&darr;');

LatexCmds.dArr = LatexCmds.dnArr = LatexCmds.dnArrow = LatexCmds.Downarrow =
  bind(VanillaSymbol,'\\Downarrow ','&dArr;');

LatexCmds.diverges = LatexCmds.uarr = LatexCmds.uparrow =
  bind(VanillaSymbol,'\\uparrow ','&uarr;');

LatexCmds.uArr = LatexCmds.Uparrow = bind(VanillaSymbol,'\\Uparrow ','&uArr;');

LatexCmds.to = bind(BinaryOperator,'\\to ','&rarr;');

LatexCmds.rarr = LatexCmds.rightarrow = bind(VanillaSymbol,'\\rightarrow ','&rarr;');

LatexCmds.implies = bind(BinaryOperator,'\\Rightarrow ','&rArr;');

LatexCmds.rArr = LatexCmds.Rightarrow = bind(VanillaSymbol,'\\Rightarrow ','&rArr;');

LatexCmds.gets = bind(BinaryOperator,'\\gets ','&larr;');

LatexCmds.larr = LatexCmds.leftarrow = bind(VanillaSymbol,'\\leftarrow ','&larr;');

LatexCmds.impliedby = bind(BinaryOperator,'\\Leftarrow ','&lArr;');

LatexCmds.lArr = LatexCmds.Leftarrow = bind(VanillaSymbol,'\\Leftarrow ','&lArr;');

LatexCmds.harr = LatexCmds.lrarr = LatexCmds.leftrightarrow =
  bind(VanillaSymbol,'\\leftrightarrow ','&harr;');

LatexCmds.iff = bind(BinaryOperator,'\\Leftrightarrow ','&hArr;');

LatexCmds.hArr = LatexCmds.lrArr = LatexCmds.Leftrightarrow =
  bind(VanillaSymbol,'\\Leftrightarrow ','&hArr;');

LatexCmds.Re = LatexCmds.Real = LatexCmds.real = bind(VanillaSymbol,'\\Re ','&real;');

LatexCmds.Im = LatexCmds.imag =
LatexCmds.image = LatexCmds.imagin = LatexCmds.imaginary = LatexCmds.Imaginary =
  bind(VanillaSymbol,'\\Im ','&image;');

LatexCmds.part = LatexCmds.partial = bind(VanillaSymbol,'\\partial ','&part;');

LatexCmds.inf = LatexCmds.infin = LatexCmds.infty = LatexCmds.infinity =
  bind(VanillaSymbol,'\\infty ','&infin;');

LatexCmds.alef = LatexCmds.alefsym = LatexCmds.aleph = LatexCmds.alephsym =
  bind(VanillaSymbol,'\\aleph ','&alefsym;');

LatexCmds.xist = //LOL
LatexCmds.xists = LatexCmds.exist = LatexCmds.exists =
  bind(VanillaSymbol,'\\exists ','&exist;');
*/
LatexCmds.and = LatexCmds.land = LatexCmds.wedge =
  bind(VanillaSymbol,'\\wedge ','&and;');

LatexCmds.or = LatexCmds.lor = LatexCmds.vee = bind(VanillaSymbol,'\\vee ','&or;');
/*
LatexCmds.o = LatexCmds.O =
LatexCmds.empty = LatexCmds.emptyset =
LatexCmds.oslash = LatexCmds.Oslash =
LatexCmds.nothing = LatexCmds.varnothing =
  bind(BinaryOperator,'\\varnothing ','&empty;');

LatexCmds.cup = LatexCmds.union = bind(BinaryOperator,'\\cup ','&cup;');

LatexCmds.cap = LatexCmds.intersect = LatexCmds.intersection =
  bind(BinaryOperator,'\\cap ','&cap;');

LatexCmds.deg = LatexCmds.degree = bind(VanillaSymbol,'^\\circ ','&deg;');

LatexCmds.ang = LatexCmds.angle = bind(VanillaSymbol,'\\angle ','&ang;');
*/
// Parser MathCommand
var latexMathParser = (function() {
  function commandToBlock(cmd) {
    var block = MathBlock();
    cmd.adopt(block, 0, 0);
    return block;
  }
  function joinBlocks(blocks) {
    var firstBlock = blocks[0] || MathBlock();

    for (var i = 1; i < blocks.length; i += 1) {
      blocks[i].children().adopt(firstBlock, firstBlock.lastChild, 0);
    }

    return firstBlock;
  }

  var string = Parser.string;
  var regex = Parser.regex;
  var letter = Parser.letter;
  var any = Parser.any;
  var optWhitespace = Parser.optWhitespace;
  var succeed = Parser.succeed;
  var fail = Parser.fail;

  // Parsers yielding MathCommands
  var variable = letter.map(Variable);
  var symbol = regex(/^[^${}\\_^]/).map(VanillaSymbol);

  var controlSequence =
    regex(/^[^\\]/)
    .or(string('\\').then(
      regex(/^[a-z]+/i)
      .or(regex(/^\s+/).result(' '))
      .or(any)
    )).then(function(ctrlSeq) {
      var cmdKlass = LatexCmds[ctrlSeq];

      if (cmdKlass) {
        return cmdKlass(ctrlSeq).parser();
      }
      else {
        return fail('unknown command: \\'+ctrlSeq);
      }
    })
  ;

  var command =
    controlSequence
    .or(variable)
    .or(symbol)
  ;

  // Parsers yielding MathBlocks
  var mathGroup = string('{').then(function() { return mathSequence; }).skip(string('}'));
  var mathBlock = optWhitespace.then(mathGroup.or(command.map(commandToBlock)));
  var mathSequence = mathBlock.many().map(joinBlocks).skip(optWhitespace);

  var optMathBlock =
    string('[').then(
      mathBlock.then(function(block) {
        return block.join('latex') !== ']' ? succeed(block) : fail();
      })
      .many().map(joinBlocks).skip(optWhitespace)
    ).skip(string(']'))
  ;

  var latexMath = mathSequence;

  latexMath.block = mathBlock;
  latexMath.optBlock = optMathBlock;
  return latexMath;
})();
/********************************************
 * Cursor and Selection "singleton" classes
 *******************************************/

/* The main thing that manipulates the Math DOM. Makes sure to manipulate the
HTML DOM to match. */

/* Sort of singletons, since there should only be one per editable math
textbox, but any one HTML document can contain many such textboxes, so any one
JS environment could actually contain many instances. */

//A fake cursor in the fake textbox that the math is rendered in.
var Cursor = P(function(_) {
  _.init = function(root) {
    this.parent = this.root = root;
    var jQ = this.jQ = this._jQ = $('<span class="mq-cursor"><span class="mq-line">&zwj;</span></span>');

    //closured for setInterval
    this.blink = function(){ jQ.toggleClass('mq-blink'); }

    this.upDownCache = {};

    this.handle = $('<span class="mq-handle"></span>');
    this.handleAnchor = $('<span class="mq-handle-anchor" ' +
                                'style="display:none"></span>')
                        .append(this.handle).insertAfter(root.jQ);
    this.handleAnchor.top = this.handleAnchor.left = 0;
  };

  _.prev = 0;
  _.next = 0;
  _.parent = 0;
  _.showHandle = function() {
    //temporary: remove handle
    return this;

    if (!this.handleAnchor.visible) {
      this.handleAnchor.show();
      this.repositionHandle(this.jQ[0].getBoundingClientRect());
      this.handleAnchor.visible = true;
    }
    return this;
  };
  _.hideHandle = function() {
    //temporary: remove handle
    return this;

    if (this.handleAnchor.visible) {
      this.handleAnchor.hide();
      delete this.handleAnchor.visible;
    }
    return this;
  };
  _.repositionHandle = function(cursorRect) {
    //temporary: remove handle
    return;

    var anchor = this.handleAnchor;
    var anchorRect = anchor[0].getBoundingClientRect();
    anchor.css({
      top: anchor.top += cursorRect.bottom - anchorRect.bottom,
      left: anchor.left += cursorRect.left - anchorRect.left
    });
  };
  _.show = function(keepHandle) {
    if (!keepHandle) this.hideHandle();
    this.jQ = this._jQ.removeClass('mq-blink');
    if ('intervalId' in this) //already was shown, just restart interval
      clearInterval(this.intervalId);
    else { //was hidden and detached, insert this.jQ back into HTML DOM
      if (this.next) {
        if (this.selection && this.selection.first.prev === this.prev)
          this.jQ.insertBefore(this.selection.jQ);
        else
          this.jQ.insertBefore(this.next.jQ.first());
      }
      else
        this.jQ.appendTo(this.parent.jQ);
      this.parent.focus();
    }
    this.intervalId = setInterval(this.blink, 500);
    return this;
  };
  _.hide = function() {
    this.hideHandle();
    if ('intervalId' in this)
      clearInterval(this.intervalId);
    delete this.intervalId;
    this.jQ.detach();
    this.jQ = $();
    return this;
  };
  _.insertAt = function(parent, prev, next) {
    var old_parent = this.parent;

    this.parent = parent;
    this.prev = prev;
    this.next = next;

    old_parent.blur(); //blur may need to know cursor's destination
  };
  _.insertBefore = function(el) {
    this.insertAt(el.parent, el.prev, el)
    this.parent.jQ.addClass('mq-hasCursor');
    this.jQ.insertBefore(el.jQ.first());
    return this;
  };
  _.insertAfter = function(el) {
    this.insertAt(el.parent, el, el.next);
    this.parent.jQ.addClass('mq-hasCursor');
    this.jQ.insertAfter(el.jQ.last());
    return this;
  };
  _.prependTo = function(el) {
    this.insertAt(el, 0, el.firstChild);
    this.jQ.prependTo(el.jQ);
    el.focus();
    return this;
  };
  _.appendTo = function(el) {
    this.insertAt(el, el.lastChild, 0);
    this.jQ.appendTo(el.jQ);
    el.focus();
    return this;
  };
  _.hopLeft = function() {
    this.jQ.insertBefore(this.prev.jQ.first());
    this.next = this.prev;
    this.prev = this.prev.prev;
    return this;
  };
  _.hopRight = function() {
    this.jQ.insertAfter(this.next.jQ.last());
    this.prev = this.next;
    this.next = this.next.next;
    return this;
  };
  _.moveLeftWithin = function(block) {
    if (this.prev) {
      // FIXME HACK: when moving right to left, want to go into NthRoot's body,
      // which is its lastChild.
      if (this.prev instanceof NthRoot) this.appendTo(this.prev.lastChild);
      else if (this.prev.up instanceof MathBlock) this.appendTo(this.prev.up);
      else if (this.prev.firstChild) this.appendTo(this.prev.firstChild)
      else this.hopLeft();
    }
    else {
      // unless we're at the beginning of the containing block, escape left
      if (this.parent !== block) this.insertBefore(this.parent.parent);
      else if (block.moveOutOf) block.moveOutOf('left', this);
    }
  };
  _.moveRightWithin = function(block) {
    if (this.next) {
      if (this.next.up instanceof MathBlock) this.prependTo(this.next.up);
      else if (this.next.firstChild) this.prependTo(this.next.firstChild)
      else this.hopRight();
    }
    else {
      // unless we're at the beginning of the containing block, escape left
      if (this.parent !== block) this.insertAfter(this.parent.parent);
      else if (block.moveOutOf) block.moveOutOf('right', this);
    }
  };
  _.moveLeft = function() {
    clearUpDownCache(this);

    if (this.selection) {
      this.insertBefore(this.selection.first).clearSelection();
    //hack by eli: move all the way past subscripts
    } else if (this.prev instanceof SupSub && this.prev.ctrlSeq === '_') {
      this.moveLeftWithin(this.root);
      while (this.isInSubscript()) this.moveLeftWithin(this.root);
    } else {
      this.moveLeftWithin(this.root);
    }

    this.root.triggerSpecialEvent('cursorMoved');
    return this.show();
  };
  _.moveRight = function() {
    clearUpDownCache(this);

    if (this.selection) {
      this.insertAfter(this.selection.last).clearSelection();
    //hack by eli: move all the way past subscripts
    } else if (this.next instanceof SupSub && this.next.ctrlSeq === '_') {
      this.moveRightWithin(this.root);
      while (this.isInSubscript()) this.moveRightWithin(this.root);
    } else {
      this.moveRightWithin(this.root);
    }
    this.root.triggerSpecialEvent('cursorMoved');
    return this.show();
  };

  /**
   * moveUp and moveDown have almost identical algorithms:
   * - first check next and prev, if so prepend/appendTo them
   * - else check the parent's 'up'/'down' property - if it's a function,
   *   call it with the cursor as the sole argument and use the return value.
   *
   *   Given undefined, will bubble up to the next ancestor block.
   *   Given false, will stop bubbling.
   *   Given a MathBlock,
   *     + moveUp will appendTo it
   *     + moveDown will prependTo it
   *
   */
  _.moveUp = function() { return moveUpDown(this, 'up'); };
  _.moveDown = function() { return moveUpDown(this, 'down'); };
  function moveUpDown(self, dir) {
    if (self.next[dir]) self.prependTo(self.next[dir]);
    else if (self.prev[dir]) self.appendTo(self.prev[dir]);
    else {
      var ancestorBlock = self.parent;
      do {
        var prop = ancestorBlock[dir];
        if (prop) {
          if (typeof prop === 'function') prop = ancestorBlock[dir](self);
          if (prop === false || prop instanceof MathBlock) {
            self.upDownCache[ancestorBlock.id] = { parent: self.parent, prev: self.prev, next: self.next };

            if (prop instanceof MathBlock) {
              var cached = self.upDownCache[prop.id];

              if (cached) {
                if (cached.next) {
                  self.insertBefore(cached.next);
                } else {
                  self.appendTo(cached.parent);
                }
              } else {
                var coords = self.jQ[0].getBoundingClientRect();
                var cachedClientRect = cachedClientRectFnForNewCache();
                cachedClientRect.scrollLeft = 0; // only used in this event thread
                prop.seek(self, coords.left, coords.bottom, prop, cachedClientRect);
              }
            }
            break;
          }
        }
        ancestorBlock = ancestorBlock.parent.parent;
      } while (ancestorBlock);
    }

    return self.clearSelection().show();
  }

  _.seek = function(target, clientX, clientY, clientRect, keepHandle) {
    clearUpDownCache(this);
    var cursor = this.clearSelection().show(keepHandle);

    var nodeId = target.attr(mqBlockId) || target.attr(mqCmdId);
    if (!nodeId) {
      var targetParent = target.parent();
      nodeId = targetParent.attr(mqBlockId) || targetParent.attr(mqCmdId);
    }
    var node = nodeId ? MathElement[nodeId] : cursor.root;
    pray('nodeId is the id of some Node that exists', node);

    var dx = clientRect.scrollLeft = this.root.jQ.scrollLeft();
    node.seek(cursor, clientX + dx, clientY, cursor.root, clientRect);
    delete clientRect.scrollLeft; // be defensive: was only valid in this event
                                  // thread, unlike the cache of clientRect's

    this.root.scrollHoriz(); // before .selectFrom when mouse-selecting, so
      // always hits no-selection case in scrollHoriz and scrolls slower

    return cursor;
  };
  function offset(self) {
    //in Opera 11.62, .getBoundingClientRect() and hence jQuery::offset()
    //returns all 0's on inline elements with negative margin-right (like
    //the cursor) at the end of their parent, so temporarily remove the
    //negative margin-right when calling jQuery::offset()
    //Opera bug DSK-360043
    //http://bugs.jquery.com/ticket/11523
    //https://github.com/jquery/jquery/pull/717
    var offset = self.jQ.removeClass('mq-cursor').offset();
    self.jQ.addClass('mq-cursor');
    return offset;
  }
  _.writeLatex = function(latex) {
    var self = this;
    clearUpDownCache(self);
    self.show().deleteSelection();

    var all = Parser.all;
    var eof = Parser.eof;

    var block = latexMathParser.skip(eof).or(all.result(false)).parse(latex);

    if (block && !block.isEmpty()) {
      block.children().adopt(self.parent, self.prev, self.next);
      var html = block.join('html');
      var jQ = MathElement.jQize(html);
      jQ.insertBefore(self.jQ);
      self.prev = block.lastChild;
      block.finalizeInsert();
      self.parent.bubble('redraw');
    }

    return this;
  };

  _.isInSubscript = function () {
    if (!this.parent || !this.parent.parent) return false;
    var p = this.parent.parent;
    if (!(p instanceof SupSub)) return false;
    return (p.ctrlSeq === '_' && p.firstChild === this.parent);
  };

  _.write =
  _.insertCh = function(ch) {
    //Hack by Eli: don't exponentiate if there's nothing before the cursor
    if ((ch == '^' || ch == '_') && !this.prev) return;

    //Hack #2 by Eli: break out of the end of exponents
    if (
      "+=-<>~".indexOf(ch) >= 0 && this.parent.parent.ctrlSeq === '^'
      && !this.next && this.prev
    ) this.moveRight();

    //Hack #2.5 by Eli: break out of the end of subscripts. Be a little more aggressive about breaking out down there
    if (
      "+=-<>~*".indexOf(ch) >= 0 && this.parent.parent.ctrlSeq === '_'
      && !this.next && this.prev
    ) this.moveRight();

    //Hack #3 by Eli: if you type "^" just after a superscript, behave as though you just pressed up
    if (ch === '^' && this.prev instanceof SupSub &&
      //note: need both of these, because if it's a superscript and subscript,
      //those could appear in either order
      (this.prev.ctrlSeq === '^' || this.prev.prev.ctrlSeq === '^')) {
      this.moveUp();
      return;
    }

    //Hack #3.5 by Eli: if you type "_" just after a subscript, return early
    if (ch === '_' && this.prev instanceof SupSub &&
      //note: need both of these, because if it's a superscript and subscript,
      //those could appear in either order
      (this.prev.ctrlSeq === '_' || this.prev.prev.ctrlSeq === '_')) {
      return;
    }


    //Hack #4 by Eli: if you type "^" just _before_ a superscript, behave as though you just pressed up
    if (ch === '^' && this.next instanceof SupSub &&
      //note: need both of these, because if it's a superscript and subscript,
      //those could appear in either order
      (this.next.ctrlSeq === '^' || (this.next.next && this.next.next.ctrlSeq === '^'))) {
      this.moveUp();
      return;
    }

    //Hack #5 by Eli: typing a number after a variable subscripts it
    if (
      !this.isInSubscript() &&
      !this.selection &&
      !(this.next && this.next instanceof SupSub) &&
      '0123456789'.indexOf(ch) >= 0 &&
      (
        (this.prev && this.prev.isVariable) ||
        (this.prev instanceof SupSub && this.prev.ctrlSeq === '_' && this.prev.prev.ctrlSeq !== '^')
      )
    ) {
      if (this.prev instanceof SupSub) {
        this.moveDown();
      } else {
        this.insertNew(LatexCmds['_']('_'));
      }
      this.insertNew(VanillaSymbol(ch));
      this.moveUp();
      return;
    }

    //hack #6: don't allow nested subscripts
    if (ch === "_" && this.isInSubscript()) return;

    //hack #7: break out of subscripts for division & exponentiation
    if (ch === '/' || ch === '^') {
      while (this.isInSubscript()) this.moveRightWithin()
    }

    clearUpDownCache(this);
    this.show();

    var cmd;
    if (ch.match(/^[a-z]$/i))
      cmd = Variable(ch);
    else if (cmd = CharCmds[ch] || LatexCmds[ch])
      cmd = cmd(ch);
    else
      cmd = VanillaSymbol(ch);

    if (this.selection) {
      this.prev = this.selection.first.prev;
      this.next = this.selection.last.next;
      cmd.replaces(this.selection);
      delete this.selection;
    }

    return this.insertNew(cmd);
  };
  _.insertNew = function(cmd) {
    cmd.createBefore(this);
    return this;
  };
  _.insertCmd = function(latexCmd, replacedFragment) {
    clearUpDownCache(this);
    this.show();

    var cmd = LatexCmds[latexCmd];
    if (cmd) {
      cmd = cmd(latexCmd);
      if (replacedFragment) cmd.replaces(replacedFragment);
      this.insertNew(cmd);
    }
    else {
      cmd = TextBlock();
      cmd.replaces(latexCmd);
      cmd.firstChild.focus = function(){ delete this.focus; return this; };
      this.insertNew(cmd).insertAfter(cmd);
      if (replacedFragment)
        replacedFragment.remove();
    }
    return this;
  };
  _.unwrapGramp = function() {
    var gramp = this.parent.parent;
    var greatgramp = gramp.parent;
    var next = gramp.next;
    var cursor = this;

    var prev = gramp.prev;
    gramp.disown().eachChild(function(uncle) {
      if (uncle.isEmpty()) return;

      uncle.children()
        .adopt(greatgramp, prev, next)
        .each(function(cousin) {
          cousin.jQ.insertBefore(gramp.jQ.first());
        })
      ;

      prev = uncle.lastChild;
    });

    if (!this.next) { //then find something to be next to insertBefore
      if (this.prev)
        this.next = this.prev.next;
      else {
        while (!this.next) {
          this.parent = this.parent.next;
          if (this.parent)
            this.next = this.parent.firstChild;
          else {
            this.next = gramp.next;
            this.parent = greatgramp;
            break;
          }
        }
      }
    }
    if (this.next)
      this.insertBefore(this.next);
    else
      this.appendTo(greatgramp);

    gramp.jQ.remove();

    if (gramp.prev)
      gramp.prev.respace();
    if (gramp.next)
      gramp.next.respace();
  };
  _.backspace = function() {
    clearUpDownCache(this);
    this.show();

    if (this.deleteSelection()); // pass
    else if (this.prev) {
      if (this.prev.isEmpty()) {
        if (this.prev.ctrlSeq === '\\le ') var ins = LatexCmds['<']('<');
        else if (this.prev.ctrlSeq === '\\ge ') var ins = LatexCmds['>']('>');
        this.prev = this.prev.remove().prev;
        if (ins) this.insertNew(ins);
      }
      else if (this.prev instanceof Bracket) {
        return this.appendTo(this.prev.firstChild).deleteForward();
      }
      else if (this.prev instanceof SupSub && this.prev.ctrlSeq === '_' && this.prev.prev.ctrlSeq !== '^') {
        this.moveDown()
        this.backspace()
        //extra hack to clear out subscript altogether when it's empty (takes two backspaces)
        if (!this.prev && !this.next) {
          this.backspace()
        } else {
          this.moveUp()
        }
      } else {
        this.selectLeft();
      }
    }
    else if (this.parent !== this.root) {
      if (this.parent.parent.isEmpty())
        return this.insertAfter(this.parent.parent).backspace();
      else if (this.next instanceof Bracket)
        return this.prependTo(this.next.firstChild).backspace();
      else
        this.unwrapGramp();
    }
    else this.root.triggerSpecialEvent('backspacePressed');

    if (this.prev)
      this.prev.respace();
    if (this.next)
      this.next.respace();
    this.parent.bubble('redraw');

    return this;
  };
  _.deleteForward = function() {
    clearUpDownCache(this);
    this.show();

    if (this.deleteSelection()); // pass
    else if (this.next) {
      if (this.next.isEmpty())
        this.next = this.next.remove().next;
      else
        this.selectRight();
    }
    else if (this.parent !== this.root) {
      if (this.parent.parent.isEmpty())
        return this.insertBefore(this.parent.parent).deleteForward();
      else
        this.unwrapGramp();
    }
    else this.root.triggerSpecialEvent('delPressed');

    if (this.prev)
      this.prev.respace();
    if (this.next)
      this.next.respace();
    this.parent.bubble('redraw');

    return this;
  };
  _.selectFrom = function(anticursor) {
    //find ancestors of each with common parent
    var oneA = this, otherA = anticursor; //one ancestor, the other ancestor
    loopThroughAncestors: do {
      for (var oneI = this; oneI !== oneA.parent.parent; oneI = oneI.parent.parent) //one intermediate, the other intermediate
        if (oneI.parent === otherA.parent) {
          left = oneI;
          right = otherA;
          break loopThroughAncestors;
        }

      for (var otherI = anticursor; otherI !== otherA.parent.parent; otherI = otherI.parent.parent)
        if (oneA.parent === otherI.parent) {
          left = oneA;
          right = otherI;
          break loopThroughAncestors;
        }

      if (oneA.parent.parent)
        oneA = oneA.parent.parent;
      if (otherA.parent.parent)
        otherA = otherA.parent.parent;
    } while (oneA.parent.parent || otherA.parent.parent || oneA.parent === otherA.parent);
    // the only way for this condition to fail is if A and B are in separate
    // trees, which should be impossible, but infinite loops must never happen,
    // even under error conditions.
    pray('cursor and anticursor are in the same tree',
         oneA.parent.parent || otherA.parent.parent || oneA.parent === otherA.parent);

    //figure out which is left/prev and which is right/next
    var left, right, leftRight;
    if (left.next !== right) {
      for (var next = left; next; next = next.next) {
        if (next === right.prev) {
          leftRight = true;
          break;
        }
      }
      if (!leftRight) {
        leftRight = right;
        right = left;
        left = leftRight;
      }
    }
    this.hide().selection = Selection(left.prev.next || left.parent.firstChild, right.next.prev || right.parent.lastChild);
    this.insertAfter(right.next.prev || right.parent.lastChild);
    this.root.selectionChanged();
  };
  _.selectLeft = function() {
    clearUpDownCache(this);
    if (this.selection) {
      if (this.selection.first === this.next) { //if cursor is at left edge of selection;
        if (this.prev) //then extend left if possible
          this.hopLeft().selection.extendLeft();
        else if (this.parent !== this.root) //else level up if possible
          this.insertBefore(this.parent.parent).selection.levelUp();
      }
      else { //else cursor is at right edge of selection, retract left if possible
        this.hopLeft();
        if (this.selection.first === this.selection.last) {
          this.clearSelection().show(); //clear selection if retracting to nothing
          return; //skip this.root.selectionChanged(), this.clearSelection() does it anyway
        }
        this.selection.retractLeft();
      }
    }
    else {
      if (this.prev)
        this.hopLeft();
      else //end of a block
        if (this.parent !== this.root)
          this.insertBefore(this.parent.parent);
        else
          return;

      this.hide().selection = Selection(this.next);
    }
    this.root.selectionChanged();
  };
  _.selectRight = function() {
    clearUpDownCache(this);
    if (this.selection) {
      if (this.selection.last === this.prev) { //if cursor is at right edge of selection;
        if (this.next) //then extend right if possible
          this.hopRight().selection.extendRight();
        else if (this.parent !== this.root) //else level up if possible
          this.insertAfter(this.parent.parent).selection.levelUp();
      }
      else { //else cursor is at left edge of selection, retract right if possible
        this.hopRight();
        if (this.selection.first === this.selection.last) {
          this.clearSelection().show(); //clear selection if retracting to nothing
          return; //skip this.root.selectionChanged(), this.clearSelection() does it anyway
        }
        this.selection.retractRight();
      }
    }
    else {
      if (this.next)
        this.hopRight();
      else //end of a block
        if (this.parent !== this.root)
          this.insertAfter(this.parent.parent);
        else
          return;

      this.hide().selection = Selection(this.prev);
    }
    this.root.selectionChanged();
  };

  function clearUpDownCache(self) {
    self.upDownCache = {};
  }

  _.prepareMove = function() {
    clearUpDownCache(this);
    return this.show().clearSelection();
  };

  _.prepareEdit = function() {
    clearUpDownCache(this);
    return this.show().deleteSelection();
  }

  _.clearSelection = function() {
    if (this.selection) {
      this.selection.clear();
      delete this.selection;
      this.root.selectionChanged();
    }
    return this;
  };
  _.deleteSelection = function() {
    if (!this.selection) return false;

    this.prev = this.selection.first.prev;
    this.next = this.selection.last.next;
    this.selection.remove();
    this.root.selectionChanged();
    return delete this.selection;
  };
});

var Selection = P(MathFragment, function(_, _super) {
  _.init = function() {
    var frag = this;
    _super.init.apply(frag, arguments);

    frag.jQwrap(frag.jQ);
  };
  _.jQwrap = function(children) {
    this.jQ = children.wrapAll('<span class="mq-selection"></span>').parent();
      //can't do wrapAll(this.jQ = $(...)) because wrapAll will clone it
  };
  _.adopt = function() {
    this.jQ.replaceWith(this.jQ = this.jQ.children());
    return _super.adopt.apply(this, arguments);
  };
  _.clear = function() {
    this.jQ.replaceWith(this.jQ.children());
    return this;
  };
  _.levelUp = function() {
    var seln = this,
      gramp = seln.first = seln.last = seln.last.parent.parent;
    seln.clear().jQwrap(gramp.jQ);
    return seln;
  };
  _.extendLeft = function() {
    this.first = this.first.prev;
    this.first.jQ.prependTo(this.jQ);
  };
  _.extendRight = function() {
    this.last = this.last.next;
    this.last.jQ.appendTo(this.jQ);
  };
  _.retractRight = function() {
    this.first.jQ.insertBefore(this.jQ);
    this.first = this.first.next;
  };
  _.retractLeft = function() {
    this.last.jQ.insertAfter(this.jQ);
    this.last = this.last.prev;
  };
});
/*********************************************************
 * The actual jQuery plugin and document ready handlers.
 ********************************************************/

//The publicy exposed method of jQuery.prototype, available (and meant to be
//called) on jQuery-wrapped HTML DOM elements.
$.fn.mathquill = function(cmd, latex) {
  switch (cmd) {
  case 'focus':
  case 'blur':
    return this.each(function() {
      var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId];
      if (block && block.textareaManager)
        block.textareaManager[cmd]()
    });
  case 'onKey':
  case 'onText':
    return this.each(function() {
      var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId],
        cursor = block && block.cursor;

      if (cursor) {
        cursor.parent.bubble(cmd, latex, { preventDefault: noop });
        if (block.blurred) cursor.hide().parent.blur();
      }
    });
  case 'redraw':
    return this.each(function() {
      var blockId = $(this).attr(mqBlockId),
        rootBlock = blockId && MathElement[blockId];
      if (rootBlock) {
        (function postOrderRedraw(el) {
          el.eachChild(postOrderRedraw);
          if (el.redraw) el.redraw();
        }(rootBlock));
      }
    });
  case 'revert':
    return this.each(function() {
      var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId];
      if (block && block.revert)
        block.revert();
    });
  case 'sliderLatex':
    return this.each(function() {
      var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId];
      if (block) {

        //fixes bug with highlighting everything and then setting state with latex
        //https://github.com/desmosinc/knox/issues/1115
        cursor = block && block.cursor;
        if (cursor) cursor.clearSelection();
        block.renderSliderLatex(latex);
        block.triggerSpecialEvent('render');
      }
    });
  case 'latex':
    if (arguments.length > 1) {
      return this.each(function() {
        var blockId = $(this).attr(mqBlockId),
          block = blockId && MathElement[blockId];
        if (block) {
          //fixes bug with highlighting everything and then setting state with latex
          //https://github.com/desmosinc/knox/issues/1115
          cursor = block && block.cursor;
          if (cursor) cursor.clearSelection();
          block.renderLatex(latex);
          block.triggerSpecialEvent('render');
        }
      });
    }

    var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId];
    return block && block.latex();
  case 'text':
    var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId];
    return block && block.text();
  case 'html':
    return this.children('.mathquill-root-block').html().replace(/ ?mq-hasCursor|mq-hasCursor /, '')
      .replace(/ class=(""|(?= |>))/g, '')
      .replace(/<span class="?mq-cursor( mq-blink)?"?>.?<\/span>/i, '');
  case 'write':
    if (arguments.length > 1)
      return this.each(function() {
        var blockId = $(this).attr(mqBlockId),
          block = blockId && MathElement[blockId],
          cursor = block && block.cursor;

        if (cursor) {
          cursor.writeLatex(latex)
          if (block.blurred) cursor.hide().parent.blur();
        }
      });
  case 'cmd':
    if (arguments.length > 1)
      return this.each(function() {
        var blockId = $(this).attr(mqBlockId),
          block = blockId && MathElement[blockId],
          cursor = block && block.cursor;

        if (cursor) {
          if (/^\\[a-z]+$/i.test(latex)) {
            var selection = cursor.selection;
            if (selection) {
              cursor.prev = selection.first.prev;
              cursor.next = selection.last.next;
              delete cursor.selection;
            }
            cursor.insertCmd(latex.slice(1), selection);
          }
          else
            cursor.insertCh(latex);
          if (block.blurred) cursor.hide().parent.blur();
        }
      });
  case 'touchtap':
    var touchstartTarget = arguments[1], x = arguments[2], y = arguments[3];
    return this.each(function() {
      var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId],
        cursor = block && block.cursor;
      if (cursor && touchstartTarget !== cursor.handle[0]) {
        var wasBlurred = block.blurred;
        block.textareaManager.focus()
        cursor.seek($(touchstartTarget), x, y, cachedClientRectFnForNewCache(), true);
        if (!wasBlurred) cursor.showHandle();
      }
    });
  case 'ignoreNextMousedown':
    var time = arguments[1];
    return this.each(function() {
      var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId];
      if (block) {
        block.ignoreMousedownTimeout = setTimeout(function() {
          block.ignoreMousedownTimeout = undefined;
        }, time);
      }
    });
  case 'moveStart':
    var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId];
    if (block && block.cursor)
      block.cursor.prependTo(block);
    break;
  case 'moveEnd':
    var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId];
    if (block && block.cursor)
      block.cursor.appendTo(block);
    break;
  case 'isAtStart':
    var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId],
      cursor = block && block.cursor;
    if (cursor) return cursor.parent === cursor.root && !cursor.prev;
    break;
  case 'isAtEnd':
    var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId],
      cursor = block && block.cursor;
    if (cursor) return cursor.parent === cursor.root && !cursor.next;
    break;
  case 'selection':
    var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId],
      cursor = block && block.cursor;
    if (!cursor) return;
    return cursor.selection ? '$'+cursor.selection.latex()+'$' : '';
  case 'clearSelection':
    return this.each(function() {
      var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId],
        cursor = block && block.cursor;
      if (cursor) {
        cursor.clearSelection();
        if (block.blurred) cursor.hide().parent.blur();
      }
    });
  default:
    var textbox = cmd === 'textbox',
      editable = textbox || cmd === 'editable',
      RootBlock = textbox ? RootTextBlock : RootMathBlock;
    return this.each(function() {
      var container = $(this), root = RootBlock();
      createRoot(container, root, textbox, editable);
      var cursor = root.cursor;
      setupTextarea(editable, container, root, cursor);
      root.editable = editable;
      mouseEvents(container);
      setupTouchHandle(editable, root, cursor);
      if (!editable) return;
      rootCSSClasses(container, textbox);
      focusBlurEvents(root, cursor);
      desmosCustomEvents(container, root, cursor);
    });
  }
};

//NOTE desmos doesn't want auto-render functionality because we want to avoid
//interfering with clients' mathquill in our api
//
//on document ready, mathquill-ify all `<tag class="mathquill-*">latex</tag>`
//elements according to their CSS class.
// $(function() {
//   $('.mathquill-editable:not(.mathquill-rendered-math)').mathquill('editable');
//   $('.mathquill-textbox:not(.mathquill-rendered-math)').mathquill('textbox');
//   $('.mathquill-embedded-latex:not(.mathquill-rendered-math)').mathquill();
// });


}());

define("mathquill", function(){});

define('template!expression_item', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='';
 if (renderShell) {
;__p+='\n\n<div class="dcg-do-not-blur dcg-expressionitem dcg-shell">\n  <div class=\'dcg-shell\'></div>\n</div>\n\n';
 } else {
;__p+='\n\n<div class="dcg-do-not-blur dcg-expressionitem">\n  <div class=\'dcg-fade-container\'>\n\n    <div class="dcg-fadeout-left"></div>\n\n    <span class="dcg-main">\n      <span class="dcg-transient-mathquill"></span>\n      <span class="dcg-template-mathquill"></span>\n    </span>\n\n    <span class="dcg-fadeout"></span>\n    <i class="dcg-icon-remove dcg-top-level-delete dcg-action-delete" handleEvent="true"></i>\n\n    <div class="dcg-slider-speed-container dcg-do-not-blur" handleEvent="true">\n      <span class="dcg-action-slower" >&laquo;</span>\n      <span class="dcg-variable-speed"></span>\n      <span class="dcg-action-faster">&raquo;</span>\n    </div>\n\n    <div class="dcg-template-bottom-container dcg-fixed-width-element">\n      <div class="dcg-template-bottom"></div>\n    </div>\n  </div>\n\n  <span class="dcg-tab dcg-action-drag dcg-action-icon-touch"\n        handleevent="true"\n        tapboundary="true"\n        disablescroll="true"\n  >\n    <span class="dcg-num dcg-variable-index"></span>\n    <span class="dcg-tab-interior dcg-action-icon-mouse">\n      <span class="template-expricon"></span>\n    </span>\n  </span>\n\n\n  <span class="dcg-exp-actions">\n    <span class="dcg-graphic" handleEvent="true"></span>\n    <nobr>\n      <span class="dcg-action-delete dcg-delete-btn dcg-tooltip" handleEvent="true" tooltip="'+
( t('Delete') )+
'"><i class=\'dcg-icon-remove\'></i></span>\n      <span class="dcg-action-duplicate dcg-duplicate-btn dcg-tooltip" handleEvent="true" tooltip="'+
( t('Duplicate') )+
'"><i class=\'dcg-icon-duplicate\'></i></span>\n      <span class="dcg-action-createtable dcg-tooltip" tooltip="'+
( t('Convert to Table') )+
'" handleEvent="true">\n        <i class=\'dcg-icon-table\'></i>\n      </span>\n    </nobr>\n  </span>\n</div>\n\n';
 }
;__p+='\n';
}
return __p;
};});
define('expressions/abstractitem_view',['require','pjs','jquery','underscore_view','conditional_blur'],function(require) {
  var P = require('pjs');
  var $ = require('jquery');
  var UnderscoreView = require('underscore_view');
  var conditionalBlur = require('conditional_blur');

  var AbstractItemView = P(UnderscoreView, function (view, _super) {
    view.init = function (model, listView) {
      _super.init.call(this);

      this.model = model;
      this.listView = listView;

      // do this now instead of letting renderSelected do this. If we wait
      // for renderSelected to do it, we'll end up calling rerender within a
      // already started render loop. That'll cause events to get bound twice
      // and other weird stuff will happen.
      if (this.model.selected) {
        this.model.renderShell = false;
      }
      //always render the first 15 equations (unless they're in folders)
      if (this.model.index < 15 && !this.model.inCollapsedFolder) {
        this.model.renderShell = false;
      }


      this.model.observe('index.itemview', this.renderIndex.bind(this));
      this.model.observe('selected.itemview', this.renderSelected.bind(this));
      this.model.observe('renderShell.itemview', this.rerender.bind(this));
      this.model.observe('renderShell.itemview', this.setMinWidth.bind(this));
      this.model.observe('folder.itemview', this.renderFolder.bind(this));
      this.model.observe('inCollapsedFolder.itemview', this.renderCollapsedFolder.bind(this));
    };

    //clear focus at the list level if the list has focus
    view.clearListFocus = function () {
      if (this.listView && this.listView.model) {
        this.listView.model.setSelected(null);
      }
    };

    //triggered from list_view when projector mode is changed
    //override from the different item type views. right now, just text_view overrides
    view.onProjectorModeChange = function() {};

    view.destruct = function () {
      this.model.unobserve('.itemview');
      this.setProperty('transient', false);
    };

    view.getTemplateParams = function () {
      return {
        renderShell: this.model.renderShell,
        inCollapsedFolder: this.model.inCollapsedFolder
      };
    };

    //this is called before the animation begins. The goal:
    // if an animation is in process (i.e. dcg-do-animate class is present)
    //   get out of here
    // otherwise, set the height to where it's supposed to start then wait
    // a frame and add dcg-do-animate class. Subsequent calls to set the height
    // will animate through css
    view.setInitialAnimationHeight = function(height) {
      if (this.$templateBottomContainer.hasClass('dcg-do-animate')) return;

      this.$templateBottomContainer.css('height', height);
      var self = this;
      setTimeout(function() {
        self.$templateBottomContainer.addClass('dcg-do-animate');
      });
    };

    //this is called once an animation is already in process, to animate
    //the height of the template bottom
    view.animateHeightTimeout = null;
    view.clearHeightTimeout = null;
    view.animateHeightTo = function (height) {
      var self = this;

      //step 1: animate to the new height. add the faded-in / faded-out class
      // this is in a timeout so that rapid typing doesn't make the bottom see-saw
      clearTimeout(this.animateHeightTimeout);
      this.animateHeightTimeout = setTimeout(function() {
        self.$templateBottomContainer.css('height', height);
        self.$templateBottom.toggleClass('dcg-faded-in', (height > 0));
      }, 250);

      //step 2: wait for the last possible animation to have finished (250ms + time for the animation to run)
      //then remove the animation class and remove the fixed height.
      //this means that subsequent changes to the size of the bottom of the expression will just let the page
      //reflow normally
      clearTimeout(this.clearHeightTimeout);
      this.clearHeightTimeout = setTimeout(function() {
        self.$templateBottomContainer.css('height', 'auto');
        self.$templateBottomContainer.removeClass('dcg-do-animate');
      }, 550);
    };

    view.templateBottomItems = 0;

    view.addViewToBottom = function (view) {
      //TODO: this is for api usage with expressions: false.
      //Ideally, this method should never be reached if we have no expression views
      if (!this.$templateBottom) return;

      this.templateBottomItems++;
      //short-circuit if we're not animating
      //
      //this also shortcuts the case where another bottom item is present
      //this can happen if this new bottom item is added before an existing one is removed.
      //for example: a*b, add sliders for both. then delete the slider for b.
      //The "add sliders:" option is added before the evaluation is removed
      //between this and the above, we just swap out this item.

      if (!this.doAnimate || this.templateBottomItems > 1) {
        this.$templateBottom.addClass('dcg-faded-in');
        view.appendTo(this.$templateBottom);
        return;
      }

      //set the height to zero
      this.setInitialAnimationHeight(0);
      //append the view
      view.appendTo(this.$templateBottom);
      //update the height of the bottom region
      this.animateHeightTo(view.$().height());
    };

    view.removeViewFromBottom = function (view) {
      //TODO: this is for api usage with expressions: false.
      //Ideally, this method should never be reached if we have no expression views
      if (!this.$templateBottom) return;

      this.templateBottomItems--;

      //second half of the shortcutted logic if we're swapping in a bottom element
      if (this.templateBottomItems > 0) {
        view.remove();
        return;
      }

      //short circuit if we're not animating
      if (!this.doAnimate) {
        this.$templateBottom.removeClass('dcg-faded-in');
        view.remove();
        return;
      }

      //set the initial animation height to the full height of the bottom
      this.setInitialAnimationHeight(this.$templateBottom.height());
      //remove the view
      view.remove();
      //animate to zero
      this.animateHeightTo(0);
    };

    view.renderIndex = function () {
      var index = this.model.index;
      this.$().attr('index', index);
      this.$('.dcg-variable-index').text(index+1);
    };

    view.renderFolder = function () {
      this.$().toggleClass('dcg-inFolder', !!this.model.folder);
    };

    view.renderCollapsedFolder = function(){
      this.$().toggleClass('dcg-inCollapsedFolder', !!this.model.inCollapsedFolder);
    };

    view.renderSelected = function () {
      if (this.model.selected) {
        if (this.model.renderShell) {
          this.model.setProperty('renderShell', false);
        }
      }

      this.$().toggleClass('dcg-selected', !!this.model.selected);
    };

    view.setMinWidth = function () {
      this.$('.dcg-fixed-width-element').css('width', this.listView.minWidth - this.listView.scrollbarWidth);
    };

    view.didCreateElement = function () {
      this.setMinWidth();
      this.$templateBottom = this.$('.dcg-template-bottom');
      this.$templateBottomContainer = this.$('.dcg-template-bottom-container');
    };

    view.didInsertElement = function () {
      _super.didInsertElement.call(this);

      var self = this;
      this.$().on('tap tapstart', function (evt) {
        // when using mouse, fire on 'tapStart' and when on touch we
        // fire on the 'tap' event.
        if (evt.type === 'tap' && evt.device === 'mouse') return;
        if (evt.type === 'tapstart' && evt.device === 'touch') return;

        self.onMouseSelect(evt);
      });

      this.$('.dcg-action-drag').on('tapstart', this.onDragPending.bind(this));
      this.$('.dcg-action-delete').on('tap', this.onDelete.bind(this));

      this.$().attr('expr-id', this.model.id);
      this.renderIndex();
      this.renderSelected();
      this.renderFolder();
      this.renderCollapsedFolder();
    };

    view.triggerDelete = function () {};
    view.triggerEnterPressed = function () {};
    view.triggerUpPressed = function () {};
    view.triggerDownPressed = function () {};
    view.triggerBackspacePressed = function () {};
    view.triggerDelPressed = function () {};
    view.onMouseSelect = function () {};

    view.sendTapToMathQuill = function(evt, mq) {
      // stop the mathquill from losing focus immediately. Only do this when
      // using mouse. When on ipad, this stops you from being able to put
      // cursor. And when on ipad, focus doesn't get lost anyways.
      if (evt.device === 'mouse') {
        evt.preventDefault();
      }

      /*
      * This will simualte a mousedown on the mathquill itself so that
      * you can start a mouse selection from outside of mathquill. But,
      * this doesn't make much sense for ipad because we don't do selection on
      * mousedown for ipad, we do it on click. That's because we want scroll
      * to work. We also don't want to pass the event into mathquill if it
      * originally started in mathquill.
      */
      if (evt.device === 'mouse') {
        // let mathquill handle the event
        if ($.contains(mq[0], evt.target)) return;

        // the event we're looking at is of type 'tapstart' and that means
        // nothing to mathquill. We need to turn this back into a 'mousedown'
        // so that it can handle it normally.
        var fakeEvent = $.event.fix(evt.originalEvent);

        // pass into mathquill so it can act like it happened within mathquill
        mq.triggerHandler(fakeEvent);
      }

      // on ipad, use MathQuill API
      else {
        var touch = evt.originalEvent.changedTouches[0];
        mq.mathquill('touchtap', touch.target, touch.clientX, touch.clientY)
                      .mathquill('ignoreNextMousedown', 1000);
      }
    };

    view.onDelete = function() {
      this.triggerDelete();
    };

    view.convertTo = function (cls, state) {

      var obj = cls(state);
      var index = this.model.index;
      var list = this.model.list;
      var folder = this.model.folder;

      obj.setProperty('list', list);

      list.undoRedo.oneTransaction(function(){
        list.removeItemAt(index);
        list.insertItemAt(index, obj);
        if (folder) folder.addItem(obj);
      });

      return obj;
    };

    view.getBounds = function () {
      var dom = this.$();
      var offset = dom.offset();
      if (!offset) return null;

      var top = offset.top;
      var height = dom.height();

      return {
        top: top,
        bottom: top + height
      };
    };

    // override in subclass
    view.allowDragDrop = function () {
      return true;
    };

    view.onDragPending = function(evt) {
      // clear focus when clicking expression handle
      conditionalBlur();

      // don't start dragging if we're not allowed to
      if (!this.allowDragDrop()) return;
      var self = this;
      this.mouseMovedTo = null;

      //if timeout happens or mouse moves sufficiently far, we will start dragging
      //if mouseup, then this was a tap, and we should let it do its thing

      //Start after 500ms
      var dragStartTimeout = setTimeout(function(){
        $(document).off('.dragpending');
        self.onDragStart(evt);
      }, 500);

      //Start after moving
      $(document).on('tapmove.dragpending', function(new_evt){
        // mouse has moved since tapstart. record this in case we actually do start dragging
        self.mouseMovedTo = new_evt.touches[0];

        var dx = evt.touches[0].x - self.mouseMovedTo.x;
        var dy = evt.touches[0].y - self.mouseMovedTo.y;

        // must have moved more than 3px away from tapstart position to immediately trigger drag
        if (Math.sqrt(dx*dx+dy*dy) > 3) {
          clearTimeout(dragStartTimeout);
          $(document).off('.dragpending');
          self.onDragStart(evt);
        }
      });

      //Cancel on mouseup
      $(document).on('tapend.dragpending', function(new_evt){
        clearTimeout(dragStartTimeout);
        $(document).off('.dragpending');
      });
    };

    view.onDragStart = function(evt) {
      // don't start dragging if we're not allowed to
      if (!this.allowDragDrop()) return;
      this.listView.dragdrop_expressions.start(evt, this);

      // we've moved our mouse since the initial tapstart. drag the expression to that point
      if (this.mouseMovedTo) {
        this.hideContextMenu();
        this.listView.dragdrop_expressions.drag(this.mouseMovedTo.x, this.mouseMovedTo.y);
      }
    };

    view.hideContextMenu = function () {
      this.triggerEvent('hideContextMenu');
    };

    view.processMissedKeyEvent = function (evt) {};
    view.addFocus = function (where) {};
    view.isFocused = function () {return false};
  });

  return AbstractItemView;
});

define('expressions/expression_view',['require','jquery','pjs','./expression_icon_view','expressions/evaluation','expressions/unresolved','expressions/domain_view','expressions/regression_view','expressions/slider_view','expressions/promptslider_view','./expression','graphing/columnmode','i18n','conditional_blur','./text','./table','mathquill','jquery.handleevent','keys','template!expression_item','expressions/abstractitem_view'],function (require) {
  var $ = require('jquery');
  var P = require('pjs');
  var ExpressionIconView = require('./expression_icon_view');
  var EvaluationView = require('expressions/evaluation');
  var UnresolvedView = require('expressions/unresolved');
  var DomainView = require('expressions/domain_view');
  var RegressionView = require('expressions/regression_view');
  var SliderView = require('expressions/slider_view');
  var PromptSliderView = require('expressions/promptslider_view');
  var ExpressionObject = require('./expression');
  var COLUMNMODE = require('graphing/columnmode');
  var i18n = require('i18n');
  var conditionalBlur = require('conditional_blur');

  //For convert-to text and convert-to-table
  var TextObject = require('./text');
  var TableObject = require('./table');

  require('mathquill');
  require('jquery.handleevent');
  var Keys = require('keys');

  var template = require('template!expression_item');

  var AbstractItemView = require('expressions/abstractitem_view');

  var ExpressionView = P(AbstractItemView, function(view, _super) {
    view.template = template;

    view.init = function (model, listView, toastView) {
      _super.init.call(this, model, listView);
      this.toastView = toastView;
      this.model.observe('formula.exprview', this.onFormulaChange.bind(this));
      this.model.observe('selected.exprview', this.onSelectedChange.bind(this));
      this.model.observe('latex.exprview', this.onLatexChange.bind(this));
      this.model.observe('dependent.exprview', this.renderDependent.bind(this));
      this.model.observe('isTableable.exprview', this.renderIsTableable.bind(this));
      this.model.observe('unresolved.exprview', this.renderUnresolved.bind(this));
      this.model.observe('loading.exprview', this.onLoadingChange.bind(this));
    };

    // enable animations on the frame after the expression is loaded
    view.onLoadingChange = function () {
      if (!this.model.loading) {
        var self = this;
        setTimeout(function () {
          self.setProperty('doAnimate', true);
        });
      }
    };

    view.renderIsTableable = function(){
      this.$('.dcg-action-createtable').toggleClass('dcg-disabled', !this.model.isTableable);
    };

    view.destruct = function () {
      _super.destruct.call(this);

      this.model.unobserve('.exprview');

      if (this.iconView) {
        this.iconView.remove();
        this.iconView = null;
      }

      if (this.sliderView) {
        // Trigger our removal from the slider timer.
        this.sliderView.remove();
        this.sliderView = null;
      }

      if (this.promptSliderView) {
        this.promptSliderView.remove();
        this.promptSliderView = null;
      }

      if (this.domainView) {
        this.domainView.remove();
        this.domainView = null;
      }

      if (this.regressionView) {
        this.regressionView.remove();
        this.regressionView = null;
      }

      if (this.evaluationView) {
        this.evaluationView.remove();
        this.evaluationView = null;
      }

      if (this.unresolvedView) {
        this.unresolvedView.remove();
        this.unresolvedView = null;
      }
    };

    view.onLatexChange = function() {
      if (this.sliderView && this.sliderView.slider.transient) {
        this.updateTransientValue();
        return;
      }

      var latex = this.model.latex;
      if (latex === '"' || latex === "'") {
        this.convertTo(TextObject, {selected:true});
        this.listView.getSelectedView().addFocus();
        return;
      }
      //call up to list_view, so that other listeners can listen
      this.listView.onLatexChange(latex);

      this.updateMathquill();
    };

    view.updateMathquill = function () {
      if (!this.mathquill) return;

      var latex = this.model.latex;

      if (latex !== undefined && this.mathquill.mathquill('latex') !== latex)
        this.mathquill.mathquill('latex', latex);
    };

    view.updateTransientValue = function () {
      if (!this.$transientValue || !this.$transientValue.length) return;
      this.$transientValue[0].innerHTML = (
        this.model.slider.computeSnappedValue(this.model.slider.value)
        .toString()
        .replace('-', '<span class="unary-operator">\u2212</span>')
      );
    };

    // OVERRIDE TO CREATE APPROPRIATE CHILD VIEW. IF NOT OVERRIDDEN, THE
    // VIEW WILL SIMPLY NOT BE CREATED AT RUNTIME.
    view.createIconView = function () {
      return ExpressionIconView(this);
    };
    view.createSliderView = function () {
      return SliderView(this.model.slider, this);
    };
    view.createPromptSliderView = function () {
      return PromptSliderView(this);
    };
    view.createDomainView = function () {
      return DomainView(this.model.domain);
    };
    view.createRegressionView = function () {
      return RegressionView(this.model.formula.regression, this.listView);
    };
    view.createEvaluationView = function () {
      return EvaluationView(this);
    };

    view.onFormulaChange = function() {
      /* jshint maxcomplexity:20 */
      // Skip this while we are rendering shell. Without this catch, we'd
      // create the child views while rendring the shells and throw them
      // away when we render fully.
      if (this.model.renderShell) return;

      var formula = this.model.formula;

      // closes stale context menus
      this.hideContextMenu();

      var showSlider = formula.is_slidable;
      if (this.sliderView && !showSlider) {
        this.sliderView.slider.unobserve('.expressionView');
        this.removeViewFromBottom(this.sliderView);
        this.sliderView = null;
        this.$().removeClass('dcg-hasSlider');
      } else if (!this.sliderView && showSlider) {
        this.sliderView = this.createSliderView();
        if (this.sliderView) {
          this.addViewToBottom(this.sliderView);
          this.sliderView.setProperty('dependentLabel', this.getDependentLabel());
          this.$().addClass('dcg-hasSlider');
          this.sliderView.slider.observe(
            'transient.expressionView',
            this.updateTransient.bind(this)
          );
          this.updateTransient();
        }
      }
      var promptCreateSlider = formula.variables && formula.variables.length > 0;
      if (this.promptSliderView && !promptCreateSlider) {
        this.removeViewFromBottom(this.promptSliderView);
        this.promptSliderView = null;
      } else if (!this.promptSliderView && promptCreateSlider) {
        this.promptSliderView = this.createPromptSliderView();
        if (this.promptSliderView) {
          this.addViewToBottom(this.promptSliderView);
        }
      }

      var showDomain = formula.is_parametric;
      if (this.domainView && !showDomain) {
        this.removeViewFromBottom(this.domainView);
        this.domainView = null;
        this.$().removeClass('dcg-hasDomain');
      } else if (!this.domainView && showDomain) {
        this.domainView = this.createDomainView();
        if (this.domainView) {
          this.addViewToBottom(this.domainView);
          this.$().addClass('dcg-hasDomain');
        }
      }

      var showRegression = formula.is_regression;
      if (this.regressionView && !showRegression) {
        this.removeViewFromBottom(this.regressionView);
        this.regressionView = null;
        this.$().removeClass('dcg-hasRegression');
      } else if (!this.regressionView && showRegression) {
        this.regressionView = this.createRegressionView();
        this.addViewToBottom(this.regressionView);
        this.$().addClass('dcg-hasRegression');
      }

      var showEvaluation = formula.is_evaluable;
      if (this.evaluationView && !showEvaluation) {
        this.removeViewFromBottom(this.evaluationView);
        this.evaluationView = null;
      } else if (!this.evaluationView && showEvaluation) {
        this.evaluationView = this.createEvaluationView();
        if (this.evaluationView) {
          this.addViewToBottom(this.evaluationView);
          this.$().addClass('.dcg-hasEvaluation');
          this.evaluationView.setProperty('dependentLabel', this.getDependentLabel());
        }
      }

      if (this.sliderView && !this.sliderView.slider.transient) {
        this.model.slider.setProperty('value', formula.constant_value);
      }

      if (this.promptSliderView) {
       this.promptSliderView.setProperty('variables', formula.variables);
      }

      if (this.evaluationView) {
        this.evaluationView.setProperty('evaluations', formula.zero_values);
      }

      if (this.regressionView) {
        this.regressionView.setProperty('regression', formula.regression);
      }
    };

    view.renderDependent = function () {
      if (this.sliderView) {
        this.sliderView.setProperty('dependentLabel', this.getDependentLabel());
      }
      if (this.evaluationView) {
        this.evaluationView.setProperty('dependentLabel', this.getDependentLabel());
      }
    };

    view.renderUnresolved = function () {
      var unresolved = this.model.unresolved;

      if (!unresolved && this.unresolvedView) {
        this.unresolvedView.remove();
        this.unresolvedView = null;
      }

      if (unresolved && !this.unresolvedView) {
        this.unresolvedView = UnresolvedView();
        this.addViewToBottom(this.unresolvedView);
      }
    };

    // NOTE: this will get called once with model.renderShell = true and once
    // with model.renderShell = false. The first time, the template will
    // shortcircuit and render the bare minimum. The second time the entire
    // dom will get destroyed and rebuilt. We don't want to add any nested
    // views when model.renderShell = false because the views' dom elements will
    // get wiped out as soon as we render with model.renderShell = false. And,
    // the whole point of renderShell=true is that we want as little as
    // possible to happen at startup as possible.
    view.didInsertElement = function () {
      _super.didInsertElement.call(this);
      if (this.model.renderShell)  return;

      this.mathquill = this.$('.dcg-template-mathquill').mathquill('editable');
      this.$transientLhs =
        this.$('.dcg-transient-mathquill').mathquill('editable')
      ;
      this.$transientLhs.hide();
      this.$transientValue = $('<span>');

      this.mathquill.on(
        'render upPressed downPressed enterPressed backspacePressed delPressed keydown focusin focus',
        this.onMathquillEvent.bind(this)
      );
      this.$transientLhs.on('tapstart', this.onSelectTransient.bind(this));
      this.mathquill.mathquill('latex', this.model.latex || "");

      this.iconView = this.createIconView();
      if (this.iconView) {
        this.iconView.replace(this.$('.template-expricon'));
      }

      this.$('.dcg-action-duplicate').on('tap', this.onDuplicateWithoutFocus.bind(this));
      this.$('.dcg-action-createtable').on('tap', this.onCreateTable.bind(this));

      this.$('.dcg-action-faster').on('tap', this.animateFaster.bind(this));
      this.$('.dcg-action-slower').on('tap', this.animateSlower.bind(this));

      this.renderIsTableable();
      this.onFormulaChange();
    };

    view.animateFaster = function () {
      if (this.sliderView) this.sliderView.animateFaster();
    };
    view.animateSlower = function () {
      if (this.sliderView) this.sliderView.animateSlower();
    };

    view.onSelectedChange = function() {
      if (!this.model.selected && this.mathquill) {
        // take focus out of mathquill
        this.mathquill.mathquill('clearSelection').mathquill('blur');
      }
    };

    view.onSelectTransient = function () {
      this.stopTransient();
      this.mathquill.mathquill('focus');
    };

    view.onMathquillEvent = function(evt) {
      /* jshint maxcomplexity:14 */
      switch(evt.type) {
        case "render":
        this.model.setProperty('latex', this.mathquill.mathquill('latex'));
        return;

        case "focus":
        case "focusin":
          if (this.sliderView) this.sliderView.slider.setProperty('isPlaying', false);
          this.model.setProperty('selected', true);
          return;

        case "upPressed":
        this.triggerUpPressed();
        return;

        case "downPressed":
        this.triggerDownPressed();
        return;

        case "enterPressed":
        this.triggerEnterPressed();
        return;

        case "backspacePressed":
        if (!this.model.isEmpty()) return;
        this.triggerBackspacePressed();
        return;

        case "delPressed":
        if (!this.model.isEmpty()) return;
        this.triggerDelPressed();
        return;

        case "keydown":
        if (Keys.lookup(evt) === Keys.ESCAPE) conditionalBlur();
        return;
      }
    };

    view.onDuplicateWithoutFocus = function() {

      var index = this.model.index;
      var state = this.model.getState();
      state.selected = false;
      delete state.id;

      var list = this.model.list;
      var folder = this.model.folder;
      var obj = ExpressionObject(state, list);

      list.undoRedo.oneTransaction(function () {
        list.insertItemAt(index + 1, obj);
        if (folder) folder.addItem(obj);
      });

      return obj;
    };

    view.onMouseSelect = function(evt) {
      if (this.listView.editListMode) return;

      if (evt.wasHandled()) return;
      evt.handle();

      this.model.setProperty('selected', true);

      this.sendTapToMathQuill(evt, this.mathquill);
    };

    view.getDependentLabel = function () {
      var dependent = this.model.dependent;
      if (!dependent) return '';

      //reformat to add back in brackets if we have a subscript
      if (dependent.match(/(.*)_(.+)/)) {
        dependent = dependent.replace(/(.*)_(.+)/, "$1_{$2}");
      }

      // ask mathquill for an html version of itself
      // note: this will break for things like parentheses, which need to be
      // inserted into the dom to know their correct size we should probably
      // be passing around mathquill objects instead of strings, but this
      // works for uncomplicated mathquill
      dependent = $(
        "<span>" +
        dependent +
        "</span>"
      ).mathquill('editable').mathquill('html');

      // surround it in the right class so that it can pull in mathquill
      // stylings
      dependent = (
        "<span class='mathquill-rendered-math'>" +
        dependent +
        "</span>"
      );

      return dependent;
    };

    var lhs = function (latex) {
      return latex.replace(RegExp("=[^=]+$"), "=");
    };

    view.startTransient = function () {
      this.setProperty('transient', true);
      this.updateTransientValue();
      this.$transientLhs.show();
      this.mathquill.hide();
      this.$transientLhs.mathquill('latex', lhs(this.model.latex));
      this.$transientLhs
        .children('.mathquill-root-block')
        .append(this.$transientValue)
      ;
    };

    view.stopTransient = function () {
      this.setProperty('transient', false);
      this.$transientValue.remove();
      this.$transientLhs.hide();
      this.mathquill.show();
      this.updateMathquill();
    };

    view.updateTransient = function () {
      if (!this.$transientValue || !this.$transientValue.length) return;

      if (this.sliderView.slider.transient) {
        this.startTransient();
      } else {
        this.stopTransient();
      }
    };

    view.isFocused = function () {
      return $(document.activeElement).closest(this.mathquill).length !== 0;
    };

    view.addFocus = function (where) {
      if (!this.mathquill) return;

      this.mathquill.mathquill('focus');

      if (where === 'start') {
        this.mathquill.mathquill('moveStart');
      } else if (where === 'end') {
        this.mathquill.mathquill('moveEnd');
      }
    };

    view.onCreateTable = function () {

      var formula = this.model.formula;

      if (!this.model.isTableable) return;

      var table_info = formula.table_info;
      var index = this.model.index;
      var state = {selected : true};

      var columnMode = COLUMNMODE.POINTS_AND_LINES;
      if (formula.is_point_list || this.model.hidden)
        columnMode = COLUMNMODE.POINTS;

      var i;
      var independent_values = [];
      var dependent_values = [];
      if(table_info.values){
        for(i = 0; i < table_info.values.length; i++){
        independent_values.push(table_info.values[i][0]);
        dependent_values.push(table_info.values[i][1]);
        }
      }
      else{
        for(i = -2; i <=2; i++){
          independent_values.push(i);
          dependent_values.push('');
        }
      }

      state.columns = [{
                          latex:table_info.independent_variable,
                          values: independent_values
                        },{
                          latex:table_info.dependent_column,
                          color: this.model.color,
                          hidden: false,
                          columnMode: columnMode,
                          values: dependent_values
                        }];

      var list = this.model.list;
      var listView = this.listView;
      var folderId = (this.model.folder ? this.model.folder.id : null);
      listView.setProperty('editListMode', false);

      list.undoRedo.oneTransaction(function(){
        if (!table_info.by_reference) {
          list.removeItemAt(index);
          index--;
        }

        var obj = TableObject(state, list);
        list.insertItemAt(index+1, obj);
        if (folderId !== null) list.getItemById(folderId).addItem(obj);
      });

      var undoCallback = function () {
        listView.setProperty('editListMode', true);
      };
      this.listView.toastView.show(i18n.t("Table created."), {undoCallback: undoCallback});
    };
  });

  return ExpressionView;
});

define('template!text', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='';
 if (renderShell) {
;__p+='\n\n<div class="dcg-do-not-blur dcg-expressionitem dcg-expressiontext dcg-shell">\n  <div class=\'dcg-shell\'></div>\n</div>\n\n';
 } else {
;__p+='\n\n<div class="dcg-do-not-blur dcg-expressiontext dcg-expressionitem">\n  <div class=\'dcg-fade-container\'>\n\n    <span class="dcg-main">\n      <div class="dcg-smart-textarea-placeholder"></div>\n    </span>\n    <i class="dcg-icon-remove dcg-top-level-delete dcg-action-delete" handleEvent="true"></i>\n\n  </div>\n\n  <span class="dcg-tab dcg-action-drag"\n        handleevent="true"\n        tapboundary="true"\n        disablescroll="true"\n  >\n    <span class=\'dcg-num dcg-variable-index\'></span>\n    <div class=\'dcg-tab-interior\'></div>\n    <i class=\'dcg-icon-text\'></i>\n  </span>\n\n  <span class=\'dcg-exp-actions\'>\n    <span\n      class="dcg-action-delete dcg-delete-btn dcg-tooltip"\n      handleEvent="true"\n      tooltip="'+
( t('Delete') )+
'"\n    >\n      <i class=\'dcg-icon-remove\'></i>\n    </span>\n  </span>\n\n</div>\n\n';
 }
;__p+='';
}
return __p;
};});
define('loadcss!css/smart_textarea', function(){});
define('template!smart_textarea', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="dcg-smart-textarea-container">\n  <div class="dcg-displayTextarea dcg-fixed-width-element"></div>\n  <textarea class="dcg-do-blur dcg-fixed-width-element dcg-smart-textarea" placeholder="'+
( t('enter a note...') )+
'"></textarea>\n</div>';
}
return __p;
};});
/*
*  This is a utility that is used in folders and text views
*  It takes a textarea and a div that's supposed to cover the textarea
*  It updates the div to match the textarea, including swapping in links
*  It resizes the textarea to match the div
*/

define('expressions/smart_textarea',['require','loadcss!css/smart_textarea','jquery','pjs','underscore_view','browser','jquery.handleevent','keys','conditional_blur','template!smart_textarea'],function(require) {
  require('loadcss!css/smart_textarea');
  var $ = require('jquery');
  var P = require('pjs');
  var UnderscoreView = require('underscore_view');
  var Browser = require('browser');
  require('jquery.handleevent');
  var Keys = require('keys');
  var conditionalBlur = require('conditional_blur');

  var template = require('template!smart_textarea');

  var SmartTextarea = P(UnderscoreView, function(view, _super) {
    view.template = template;
    view.init = function (text) {
      _super.init.call(this);

      this.$textarea = null;
      this.$displayText = null;
      this.setProperty('text', text || '');
    };

    view.didCreateElement = function() {
      _super.didCreateElement.call(this);

      this.$textarea = this.$('.dcg-smart-textarea');
      this.$displayText = this.$('.dcg-displayTextarea');
      this.observe('text', this.renderText.bind(this));

      this.$textarea.on('input propertychange change', function(evt) {
        this.setProperty('text', this.$textarea.val());
      }.bind(this));
      this.$textarea.on('keydown', this.onKeydownEvent.bind(this));

      this.$displayText.on('touchend', function(evt) {
        evt.preventDefault();
      });

      // We are going to stop clicks on links and let the rest filter through to the focus() handler below.
      this.$displayText.on('tap tapstart', 'a', function(evt) {
        evt.handle();
      });

      // FF has an issue where focus is lost of we change the '.selected' class while clicking. Instead of
      // allowing the "onMouseSelect" code to run, we just expect that the expression will get focus. And that
      // will also cause this to become selected. The difference is that by doing "evt.handle()" here we focus
      // then select (rather than select then focus). FF simply prefers it that way.
      this.$textarea.on('tapstart', function (evt) {
        evt.handle();
      }.bind(this));

      this.$textarea.focus(function(){
        this.setProperty('focused', true);
      }.bind(this));
      this.$textarea.blur(function(){
        this.setProperty('focused', false);
      }.bind(this));
    };

    view.didInsertElement = function () {
      _super.didInsertElement.call(this);
      this.renderText();
    };

    view.onKeydownEvent = function (evt) {
      /* jshint maxcomplexity:12 */
      if (!this.$textarea) return;

      var ta = this.$textarea[0];
      var key = Keys.lookup(evt);

      // pressing enter inside textarea creates a new expression underneath
      if (key === Keys.ENTER) {
        evt.preventDefault();
        this.triggerEvent('enterPressed');
      // pressing escape removes focus
      } else if (key === Keys.ESCAPE) {
        conditionalBlur();
      // pressing up while at start of textarea selects expression above
      } else if (key === Keys.UP) {
        if (ta.selectionStart === 0 && ta.selectionEnd === 0) {
          evt.preventDefault();
          this.triggerEvent('upPressed');
        }
      // pressing down while at end of textarea selects expression below
      } else if (key === Keys.DOWN) {
        if (ta.selectionStart === ta.value.length && ta.selectionEnd === ta.value.length) {
          evt.preventDefault();
          this.triggerEvent('downPressed');
        }
      // pressing backspace when completely empty should delete textarea
      } else if (key === Keys.BACKSPACE) {
        if (ta.value.length === 0) {
          evt.preventDefault();
          this.triggerEvent('backspacePressed');
        }
      // pressing delete when completely empty should delete textarea
      } else if (key === Keys.DELETE) {
        if (ta.value.length === 0) {
          evt.preventDefault();
          this.triggerEvent('delPressed');
        }
      }
    };

    view.destruct = function () {
      this.blur();
    };

    view.markedUpText = function () {
      var marked_up_text = this.text || '';
      // converts '<' and '>' to html entity
      marked_up_text = marked_up_text.replace(/</g, '&lt;').replace(/>/g, '&gt;');

      // wraps links in <a> tags
      var exp = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
      marked_up_text = marked_up_text.replace(exp,"<a href='$1' target ='_blank'>$1</a>");

      return marked_up_text;
    };

    view.renderText = function () {
      if (!this.$textarea) return;

      this.$textarea.val(this.text);
      this.$displayText.html(this.markedUpText());
      this.fitText();
      this.$textarea.toggleClass('dcg-empty', !this.text);
      setTimeout(this.fitText.bind(this), 1); //TODO - do we still need this?
    };

    view.fitText = function () {
      if (!this.$displayText) return;

      var height = this.$displayText.outerHeight();
      if (height > 0) this.$textarea.css('height', height);
    };

    view.isFocused = function () {
      return $(document.activeElement).closest(this.$()).length !== 0;
    };

    view.blur = function () {
      if (this.$textarea) this.$textarea.blur();
    };

    view.addFocus = function (where) {
      // Can't reliably focus textarea programatically from within iframe on ipad
      // see #3106
      if (Browser.IS_IPAD && Browser.IS_IN_IFRAME) {
        return;
      }
      var textarea = this.$textarea[0];
      textarea.focus();
      if (where === 'end') {
        textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
      } else if (where === 'start') {
        textarea.selectionStart = textarea.selectionEnd = 0;
      }
    };
  });

  return SmartTextarea;
});

define('expressions/text_view',['require','jquery','pjs','./abstractitem_view','template!text','./smart_textarea','jquery.handleevent'],function(require) {
  var $ = require('jquery');
  var P = require('pjs');
  var AbstractItemView = require('./abstractitem_view');
  var template = require('template!text');
  var SmartTextarea = require('./smart_textarea');
  require('jquery.handleevent');

  var TextView = P(AbstractItemView, function(view, _super) {
    view.template = template;

    view.init = function (model, listView) {
      _super.init.call(this, model, listView);

      this.model.observe('selected.textview', this.onSelectedChange.bind(this));

      //sync up smart_textarea and this.model
      this.smartTextarea = SmartTextarea(this.model.text);
      this.model.observe('text.textview', function() {
        this.smartTextarea.setProperty('text', this.model.text);
      }.bind(this));
      this.smartTextarea.observe('text', function() {
        this.model.setProperty('text', this.smartTextarea.text);
      }.bind(this));

      // fitText doesn't work when we're hidden. Must do it when being shown.
      this.model.observe('inCollapsedFolder.textview', function () {
        if (!this.model.inCollapsedFolder) {
          this.smartTextarea.fitText();
        }
      }.bind(this));
    };

    view.destruct = function () {
      this.model.unobserve('.textview');
      this.smartTextarea.destruct();
    };

    view.onProjectorModeChange = function() {
      this.smartTextarea.fitText();
    };

    view.didInsertElement = function () {
      _super.didInsertElement.call(this);

      if (this.model.renderShell) return;
      this.smartTextarea.replace(this.$('.dcg-smart-textarea-placeholder'));

      this.smartTextarea.observe('focused', function () {
        if (this.smartTextarea.focused) this.model.setProperty('selected', true);
      }.bind(this));

      this.smartTextarea.observeEvent('enterPressed', this.triggerEnterPressed.bind(this));
      this.smartTextarea.observeEvent('upPressed', this.triggerUpPressed.bind(this));
      this.smartTextarea.observeEvent('downPressed', this.triggerDownPressed.bind(this));
      this.smartTextarea.observeEvent('backspacePressed', this.triggerBackspacePressed.bind(this));
      this.smartTextarea.observeEvent('delPressed', this.triggerDelPressed.bind(this));
      //need to include smart-textarea in minWidth
      this.setMinWidth();
    };

    view.onSelectedChange = function() {
      if (!this.model.selected) {
        this.smartTextarea.blur();
      }
    };

    view.onMouseSelect = function(evt) {
      if (evt.wasHandled()) return;
      evt.handle();

      this.model.setProperty('selected', true);
    };

    view.isFocused = function () {
      return $(document.activeElement).closest(this.$()).length !== 0;
    };

    view.addFocus = function (where) {
      this.smartTextarea.addFocus(where);
    };
  });

  return TextView;
});

define('loadcss!css/expressions.table', function(){});
define('template!table_icon', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<span class="dcg-icon-box dcg-variable-errortooltip tipsy-sticky dcg-action-icon dcg-do-not-blur" \n      handleevent="true"\n      disablescroll="true"\n>\n  <span class="dcg-icon dcg-graph-icon dcg-variable-colorcss">\n    <i class=\'dcg-icon-hidden\'></i>\n  </span>\n</span>';
}
return __p;
};});
define('template!table_column_menu', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class=\'dcg-table-column-menu dcg-options-menu\'>\n  <div class=\'dcg-triangle\'></div>\n  <div class=\'dcg-styles-div\'>\n    <div class=\'dcg-title\'>'+
( t('style:') )+
'</div>\n    <div>\n      <span class=\'dcg-columnmode-option dcg-graph-icon dcg-table-points dcg-variable-colorcss\' mode="POINTS"></span>\n      <span class=\'dcg-columnmode-option dcg-graph-icon dcg-table-lines dcg-variable-colorcss\' mode="LINES"></span>\n      <span class=\'dcg-columnmode-option dcg-graph-icon dcg-table-points-and-lines dcg-variable-colorcss\' mode="POINTS_AND_LINES"></span>\n    </div>\n  </div>\n  <div class=\'dcg-colors-div\'>\n    <div class=\'dcg-title\'>'+
( t('color:') )+
'</div>\n    <div class="template-colorsview"></div>\n  </div>\n</div>';
}
return __p;
};});
define('expressions/table_column_menu_view',['require','pjs','underscore_view','template!table_column_menu','jquery','./color_menu_view'],function(require){
  var P = require('pjs');
  var UnderscoreView = require('underscore_view');
  var template = require('template!table_column_menu');
  var $ = require('jquery');
  var ColorMenuView = require('./color_menu_view');

  var TableColorMenuView = P(UnderscoreView, function (view, _super) {
    view.template = template;

    view.init = function (parentView, column) {
      _super.init.call(this);
      this.column = column;
      this.parentView = parentView;

      this.column.observe('color.columnmenuview', this.renderColorCSS.bind(this));
      this.column.observe('columnMode.columnmenuview', this.renderSelectedColumnMode.bind(this));
      this.column.observe('shouldGraph.columnmenuview', this.renderSelectedColumnMode.bind(this));
    };

    view.destruct = function () {
     this.column.unobserve('.columnmenuview');
    };

    view.renderColorCSS = function () {
      var color = this.column.color;
      this.$('.dcg-variable-colorcss').css({
        'border-color' : color,
        'background-color': color
      });
    };

    view.renderSelectedColumnMode = function () {
      this.$('.dcg-columnmode-option').removeClass('dcg-selected');

      if (this.column.shouldGraph) {
        var columnMode = this.column.columnMode;
        this.$('.dcg-columnmode-option[mode="'+columnMode+'"]').addClass('dcg-selected');
      }
    };

    view.didInsertElement = function () {
      this.$().on('tap tapstart', '.dcg-columnmode-option', this.onSelectColumnMode.bind(this));
      this.renderColorCSS();
      this.renderSelectedColumnMode();

      // this view has a nested template. We instantiate the color picker
      // and replace a placeholder element within the html.
      var colorsView = ColorMenuView(this.column);
      colorsView.replace(this.$('.template-colorsview'));
    };

    view.onSelectColumnMode = function (evt) {
      // when using mouse, fire on 'tapStart' and when on touch we
      // fire on the 'tap' event.
      if (evt.type === 'tap' && evt.device === 'mouse') return;
      if (evt.type === 'tapstart' && evt.device === 'touch') return;

      var columnMode = $(evt.target).closest('.dcg-columnmode-option').attr('mode');

      // the column is visible and we've clicked the same columnMode again; hide the column and return
      if (!this.column.hidden && this.column.columnMode === columnMode) {
        this.column.setProperty('hidden', true);
        return;
      }

      this.column.setProperty('columnMode', columnMode);
      this.column.setProperty('hidden', false);

      // making column visible should make folder visible
      var folder = this.column.table.folder;
      if (folder) {
        folder.setProperty('hidden', false);
      }
    };

  });

  return TableColorMenuView;
});

define('expressions/table_icon_view',['require','./abstract_icon','pjs','template!table_icon','graphing/columnmode','./table_column_menu_view','jquery.handleevent','conditional_blur'],function(require){
  var AbstractIconView = require('./abstract_icon');
  var P = require('pjs');
  var template = require('template!table_icon');
  var COLUMNMODE = require('graphing/columnmode');
  var TableColumnMenuView = require('./table_column_menu_view');
  require('jquery.handleevent');
  var conditionalBlur = require('conditional_blur');

  var TableIconView = P(AbstractIconView, function (view, _super) {
    view.template = template;

    view.init = function (parentView) {
      _super.init.call(this, parentView);
      this.column = this.model;
      this.tableView = parentView.tableView;
      this.listView = this.tableView.listView;
      this.column.observe('color.iconview', this.renderColorCSS.bind(this));
      this.column.observe('error.iconview', this.onDisplayChange.bind(this));
      this.column.observe('columnMode.iconview', this.onDisplayChange.bind(this));
      this.column.observe('shouldGraph.iconview', this.onDisplayChange.bind(this));
      this.tableView.observeEvent('hideContextMenu.iconview', this.hideOptions.bind(this));
    };

    view.destruct = function () {
      _super.destruct.call(this);
      this.column.unobserve('.iconview');
      this.tableView.unobserve('.iconview');
    };

    view.renderErrorShown = function () {
      this.$('.dcg-icon').toggleClass('dcg-error', !!this.errorShown);
      this.$().closest('.dcg-cell').toggleClass('dcg-error', !!this.errorShown);
    };

    view.renderColorCSS = function() {
      this.$('.dcg-variable-colorcss').css('border-color', this.column.color);
      this.$('.dcg-variable-colorcss').css('background', this.column.color);
    };

    view.toggleGraphShown = function() {
      if (!this.column.isGraphable) return;
      if (this.errorShown) return;

      // Trying to edit whether a graph is shown in a hidden folder should
      // show the folder.
      if (this.model.table.folder && this.model.table.folder.hidden) {
        this.model.table.folder.setProperty('hidden', false);
        this.column.setProperty("hidden", false);
        return;
      }

      this.column.setProperty("hidden", !this.column.hidden);
    };

    view.didInsertElement = function () {
      _super.didInsertElement.call(this);
      var self = this;
      function handleIconTap (evt) {
        if (evt.wasLongheld()) return;
        if (self.optionsShown) {
          self.hideOptions();
          return;
        }
        if (self.listView.editListMode) {
          self.toggleOptions();
        } else {
          self.toggleGraphShown();
        }
      }

      function handleIconLongHold (evt) {
        if (self.optionsShown) return;
        self.toggleOptions(); // will create TableColumnMenuView
      }

      function handleIconTapStart (evt_orig) {
        if (self.optionsShown) return;
        if (evt_orig.touches.length !== 1) return;

        conditionalBlur();
      }

      this.$('.dcg-action-icon').on('tap', handleIconTap);
      this.$('.dcg-action-icon').on('longhold', handleIconLongHold);
      this.$('.dcg-action-icon').on('tapstart', handleIconTapStart);

      this.renderColorCSS();
      this.onDisplayChange();

      this.$icon = this.$('.dcg-icon');
    };

    view.createOptionsMenuView = function () {
      var optionsView = TableColumnMenuView(this, this.column);
      optionsView.appendTo(this.listView.$());

      // putting the column menu view at the topLeft of the .dcg-icon-box
      // it's up to the column menu view's css to position it beyond that
      var placeholder = this.$('.dcg-icon-box');
      var placeholderOffset = placeholder.offset();
      var listViewOffset = this.listView.$().offset();
      optionsView.$().css({
        position: 'absolute',
        top: placeholderOffset.top - listViewOffset.top + 'px',
        left: placeholderOffset.left - listViewOffset.left + 'px',
        display: 'block' //wait until we know where it is to show it. fixes #3154
      });

      return optionsView;
    };

    view.onDisplayChange = function () {
      _super.onDisplayChange.call(this);
      if (!this.$icon) return;

      var shouldGraph = this.column.shouldGraph;
      var columnMode = this.column.columnMode;
      var isGraphable = this.column.isGraphable;
      var icon_class = '';

      if (this.error || !isGraphable) {
        icon_class = '';
      } else {

        if (!shouldGraph) {
          icon_class = 'dcg-graph-hidden';
        } else if (columnMode === COLUMNMODE.POINTS) {
          icon_class = 'dcg-table-points';
        } else if (columnMode === COLUMNMODE.LINES) {
          icon_class = 'dcg-table-lines';
        } else if (columnMode === COLUMNMODE.POINTS_AND_LINES) {
          icon_class = 'dcg-table-points-and-lines';
        }

      }

      // efficently changes the class of the icon
      if (this.rendered_icon_class === icon_class) return;
      if (this.rendered_icon_class) {
        this.$icon.removeClass(this.rendered_icon_class);
      }
      this.rendered_icon_class = icon_class;
      if (icon_class) {
        this.$icon.addClass(icon_class);
      }

    };
  });

  return TableIconView;
});
define('template!table', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='';
 if (renderShell) {
;__p+='\n\n<div class="dcg-expressionitem dcg-expressiontable dcg-shell">\n  <div class=\'dcg-shell\'></div>\n</div>\n\n';
 } else {
;__p+='\n\n<div class="dcg-expressionitem dcg-expressiontable">\n\n  <div class=\'dcg-fade-container dcg-disable-horizontal-scroll-to-cursor\'>\n\n    <span class="dcg-main">\n      <div class="dcg-tabledata">\n\n        ';
 _.each(columns, function (column, c) {
;__p+='\n          <div class="dcg-column">\n\n            ';

               print(templates.table_cell_header());

               _.each(columns[0].cells, function (junk, r) {
                 print(templates.table_cell_body())
               });

;__p+='\n\n          </div>\n        ';
 });
;__p+='\n\n      </div>\n    </span>\n\n    ';
 //covers up the right hand side of an overflowing table
;__p+='\n    <span class="dcg-fadeout"></span>\n    <i class="dcg-icon-remove dcg-top-level-delete dcg-action-delete" handleEvent="true"></i>\n  </div>\n\n  <span class="dcg-tab dcg-action-drag"\n        handleevent="true"\n        tapboundary="true"\n        disablescroll="true"\n  >\n    <span class=\'dcg-num dcg-variable-index\'></span>\n    <div class=\'dcg-tab-interior\'></div>\n  </span>\n\n  <span class=\'dcg-exp-actions\'>\n\n    <span\n      class="dcg-action-delete dcg-delete-btn dcg-tooltip"\n      handleEvent="true"\n      tooltip="'+
( t('Delete') )+
'"\n    >\n      <i class=\'dcg-icon-remove\'></i></span>\n    </span>\n</div>\n\n';
 }
;__p+='\n';
}
return __p;
};});
define('template!table_cell_body', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="dcg-non-editable dcg-empty dcg-cell">\n  <div class="dcg-inner-border"></div>\n  <span class="dcg-error-indicator dcg-do-not-blur tipsy-sticky" handleevent="true">\n  </span>\n\n  <span class=\'mathquill-rendered-math\'></span>\n  <div class="dcg-empty-line"></div>\n</div>\n';
}
return __p;
};});
define('template!table_cell_header', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="dcg-cell dcg-table-header">\n  <div class="dcg-inner-border"></div>\n  <span class="template-icon"></span>\n  <span class="mathquill-rendered-math"></span>\n  <span class="dcg-fadeout"></span>\n  <span class="dcg-action-removecolumn dcg-icon-remove dcg-do-not-blur" handleevent="true"></span>\n  <div class="dcg-empty-line"></div>\n</div>\n';
}
return __p;
};});
define('expressions/table_view',['require','loadcss!css/expressions.table','jquery','underscore','pjs','underscore_view','mathquill','jquery.handleevent','keys','conditional_blur','i18n','./abstractitem_view','./table_icon_view','template!table','template!table_cell_body','template!table_cell_header'],function(require) {
  require('loadcss!css/expressions.table');
  var $ = require('jquery');
  var _ = require('underscore');
  var P = require('pjs');
  var UnderscoreView = require('underscore_view');
  require('mathquill');
  require('jquery.handleevent');
  var Keys = require('keys');
  var conditionalBlur = require('conditional_blur');
  var i18n = require('i18n');

  var AbstractItemView = require('./abstractitem_view');
  var TableIconView = require('./table_icon_view');

  var templates = {};

  templates.table = require('template!table');
  templates.table_cell_body = require('template!table_cell_body');
  templates.table_cell_header = require('template!table_cell_header');

  var TableView = P(AbstractItemView, function(view, _super) {

    view.template = templates.table;

    view.init = function (model, listView) {
      _super.init.call(this, model, listView);

      this.model.triggerRowRemoved = this.onRowRemoved.bind(this);
      this.model.triggerRowAdded = this.onRowAdded.bind(this);
      this.model.triggerColumnAdded = this.onColumnAdded.bind(this);
      this.model.triggerColumnRemoved = this.onColumnRemoved.bind(this);
      this.model.triggerColumnMoved = this.onColumnMoved.bind(this);
      this.model.observe('changingMultipleCells.' + this.guid, this.onChangingMultipleCells.bind(this));
      this.model.observe('selectedCell.' + this.guid, this.onSelectedCellChange.bind(this));
      this.model.observe('inCollapsedFolder.' + this.guid, function () {
        if (!this.model.inCollapsedFolder) {
          //even though we render initially when you open a collapsed folder,
          //I think we still need this for the following (absurd) edge case:
          //* open folder
          //* close folder
          //* toggle projector mode
          //* open folder
          this.recomputeAllRowHeights();
        }
      }.bind(this));
    };

    view.destruct = function () {
      this.model.unobserve('.' + this.guid);

      function noop () {}
      this.model.triggerRowRemoved = noop;
      this.model.triggerRowAdded = noop;
      this.model.triggerColumnAdded = noop;
      this.model.triggerColumnRemoved = noop;
      this.model.triggerColumnMoved = noop;
    };

    view.getTemplateParams = function () {
      return {
        columns: this.model.columns,
        renderShell: this.model.renderShell,
        templates: templates
      };
    };

    view.onChangingMultipleCells = function () {
      // we're done making multiple changes. check if any cell changes
      // requested a syncRow
      if (!this.model.changingMultipleCells) {
        if(this.__syncRowRequestedDuringBatchedUpdate) {
          this.__syncRowRequestedDuringBatchedUpdate = false;
          this.syncAllRowHeights();
        }
      }
    };

    view.onRowRemoved = function (index) {
      if (!this.columnViews) return;

      // index starts at 0 for row under headers. columnViews starts at 0
      // including header. Make the adjustment here.
      var r = index+1;

      // remove the cells
      for (var c = 0; c < this.columnViews.length; c++) {
        var cellView = this.columnViews[c].splice(r, 1)[0];
        cellView.remove();
      }

      // update which cell is selected
      this.model.notifyPropertyChange('selectedCell');
    };

    view.onRowAdded = function (index) {
      if (!this.columnViews) return;

      // index starts at 0 for row under headers. columnViews starts at 0
      // including header. Make the adjustment here.
      var r = index+1;
      var cell;
      var cellView;
      var columns = this.model.columns;
      var columnCount = this.columnViews.length;
      var $columns = this.$('.dcg-column');

      for (var c = 0; c < columnCount; c++) {
        cell = columns[c].cells[index];

        // insert new cells into columns to form a row
        cellView = CellView(cell, this);
        cellView.insertAfter($columns.eq(c).find('.dcg-cell:nth-of-type('+r+')'));

        this.columnViews[c].splice(r, 0, cellView);
      }

      this.syncRowHeight(r);

      this.listView.model.updateDrawOrder();

      // update which cell is selected
      this.model.notifyPropertyChange('selectedCell');
    };

    view.onColumnRemoved = function (index) {
      if (!this.columnViews) return;

      // remove the cells and then the entire column
      var columnCellViews = this.columnViews.splice(index, 1)[0];
      for (var i=0; i < columnCellViews.length; i++) {
        columnCellViews[i].remove();
      }
      this.$('.dcg-column:nth-child('+(index+1)+')').remove();

      var cell = this.selectedCell;

      if (cell && cell.column > index) {
        // selection was after the deleted column, so decrease selected
        // column.
        this.setProperty('selectedCell', {row: cell.row, column: cell.column-1});
      } else if (cell && cell.column === index) {
        // deleted column was selected, so we need to try to select another
        // one.

        if (this.columns.length <= index) {
          // we just deleted the last column, so we have to select the one
          // to the left of where we just deleted
          this.selectCell(cell.row, cell.column-1);
        } else {
          // we can put focus back in the column that just slid into the
          // deleteded one's place.
          this.selectCell(cell.row, cell.column);
        }
      } else {
        // don't need to do anything because the deleted column was after the
        // selected column. Or, there was no selected column.
      }

      this.syncAllRowHeights();

      this.listView.model.updateDrawOrder();

      // update which cell is selected
      this.model.notifyPropertyChange('selectedCell');
    };

    view.onColumnAdded = function (index) {
      if (!this.columnViews) return;

      var column = this.model.columns[index];
      var cells = column.cells;
      var i, views = [];

      // create header
      views.push(HeaderView(column, this));

      // create each cell for each row
      for (i=0; i<cells.length-1; i++) {
        views.push(CellView(cells[i], this));
      }

      // add bottom cell
      views.push(BottomCellView(cells[i], this));

      this.columnViews.splice(index, 0, views);

      // add a column to the table
      var $column = $('<div class="dcg-column"></div>').insertAfter(this.$('.dcg-column:nth-child('+index+')'));

      // add each cell view to the column
      views.forEach(function (view, i) {
        view.appendTo($column);
      });

      this.syncAllRowHeights();

      this.listView.model.updateDrawOrder();

      // update which cell is selected
      this.model.notifyPropertyChange('selectedCell');
    };

    view.onColumnMoved = function (from, to) {
      if (!this.columnViews) return;
      var columnView = this.columnViews.splice(from, 1)[0];
      this.columnViews.splice(to, 0, columnView);

      // remove the column and insert somewhere else
      var $movedColumn = this.$('.dcg-column:nth-child('+(from+1)+')').detach();
      $movedColumn.insertAfter(this.$('.dcg-column:nth-child('+(to)+')'));
    };

    view.onProjectorModeChange = function () {
      this.recomputeAllRowHeights();
    };

    view.didCreateElement = function () {
      var self = this;
      this.$().on('focusin', function(){
        setTimeout(self.onFocusChange.bind(self),0);
      });
      this.$().on('keydown', this.onMathQuillKeydownEvent.bind(this));
      this.$().on(
        'upPressed downPressed leftPressed rightPressed enterPressed backspacePressed delPressed',
        this.onMathQuillSpecialEvent.bind(this)
      );
    };

    view.didInsertElement = function () {
      _super.didInsertElement.call(this);
      if (this.model.renderShell) return;

      this.columnViews = [];

      // all the cells are placed in the dom, but they aren't setup yet.
      // optimization: could walk through the table more efficiently to access
      // the cell's dom element rather than doing a this.findCell(r,c) every
      // time. Could walk left to right, top to bottom.
      var columns = this.model.columns;
      var columnCount = columns.length;
      var rowCount = columns[0].cells.length;
      var r,c,cell,cellView;

      // setup header cells
      for (c=0; c < columnCount; c++) {
        cell = columns[c];

        if (c+1 < columnCount) {
          cellView = HeaderView(cell, this);
        } else {
          cellView = RightHeaderView(cell, this);
        }

        cellView.setDomNode(this.findCell(0,c));
        this.columnViews[c] = [cellView];
      }

      // setup body cells
      var bottomRow = rowCount;

      for (r=1; r <= rowCount; r++) {
        for (c=0; c < columnCount; c++) {
          cell = columns[c].cells[r-1];

          if (r === bottomRow) {
            cellView = BottomCellView(cell, this);
          } else {
            cellView = CellView(cell, this);
          }

          cellView.setDomNode(this.findCell(r,c));

          this.columnViews[c].push(cellView);
        }
      }

      this.syncAllRowHeights();
      this.onSelectedCellChange();
    };

    view.measureRowHeight = function (row) {
      var maxCollapsedHeight = 0;

      for (var i=0; i<this.columnViews.length; i++) {
        var cellView = this.columnViews[i][row];

        // make sure we've measured this cell before. Newly created cells are collapsed but unmeasured
        if (cellView.collapsedHeight === undefined) {
          cellView.measureHeight();
        }

        if (cellView.collapsedHeight > maxCollapsedHeight) {
          maxCollapsedHeight = cellView.collapsedHeight;
        }
      }

      return maxCollapsedHeight;
    };

    view.setRowHeight = function (row, height) {
      for (var i=0; i<this.columnViews.length; i++) {
        var cellView = this.columnViews[i][row];
        cellView.setHeight(height);
        cellView.setMathquillTop();
      }
    };

    view.recomputeAllRowHeights = function () {
      if (!this.columnViews) return;
      // must collapse all cells first
      for (var i=0; i<this.columnViews.length; i++) {
        var views = this.columnViews[i];
        for (var j=0; j<views.length; j++) {
          views[j].collapseHeight();
        }
      }

      this.syncAllRowHeights();
    };

    // is called when entire table needs updated
    view.syncAllRowHeights = function () {
      if (this.model.inCollapsedFolder) return;

      var row;
      var rows = this.columnViews[0].length;
      var heights = [];

      for (row=0; row<rows; row++) {
        heights.push(this.measureRowHeight(row));
      }

      for (row=0; row<rows; row++) {
        this.setRowHeight(row, heights[row]);
      }
    };

    view.syncRowHeight = function (row) {
      // optimizes the case that multiple cells are being updated at once.
      // instead of measuring row heights for each value update, we wait until
      // the last cell is changed and measure all rows once.
      if (this.model.changingMultipleCells) {
        this.__syncRowRequestedDuringBatchedUpdate = true;
      } else {
        this.setRowHeight(row, this.measureRowHeight(row));
      }
    };

    view.onSelectedCellChange = function () {
      if (!this.columnViews) return;

      // could optimize by remembering what cell last had selected class
      this.$('.dcg-tabledata .dcg-selected').removeClass('dcg-selected');

      var cell = this.model.selectedCell;

      // TODO - set selectedCell = null at time the cell is deleted rather than
      // catch it here. This is a bit hacky.
      // make sure cell isn't out of range
      if (cell) {
        if (cell.column >= this.columnViews.length || cell.row >= this.columnViews[0].length) {
          this.model.selectedCell = null; //silently overwrite the property. won't fire observers
          return;
        }
      }

      if (cell) {
        var cellView = this.columnViews[cell.column][cell.row];
        cellView.$().addClass('dcg-selected');

        this.model.setProperty('selected', true);
      }

      // if the cell with focus isn't selected, then remove focus
      var caret = this.getCaretPosition();
      if (caret && !_.isEqual(caret, cell)) {
        if (document.activeElement) {
          conditionalBlur();
        }
      }

      // need to do this manually if the cell that's focused is not editable.
      // these handlers are what hide/show keypad.
      if (cell) {
        var input = this.findCellInput(cell.row, cell.column)[0];
        this.listView.onFocusIn({target: input});
      } else {
        this.listView.onFocusOut();
      }

      var no_faded_h = cell && cell.column+1 === this.model.columns.length;
      var no_faded_v = cell && cell.row === this.model.columns[0].cells.length;
      this.$().toggleClass('dcg-no-faded-h', !!no_faded_h);
      this.$().toggleClass('dcg-no-faded-v', !!no_faded_v);

      this.hideContextMenu();

      var lastRowSelected = (
        this.model.selectedCell &&
        this.model.selectedCell.row === this.model.columns[0].cells.length
      );

      this.setProperty('lastRowSelected', lastRowSelected);
    };

    view.onMouseSelect = function(evt) {
      if (evt.wasHandled()) return;
      evt.handle();

      // use .originalEvent.target to ignore the bounds-checking stuff that
      // touchtracking.js does, because the cursor handle can (and in fact
      // usually does) stick out of the td's bounding box
      var td = $(evt.originalEvent.target).closest('.dcg-cell');
      var editable = td.find('.mathquill-editable');
      if (editable.length) {
        this.sendTapToMathQuill(evt, editable);
        return;
      }

      var target = $(evt.target);
      var table = target.closest('.dcg-tabledata')[0];

      // if we're clicking on the table itself, we don't know which cell
      // we meant to click. We'll just act like we clicked the outer padding.
      // that's not terrible, because for us to reach this point, we must
      // have clicked in seemingly blank space anyways.
      if (table && evt.target === table) {
        table = null;
      }

      if (!table) {
        if (document.activeElement) conditionalBlur();

        this.model.setProperty('selectedCell', null);
        this.model.setProperty('selected', true);
        return;
      }

      //select the uneditable cell
      var cell = this.getNodesCellPosition(target);
      this.selectCell(cell.row, cell.column);
    };

    view.getNodesCellPosition = function (node) {
      var c = node.closest('.dcg-column').prevAll('.dcg-column').length;
      var r = node.closest('.dcg-cell').prevAll('.dcg-cell').length;
      return {row: r, column: c};
    };

    view.getCaretPosition = function () {
      if (this.$().find(document.activeElement).length) {
        return this.getNodesCellPosition($(document.activeElement));
      } else {
        return null;
      }
    };

    view.findCell = function (r ,c) {
      return this.$('.dcg-column:nth-of-type('+(c+1)+') .dcg-cell:nth-of-type('+(r+1)+')');
    };

    view.findCellInput = function (r, c) {
      return this.findCell(r,c).find('.mathquill-rendered-math');
    };

    view.selectCell = function (r, c, selectEnd) {
      if (r < 0 || c < 0) return;

      var mathquill = this.findCellInput(r, c);
      if (!mathquill.length) return;

      var newSelectedCell = {row: r, column: c};
      this.model.setProperty('selectedCell', newSelectedCell);

      if (mathquill.hasClass('mathquill-editable')) {
        mathquill.mathquill('focus');
        if (selectEnd) {
         mathquill.mathquill('moveEnd');
        } else {
          mathquill.triggerHandler('select_all');
        }
      } else {
        conditionalBlur();
      }
    };

    view.unfocus = function () {
      var active = document.activeElement;
      if (this.$().find(active).length) {
        active.blur();
      }
    };

    view.processMissedKeyEvent = function (evt) {
      this.doKeyAction(Keys.lookup(evt), evt);
    };

    view.onMathQuillKeydownEvent = function (evt) {
      var key = Keys.lookup(evt);
      if (key === Keys.Tab || key === Keys.ESCAPE) {
        this.doKeyAction(key, evt);
      }
    };

    view.onMathQuillSpecialEvent = function (evt) {
      var evt_type = evt.type;
      var key = evt_type.slice(0, -('Pressed'.length));
      key = key.charAt(0).toUpperCase() + key.slice(1);
      this.doKeyAction(key, evt);
    };

    view.doKeyAction = function (key, evt) {
      /* jshint maxcomplexity:24 */
      // it's possible this came from a fake key event (keypad for example)
      // just create a dumby event so that evt.preventDefault() is callable.
      if (!evt) evt = $.Event();

      var list = this.listView.model;

      var selectedCell = this.model.selectedCell;
      var r_orig = selectedCell ? selectedCell.row : -1;
      var c_orig = selectedCell ? selectedCell.column : -1;

      var columns = this.model.columns;
      var totalRows = columns[0].cells.length;
      var totalCols = columns.length;

      var _move = function (r, c) {

        // try to wrap it around up one row and to the very right.
        if (r === -1) {
          this.triggerUpPressed();
        } else if ( r > totalRows) {
          this.triggerDownPressed();
        } else {

          // wrap around the left side. goes up a row and to the far right.
          if (c === -1) {
            c = totalCols-1;
            r--;

          // wrap around the right side. goes down a row and to the far left.
          } else if (c === totalCols) {
            r++;
            c=0;
          }

          this.selectCell(r, c);
          evt.preventDefault();
        }
      }.bind(this);

      var _deleteRow = function (r) {

        // don't delete the last row
        if (totalRows <= 1) return;

        // remove the old row
        this.model.removeRow(r_orig-1);

        this.selectCell(r, c_orig);
        evt.preventDefault();
      }.bind(this);

      var _deleteColumn = function (c) {
        // don't delete the first col, and don't delete one of last two cols
        if ( c_orig === 0 || totalCols <= 2) return;

        // remove the old row
        this.model.removeColumn(c_orig);

        this.selectCell(r_orig, c);
        evt.preventDefault();
      }.bind(this);

      switch (key) {

        case Keys.LEFT:  _move(r_orig, c_orig-1);  break;
        case Keys.RIGHT:  _move(r_orig, c_orig+1); break;
        case Keys.UP:  _move(r_orig-1, c_orig);    break;
        case Keys.DOWN:  _move(r_orig+1, c_orig);  break;

        case Keys.ENTER:
          //at the end, we add a new expression underneath
          if (r_orig >= totalRows) return this.triggerEnterPressed();

          //in later columns, we just move down
          if (c_orig > 0) return _move(r_orig + 1, c_orig);

          //in the last row of the first column, we auto-populate
          if (r_orig === totalRows - 1) {
            this.model.insertRow(r_orig, this.model.getAutofillValues(r_orig));
            return this.selectCell(r_orig+1, c_orig);
          }

          //default in first column: insert blank row
          this.model.insertRow(r_orig, c_orig);
          this.selectCell(r_orig+1, c_orig);
          break;

        case Keys.ESCAPE:
          conditionalBlur();
          this.model.setProperty('selectedCell', null);
          break;

        case Keys.TAB:

          // if focus isn't within the table, then prevent tab default.
          if ($(document.activeElement).closest(this.$()).length === 0) {
            evt.preventDefault();
            return;
          }
          break;

        case Keys.BACKSPACE:
          if (r_orig === 0) {
            if(c_orig === 0){ //backspace in empty top-left cell removes whole table
              this.triggerBackspacePressed();
              list.undoRedo.triggerFlash();
            }

            // move left if you're the rightmost column or in only column after the first
            else if (c_orig === totalCols-1 || c_orig === 1 && totalCols === 3) {
              _move(0, c_orig-1);
            }

            else {
              _deleteColumn(c_orig-1);
            }

          } else if (c_orig !== 0) {
            _move(r_orig, c_orig-1);
          } else if (r_orig === totalRows) {
            // backspace in bottom row simply moves up a row.
            _move(r_orig-1, c_orig);
          } else {
            _deleteRow(r_orig-1);
          }
          break;

        case Keys.DELETE:
          if (r_orig === 0) {
            if(c_orig === 0){
              this.triggerDelPressed();
              list.undoRedo.triggerFlash();
            }

            // only delete column if its not on the far right
            else if (c_orig < totalCols-1) {
              _deleteColumn(c_orig);
            }

          } else if (r_orig >= totalRows) {
            // can't delete last row
          } else {
            _deleteRow(r_orig);
          }
          break;
      }
    };

    view.onFocusChange = function() {
      if (!this.model) return;
      this.model.setProperty('selectedCell', this.getCaretPosition());
      if (!this.model.list) return;
      //changing selection within a table should be treated like other instances of selection changing
      //for example: we want to ensureActiveChildIsVisible in list_view
      this.model.list.notifyPropertyChange('selectedItem');
    };


    view.isFocused = function () {
      return !!this.model.selectedCell;
    };

    view.addFocus = function (where, r, c) {
      if (where === 'cell') {
        this.selectCell(r,c);
      }

      else if (where !== 'end') {
        this.selectCell(0,0);
      }

      else {
        this.selectCell(this.model.columns[0].cells.length, 0);
      }
    };

  });


  // a view that will be a cell within a div-based table. it contains machinery to measure and set the cell's
  // height. That's important for syncing the heights of all cells in a 'row'
  var DivCellView = P(UnderscoreView, function (divCellView, _super) {

    divCellView.init = function () {
      _super.init.call(this);

      this.collapsedHeight = undefined;
      this.renderedHeight = undefined;
      this.mathquillTop = 0;
    };

    // overridden by subclass
    divCellView.lookupCellPosition = function () {};

    divCellView.handleHeightUpdate = function () {
      this.collapseHeight();
      this.tableView.syncRowHeight(this.lookupCellPosition().row);
    };

    // removes the height style of the cell. It'll collapse down to the size of the contents
    // NOTE: this.collapsedHeight and this.renderedHeight will be invalid after this
    //       it's up to whomever calls this to make sure measureHeight is called
    //       at an appropriate time. The two have been split for potential performance reasons.
    divCellView.collapseHeight = function () {
      this.$().css('height', '');
      this.collapsedHeight = undefined;
      this.renderedHeight = undefined;
    };

    // measures the current height. It's assumed that the cell is collapsed; otherwise you
    // could have just read this.renderedHeight directly
    divCellView.measureHeight = function () {
      this.collapsedHeight = this.$().outerHeight();
      this.renderedHeight = this.collapsedHeight;
    };

    // sets the new height of the cell
    divCellView.setHeight = function (height) {
      if (this.renderedHeight !== height) {
        this.renderedHeight = height;
        this.$().css('height', height);
      }
    };

    // moves mathquill to the bottom of the cell
    divCellView.setMathquillTop = function () {
      var mathquillTop = this.renderedHeight - this.collapsedHeight;
      if (mathquillTop !== this.mathquillTop) {
        this.mathquillTop = mathquillTop;
        this.$('.mathquill-rendered-math').css('top', mathquillTop);
      }
    };
  });

  var RightHeaderView = P(DivCellView, function(headerView, _super) {
    headerView.template = templates.table_cell_header;

    headerView.init = function (model, tableView) {
      _super.init.call(this);

      this.model = model;
      this.tableView = tableView;
    };

    headerView.lookupCellPosition = function () {
      return {
        row: 0,
        column: this.model.index
      };
    };

    headerView.didInsertElement = function () {
      _super.didInsertElement.call(this);

      // it's the right side
      this.$().addClass('dcg-right');
      this.$().append('<span class="dcg-fade-right"></span>');

      this.$mathquill = this.$('.mathquill-rendered-math').mathquill('editable');

      var self = this;
      this.$().on('blur focusout', '.mathquill-rendered-math', function () {
        self.$mathquill.mathquill('clearSelection');
      });

      this.$().on('render', '.mathquill-rendered-math', function () {
        var latex = $(this).mathquill('latex');
        if (!latex) return;

        // set latex back to blank
        $(this).mathquill('latex', '');

        var index = self.model.index;
        self.model.table.insertColumn(index , {latex: latex});

        // select the new cell and put focus at end
        self.tableView.selectCell(0, index, true);
      });
    };

  });

  var HeaderView = P(DivCellView, function(headerView, _super) {
    headerView.template = templates.table_cell_header;

    headerView.init = function (model, tableView) {
      _super.init.call(this);
      this.__renderedLatex = '';
      this.__renderedBefore = false;

      this.model = model;
      this.tableView = tableView;

      // TODO - get rid of a need to put index in html
      this.model.observe('index.headerview', this.updateIndex.bind(this));
      this.model.observe('latex.headerview', this.onLatexChange.bind(this));
      this.model.observe('selected.headerview', this.onSelectedChange.bind(this));
    };

    // it's possible to select the headers during trace, so we need
    // to make sure we focus the header too
    headerView.onSelectedChange = function () {
      if (this.model.selected) {
        var tableView = this.tableView;
        if (!tableView) return;

        tableView.selectCell(0, this.model.index);
      }
    };

    headerView.lookupCellPosition = function () {
      return {
        row: 0,
        column: this.model.index
      };
    };

    headerView.destruct = function () {
      this.model.unobserve('.headerview');
    };

    headerView.updateIndex = function () {
      this.$().attr('index', this.model.index);
    };

    headerView.onLatexChange = function () {
      if (!this.$mathquill) return;

      if (this.__renderedLatex !== this.model.latex) {
        this.__renderedLatex = this.model.latex;
        this.$mathquill.mathquill('latex', this.model.latex);
      }

      if (this.__renderedBefore) this.handleHeightUpdate();
      this.__renderedBefore = true;
    };

    headerView.didInsertElement = function () {
      _super.didInsertElement.call(this);

      if (this.model.index === 0) {
        this.$().addClass('dcg-left');
      }

      this.$mathquill = this.$('.mathquill-rendered-math').mathquill('editable');
      // TODO - move these mathquill handlers up to the table view instead of
      // assigning them on each table cell individually
      var self = this;
      this.$().on('blur focusout', '.mathquill-rendered-math', function () {
        self.$mathquill.mathquill('clearSelection');
      });
      this.$().on('tap', '.dcg-action-removecolumn', function () {
        self.model.table.removeColumn(self.model.index);
      });
      this.$().on('render', '.mathquill-rendered-math', function () {
        var oldLatex = self.model.latex;
        var newLatex = $(this).mathquill('latex');
        if (oldLatex === newLatex) return;

        self.__renderedLatex = newLatex;
        self.model.setProperty('latex', newLatex);
      });

      this.iconView = TableIconView(this);
      this.iconView.replace(this.$('.template-icon'));

      this.onLatexChange();
      this.updateIndex();
    };

  });


  var BaseCellView = P(DivCellView, function (cellView, _super) {
    cellView.template = templates.table_cell_body;

    cellView.init = function (model, tableView) {
      _super.init.call(this);

      this.model = model;
      this.tableView = tableView;

      this.__renderedDisabled = true;
      this.__renderedValue = '';
      this.__renderedError = '';
      this.__renderedBefore = false;
    };

    cellView.didInsertElement = function () {
      _super.didInsertElement.call(this);

      if (this.model.column === _.first(this.model.column.table.columns)) {
        this.$().addClass('dcg-left');
      }

      if (this.model.column === _.last(this.model.column.table.columns)) {
        this.$().addClass('dcg-right');
        this.$().append('<span class="dcg-fade-right"></span>');
      }

      if (this.model === _.last(this.model.column.cells)) {
        this.$().addClass('dcg-bottom');
        this.$().append('<span class="dcg-fade-bottom"></span>');
      }
    };

    cellView.lookupCellPosition = function () {
      var cells = this.model.column.cells;
      var cell = this.model;

      return {
        row: _.indexOf(cells, cell) + 1, //because there is a header above it
        column: this.model.column.index
      };
    };

    cellView.onValueChange = function () {
      var oldValue = this.model.getOldProperty('value');
      var value = this.model.value;
      this.$().toggleClass('dcg-empty', !value);

      if (!this.$mathquill) return;

      if (this.__renderedValue !== value) {
        this.__renderedValue = value;

        // disabled mathquill can only have simple numerical values. Just
        // set the text. Ideally .mathquill('latex', ...) would work for
        // non-editable mathquill, but it doesn't. So we can hack this
        // together by simply setting the inner contents directly.
        if (this.__renderedDisabled) {
          this.$mathquill.text(value).mathquill();
        }

        else {
          this.$mathquill.mathquill('latex', value);
        }
      }

      // we were a single line and are still a single line if the oldValue and new value
      // are both (a simple number OR empty). If this has happened, we don't need to
      // update the height of this cell. It hasn't changed.
      var stillSingleLine = (!oldValue || isFinite(oldValue)) && (!value || isFinite(value));
      if (this.__renderedBefore && !stillSingleLine) this.handleHeightUpdate();
      this.__renderedBefore = true;
    };

    cellView.onDisabledChange = function () {
      var disabled = !!this.model.column.disabled;
      if (!this.$mathquill || this.__renderedDisabled === disabled) return;
      this.__renderedDisabled = disabled;

      this.$().toggleClass('dcg-non-editable', !!disabled);

      // revert mathquill to not editable
      if (disabled) {
        // Ideally we'd use .mathquill('revert') but that doesn't do what
        // you'd expect. It completely gets rid of mathquill. It doesn't turn
        // an editable mathquill back to non-editable. So, we destroy the
        // mathquill and replace it with an non-editable one.
        var $newMathquill = $('<span class="mathquill-rendered-math">'+ this.model.value +'</span>');
        this.$mathquill.replaceWith($newMathquill);
        this.$mathquill = $newMathquill;

        // created a new mathquill, so mark that it's not shifted down at all
        this.mathquillTop = 0;
      }

      // make mathquill editable
      else {

        // TODO - The empty underline is the wrong size if we make
        // mathquill editable in the same code loop as when the td
        // is added to the dom. Not sure how to fix that.
        this.$mathquill.mathquill('editable');
      }
    };

    cellView.onErrorChange = function () {
      var error = this.model.error ? i18n.unpack(this.model.error) : '';

      if (!this.$error || this.__renderedError === error) return;
      this.__renderedError = error;

      this.$error.attr('tooltip', error);
      this.$().toggleClass('dcg-error', !!error);
    };
  });

  var BottomCellView = P(BaseCellView, function (cellView, _super) {

    cellView.init = function (model, tableView) {
      _super.init.call(this, model, tableView);

      this.model.column.observe('disabled.cellview', this.onDisabledChange.bind(this));
    };

    cellView.destruct = function () {
      this.model.column.unobserve('.cellview');
    };

    cellView.didInsertElement = function () {
      _super.didInsertElement.call(this);

      this.$mathquill = this.$('.mathquill-rendered-math');

      this.onDisabledChange();

      var self = this;
      this.$().on('blur focusout', '.mathquill-rendered-math', function () {
        self.$mathquill.mathquill('clearSelection');
      });

      this.$().on('render', '.mathquill-rendered-math', function () {
        var latex = $(this).mathquill('latex');
        if (latex === '') return;

        // add a row
        $(this).mathquill('latex', '');
        var position = self.lookupCellPosition();

        var table = self.model.column.table;

        var rowValues = [];
        for (var i=0; i < table.columns.length; i++) {
          rowValues[i] = '';
        }

        rowValues[position.column] = latex;
        table.insertRow(position.row-1, rowValues);
        self.tableView.selectCell(position.row, position.column, true);
      });
    };
  });

  var CellView = P(BaseCellView, function (cellView, _super) {

    cellView.template = templates.table_cell_body;
    cellView.init = function (model, tableView) {
      _super.init.call(this, model, tableView);

      this.model.observe('value.cellview', this.onValueChange.bind(this));
      this.model.observe('error.cellview', this.onErrorChange.bind(this));
      this.model.column.observe('disabled.' + this.guid, this.onDisabledChange.bind(this));
    };

    cellView.destruct = function () {
      this.model.unobserve('.cellview');
      this.model.column.unobserve('disabled.' + this.guid);
    };

    cellView.didInsertElement = function () {
      _super.didInsertElement.call(this);

      this.$error = this.$('.dcg-error-indicator');
      this.$mathquill = this.$('.mathquill-rendered-math');

      this.onDisabledChange();
      this.onValueChange();
      this.onErrorChange();

      // TODO - move these mathquill handlers up to the table view instead of
      // assigning them on each table cell individually
      var self = this;
      this.$().on('blur focusout', '.mathquill-rendered-math', function () {
        self.$mathquill.mathquill('clearSelection');
      });

      // TODO - should move to model. Without this, the model won't have Undo/Redo
      this.$().on('render', '.mathquill-rendered-math', function () {
        var oldValue = self.model.value;
        var newValue = $(this).mathquill('latex');
        if (oldValue === newValue) return;
        self.__renderedValue = newValue;

        var id = self.model.column.table.id;
        var position = self.lookupCellPosition();
        var list = self.tableView.listView.model; //TODO ick
        function getCell () {
          var table = list.getItemById(id);
          var column = table.columns[position.column];
          return column.cells[position.row-1];
        }

        list.undoRedo.addTransaction({
          type: list.undoRedo.CAUSE_OF_CHANGE,
          undo: function () {
            var cell = getCell();
            cell.setProperty('value', oldValue);
            cell.column.table.requestParse();
          },
          redo: function () {
            var cell = getCell();
            cell.setProperty('value', newValue);
            cell.column.table.requestParse();
          }
        });

      });
    };
  });

  return TableView;
});

define('template!folder', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='';
if (renderShell) {
;__p+='\n\n<div class="dcg-do-not-blur dcg-expressionitem dcg-expressionfolder dcg-shell">\n  <div class="dcg-shell"></div>\n</div>\n\n';
 } else {
;__p+='\n\n<div class="dcg-do-not-blur dcg-expressionfolder dcg-expressionitem">\n  <div class="dcg-fade-container">\n\n    <span class="dcg-main">\n      <div class="dcg-caret-container dcg-action-toggle-folder-collapsed dcg-do-not-blur" handleEvent="true">\n        <i class="dcg-icon-caret-down" ></i>\n      </div>\n\n      <div class="dcg-smart-textarea-placeholder"></div>\n    </span>\n    <i class="dcg-icon-remove dcg-top-level-delete dcg-action-delete" handleEvent="true"></i>\n\n  </div>\n\n  <span class="dcg-tab dcg-action-drag"\n        handleEvent="true"\n        tapboundary="true"\n        disablescroll="true"\n  >\n    <span class="dcg-num dcg-variable-index"></span>\n    <div class="dcg-tab-interior">\n    <span class="dcg-action-toggle-folder-hidden dcg-graph-icon dcg-folder dcg-icon">\n      <i class="dcg-icon-hidden"></i>\n      <i class="dcg-icon-folder"></i>\n    </span>\n    </div>\n  </span>\n\n  <span class="dcg-exp-actions">\n    <span\n      class="dcg-action-delete dcg-delete-btn dcg-tooltip"\n      handleEvent="true"\n      tooltip="'+
( t('Delete') )+
'"\n    >\n      <i class=\'dcg-icon-remove\'></i></span>\n    </span>\n  </span>\n\n</div>\n\n';
 }
;__p+='\n';
}
return __p;
};});
define('expressions/folder_view',['require','pjs','expressions/abstractitem_view','template!folder','./smart_textarea','jquery.handleevent'],function (require) {
  var P = require('pjs');
  var AbstractItemView = require('expressions/abstractitem_view');
  var template = require('template!folder');
  var SmartTextarea = require('./smart_textarea');
  require('jquery.handleevent');

  var FolderView = P(AbstractItemView, function(view, _super) {
    view.template = template;

    view.init = function (model, listView) {
      _super.init.call(this, model, listView);
      this.model = model;
      model.observe('hidden.folderView', this.onHiddenChanged.bind(this));
      model.observe('collapsed.folderView', this.onCollapsedChanged.bind(this));
      model.observe('selected.folderView', this.onSelectedChange.bind(this));
      model.observe('count.folderView', this.onMemberIdsChange.bind(this));

      this.smartTextarea = SmartTextarea(this.model.title);
      this.model.observe('title.folderView', function() {
        this.smartTextarea.setProperty('text', this.model.title);
      }.bind(this));
      this.smartTextarea.observe('text', function() {
        this.model.setProperty('title', this.smartTextarea.text);
      }.bind(this));
    };

    view.destruct = function () {
      this.model.unobserve('.folderView');
      this.smartTextarea.destruct();
    };

    view.didInsertElement = function () {
      _super.didInsertElement.call(this);
      if (this.model.renderShell) return;

      this.smartTextarea.replace(this.$('.dcg-smart-textarea-placeholder'));

      this.smartTextarea.observe('focused', function () {
        if (this.smartTextarea.focused) this.model.setProperty('selected', true);
      }.bind(this));
      this.smartTextarea.observeEvent('enterPressed', this.triggerEnterPressed.bind(this));
      this.smartTextarea.observeEvent('upPressed', this.triggerUpPressed.bind(this));
      this.smartTextarea.observeEvent('downPressed', this.triggerDownPressed.bind(this));
      this.smartTextarea.observeEvent('backspacePressed', this.triggerBackspacePressed.bind(this));
      this.smartTextarea.observeEvent('delPressed', this.triggerDelPressed.bind(this));
      //need to include smart-textarea in minWidth
      this.setMinWidth();

      this.$('.dcg-action-toggle-folder-collapsed').on(
        'tap',
        this.toggleCollapsed.bind(this)
      );
      this.$('.dcg-action-toggle-folder-hidden').on(
        'tap',
        this.toggleHidden.bind(this)
      );

      this.onCollapsedChanged();
      this.onHiddenChanged();
      this.onMemberIdsChange();
    };

    view.onSelectedChange = function () {
      if (!this.selected && this.$title) {
        this.smartTextarea.blur();
      }
    };

    view.onMemberIdsChange = function () {
      this.$().toggleClass('dcg-has-items', this.model.count > 0);
    };

    view.onProjectorModeChange = function() {
      this.smartTextarea.fitText();
    };

    view.onMouseSelect = function(evt) {
      if (evt.wasHandled()) return;
      evt.handle();

      this.model.setProperty('selected', true);
    };

    view.toggleHidden = function () {
      this.model.setProperty('hidden', !this.model.hidden);
    };

    view.toggleCollapsed = function () {
      this.model.setProperty('collapsed', !this.model.collapsed);
    };

    view.onHiddenChanged = function () {
      this.$().toggleClass('dcg-hidden', !!this.model.hidden);
    };

    view.onCollapsedChanged = function () {
      this.$().toggleClass('dcg-collapsed', !!this.model.collapsed);

      if (!this.model.collapsed) {
        this.listView.triggerFolderOpened();
      }
    };

    view.addFocus = function (where) {
      this.smartTextarea.addFocus();
    };
  });

  return FolderView;
});

define('loadcss!css/expressions.image', function(){});
define('loadcss!css/image_opacity_menu', function(){});
define('template!image_options_menu', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class=\'dcg-exp-options-menu dcg-image-options-menu dcg-options-menu\'>\n  <div class=\'dcg-triangle\'></div>\n  <div class=\'dcg-opacities-div\'>\n    <div class=\'dcg-opacities-menu\'>\n      <div class=\'dcg-title\'>opacity:</div>\n      <div class=\'dcg-opacities-menu\'>\n      ';
 _.each([.2, .4, .6, .8, 1], function (opacity) {
;__p+='\n        <span class="dcg-opacity-option dcg-graph-icon"\n          image-opacity="'+
( opacity )+
'"\n          handleevent="true">\n            <span class="dcg-image-thumb"\n              style="opacity: '+
( opacity )+
'">\n            </span>\n            <i class=\'dcg-icon-check\'></i>\n        </span>\n      ';
 })
;__p+='\n      </div>\n    </div>\n  </div>\n</div>\n';
}
return __p;
};});
define('expressions/image_options_view',['require','loadcss!css/image_opacity_menu','pjs','jquery','underscore_view','template!image_options_menu'],function(require){
  require('loadcss!css/image_opacity_menu');

  var P = require('pjs');
  var $ = require('jquery');
  var UnderscoreView = require('underscore_view');
  var template = require('template!image_options_menu');


  var ImageOptionsMenuView = P(UnderscoreView, function (view, _super) {
    view.template = template;

    view.init = function (image) {
      this.image = image;
      this.image.observe('opacity.' + this.guid, this.renderSelectedOpacity.bind(this));
      this.image.observe('hidden.' + this.guid, this.renderSelectedOpacity.bind(this));
      this.image.observe('image_url.' + this.guid, this.renderImageURL.bind(this));
    };

    view.destruct = function () {
      this.image.unobserve('.' + this.guid);
    };

    view.onSelectOpacity = function (evt) {
      // when using mouse, fire on 'tapStart' and when on touch we
      // fire on the 'tap' event.
      if (evt.type === 'tap' && evt.device === 'mouse') return;
      if (evt.type === 'tapstart' && evt.device === 'touch') return;

      var opacity = parseFloat($(evt.target).closest('.dcg-opacity-option').attr('image-opacity'));
      this.image.setProperty('hidden', false);
      this.image.setProperty('opacity', opacity);

      //if we're in a folder, show it.
      if (this.image.folder) this.image.folder.setProperty('hidden', false);
    };

    view.renderSelectedOpacity = function () {
      var opacity = this.image.opacity;
      this.$('.dcg-opacity-option').removeClass('dcg-selected');
      if (!this.image.hidden) {
        this.$('.dcg-opacity-option[image-opacity="'+opacity+'"]').addClass('dcg-selected');
      }
    };

    view.renderImageURL = function () {
      if (this.image.image_url) {
        this.$('.dcg-image-thumb').css('background-image', 'url('+ encodeURI(this.image.image_url) +')');
      }
    };

    view.didInsertElement = function () {
      this.$().on('tap tapstart', '.dcg-opacity-option', this.onSelectOpacity.bind(this));
      this.renderSelectedOpacity();

      this.renderImageURL();
    };

  });

  return ImageOptionsMenuView;
});

define('template!image_icon', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<span class="dcg-icon dcg-graph-icon dcg-variable-errortooltip tipsy-sticky">\n  <span class="dcg-image-thumb"></span>\n  <i class="dcg-icon-hidden"></i>\n</span>\n';
}
return __p;
};});
define('expressions/image_icon_view',['require','pjs','expressions/abstract_icon','./image_options_view','template!image_icon','jquery.handleevent'],function(require){
  var P = require('pjs');
  var AbstractIconView = require('expressions/abstract_icon');
  var ImageOptionsMenuView = require('./image_options_view');
  var template = require('template!image_icon');
  require('jquery.handleevent');

  var ImageIconView = P(AbstractIconView, function (view, _super) {
    view.template = template;

    view.init = function (parentView) {
      _super.init.call(this, parentView);
      this.expression = this.model;
      this.image = this.model;

      this.image.observe('opacity.' + this.guid, this.onDisplayChange.bind(this));
      this.image.observe('shouldGraph.' + this.guid, this.onDisplayChange.bind(this));
      this.image.observe('loaded.' + this.guid, this.onDisplayChange.bind(this));
      this.image.observe('error.' + this.guid, this.onDisplayChange.bind(this));
      this.image.observe('image_url.' + this.guid, this.renderImageURL.bind(this));

      this.parentView.observeEvent('hideContextMenu.' + this.guid, this.hideOptions.bind(this));
    };

    view.destruct = function () {
      _super.destruct.call(this);

      this.image.unobserve('.' + this.guid);
      this.parentView.unobserve('.' + this.guid);
    };

    view.renderImageURL = function () {
      if (this.image.image_url) {
        this.$imgThumb.css('background-image', 'url('+ encodeURI(this.image.image_url)+')');
      }
    };

    view.didInsertElement = function () {
      var self = this;
      _super.didInsertElement.call(this);
      this.$icon = this.$('.dcg-icon');
      this.$imgThumb = this.$icon.find('.dcg-image-thumb');

      this.renderImageURL();
      this.onDisplayChange();

      var handleIconTapped = function(evt, device){
        if(evt.wasHandled('dragdrop')) return; //Don't toggle if we were handled by dragdrop
        if(evt.wasLongheld()) return;
        if(evt.device !== device) return;

        if (self.optionsShown) {
          self.toggleOptions();
          return false;
        }

        if (self.parentView.listView.editListMode) {
          self.toggleOptions();
        } else {
          if (self.errorShown) return;

          if (self.image.folder && self.image.folder.hidden) {
            self.image.setProperty('hidden', false);
            self.image.folder.setProperty('hidden', false);
          } else {
            self.image.setProperty('hidden', !self.image.hidden);
          }
        }
      };

      var handleIconLongHold = function(evt, device) {
        if(evt.device !== device) return;

        evt.handle('longhold');
        self.toggleOptions();
      };

      this.$().closest('.dcg-action-icon-mouse').on('tap', function(evt){
        handleIconTapped(evt, 'mouse');
      });

      this.$().closest('.dcg-action-icon-touch').on('tap', function(evt){
        handleIconTapped(evt, 'touch');
      });

      this.$().closest('.dcg-action-icon-mouse').on('longhold', function(evt){
        handleIconLongHold(evt, 'mouse');
      });

      this.$().closest('.dcg-action-icon-touch').on('longhold', function(evt){
        handleIconLongHold(evt, 'touch');
      });
    };

    view.createOptionsMenuView = function () {
      var listView = this.parentView.listView;
      var optionsView = ImageOptionsMenuView(this.expression);
      optionsView.appendTo(listView.$());

      // putting the ImagenOptionsView at the topLeft of the .dcg-icon
      // it's up to the ImageOptionsView's css to position it beyond that
      var placeholder = this.$('.dcg-icon');
      var placeholderOffset = placeholder.offset();
      var listViewOffset = listView.$().offset();
      optionsView.$().css({
        position: 'absolute',
        top: placeholderOffset.top - listViewOffset.top + 'px',
        left: placeholderOffset.left - listViewOffset.left + 'px',
        display: 'block' //wait until we know where it is to show it. fixes #3154
      });
      return optionsView;
    };

    view.onDisplayChange = function () {
      _super.onDisplayChange.call(this);
      if (!this.$icon) return;

      var icon_class = '';

      if (!this.image.loaded) {
        icon_class = 'dcg-loading-image';
      } else if (this.error) {
        icon_class = '';
      } else if (!this.image.shouldGraph) {
        icon_class = 'dcg-hidden';
      }

      // efficently changes the class of the icon
      if (this.rendered_icon_class !== icon_class) {
        if (this.rendered_icon_class) {
          this.$icon.removeClass(this.rendered_icon_class);
        }
        this.rendered_icon_class = icon_class;
        if (icon_class) {
          this.$icon.addClass(icon_class);
        }
      }
      if (!icon_class) {
        this.$imgThumb.css('opacity', this.image.opacity);
      }
    };
  });

  return ImageIconView;
});
define('template!image', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='';
 if (renderShell) {
;__p+='\n\n<div class="dcg-do-not-blur dcg-expressionitem expressionimage dcg-shell">\n  <div class=\'dcg-shell\'></div>\n</div>\n\n';
 } else {
;__p+='\n\n<div class="dcg-do-not-blur dcg-expressionimage dcg-expressionitem">\n  <div class=\'dcg-fade-container\'>\n\n    <span class="dcg-main">\n      <div class="dcg-image-loading">Loading image...</div>\n      <div class="dcg-image-loaded">\n\n          <div class="dcg-smart-textarea-placeholder"></div>\n\n          <div class="dcg-do-blur" handleEvent="true">\n            <div class="dcg-edit-image dcg-variable-invalid dcg-desmos-input-container">\n              <div class="dcg-center-inputs">\n                '+
( t('center:'))+
'\n                <span class="dcg-image-center">\\left(\\MathQuillMathField[dcg-image-input-x]{} , \\MathQuillMathField[dcg-image-input-y]{}\\right)</span>\n              </div>\n              <div class="dcg-size-inputs">\n                '+
( t('size:'))+
'\n                <span class="dcg-image-size">\\MathQuillMathField[dcg-image-input-width]{} &times; \\MathQuillMathField[dcg-image-input-height]{}</span>\n              </div>\n            </div>\n          </div>\n\n      </div>\n    </span>\n    <span class="dcg-fadeout"></span>\n\n    <i class="dcg-icon-remove dcg-top-level-delete dcg-action-delete" handleEvent="true"></i>\n\n    <div class="dcg-template-bottom-container dcg-fixed-width-element">\n      <div class="dcg-template-bottom"></div>\n    </div>\n  </div>\n\n  <span class="dcg-tab dcg-action-drag dcg-action-icon-touch" handleEvent="true">\n    <span class=\'dcg-num dcg-variable-index\'></span>\n    <div class=\'dcg-tab-interior dcg-action-icon-mouse\'>\n      <span class="template-imageicon"></span>\n    </div>\n  </span>\n\n  <span class=\'dcg-exp-actions\'>\n    <span class="dcg-graphic" handleEvent="true"></span>\n    <span class="dcg-action-delete dcg-delete-btn" handleEvent="true"><i class=\'dcg-icon-remove\'></i></span>\n  </span>\n\n</div>\n\n';
 }
;__p+='\n';
}
return __p;
};});
define('expressions/image_view',['require','loadcss!css/expressions.image','jquery','pjs','keys','./abstractitem_view','./image_icon_view','expressions/promptslider_view','conditional_blur','./smart_textarea','jquery.handleevent','template!image'],function(require) {
  require('loadcss!css/expressions.image');
  var $ = require('jquery');
  var P = require('pjs');
  var Keys = require('keys');
  var AbstractItemView = require('./abstractitem_view');
  var ImageIconView = require('./image_icon_view');
  var PromptSliderView = require('expressions/promptslider_view');
  var conditionalBlur = require('conditional_blur');
  var SmartTextarea = require('./smart_textarea');
  require('jquery.handleevent');

  var template = require('template!image');

  var ImageView = P(AbstractItemView, function(view, _super) {

    view.template = template;

    view.init = function (model, listView) {
      _super.init.call(this, model, listView);
      this.model = model;

      // enable animations on the frame after the helpers are evaluated.
      // Only need to watch for a single helper because they'll all be batched.
      var self = this;
      this.model.helpers.x.observe('formula.' + this.guid, function () {
        setTimeout(function () {
          self.setProperty('doAnimate', true);
        });
      });
      this.smartTextarea = SmartTextarea(this.model.name);
      this.model.observe('name.' + this.guid, function() {
        this.smartTextarea.setProperty('text', this.model.name);
      }.bind(this));
      this.smartTextarea.observe('text', function() {
        this.model.setProperty('name', this.smartTextarea.text);
      }.bind(this));
    };

    view.addFocus = function (where) {
      this.smartTextarea.addFocus();
    };

    view.onSelectedChange = function() {
      if (!this.model.selected ) {
        // find the focused mathquill (if there is one)
        var focused = $(document.activeElement).closest('.mathquill-editable');

        // check if the focused mathquill is within this view
        if (focused.closest(this.$()).length) {
          focused.mathquill('blur');
        }
      }
    };

    view.handleLeftPressed = function (evt) {
      var input = $(evt.target).closest('.dcg-math-input')[0];
      if (this.$y[0] === input) {
        this.$x.mathquill('focus');
      } else if (this.$height[0] === input) {
        this.$width.mathquill('focus');
      }
    };

    view.handleRightPressed = function (evt) {
      var input = $(evt.target).closest('.dcg-math-input')[0];
      if (this.$x[0] === input) {
        this.$y.mathquill('focus');
      } else if (this.$width[0] === input) {
        this.$height.mathquill('focus');
      }
    };

    view.handleDownPressed = function (evt) {
      var input = $(evt.target).closest('.dcg-math-input')[0];
      if (this.$x[0] === input) {
        this.$width.mathquill('focus');
      } else if (this.$y[0] === input) {
        this.$height.mathquill('focus');
      }
    };

    view.handleUpPressed = function (evt) {
      var input = $(evt.target).closest('.dcg-math-input')[0];
      if (this.$width[0] === input) {
        this.$x.mathquill('focus');
      } else if (this.$height[0] === input) {
        this.$y.mathquill('focus');
      }
    };

    view.handleKeydown = function (evt) {
      var key = Keys.lookup(evt);
      if (key === Keys.ESCAPE) conditionalBlur();
    };

    // blur input when enter pressed
    view.handleMathquillInput = function(evt) {
      var input = this.$(evt.target).closest('.dcg-math-input');
      var value = input.mathquill('latex');
      var limit = input.attr('limit');
      this.model.setProperty(limit, value);
    };

    view.didFocusIn = false;
    view.focusInMathquill = function(evt) {
      var input = this.$(evt.target).closest('.dcg-math-input');

      //focusin is triggered always, even when reclicking into a selected mathquill
      //we don't want to reselect in that case.
      if (!input.hasClass('dcg-focus')) {
        input.addClass('dcg-focus');
        input.triggerHandler('select_all');
        //on iPad/iPhone select_all isn't working synchronously. gross hack to make sure that we select all
        //TODO: remove this when we update mathquill, which fixes lots of focus issues
        setTimeout(function() {
          if (!input.find('.mq-selection').length) {
            input.triggerHandler('select_all');
          }
        }, 1);
      }

      this.model.setProperty('selected', true);

      //focusIn is called before focusOut, but we want this to happen after
      this.didFocusIn = true;
      this.$().addClass('dcg-input-focused');
      var self = this;
      setTimeout(function(){
        self.didFocusIn = false;
      });
    };

    view.focusOutMathquill = function(evt) {
      var input = this.$(evt.target).closest('.mathquill-editable');
      input.removeClass('dcg-focus');
      input.mathquill('clearSelection');

      if (!this.didFocusIn) this.$().removeClass('dcg-input-focused');
    };

    view.didInsertElement = function () {
      _super.didInsertElement.call(this);
      if (this.model.renderShell) return;

      this.smartTextarea.replace(this.$('.dcg-smart-textarea-placeholder'));
      this.smartTextarea.observe('focused', function () {
        if (this.smartTextarea.focused) this.model.setProperty('selected', true);
      }.bind(this));
      this.smartTextarea.observeEvent('enterPressed', this.triggerEnterPressed.bind(this));
      this.smartTextarea.observeEvent('upPressed', this.triggerUpPressed.bind(this));
      this.smartTextarea.observeEvent('downPressed', this.triggerDownPressed.bind(this));
      this.smartTextarea.observeEvent('backspacePressed', this.triggerBackspacePressed.bind(this));
      this.smartTextarea.observeEvent('delPressed', this.triggerDelPressed.bind(this));

      //need to include smart-textarea in minWidth
      this.setMinWidth();

      this.iconView = ImageIconView(this);
      this.iconView.replace('.template-imageicon');

      // create and select for the \MathQuillMathField's
      var containingMathquill = this.$('.dcg-image-center,.dcg-image-size').mathquill();
      this.$x = containingMathquill.find('.dcg-image-input-x').attr('limit','x');
      this.$y = containingMathquill.find('.dcg-image-input-y').attr('limit','y');
      this.$width = containingMathquill.find('.dcg-image-input-width').attr('limit','width');
      this.$height = containingMathquill.find('.dcg-image-input-height').attr('limit','height');

      // listen to the mathquill inputs
      var editables = containingMathquill.find('.mathquill-editable');
      var self = this;
      editables.on('focusin', this.focusInMathquill.bind(this))
               .on('focusout', this.focusOutMathquill.bind(this))
               .on('render', this.handleMathquillInput.bind(this))
               .on('leftPressed', this.handleLeftPressed.bind(this))
               .on('upPressed', this.handleUpPressed.bind(this))
               .on('downPressed', this.handleDownPressed.bind(this))
               .on('rightPressed', this.handleRightPressed.bind(this))
               .on('keydown', this.handleKeydown.bind(this))
               .on('tap', function (evt) {
                  // self = the ImageView
                  // this = the editable mathquill that was clicked
                  self.sendTapToMathQuill(evt, $(this));
               })
               .addClass('dcg-math-input');

      // add these observers after the element is fully instantiated. Only after that
      // point is the dom fully in place for these renders to work. If the model updates
      // while the shell is still visible, we'll either get an error thrown (renderInvalids)
      // or we'll miss the dom update completely (renderVariables).
      this.renderX();
      this.renderY();
      this.renderWidth();
      this.renderHeight();
      this.renderInvalids();
      this.renderLoaded();
      this.renderVariables();
      this.model.observe('loaded.' + this.guid, this.renderLoaded.bind(this));
      this.model.observe('variables.' + this.guid, this.renderVariables.bind(this));
      this.model.observe('selected.' + this.guid, this.onSelectedChange.bind(this));
      this.model.observe('x.' + this.guid, this.renderX.bind(this));
      this.model.observe('y.' + this.guid, this.renderY.bind(this));
      this.model.observe('width.' + this.guid, this.renderWidth.bind(this));
      this.model.observe('height.' + this.guid, this.renderHeight.bind(this));
      this.model.observe('errors.' + this.guid, this.renderInvalids.bind(this));
    };

    view.renderLoaded = function() {
      var loaded = this.model.loaded;
      this.$().toggleClass('dcg-loading', !loaded);

      // must redraw the mathquill when loaded because it can't render correctly when display:none
      if (loaded) {
        this.$('.dcg-image-center,.dcg-image-size').mathquill('redraw');
        this.smartTextarea.renderText();
      }
    };

    view.destruct = function () {
      this.model.unobserve('.' + this.guid);
      this.model.helpers.x.unobserve('formula.' + this.guid);
      this.smartTextarea.destruct();

      if (this.optionsView) {
        this.optionsView.remove();
        this.optionsView = null;
      }
      if (this.promptSliderView) {
        this.promptSliderView.remove();
        this.promptSliderView = null;
      }
    };

    view.renderInvalids = function () {
      this.$x.toggleClass('dcg-invalid', !!this.model.errors.x);
      this.$y.toggleClass('dcg-invalid', !!this.model.errors.y);
      this.$width.toggleClass('dcg-invalid', !!this.model.errors.width);
      this.$height.toggleClass('dcg-invalid', !!this.model.errors.height);
    };

    view.renderX = function () {
      var value = this.model.x;
      if (this.$x.mathquill('latex') !== value) {
        this.$x.mathquill('latex', value);
      }
    };

    view.renderY = function () {
      var value = this.model.y;
      if (this.$y.mathquill('latex') !== value) {
        this.$y.mathquill('latex', value);
      }
    };

    view.renderWidth = function () {
      var value = this.model.width;
      if (this.$width.mathquill('latex') !== value) {
        this.$width.mathquill('latex', value);
      }
    };

    view.renderHeight = function () {
      var value = this.model.height;
      if (this.$height.mathquill('latex') !== value) {
        this.$height.mathquill('latex', value);
      }
    };

    view.renderVariables = function () {
      if (!this.model.variables) return;

      var promptCreateSlider = this.model.variables.length > 0;
      if (this.promptSliderView && !promptCreateSlider) {
        this.removeViewFromBottom(this.promptSliderView);
        this.promptSliderView = null;
      } else if (!this.promptSliderView && promptCreateSlider) {
        this.promptSliderView = this.createPromptSliderView();
        this.addViewToBottom(this.promptSliderView);
      }

      if (this.promptSliderView) {
        this.promptSliderView.setProperty('variables', this.model.variables);
      }
    };

    view.createPromptSliderView = function () {
      return PromptSliderView(this);
    };

    view.onMouseSelect = function(evt) {
      if (evt.wasHandled()) return;
      evt.handle();

      this.model.setProperty('selected', true);
    };

    view.isFocused = function () {
      return $(document.activeElement).closest(this.$()).length !== 0;
    };
  });

  return ImageView;
});

define('template!list', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div>\n\n<div class=\'dcg-show-expressions-tab\'>\n  <a\n    class=\'dcg-resize-list-btn dcg-action-showexpressions dcg-tooltip\'\n    tooltip="'+
( t('Show List') )+
'"\n  >\n    <i class=\'dcg-icon-show\'></i>\n  </a>\n</div>\n\n\n<div class="dcg-exppanel-outer">\n  <div class="dcg-exppanel-container">\n    <div class="dcg-expression-top-bar">\n      <a class=\'dcg-btn dcg-btn-medium dcg-pull-left dcg-hide-in-edit dcg-add-expression-btn dcg-action-add-expression dcg-tooltip dcg-do-not-blur\' handleEvent="true" tooltip="'+
( t('Add Item') )+
'"><i class=\'dcg-icon-plus\'></i><i class=\'dcg-icon-caret-down\'></i></a>\n\n      <a class=\'dcg-btn dcg-btn-red dcg-btn-medium dcg-pull-left dcg-show-in-edit dcg-action-clearall\'> '+
( t('Delete All') )+
'</a>\n      <span class=\'dcg-center-aligned dcg-show-in-edit\'>\n        <a class=\'dcg-action-undo dcg-tooltip\' tooltip="'+
( t('Undo (ctrl+z)') )+
'"><i class=\'dcg-icon-undo\'></i></a>\n        <a class=\'dcg-action-redo dcg-tooltip\' tooltip="'+
( t('Redo (ctrl+y)') )+
'"><i class=\'dcg-icon-redo\'></i></a>\n      </span>\n\n      <a class=\'dcg-resize-list-btn dcg-hide-in-edit dcg-action-hideexpressions dcg-tooltip\' tooltip="'+
( t('Hide List') )+
'"><i class=\'dcg-icon-hide\'></i></a>\n\n      <a\n        class=\'dcg-btn dcg-btn-medium dcg-pull-right dcg-action-toggle-edit dcg-hide-in-edit dcg-tooltip dcg-do-not-blur\' handleEvent="true" tooltip="'+
( t('Edit List') )+
'">\n        <i class=\'dcg-icon-settings\' />\n      </a>\n      <a\n        class=\'dcg-btn dcg-btn-blue dcg-btn-medium dcg-pull-right dcg-action-toggle-edit dcg-show-in-edit dcg-do-not-blur\'\n        handleEvent="true">\n          '+
( t('Done') )+
'\n      </a>\n    </div>\n\n    <div class="dcg-exppanel dcg-disable-horizontal-scroll-to-cursor">\n\n      <div class=\'dcg-drop-image\'>\n        <span>'+
( t('Drop Image Here') )+
'</span>\n      </div>\n\n      <div class="dcg-expressionlist">\n        <span class="dcg-template-expressioneach"></span>\n        <div class="template-newexpression"></div>\n\n        <a class="dcg-expressions-branding" href="//www.desmos.com/" target="_blank">\n          <div class="dcg-powered-by">powered by</div>\n          <i class="dcg-icon-desmos"></i>\n        </a>\n      </div>\n    </div>\n  </div>\n</div>\n\n\n</div> <!-- close container div-->\n';
}
return __p;
};});
define('expressions/list_view',['require','loadcss!css/expression_top_bar','loadcss!css/expressions','loadcss!css/expressions.icon','jquery','underscore','pjs','tipsy','underscore_view','touchtracking','expressions/dragdrop_expressions','./add_expression','conditional_blur','keys','browser','scroll_helpers','jquery.handleevent','./new_expression','./expression','./expression_view','./text_view','./table_view','./folder_view','./image_view','template!list'],function (require) {
  require('loadcss!css/expression_top_bar');
  require('loadcss!css/expressions');
  require('loadcss!css/expressions.icon');

  var $ = require('jquery');
  var _ = require('underscore');
  var P = require('pjs');
  require('tipsy');
  var UnderscoreView = require('underscore_view');
  var touchtracking = require('touchtracking');
  var DragDropExpressions = require('expressions/dragdrop_expressions');
  var AddExpressionView = require('./add_expression');
  var conditionalBlur = require('conditional_blur');
  var Keys = require('keys');
  var Browser = require('browser');

  var scrollHelpers = require('scroll_helpers');
  require('jquery.handleevent');
  var NewExpressionView = require('./new_expression');
  var ExpressionObject = require('./expression');
  var ExpressionView = require('./expression_view');
  var TextView = require('./text_view');
  var TableView = require('./table_view');
  var FolderView = require('./folder_view');
  var ImageView = require('./image_view');

  var template = require('template!list');

  var ExpressionListView = P(UnderscoreView, function (view, _super) {
    view.__itemViews = {};
    view.__latexChangeCallbacks = [];
    view.isTransient = false;
    view.transientChildren = [];
    view.template = template;

    // Overridden by Calc.
    // TODO: copied and pasted over from list_view_tablet, but this feels really dirty
    // There's got to be a better way to do this.
    view.triggerClearGraph = function () {};

    view.onLatexChange = function (latex) {
      _.each(this.__latexChangeCallbacks, function (cb) { cb(latex); });
    };

    view.init = function (model, $root, toastView, graphSettings) {
      _super.init.call(this);

      this.$root = $root || $('body');
      this.setProperty('scrollbarWidth', 0);
      this.setProperty('minWidth', 356);

      this.toastView = toastView;
      this.graphSettings = graphSettings;
      this.model = model;
      this.model.triggerItemInserted = this.onItemInserted.bind(this);
      this.model.triggerItemRemoved = this.onItemRemoved.bind(this);
      this.model.triggerItemMoved = this.onItemMoved.bind(this);
      this.model.triggerSetState = this.onSetState.bind(this);

      this.observe('itemFocused', this.renderItemFocused.bind(this));
      this.observe('editListMode', this.renderEditListMode.bind(this));

      // ensure selected expression is visible on selection change and focused
      // expression is visible on keypress
      this.model.observe('selectedItem', this.ensureActiveChildIsVisible.bind(this));

      this.dragdrop_expressions = DragDropExpressions(this);
      this.createAllItemViews();
    };

    view.computeTransient = function(){
      this.setProperty('transient', this.transientChildren.length > 0);
    };

    //when sliding a slider, we want to temporarily pad the bottom enough that things don't move around
    view.padLastExpression = function(padding) {
      var $lastExp = this.$('.dcg-expressionitem.dcg-new-expression');
      $lastExp.css('margin-bottom', + padding + 'px');
    };

    view.unpadLastExpression = function() {
      var $lastExp = this.$('.dcg-expressionitem.dcg-new-expression');
      $lastExp.css('margin-bottom', '0');
      this.recalculateScrollbarWidth();
    };

    view.padLastExpressionUntilTapEnd = function(padding){
      var self = this;
      this.padLastExpression(padding);
      $(document).on('tap.animating-bottom', function() {
        if (self.$('.dcg-exp-options-menu').length === 0) {
          self.unpadLastExpression();
          $(document).off('tap.animating-bottom');
        }
      });
    };

    //we need to set minWidth at least once, because otherwise
    //we never set the css property, which caused: https://github.com/desmosinc/knox/issues/3878
    //we also don't want to set the css every time, because that'll be a performance burden
    //finally, we need to set it *initially* or else we get a weird slide-in animation
    //because layout_controller doesn't call this until after everything's all instantiated.
    //solution: just store some state recording whether we should ignore our no-op trap
    view.minWidthHasBeenSet = false;
    view.setMinWidth = function (newWidth) {
      if (!this.$exps) return;
      if (newWidth === this.minWidth && this.minWidthHasBeenSet) return;
      this.minWidthHasBeenSet = true;
      this.setProperty('minWidth', newWidth);
      var newCss = {minWidth: newWidth};
      if (!this.itemFocused) newCss.maxWidth = newWidth;
      this.$exppanelContainer.css(newCss);
    };

    view.updateAllViewWidths = function () {
      _.each(this.__itemViews, function (view) { view.setMinWidth(); });
    };

    view.recalculateScrollbarWidth = function () {
      var scrollbarWidth = this.$('.dcg-exppanel').width() - this.$('.dcg-expressionlist').width();
      scrollbarWidth = Math.max(scrollbarWidth, 0);
      this.setProperty('scrollbarWidth', scrollbarWidth);
    };

    view.updateWidth = function () {
      if (!this.$exps) return;
      var exppanel = this.$exppanelContainer;
      var maxWidth = 0;
      //don't update width if we're full-width (i.e. on a smallscreen)
      if (exppanel.css('min-width') === '100%') return;

      var minWidth = this.minWidth;

      this.$('.dcg-disable-horizontal-scroll-to-cursor').scrollLeft(0);

      function includeWidth ($element) {
        var main = $element.find('.dcg-main');
        if (!main.length) return;

        var width = main.outerWidth() + main.offset().left;
        if (width > maxWidth) maxWidth = width;
      }
      var selected = this.getSelectedView();
      if (selected && (this.itemFocused || selected.model.isTable)) {
        includeWidth(selected.$());
      }

      if (this.editListMode) {
         this.$('.dcg-expressiontable').each(function () {
           includeWidth($(this));
         });
      }

      if (maxWidth < minWidth) {
        maxWidth = minWidth;
      }

      exppanel.css('max-width', maxWidth);
      this.recalculateScrollbarWidth();
    };


    view.onItemInserted = function (index, item) {
      //update index for newExpressionView
      if (this.newExpressionView) {
        this.newExpressionView.setProperty('index', this.model.getItemCount()+1);
      }

      // if we've started adding items to dom, add this item. Otherwise,
      // the view will be created when the ExpressionListView is inserted
      // into the dom
      if (this.$items) {
        var view = this.createItemView(item);
        if (view) {
          if (index === 0) {
            view.prependTo(this.$items); // beginning
          } else if (index === this.model.getItemCount()-1) {
            view.appendTo(this.$items); //end
          } else { //somewhere in the middle
            view.insertAfter(this.$items.children(':nth-child('+ index +')'));
          }

          //in edit list mode, we animate new items
          if (this.editListMode) {
            view.$().css({
              transform: 'scale(0,0)',
              opacity: 0
            });

            //wait one frame, or the 0,0 won't catch
            setTimeout(function() {
              view.$().css({
                transition: '.2s',
                opacity: 1,
                transform: ''
              });
            }, 1);
            //remove our transition after the animation's done
            setTimeout(function () {
              view.$().css({
                transition: 'none'
              });
            }, 300);
          }
        }

        var len = this.model.getItemCount();
        for (var i=index; i<len; i++) {
          this.model.getItemByIndex(i).setProperty('index', i);
        }

        this.updateWidth();
        this.ensureActiveChildIsVisible();
      }
    };

    view.onItemRemoved = function (index, item) {
      var item_id = String(item.id);

      item.unobserve('.listview');

      // update index on newExpressionView
      if (this.newExpressionView) {
        this.newExpressionView.setProperty('index', this.model.getItemCount()+1);
      }

      // remove item view from dom
      var view = this.__itemViews[item_id];
      if (view) {
        view.remove();
        delete this.__itemViews[item_id];

        var len = this.model.getItemCount();
        for (var i=index; i<len; i++) {
          this.model.getItemByIndex(i).setProperty('index', i);
        }
      }

      this.updateWidth();
    };

    view.onItemMoved = function (from, to) {
      // update index of each affected item
      var min_affected = Math.min(from,to);
      var max_affected = Math.max(from,to);
      for (var i = min_affected; i <= max_affected; i++) {
        this.model.getItemByIndex(i).setProperty('index', i);
      }

      // move view to correct spot
      var view = this.getItemView(this.model.getItemByIndex(to).id);
      if (view) {
        var $items = this.$items;
        // put at beginning
        if (to === 0) {
          $items.prepend(view.$());
        }

        // put at end
        else if (to === this.model.getItemCount() - 1) {
          $items.append(view.$());
        }

        // put somewhere in middle
        else {

          // must add 1 to index if to > from. This is because the from spot will
          // get plucked out and inserted after the to spot. Means we need to
          // search one deeper into sibling list to find the correct node to
          // insert after.
          var child_index = to + ( to > from ? 1 : 0);
          view.$().insertAfter($items.children(':nth-child('+ child_index +')'));
        }
      }
    };

    view.onSetState = function (list) {
      // destroy item views
      //TODO - could do a destruct() and remove all at once from dom for optimization.
      for (var id in this.__itemViews) {
        if (this.__itemViews.hasOwnProperty(id)) this.__itemViews[id].remove();
      }

      this.__itemViews = {};

      // update index on newExpressionView
      if (this.newExpressionView) {
        this.newExpressionView.setProperty('index', this.model.getItemCount()+1);
      }

      // make all the views at once and insert one large structure
      this.createAllItemViews();
      this.appendAllItemViews();
    };

    view.renderItemFocused = function () {
      this.$root.toggleClass('dcg-ITEM-FOCUSED', !!this.itemFocused);
    };

    view.instantiateItemView = function (item) {
      if (item.isExpression) {
        return ExpressionView(item, this);
      } else if (item.isText) {
        return TextView(item, this);
      } else if (item.isTable) {
        return TableView(item, this);
      } else if (item.isFolder) {
        return FolderView(item, this);
      } else if (item.isImage) {
        return ImageView(item, this);
      }
    };

    view.createItemView = function (item) {
      var view = this.instantiateItemView(item);
      var item_id = String(item.id);

      if (view) {
        this.__itemViews[item_id] = view;

        // add some triggers to the view
        var self = this;
        view.triggerDelete = function(){self.onDelete(view)};
        view.triggerEnterPressed = function(){self.onEnterPressed(view)};
        view.triggerUpPressed = function(){self.onUpPressed(view)};
        view.triggerDownPressed = function(){self.onDownPressed(view)};
        view.triggerBackspacePressed = function(){self.onBackspacePressed(view)};
        view.triggerDelPressed = function(){self.onDelPressed(view)};
        view.observe('transient', function(prop, view){
          if(view.transient) {
            self.transientChildren.push(view);
          } else {
            self.transientChildren = _(self.transientChildren).without(view);
          }
          self.computeTransient();
        });
      }

      return view;
    };

    view.createAllItemViews = function () {
      var len = this.model.getItemCount();
      for (var i=0; i<len; i++) {
        var item = this.model.getItemByIndex(i);
        this.createItemView(item);
      }
    };

    //this method is for large graphs with lots of unrendered shells
    //previously split between timermoduels and renderviewport.
    //
    //first, it finds the first visible expression.
    //then, starting there, it renders all of the expressions there and below.
    view.renderVisibleExpressions = function () {
      var anyUnrendered = this.model.__items.some(function (item) {
        return item.renderShell;
      });
      if (!anyUnrendered) return;
      var expPanelTop = this.$('.dcg-exppanel').offset().top;
      var first = this.expressionAtPoint(5, expPanelTop);
      if (!first) return;

      //if the user set that we should use shells offscreen (for perf), do
      var last = null;
      if (this.graphSettings.config.useShellsOffscreen) {
        var scrollHeight = this.$('.dcg-exppanel').height();
        last = this.expressionAbovePoint(5, expPanelTop + scrollHeight);
      }

      this.renderExpression(first.index, last);
    };

    //called from a folder when it uncollapses
    view.triggerFolderOpened = function() {
      this.renderVisibleExpressions();
    };

    // render expressions on a loop, starting from first.index (above)
    //
    // notes:
    //   * this only updates expressions *below* where you are. We don't
    // want to have what you're looking at move.
    //   * if "last" is provided, we don't update expressions beyond it
    view.renderExpressionTimeout = null;
    view.renderExpression = function(index, last) {
      clearTimeout(this.renderExpressionTimeout);

      var item = this.model.getItemByIndex(index);
      while (item && (!item.renderShell || item.inCollapsedFolder)) {
        index++;
        item = this.model.getItemByIndex(index);
      }

      if (last && index > last.index) return;

      var self = this;
      if (item) {
        item.setProperty('renderShell', false);
        this.renderExpressionTimeout = setTimeout(function() {
          self.renderExpression(index+1, last);
        },1);
      }
    };

    view.appendAllItemViews = function () {
      if (!this.$items) return;
      var len = this.model.getItemCount();
      for (var i=0; i<len; i++) {
        var item = this.model.getItemByIndex(i);
        var view = this.getItemView(item.id);
        view.appendTo(this.$items);
      }

      this.updateWidth();
      this.renderVisibleExpressions();
    };

    // holds a copy of the each item's view for later reference

    view.getItemView = function (id) {
      return this.__itemViews[String(id)];
    };

    view.onDelete = function (view) {
      var self = this;
      var animationDuration = 0.2;
      view.$().css({
        'transition': animationDuration + 's',
        'opacity': '0',
        'transform': "scale(.1, .1)"
      });
      setTimeout(function() {
        self.model.undoRedo.oneTransaction(function(){
          self.model.removeItemAt(view.model.index);
          if (self.model.getItemCount() === 0) {
            var new_exp = ExpressionObject(undefined, self.model);
            self.model.insertItemAt(0, new_exp);
          }
        });
      }, 1000*animationDuration);
    };

    view.onUpPressed = function (view) {
      // nothing above
      if (view.model.index === 0) return;

      this.selectPrevExpression(view.model);
      this.getSelectedView().addFocus('end');
    };

    view.onDownPressed = function (view) {
      this.selectNextExpression(view.model);
      this.getSelectedView().addFocus('start');
    };

    view.onBackspacePressed = function (view) {
      var wasText = view.model.isText;

      //if you press backspace from the last element of a folder, it
      //delete -- it removes you from the folder
      var nextItem = this.model.getItemByIndex(view.model.index + 1);
      if (view.model.folder && (!nextItem || !nextItem.folder)) {
        view.model.folder.removeItem(view.model);
        return;
      }

      this.upwardDeleteExpression(view.model);

      // having issues in iframe on ipad. backspace deletes the textbox
      // but doesn't focus into the expression above
      // see #3106
      if (wasText && Browser.IS_IPAD && Browser.IS_IN_IFRAME) {
        this.model.setSelected(null);
        return;
      }

      this.getSelectedView().addFocus('end');
    };

    view.onDelPressed = function (view) {
      this.downwardDeleteExpression(view.model);
      this.getSelectedView().addFocus('start');
    };

    view.onEnterPressed = function (view) {
      // having issues in iframe on ipad. make enter work like escape
      // see #3106
      if (view.model.isText && Browser.IS_IPAD && Browser.IS_IN_IFRAME) {
        conditionalBlur();
        this.model.setSelected(null);
        return;
      }

      var obj = ExpressionObject({ selected:true }, this.model);
      var self = this;
      var insertIndex = view.model.index + 1;
      //insert below the last element of a collapsed folder
      if (view.model.isFolder && view.model.collapsed) {
        insertIndex += _(view.model.memberIds).keys().length;
      }

      self.model.undoRedo.oneTransaction(function() {
        self.model.insertItemAt(insertIndex, obj);
        if (view.model.isFolder && !view.model.collapsed) {
          view.model.addItem(obj);
        }
        if (view.model.folder) view.model.folder.addItem(obj);
      });
      this.getSelectedView().addFocus();
    };

    view.expressionsVisible = true;
    view.hideExpressions = function() {
      // deselect expression
      this.model.setSelected(null);
      conditionalBlur();
      //note: the above 2 lines should do this, and this next call should be a no-op. Adding in one last
      //line of defense. See: https://github.com/desmosinc/knox/issues/4580
      this.setProperty('needsFakeKeypad', false);
      this.setProperty('expressionsVisible', false);
    };

    view.showExpressions = function() {
      this.setProperty('expressionsVisible', true);
      conditionalBlur();
    };

    view.renderEditListMode = function () {
      var $root = this.$root;
      var self = this;

      if (this.editListMode) {
        $root.addClass('dcg-EDIT-LIST-MODE');
        this.model.setSelected(null);
        // listen for a tapstart event to close edit-list-mode
        $(document).on('tapstart.edit-list-mode', function (evt) {
          if (
            $(evt.target).closest('.dcg-exppanel').length === 0 &&
            $(evt.target).closest('.dcg-options-menu').length === 0 &&
            $(evt.target).closest('.dcg-expression-top-bar').length === 0
          ) {
            self.setProperty('editListMode', false);
          }
        });
      } else {
        $root.removeClass('dcg-EDIT-LIST-MODE');
        // don't listen for the event to close edit-list-mode anymore
        $(document).off('.edit-list-mode');
      }
    };

    /*
    * EVENTS
    */
    view.handleFocusChange = function (focused) {
      var target = $(focused);
      var inMathquill = target.closest('.mathquill-rendered-math').length !== 0;
      var inEditableMathquill = target.closest('.mathquill-editable').length !== 0;
      var inMathquillWithMathField = target.closest('.mathquill-rendered-math:not(.mathquill-editable)')
                                           .find('.mathquill-editable').length !== 0;
      var inMathInput = target.closest('.dcg-math-input').length !== 0;
      var inText = target.closest('.dcg-expressiontext').length !== 0;
      var inFolder = target.closest('.dcg-expressionfolder').length !== 0;

      // clicking in the uneditable part of a mathquill that has \MathQuillMathFields embedded
      // still sends a focusIn event. Let's correct that by acting like mathquill isn't focused.
      if (!inEditableMathquill && inMathquill && inMathquillWithMathField) {
        inMathquill = false;
        inEditableMathquill = false;
        inMathInput = false;
      }

      // in case we're in list mode, get out of it!
      if (!inMathInput && (inMathquill || inEditableMathquill || inText || inFolder)) {
        this.setProperty('editListMode', false);
      }

      //itemFocused should only trigger when we're editing mathquill.
      //that shows us when the keypad is up, the list is expanded, etc.
      //none of those actions occur in text or folders
      this.setProperty('itemFocused', inMathquill || inEditableMathquill);
      this.setProperty('needsFakeKeypad', inMathquill && inEditableMathquill);
    };
    view.onFocusIn = function (evt) {

      //it's possible to add focus to an expression even when the expressions are hidden.
      // Most prominently: if you click a curve to select it and then type
      // If that happens, we want to show the expression that's being edited, so pop back out the expressions list
      if (!this.expressionsVisible) {
        this.showExpressions();
      }

      // sometimes mathquill notifies of focusin before the focus is set. So we have to
      // pass in where focus is about to be rather than simply use document.activeElement.
      this.handleFocusChange(evt.target);

      clearTimeout(this.fakeKeypadTimeout);
    };

    view.onFocusOut = function () {
      clearTimeout(this.fakeKeypadTimeout);
      // setTimeout here is used to coalesce calls to onFocusOut and onFocusIn
      // that happen in the same tick. This happens, e.g. when a new
      // expression is created, and we move focus from the previous expression
      // to it.
      this.fakeKeypadTimeout = setTimeout(function () {

        // Mathquill does something weird where it triggers a focusout on
        // render, but nothing actually happens to focus. To combat that, and
        // anything else similar, we check what's actually focused
        this.handleFocusChange(document.activeElement);

      }.bind(this), 0);
    };

    view.offset = function () {
      return this.$exps.offset();
    };

    view.setBottom = function (bottom) {
      if (!this.$exps) return;
      var oldBottom = parseFloat(this.$exps.css('bottom').slice(0,-2));
      if (!isFinite(oldBottom)) oldBottom = 0;
      this.$exps.css('bottom', bottom + 'px');

      //If the user is currently in a mouse interaction and the height
      //is increasing, pad the last expression until they end their interaction to
      //prevent things from moving under them
      if (bottom === 0 && touchtracking.isTapActive()) {
        this.padLastExpressionUntilTapEnd(oldBottom);
      }
      this.recalculateScrollbarWidth();
    };

    view.didCreateElement = function () {
      var self = this;
      var list = this.model;

      _super.didCreateElement.call(this);

      this.$exps = this.$('.dcg-exppanel-outer');

      this.addExpressionView = AddExpressionView(this, this.$root, this.graphSettings, this.toastView);
      this.addExpressionView.appendTo(this.$exps);
      this.addExpressionView.setupOpenButton(this.$('.dcg-action-add-expression'), 'tap');
      this.observe('scrollbarWidth minWidth', this.updateAllViewWidths.bind(this));

      this.$exps.tipsy({
        fade: 'fast',
        title: 'tooltip',
        wait: 500,
        delegate: '.dcg-tooltip'
      });

      this.$exppanelContainer = this.$('.dcg-exppanel-container');
      this.$exppanel = this.$('.dcg-exppanel');
      this.$items = this.$('.dcg-template-expressioneach');

      this.appendAllItemViews();

      //
      //listen for scroll. add class when scrolled, and set renderShells=false
      //

      var debouncedScroll = _.debounce(function(evt) {
        if (evt) this.$('.dcg-expression-top-bar').toggleClass(
          'dcg-expressions-scrolled',
          $(evt.target).scrollTop() > 0
        );
        this.renderVisibleExpressions();
      }.bind(this), 200);

      this.$exppanel.scroll(function(evt) {
        //stop rendering offscreen things immediately -- don't wait for debounce
        clearTimeout(self.renderExpressionTimeout);
        debouncedScroll(evt);
      });

      //
      // for iPad & nexus, listen for taps in the empty area underneath an expression and defocus
      // because that doesn't happen automatically. The way I'm detecting such a tap is by checking if the
      // event is within an .expressionitem. If it's not, we're assuming the tap is within empty space.
      //
      this.$exppanel.on('tapstart', function(evt) {
        // avoids losing focus when on desktop and we mouseDown on the scrollbar. If we want to lose foucs in
        // that case, this line is perfect to remove. If we want something more robust to detect that we're
        // on the scrollbar, we might be able to check x position of the event compared to the width of the
        // inner content.
        if (evt.device === 'mouse') return;

        if ($(evt.target).closest('.dcg-expressionitem').length === 0) {
          conditionalBlur();
        }
      });

      this.$exppanel.on('keypress', this.ensureActiveChildIsVisible.bind(this));

      //the below should happen automatically, but doesn't on iPad / android
      //this lets you defocus the currently focused expression by clicking the 'Expressions' header
      this.$('.dcg-expression-top-bar').on('tapstart', function(evt) {
        if (evt.wasHandled()) return;
        list.setSelected(null);
      });


      this.$exps.on('tap', '.dcg-action-clearall', function () {
        self.triggerClearGraph();
        var undoCallback = function() {
          self.setProperty('editListMode', true);
        };
        self.toastView.show("Graph cleared.", {undoCallback: undoCallback});
      });

      this.$exps.on('tap', '.dcg-action-undo', function () {
        list.undoRedo.undo();
      });

      this.$exps.on('tap', '.dcg-action-redo', function () {
        list.undoRedo.redo();
      });

      this.$exps.on('focusout', this.onFocusOut.bind(this));
      this.$exps.on('focusin',  this.onFocusIn.bind(this));
      this.$('.dcg-action-toggle-edit').on('tap', function () {
        self.setProperty('editListMode', !self.editListMode);
      });
      this.$('.dcg-action-hideexpressions').on('tap', this.hideExpressions.bind(this));
      this.$('.dcg-action-showexpressions').on('tap', this.showExpressions.bind(this));
      // Relies on handleKeyDown returning early if no expression is selected for
      // correctness when there are multiple calculators in the page. This means
      // we want to have the invariant that only one list_view can have a selected
      // item at a time.
      $(document.documentElement).on('keydown', this.handleKeyDown.bind(this));

      this.renderItemFocused();
      this.renderEditListMode();

      this.newExpressionView = NewExpressionView(this);
      this.newExpressionView.replace(this.$('.template-newexpression'));
      this.newExpressionView.setProperty('index', this.model.getItemCount()+1);

      // whenever mathquill renders
      this.$exps.on('render', function (evt) {
        self.updateWidth();
      });

      // these things all factor into how wide the expression list is, so we watch them
      this.model.observe('selectedItem', function () {
        self.updateWidth();
      });
      this.observe('editListMode itemFocused', function () {
        self.updateWidth();
      });

      // any time that focus changes we need to make sure that a part of the page doesn't
      // scroll in order show the cursor. this is specifically important for IE9 and tables.
      // In IE9 there will be a quick flash when the expression list is scrolled back to 0,0
      // but I can't find anything that happens synchronously. I've tried:
      //    1) Listening to changes to selectedCell of the selected table
      //    2) Listening for 'scroll' event on the element that gets scrolled
      //
      // both of those still show a quick flash, so this is the chosen method since it's
      // the simplest and most general.
      this.$exps.on('focusin', function () {
        setTimeout(function () {
          self.updateWidth();
        }, 0);
      });
    };

    view.didInsertElement = function () {
      this.updateWidth();
      this.$exppanelContainer.addClass('dcg-do-animate');
    };

    view.getFirstVisibleItem = function() {
      var top = this.$exppanel.offset().top;
      var el = this.expressionAtPoint(0, top);

      if (!el) {
        return this.model.getItemByIndex(0);
      }
      //make sure it's fully visible
      if (this.getItemView(el.id).$().offset().top < top - 2) { //Allow for overlapping borders
        el = this.model.getItemByIndex(el.index+1);
      }
      return el;
    };

    view.appendBlankExpression = function() {
      this.newExpressionView.newMath();
    };

    // Find the view for the selected expression and scroll that expression
    // into view. If the expression doesn't have a view yet, we'll let the
    // view call this once it's inserted into the dom. If there is no selected
    // view, then check if there's a focused view. If so, scroll that until
    // it's visible
    view.ensureActiveChildIsVisible = function(){
      if (!this.$exps || !this.$exps.is(':visible')) return;

      // if an item is selected, try to force it into view
      if (this.model.selectedItem) {
        var selectedView = this.getItemView(this.model.selectedItem.id);
        if (selectedView) {

          var active = $(document.activeElement);
          var mathquill = active.closest('.mathquill-editable');

          //scroll the specific mathquill if we're in one (i.e. focused in a table or exp)
          if (mathquill.length) {
            var padding = (selectedView.model.isTable ? 60 : 90);
            return scrollHelpers.scrollVisible(mathquill, this.$exppanel, padding);
          }
          //scroll the activeElement if it exists (i.e. focus is in a textarea or folder title)
          if (active.closest('.dcg-expressionitem').length) {
            return scrollHelpers.scrollVisible(active, this.$exppanel, 90);
          }
          //scroll the whole view
          scrollHelpers.scrollVisible(selectedView.$(), this.$exppanel, 90);
        }
      }
    };

    view.handleKeyDown = function(evt) {
      /* jshint maxcomplexity:26 */
      // make sure nothing has focus
      if ($.contains(document.body, document.activeElement)) {
        return;
      }

      // make sure event didn't happen from within expression list
      if ($(evt.target).closest('.dcg-exppanel').length) {
        return;
      }

      // make sure target is still in dom. fixes #3282
      if (!$.contains(document.documentElement, evt.target)) {
        return;
      }

      var selected = this.getSelectedView();
      if (selected && selected.isFocused()) {
        selected.processMissedKeyEvent(evt);
        return;
      }
      var key = Keys.lookup(evt);

      if (!selected) return;

      switch (key) {
        case Keys.UP:
          evt.preventDefault();
          this.selectPrevExpression(selected.model);
          break;

        case Keys.DOWN:
          evt.preventDefault();
          this.selectNextExpression(selected.model, true);
          break;
        case Keys.ESCAPE:
          evt.preventDefault();
          this.model.setSelected(null);
          break;

        case Keys.RIGHT:
        case Keys.TAB:
          evt.preventDefault();
          if (selected) {
            if (selected.model.isTable) {
              selected.addFocus('cell', 0, 0);
            } else {
              selected.addFocus('start');
            }
          }
          break;

        case Keys.LEFT:
          evt.preventDefault();
          if (selected) {
            if (selected.model.isTable) {
              selected.addFocus('cell', 0, selected.model.columns.length - 1);
            } else {
              selected.addFocus('end');
            }
          }
          break;

        case Keys.BACKSPACE:
          evt.preventDefault();
          if(selected){
            this.upwardDeleteExpression(selected.model);
          }
          break;

        case Keys.DELETE:
          evt.preventDefault();
          if(selected){
            this.downwardDeleteExpression(selected.model);
          }
          break;

        case Keys.ENTER:
          evt.preventDefault();
          if (selected) this.onEnterPressed(selected);
          break;

        default:
          //ignore things like ctrl-copy, ctrl-paste, alt-tab, shift
          if (evt.metaKey ||
              evt.ctrlKey ||
              key === Keys.SHIFT ||
              key === Keys.SPACEBAR
          ) {
            return;
          }

          if (selected) {
            if (selected.model.isTable) {
              // do nothing since we don't know where to type
            } else {
              selected.addFocus('end');
            }
          }
      }
    };

    /*
    * PUBLIC METHODS
    */
    view.getSelectedView = function () {
      var selected = this.model.getSelected();
      if (selected) {
        var view = this.getItemView(selected.id);
        return view;
      }

      return null;
    };

    view.upwardDeleteExpression = function (expression) {
      var index = expression.index;
      var prev = this.model.getItemByIndex(this.findPrevSelectableIndex(index));
      var self = this;
      var list = this.model;

      list.undoRedo.oneTransaction(function () {
        // remove this item
        list.removeItemAt(index);

        // if list is now empty, add a blank expression
        if (list.getItemCount() === 0) {
          prev = ExpressionObject(undefined, list);
          list.insertItemAt(0, prev);
        }

        // if there isn't an item before us, select the item that was after us
        if (!prev) {
          prev = list.getItemByIndex(self.findNextSelectableIndex(index-1));
        }

        if (prev) {
          prev.setProperty('selected', true);
        }
      });
    };

    view.findPrevSelectableIndex = function (index) {
      var item;

      do {
       index--;
       item = this.model.getItemByIndex(index);
      } while (item && item.inCollapsedFolder);

      return item ? index : undefined;
    };

    view.findNextSelectableIndex = function (index) {
      var item;

      do {
       index++;
       item = this.model.getItemByIndex(index);
      } while (item && item.inCollapsedFolder);

      return item ? index : undefined;
    };

    view.downwardDeleteExpression = function (expression) {
      var index = expression.index;
      var next = this.model.getItemByIndex(this.findNextSelectableIndex(index));
      var list = this.list;

      if (next) {
        list.setSelected(next);
        list.removeItemAt(index);
      }

      // last, but not only expression
      else if (this.model.getItemCount() > 1) {
        list.setSelected(index-1);
        list.removeItemAt(index);
      }

      // only expression
      else {
        list.undoRedo.oneTransaction(function(){
          list.removeItemAt(0);
          list.insertItemAt(0, ExpressionObject(undefined, list));
          list.setSelected(0);
        });
      }
    };

    view.selectPrevExpression = function (expression) {
      if (!expression) return;

      var index = expression.index;
      var prev = this.model.getItemByIndex(this.findPrevSelectableIndex(index));

      if (prev) {
        prev.setProperty('selected', true);

        // check if this was an empty last expression
        // if so, remove it
        if (index === this.model.getItemCount() - 1 && expression.isEmpty()) {
          this.model.removeItemAt(index);
        }
      }
    };

     view.selectNextExpression = function (expression, dontCreateNew) {
       if (!expression) return;

       var index = expression.index;
       var next = this.model.getItemByIndex(this.findNextSelectableIndex(index));

       if (next) {
         next.setProperty('selected', true);
       } else if(!dontCreateNew) {
         var obj = ExpressionObject({ selected:true }, this.model);
         this.model.insertItemAt(this.model.getItemCount(), obj);
       }
     };

    /*
    * Returns a list of visible expression views, ordered by index.
    */
    view._getVisibleViews = function () {
      var visibleViews = [];

      for (var i = 0; i < this.model.getItemCount(); i++) {
        var exp = this.model.getItemByIndex(i);
        var view = this.getItemView(exp.id);
        if (view && view.$().is(':visible')) visibleViews.push(view);
      }

      return visibleViews;
    };

    /*
    * Does a binary search to find the .expressionitem that is at the point
    */
    view.expressionAtPoint = function (x, y) {
      var visibleViews = this._getVisibleViews();
      var lo = 0;
      var hi = visibleViews.length-1;

      while (lo<=hi) {
        var mid = lo + Math.floor((hi-lo)/2);
        var view = visibleViews[mid];
        var rect = view.getBounds();

        if (rect.top > y) {
          hi = mid - 1;
        } else if (rect.bottom < y) {
          lo = mid + 1;
        } else {
          return view.model;
        }
      }

      return null;
    };

    /*
    * Finds the first expression at or above the point
    */
    view.expressionAbovePoint = function (x, y) {
      var visibleViews = this._getVisibleViews();
      var lo = 0;
      var hi = visibleViews.length-1;
      var found = null;

      while (lo<=hi) {
        var mid = lo + Math.floor((hi - lo)/2);
        var view = visibleViews[mid];
        var rect = view.getBounds();

        if (rect.top > y) {
          hi = mid - 1;
        } else {
          lo = mid + 1;
          found = view.model;
        }
      }

      return found;
    };

    view.onProjectorModeChange = function() {
      for (var id in this.__itemViews) {
        if (this.__itemViews.hasOwnProperty(id)) {
          this.__itemViews[id].onProjectorModeChange();
        }
      }
    };

    // keypad sends a message to the list_view if a key is pressed but
    // no mathquill is currently focused. It's up to the list_view to
    // figure out what to do with the key. The time that this happens
    // is when a disabled table cell is highlighted. We need the arrow
    // keys to still work.
    view.handleUnfocusedKeypadAction = function (key) {
      var selectedView = this.getSelectedView();
      if (selectedView && selectedView.model.isTable ) {
        if (selectedView.model.selectedCell) {
          selectedView.doKeyAction(key);
        }
      }
    };

    view.addFocusForKeypad = function () {
      //use currently selected expression if one is selected (no-op if it's also focused)
      var selected = this.model.getSelected();
      if (selected && selected.isExpression) {
        this.getItemView(selected.id).addFocus();
        return;
      }

      //if currently selected is a table, return early if it already has focus
      if (selected && selected.isTable && this.itemFocused) {
        return;
      }

      //if not, get the element at the top of the list
      var item = this.getFirstVisibleItem();

      //search downward until we find an expression that we can focus
      while (item && !item.isExpression) {
        item = this.model.getItemByIndex(item.index + 1);
      }

      //if we found an item: focus it!
      if (item) {
        this.getItemView(item.id).addFocus();
        return;
      }

      //append a blank expression at the bottom of the list, and focus that
      this.appendBlankExpression();
    };

  });

  return ExpressionListView;
});

define('loadcss!css/keypad', function(){});
define('template!keypad', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class=\'dcg-keypad\'>\n  <div class=\'dcg-keys-container dcg-retracted\'>\n    <div class=\'dcg-keys-background dcg-do-not-blur\'>\n      <div class=\'dcg-keys\'>\n\n        <div class=\'dcg-functions-popover dcg-popover dcg-top\'>\n          <div class=\'dcg-popover-interior\'>\n            <div class=\'dcg-popover-header\'>\n              <table><tr>\n              ';
 _.each(popups.functionsPopup, function(contents, section) {
;__p+='\n                <td>\n                  <span key="'+
(contents.tab.id)+
'" class="dcg-heading dcg-tappable dcg-btn dcg-btn-gray'+
((section == "trig" ?  " dcg-selected":""))+
'">\n                    '+
( contents.tab.html )+
'\n                  </span>\n                </td>\n              ';
 })
;__p+='\n              </tr></table>\n            </div>\n\n            ';
 _.each(popups.functionsPopup, function(contents, section) {
;__p+='\n              <table class=\'dcg-interior-buttons\' section=\''+
(section)+
'\'>\n                ';
 if (section == "trig") {
;__p+='\n                  <tr class=\'dcg-section-headings\'>\n                    <td>trig</td>\n                    <td>inverse</td>\n                    <td>hyperb</td>\n                  </tr>\n                ';
 }
;__p+='\n                <tr>\n\n                ';

                   var i = 0;
                    _.each(contents.funcs, function(func) {

;__p+='\n                  '+
((i%3 == 0 ? "</tr><tr>" : ""))+
'\n                  ';
 i++
;__p+='\n                  <td>\n                    <span\n                      class="dcg-option dcg-btn dcg-tappable'+
(func.aClass ? " " + func.aClass : "")+
' dcg-'+
(func.id)+
'-key"\n                      key="'+
(func.id)+
'"\n                    >\n                      '+
( func.html )+
'\n                    </span>\n                  </td>\n              ';
 })
;__p+='\n              </tr></table>\n            ';
 })
;__p+='\n          </div>\n          <div class=\'dcg-arrow\'></div>\n        </div>\n\n        ';
 _.each(buttons, function(keypad, keypadID) {
;__p+='\n         <div class="dcg-'+
(keypadID)+
' dcg-main-keypad-section">\n           ';
 _.each(keypad, function(row) {
;__p+='\n             <div class="dcg-row">\n               ';
 _.each(row['keys'], function(key) {
;__p+='<div\n                   class="dcg-cell '+
(key.cellClass ? key.cellClass: "")+
'"\n                 >\n                   ';
 if (key.html) {
;__p+='\n                     <a\n                       class="dcg-btn '+
(key.aClass ? key.aClass : "")+
' dcg-'+
(key.id)+
'-key"\n                       key="'+
(key.id)+
'"\n                     >\n                       '+
( t(key.html) )+
'\n                     </a>\n                   ';
 }
;__p+='\n                 </div>';
 })
;__p+='\n               <div style=\'clear:both\'></div>\n             </div>\n           ';
 })
;__p+='\n         </div>\n        ';
 })
;__p+='\n        <div style=\'clear:both\'></div>\n      </div>\n\n      <div class=\'dcg-minimize-keypad dcg-tooltip\' tooltip="'+
( t('Hide Keypad').replace(' ', '&nbsp;') )+
'">\n        <i class=\'dcg-icon-keyboard\'></i>\n        <i class=\'dcg-icon-caret-down\'></i>\n      </div>\n\n      <div class=\'dcg-minimize-keypad dcg-tooltip dcg-inline-minimize-keypad\' tooltip="'+
( t('Hide Keypad').replace(' ', '&nbsp;') )+
'">\n        <i class=\'dcg-icon-remove\'></i>\n      </div>\n    </div>\n  </div>\n\n  <div class="dcg-show-keypad dcg-do-not-blur dcg-tooltip" tooltip="'+
( t('Show Keypad').replace(' ', '&nbsp;') )+
'">\n    <i class=\'dcg-icon-keyboard\'></i>\n    <i class="dcg-icon-caret-up dcg-do-not-blur"></i>\n  </div>\n</div>\n';
}
return __p;
};});
define('text!data/keypad_keys.json',[],function () { return '{\n"trigFuncs":        ["sin","cos","tan","csc","sec","cot"],\n\n"oneArgFuncs":      ["ceil","floor","round","abs","ln","log","exp"],\n\n"twoArgFuncs":      ["min","max","lcm","gcd","mod", "nCr", "nPr"],\n\n"tabs":             ["trig","calc","misc"],\n\n"staticKeys": {\n  "unknown":          {"display":{"html":"?"},\n                      "action":{"cmd":"?"}},\n  "pi":               {"display":{"html":"&pi;"},\n                      "action":{"cmd":"\\\\pi"}},\n  "tau":               {"display":{"html":"&tau;"},\n                      "action":{"cmd":"\\\\tau"}},\n  "leftparen":        {"display":{"html":"("},\n                      "action":{"cmd":"("}},\n  "rightparen":       {"display":{"html":")"},\n                      "action":{"cmd":")"}},\n  "sqrt":             {"display":{"html":"&radic;"},\n                      "action":{"cmd":"\\\\sqrt"}},\n  "cuberoot":         {"display":{"html":"3&radic;"},\n                      "action":{"custom": "cuberoot"}},\n  "lt":               {"display":{"html":"&lt;"},\n                      "action":{"cmd":"<"}},\n  "gt":               {"display":{"html":"&gt;"},\n                      "action":{"cmd":">"}},\n  "le":               {"display":{"html":"&le;"},\n                      "action":{"cmd":"\\\\le"}},\n  "ge":               {"display":{"html":"&ge;"},\n                      "action":{"cmd":"\\\\ge"}},\n\n  "squared":          {"display":{"aClass":"dcg-exponent", "html":"a^2"},\n                      "action":{"custom":"squared"}},\n\n  "exponent":         {"display":{"aClass":"dcg-exponent", "html":"a^b"},\n                      "action":{"cmd":"^"}},\n  "subscript":        {"display":{"html":"a_b"},\n                      "action":{"cmd":"_"}},\n  "fact":             {"display":{"html":"a!"},\n                      "action":{"cmd":"!"}},\n  "theta":            {"display":{"html":"&theta;"},\n                      "action":{"cmd":"\\\\theta"}},\n\n  "brackets":        {"display":{"html":"{ }", "noMQ":true},\n                      "action":{"custom":"brackets"}},\n  "squarebrackets":        {"display":{"html":"[ ]", "noMQ":true},\n                      "action":{"custom":"squarebrackets"}},\n  "colon":            {"display":{"html":":"},\n                      "action":{"cmd":":"}},\n  "pipes":            {"display":{"html":"|a|"},\n                      "action":{"cmd":"|"}},\n  "comma":            {"display":{"html":","},\n                      "action":{"cmd":","}},\n\n  "times":            {"display":{"html":"&times;"},\n                      "action":{"cmd":"*"}},\n  "plus":             {"display":{"html":"+"},\n                      "action":{"cmd":"+"}},\n  "divide":           {"display":{"html":"&divide;"},\n                      "action":{"cmd":"/"}},\n  "minus":            {"display":{"html":"&ndash;"},\n                      "action":{"cmd":"-"}},\n  "equals":           {"display":{"html":"="},\n                      "action":{"cmd":"="}},\n  "twiddle":           {"display":{"html":"~"},\n                      "action":{"cmd":"~"}},\n  "decimal":          {"display":{"html":"."},\n                      "action":{"cmd":"."}},\n\n  "backspace":        {"display":{"aClass":"dcg-btn-gray",\n                                  "html":"<i class=\\"dcg-icon-delete\\"></i>",\n                                "colspan": 1.5\n                               },\n                      "action":{"key":"Backspace"}},\n  "enter":            {"display":{"aClass":"dcg-btn-gray",\n                                  "html":"<i class=\\"dcg-icon-arrow-enter\\"></i>",\n                                  "colspan": 2\n                                },\n                      "action":{"key":"Enter"}},\n  "toggleLetters":    {"display":{"aClass":"dcg-btn-gray",\n                                  "html":"A B C",\n                                  "colspan":2},\n                      "action":{"changeLayout": "letters"}},\n  "toggleNumbers":    {"display":{"aClass":"dcg-btn-gray",\n                                "html":"1 2 3",\n                                "colspan":2\n                               },\n                      "action":{"changeLayout":"mainNumbers"}},\n\n  "popupFunctions":  {"display":{"aClass":"dcg-btn-gray", "html":"func<span class=\'dcg-hide-on-narrow\'>tion</span>s", "colspan":2},\n                      "action":{"popup": "functions"}},\n\n  "blank":            {"display":{},\n                      "action":{}},\n\n  "halfBlank":        {"display":{"colspan":0.5},\n                      "action":{}},\n\n  "left":             {"display":{"html":"<i class=\\"dcg-icon-arrow-left\\"></i>"},\n                      "action":{"key":"Left"}},\n  "up":               {"display":{"html":"&uarr;"},\n                      "action":{"key":"Up"}},\n  "right":            {"display":{"html":"<i class=\\"dcg-icon-arrow-right\\"></i>"},\n                      "action":{"key":"Right"}},\n  "down":             {"display":{"html":"&darr;"},\n                      "action":{"key":"Down"}},\n\n\n  "toggleCapital":    {"display":{"aClass":"dcg-btn-gray",\n                                  "html":"<i class=\\"dcg-icon-shift\\"></i>",\n                                  "colspan":1.5},\n                                  "action":{"changeLayout": "capitalLetters"}},\n  "toggleLowercase":    {"display":{"aClass":"dcg-btn-gray dcg-active",\n                                  "html":"<i class=\\"dcg-icon-shift\\"></i>",\n                                  "colspan":1.5},\n                                  "action":{"changeLayout": "letters"}},\n  "loga":             {"display":{"html":"log_a"},\n                      "action":{"custom":"loga"}},\n  "ddx":              {"display":{"html":"d/dx"},\n                      "action":{"custom":"d/dx"}},\n  "sum":              {"display":{"html":"\\\\sum"},\n                      "action":{"cmd":"\\\\sum"}},\n  "prod":             {"display":{"html":"\\\\prod"},\n                      "action":{"cmd":"\\\\prod"}},\n  "highlightedX":     {"display":{"html":"x", "aClass":"dcg-highlighted"},\n                      "action":{"cmd":"x"}},\n  "highlightedY":     {"display":{"html":"y", "aClass": "dcg-highlighted"},\n                      "action":{"cmd":"y"}}\n  }\n}\n';});

define('main/keypad_keys',['require','jquery','underscore','i18n','mathquill','text!data/keypad_keys.json'],function(require){
  var $ = require('jquery');
  var _ = require('underscore');
  var i18n = require('i18n');
  require('mathquill');
  var keypad_data = JSON.parse(require('text!data/keypad_keys.json'));
  var i;

  //Start with explicitly defined keys
  var keys = keypad_data.staticKeys;

  //Queue i18n to translate strings that show up in keyboard
  i18n.t('functions');
  i18n.t('A B C');
  i18n.t('more');
  i18n.t('enter');

  //Expand summary-form data from JSON to create input structure for keypad
  _.each(keypad_data.tabs, function(t){
    keys[t+'Tab'] = {display:{html:t}, action:{tab:t}};
  });

  _.each(keypad_data.oneArgFuncs, function (f) {
    keys[f] = {display:{html:f},action:{func:f}};
  });

  _.each(keypad_data.twoArgFuncs, function (f) {
    keys[f] = {display:{html:f},action:{func:f, args:2}};
  });

  _.each(keypad_data.trigFuncs, function (fn) {
    _.each([fn, 'arc'+fn,fn+'h'], function (f) {
      keys[f] = {display:{html:f},action:{func:f}};
    });
  });

  var ch;
  for (i = 0; i < 26; i++) { // A-F
    ch = String.fromCharCode(65+i);
    keys[ch] = {display:{html:ch}, action:{cmd:ch}};
  }

  for (i = 0; i < 26; i++) { // a-f
    ch = String.fromCharCode(97+i);
    keys[ch] = {display:{html:ch}, action:{cmd:ch}};
  }

  for (i = 0; i < 10; i++) { // 0-9
    var num = String.fromCharCode(48+i);
    keys[num] = {display:{html:num}, action:{cmd:num}};
  }

  var genButton = function (key, buttonId) {
    var display = key.display;
    var action = key.action;

    display.id = buttonId;

    if (!('cellClass' in display)) display.cellClass = '';

    if (!('aClass' in display)) display.aClass = '';

    if (display.colspan) {

      if (display.cellClass) display.cellClass += ' ';

      switch(display.colspan) {
        case 0.5:
          display.cellClass += 'dcg-halfwide';
          break;
        case 2:
          display.cellClass += 'dcg-twowide';
          break;
        case 1.5:
          display.cellClass += 'dcg-onepointfivewide';
          break;
      }
    }

    if (display.html) {
      display.aClass = (display.aClass ? display.aClass + ' dcg-key' : 'dcg-key');
      display.aClass += ' dcg-tappable';
    }

    if (
      !(action.tab || action.key || action.popup || action.changeLayout) &&
      !display.noMQ && display.html
    ) {
      display.mathquill = true;

      // ask mathquill for an html version of itself
      // note: this will break for things like parentheses with contents,
      // which need to be inserted into the dom to know their correct size.
      // but works for uncomplicated mathquill
      // WARNING - if run multiple times, this will modify this.keys in breaking ways
      display.html = $('<span>' + display.html + '</span>').mathquill().mathquill('html');
      display.aClass += ' mathquill-rendered-math';
    }
  };

  _.each(keys, genButton);

  return keys;
});

define('main/keypad_view',['require','console','loadcss!css/keypad','jquery','underscore','browser','main/cookie','template!keypad','underscore_view','pjs','tipsy','main/cookie','main/keypad_keys'],function (require) {
  var console = require('console');
  require('loadcss!css/keypad');

  var $ = require('jquery');
  var _ = require('underscore');
  var Browser = require('browser');
  var Cookie = require('main/cookie');
  var template = require('template!keypad');
  var UnderscoreView = require('underscore_view');
  var P = require('pjs');
  require('tipsy');

  require('main/cookie');
  var KEYS = require('main/keypad_keys');

  var KeypadView = P(UnderscoreView, function (view, _super){

    view.template = template;

    view.init = function () {
      _super.init.call(this);
      this.keys = KEYS;
      this.setupKeypad();
      this.setLayout('mainNumbers');
      this.setProperty('functionsOpen', false);
      this.setProperty('isOpen', false);
      // Flag for whether the user has minimized the keypad with the minimize
      // button. In this case, we keep it minimized unless the user opens it with
      // the open keypad button.
      this.userMinimized = false;

      this.editableViews = [];
    };

    view.getEditableViewThatNeedsKeypad = function () {
      for (var i=0; i<this.editableViews.length; i++) {
        if (this.editableViews[i].needsFakeKeypad) {
          return this.editableViews[i];
        }
      }

      return null;
    };

    view.getActiveMathquill = function () {
      var mathquill = $(document.activeElement).closest('.mathquill-editable');
      return mathquill.length ? mathquill : null;
    };

    view.registerEditableView = function (editableView) {
      this.editableViews.push(editableView);

      editableView.observe('needsFakeKeypad', this.onNeedsFakeKeypad.bind(this));
    };

    view.onNeedsFakeKeypad = function () {
      this.requestSetIsOpen(!!this.getEditableViewThatNeedsKeypad());
    };

    view.didCreateElement = function(){
      var self = this;
      self.setLayout(self.layout);

      //handles to the various buttons that we're going to use a lot
      self.$hideBtn = self.$('.dcg-minimize-keypad');
      self.$showBtn = self.$('.dcg-show-keypad');
      self.$funcPopover = self.$('.dcg-functions-popover');
      self.$container = self.$('.dcg-keys-container');
      self.$keys = self.$('.dcg-keys');
      self.$funcBtn = self.$('.dcg-popupFunctions-key');
      self.setTab('trig');

      this.observe('functionsOpen', this.renderFunctionsOpen.bind(this));
      this.observe('graphpaperHeight', this.positionFunctionsPopup.bind(this));

      this.$().tipsy({
        fade: 'fast',
        title: 'tooltip',
        wait: 500,
        delegate: '.dcg-tooltip',
        gravity: 's',
        offset: 2
      });

      self.$().on('tap', '.dcg-tappable', function (evt) {
        var button = $(evt.target).closest('.dcg-tappable');
        self.buttonClicked(button);
      });

      self.$showBtn.show();

      //initialize hide & show
      self.$hideBtn.on("tap", function () {
        self.userMinimized = true;
        Cookie.setCookie("keypadMinimized", "true");
        self._hideKeypad();
      });

      self.$showBtn.on("tap", function () {
        self.userMinimized = false;
        Cookie.setCookie("keypadMinimized", "false");
        self._showKeypad();

        // focus is already in a mathquill.
        if (self.getActiveMathquill()) {
          return;
        }

        // the keypad is going to be maximized, but we have
        // no clear place to put focus. Run through the views
        // and request them to put focus.
        //
        // NOTE: works deterministically because only the
        // expressionsView defines the `.addFocusForKeypad()`
        // function. If we add more views that require the fake
        // keypad we can come up with something better.
        for (var i=0; i<self.editableViews.length; i++) {
          if (self.editableViews[i].addFocusForKeypad) {
            self.editableViews[i].addFocusForKeypad();
          }
        }

      });

      self.userMinimized = (Cookie.getCookie("keypadMinimized") === "true");
    };

    view._hideKeypad = function () {
      clearTimeout(this.__showHideTimeout);

      var self = this;
      // Timeout is used to avoid keypad flicker when moving between expressions.
      this.__showHideTimeout = setTimeout(function () {
        self.__showHideTimeout = null;
        self.setProperty('isOpen', false);
        self.setProperty('functionsOpen', false);
        self.$container.addClass('dcg-retracted');

        if (Browser.IS_IE8 || Browser.IS_IE9) {
          // IE<10 doesn't support transitions, so we shouldn't fade the button
          // in
          self.$showBtn.show();
        } else {
          self.$showBtn.fadeIn();
        }
      });
    };

    view._showKeypad = function () {
      clearTimeout(this.__showHideTimeout);
      var self = this;
      this.__showHideTimeout = setTimeout(function () {
        self.__showHideTimeout = null;
        self.setLayout("mainNumbers");
        self.$showBtn.hide();
        self.setProperty('isOpen', true);
        self.$container.removeClass('dcg-retracted');
      });
    };

    view.requestSetIsOpen = function (isOpen) {
      if (this.userMinimized  && !this.isOpen) return;
      if (isOpen === this.isOpen && !this.__showHideTimeout) return;

      if (isOpen) {
        this._showKeypad();
      } else {
        this._hideKeypad();
      }
    };

    view.getButton = function (buttonId) {
      if (!this.keys[buttonId])
        buttonId = "unknown";
      return this.keys[buttonId].display;
    };

    view.buttonArray = function (buttonsString) {
      return _.map(buttonsString.split(' '), this.getButton, this);
    };

    view.setupKeypad = function () {

      this.buttons = {
        mainNumbersLeft: [
          {keys: this.buttonArray('highlightedX highlightedY squared exponent') },
          {keys: this.buttonArray('leftparen rightparen lt gt') },
          {keys: this.buttonArray('pipes comma le ge') },
          {keys: this.buttonArray('toggleLetters sqrt pi') }
        ],

        numbersMiddle: [
          {keys: this.buttonArray('7 8 9 divide') },
          {keys: this.buttonArray('4 5 6 times') },
          {keys: this.buttonArray('1 2 3 minus') },
          {keys: this.buttonArray('0 decimal equals plus') }
        ],

        numbersRight: [
          {keys: this.buttonArray('popupFunctions') },
          {keys: this.buttonArray('left right') },
          //intentionally leave the last blank off so that enter isn't covered by it
          {keys: this.buttonArray('halfBlank backspace') },
          {keys: this.buttonArray('enter') }
        ],

        letters: [
          {keys: this.buttonArray('q w e r t y u i o p') },
          {keys: this.buttonArray('halfBlank a s d f g h j k l halfBlank') },
          {keys: this.buttonArray('toggleCapital z x c v b n m backspace') },
          {keys: this.buttonArray(
            'toggleNumbers subscript brackets colon squarebrackets twiddle theta enter'
          )}
        ],
        capitalLetters: [
          {keys: this.buttonArray('Q W E R T Y U I O P') },
          {keys: this.buttonArray('halfBlank A S D F G H J K L halfBlank') },
          {keys: this.buttonArray('toggleLowercase Z X C V B N M backspace') },
          {keys: this.buttonArray(
            'toggleNumbers subscript brackets colon squarebrackets twiddle theta enter'
          )}
        ]
      };

      this.popups = {
        functionsPopup: {
          trig: {
            tab:this.getButton('trigTab'),
            funcs: this.buttonArray(
              'sin arcsin sinh cos arccos cosh tan arctan tanh csc arccsc csch sec arcsec sech cot arccot coth'
            )
          },

          calc: {
            tab: this.getButton('calcTab'),
            funcs: this.buttonArray('exp ln log loga ddx sum prod fact e')
          },

          misc: {
            tab: this.getButton('miscTab'),
            funcs: this.buttonArray(
              'ceil floor round abs min max lcm gcd mod nCr nPr fact sqrt cuberoot pipes brackets'
            )
          }
        }
      };
    };

    view.getTemplateParams = function(){
        return {buttons: this.buttons, popups: this.popups};
    };

    view.height = function () {
      return this.isOpen ? this.$container.height() : 0;
    };

    view.setLayout = function (newLayout) {
      this.layout = newLayout;
      this.$().removeClass('dcg-layout-letters dcg-layout-capitalLetters dcg-layout-mainNumbers')
              .addClass('dcg-layout-' + newLayout);
    };

    view.setTab = function (newTab) {
      var tabs = ['trig','calc','misc'];
      var self = this;
      _.each(tabs, function (tab) {
        self.$('[key=' + tab + 'Tab]').removeClass('dcg-selected');
        self.$('[section=' + tab + ']').hide();
      });
      this.$('[key=' + newTab + 'Tab]').addClass('dcg-selected');
      this.$('[section=' + newTab + ']').show();
    };

    view.renderFunctionsOpen = function () {
      this.$funcBtn.toggleClass("dcg-active", this.functionsOpen);
      this.$funcPopover.toggle(this.functionsOpen);
      this.positionFunctionsPopup();
    };

    view.positionFunctionsPopup = function () {
      if (!this.functionsOpen) return;

      //this just changes which direction the arrowhead is pointing
      var $arrow = this.$funcPopover.find('.dcg-arrow');
      if (this.graphpaperHeight < 525) {
        this.$funcPopover.removeClass("dcg-top").addClass("dcg-left");

        var btnDistanceFromBottom = this.$container.outerHeight() -
              (this.$funcBtn.offset().top - this.$container.offset().top);

        //subtract off half width and then make 2 adjustments:
        // -2px because popover has bottom: 2px
        // -10px to compensate for the 10px height of the arrow
        var arrowBottom = btnDistanceFromBottom - this.$funcBtn.outerHeight() / 2 - 2 - 10;

        $arrow.css({
          left: 'auto',
          bottom: arrowBottom
        });
      } else {
        this.$funcPopover.removeClass("dcg-left").addClass("dcg-top");
        $arrow.css({
          left: this.$funcPopover.width() - this.$funcBtn.width() / 2,
          bottom: 'auto',
        });
      }
    };

    view.buttonClicked = function (button) {
      /* jshint maxcomplexity:293 */
      var keyID        = this.$(button).attr('key'),
          buttonAction = this.keys[keyID].action;

      if (buttonAction.changeLayout) {
        this.setProperty('functionsOpen', false);
        this.setLayout(buttonAction.changeLayout);
        return;
      }
      if (buttonAction.tab) {
        return this.setTab(buttonAction.tab);
      }
      if (buttonAction.popup === 'functions') {
        return this.setProperty('functionsOpen', !this.functionsOpen);
      }

      //hide popup when any button is pressed (Except a popup or tab button)
      this.setProperty('functionsOpen', false);

      var editor = this.getActiveMathquill();

      if (!editor) {
        var activeView = this.getEditableViewThatNeedsKeypad();
        if (activeView && activeView.handleUnfocusedKeypadAction) {
          activeView.handleUnfocusedKeypadAction(buttonAction.key);
        }

        return;
      }

      try {
        if (buttonAction.custom) {
          switch (buttonAction.custom) {
            case 'brackets':
              editor.mathquill('cmd', '{');
              editor.mathquill('cmd', '}');
              editor.mathquill('onKey', 'Left');
              break;
            case 'squarebrackets':
              editor.mathquill('cmd', '[');
              editor.mathquill('cmd', ']');
              editor.mathquill('onKey', 'Left');
              break;
            case 'loga':
              editor.mathquill('write','log_{}\\left( \\right)');
              editor.mathquill('onKey', 'Left');
              editor.mathquill('onKey', 'Left');
              editor.mathquill('onKey', 'Left');
              break;
            case 'cuberoot':
              editor.mathquill('write', '\\sqrt[3]{}');
              editor.mathquill('onKey', 'Left');
              break;
            case 'squared':
              //route as if typed the exponent button, so that we get the
              //nice behavior where exponentiating in an exponent is treated
              //as a backspace first
              editor.mathquill('cmd', '^');
              editor.mathquill('cmd', '2');
              editor.mathquill('onKey', 'Right');
              break;
            case 'cubed':
              editor.mathquill('write', '^{3}');
              break;
            case 'd/dx':
              editor.mathquill('write','\\frac{d}{dx}');
              break;
          }
        } else if (buttonAction.key) {
          editor.mathquill("onKey", buttonAction.key);
        } else if (buttonAction.cmd) {
          editor.mathquill('cmd', buttonAction.cmd);
          //if (buttonAction.moveLeft) {
          //  editor.mathquill("onKey", "Left");
          //}
        } else if (buttonAction.func) {
          var suffix = '\\left( \\right)';
          if (buttonAction.args === 2) {
            suffix = '\\left({},{}\\right)';
          }
          editor.mathquill('write', buttonAction.func + suffix);
          editor.mathquill('onKey', 'Left');
          if (buttonAction.args === 2) {
            editor.mathquill('onKey', 'Left');
          }
        }
        // after everything is said and done, tell mathquill it rendered. This
        // will update the value stored for the expressions latex. And that
        // will cause this change to go into undo/redo.
        editor.trigger('render');
      } catch (e) {
        console.log(e);
      }
    };
  });

  return KeypadView;
});

//Abstract out getState and setState functionality
//TODO - setState is still pretty gross, but this is better than copy/pasting that grossness

define('main/state_controller',['require','pjs','expressions/colors','jquery'],function (require) {
  var P = require('pjs');
  var Colors = require('expressions/colors');
  var $ = require('jquery');

  var StateController = P(function (proto) {

    var BLANK_STATE = {
      'graph': {
        'viewport': {
          'xmin': -10,
          'xmax': 10,
          'ymin': -10,
          'ymax': 10
        },
        'xAxisArrows': 'none',
        'yAxisArrows': 'none',
        'xAxisLabel': '',
        'yAxisLabel': '',
        'xAxisStep': 0,
        'yAxisStep': 0,
        'xAxisNumbers': true,
        'yAxisNumbers': true,
        'polarNumbers': true,
        'showXAxis': true,
        'showYAxis': true,

        'showGrid': true,
        'squareAxes': true,
        'labelXMode': '',
        'labelYMode':''
      },
      'expressions': {'list': [{'id': 1, 'latex': ''}]}
    };

    proto.init = function (grapher, expressionsModel, graphSettings, evaluator) {
      this.grapher = grapher;
      this.expressionsModel = expressionsModel;
      this.graphSettings = graphSettings;
      this.evaluator = evaluator;
      this.isFirstSetState = true;
    };

    proto.triggerSetState = function () {};

    proto.getState = function () {
      return {
        graph: this.grapher.getState(),
        expressions: this.expressionsModel.getState()
      };
    };

    proto.setState = function (state) {
      //don't set blank state more than once
      if (
        !this.isFirstSetState &&
        (state === null) &&
        this.expressionsModel.isEmpty()
      ) {
        return;
      }

      var self = this;
      var manipulator = function (state) {
        Colors.reset();
        if (!state) state = BLANK_STATE;
        if (typeof state === 'string') state = JSON.parse(state);

        // Empty the evaluator and the graph so that when we switch to the new
        // viewport, we don't flash a rescaled version of the old state.
        if ('expressions' in state) {
          self.expressionsModel.setState({ list: [] });
        }

        self.evaluator.batch(function () {
          self.expressionsModel.setSelected(null);
          self.grapher.clear();
          self.grapher.redrawGraphsLayer();

          if ('graph' in state) {
            if (!('degreeMode' in state.graph)) state.graph.degreeMode = false;

            self.grapher.setState(state.graph);
          }

          if ('expressions' in state) {
            self.expressionsModel.setState(state.expressions);
            self.evaluator.markAsCompleteState();
          }
        });
      };

      //apply it this first time, but don't add to undo/redo
      if (this.isFirstSetState) {
        manipulator(state);
        this.isFirstSetState = false;
        return;
      }

      var curState = this.getState();
      this.expressionsModel.undoRedo.addTransaction({
        type: this.expressionsModel.undoRedo.CAUSE_OF_CHANGE,
        undo: function () { manipulator(curState); },
        redo: function () { manipulator(state); },

        // we stringify two json objects that come out of the same function.
        // If the objects are the same, then the stringified versions will be
        // exactly the same.
        ensureChangeOccured: function () {
          var newState = JSON.stringify(self.getState());
          var oldState = JSON.stringify(curState);

          return oldState === newState;
        }
      });
    };

    proto.setBlank = function () {
      this.setState(BLANK_STATE);
    };

    proto.setStateFromURL = function (url) {
      return $.getJSON(url).done(function (msg) {
        this.setState(msg.state);
      }.bind(this));
    };
  });

  return StateController;

});

// Listens to expressionsModel and propagates selection changes to the grapher
// and evaluator.
//
// TODO this could be *much* simpler if we had a better model for expressing
// selection within a table.
define('main/propagate_selection',['require'],function (require) {
  function propagateSelection(expressionsModel, grapher, evaluator) {
    var lastSelectedId;
    var lastSelectedModel;

    // Show pois for the currently selected equation.
    var onSelectedExpressionChange = function () {
      var selected = expressionsModel.getSelected();
      // sets up a listener for changes in selection within tables and folders. It's fine
      // that we add these observers for even non-tables and non-folders.
      if (selected !== lastSelectedModel) {
        if (lastSelectedModel) {
          lastSelectedModel.unobserve('.propagate_selection');
        }
        if (selected) {
          selected.observe('selectedCell.propagate_selection', onSelectedExpressionChange);
          selected.observe('selectedHiddenChild.propagate_selection', onSelectedExpressionChange);
        }
        lastSelectedModel = selected;
      }

      var selectedId = (selected) ? selected.id : undefined;

      if (selected && selected.isTable) {
        var selectedCell = selected.selectedCell;
        if (selectedCell) {
          var selectedCol = selected.columns[selectedCell.column];
          selectedId = selectedCol ? selectedCol.id : undefined;
        } else {
          selectedId = undefined;
        }
      }

      if (selected && selected.isFolder) {
        var selectedChild = selected.selectedHiddenChild;
        if (selectedChild) {
          selectedId = selectedChild.id;
        } else {
          selectedId = undefined;
        }
      }

      var idChanged = (selectedId !== lastSelectedId);

      if (idChanged) {
        grapher.select(selectedId);
        var intersectIds = grapher.getOpenIntersectionIds();
        if (typeof selectedId !== "undefined") intersectIds[selectedId] = true;
        evaluator.setIntersectIds(intersectIds);
        // Causes a redraw that will update the grapher appearance.
        evaluator.updateIntersections(selectedId);
      }

      lastSelectedId = selectedId;
    };

    expressionsModel.observe('selectedItem', onSelectedExpressionChange);
  }

  return propagateSelection;
});
define('template!pillboxes', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="dcg-pillbox-container">\n\n  <div class="dcg-settings-pillbox">\n    <span\n      class="dcg-tooltip-e dcg-action-settings"\n      tooltip="'+
( t('Graph Settings') )+
'"\n      tipsy-offset="5"\n    >\n      <i class="dcg-icon-wrench"></i>\n    </span>\n  </div>\n\n  <div class="dcg-zoom-more-options">\n      <div class="dcg-zoom-options-header dcg-action-moreoptions">\n        <span class="dcg-title">'+
( t('zoom') )+
'</span>\n        <i class="dcg-icon dcg-icon-zoom"></i>\n      </div>\n\n      <div class="dcg-zoom-options-menu-container">\n        <div class="dcg-zoom-options-menu">\n          <div class="dcg-option dcg-action-zoomin">\n            '+
( t('zoom in') )+
'\n            <i class="dcg-icon dcg-icon-plus"></i>\n          </div>\n          <div class="dcg-option dcg-action-zoomout">\n            '+
( t('zoom out') )+
'\n            <i class="dcg-icon dcg-icon-minus"></i>\n          </div>\n          <div class="dcg-option dcg-action-zoomsquare">\n            '+
( t('square') )+
'\n            <i class="dcg-icon dcg-icon-square"></i>\n          </div>\n          <div class="dcg-option dcg-action-zoomrestore">\n            '+
( t('default') )+
'\n            <i class="dcg-icon dcg-icon-home"></i>\n          </div>\n        </div>\n      </div>\n  </div>\n\n  <div class="dcg-graphpaper-branding">\n    <div class="dcg-powered-by">powered by</div>\n    <i class="dcg-icon-desmos"></i>\n  </div>\n\n<div>';
}
return __p;
};});
define('loadcss!css/settings', function(){});
define('template!settings', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="dcg-settings-container dcg-left dcg-popover dcg-constrained-height-popover">\n    <div class="dcg-popover-interior">\n      <div class="dcg-popover-fixedwidth">\n        <div class="dcg-popover-content">\n          <div class="dcg-modern-btn dcg-action-projectormode">'+
( t('Projector Mode') )+
'</div>\n        </div>\n\n        <div class="dcg-popover-content dcg-graph-settings">\n\n          <div class="dcg-section-title">\n            '+
( t('Graph Paper') )+
'\n          </div>\n\n          <div class="dcg-grid-settings">\n            <div class="dcg-polargroup">\n              <div class="dcg-icon dcg-action-cartesian"></div>\n              <div class="dcg-icon dcg-action-polar"></div>\n              <div class="dcg-title">'+
( t('Grid') )+
'</div>\n            </div>\n\n            <span class="dcg-checkbox dcg-action-zoomsquare">\n              <span class="dcg-checkbox-box"><i class="dcg-icon-check"></i></span>\n              <span class="dcg-checkbox-label">'+
( t('Square Grid') )+
'</span>\n            </span>\n            <div style="clear:both"></div>\n          </div>\n\n          <div class="dcg-collapsable-options dcg-x-axis-options dcg-collapsed">\n            <div class="dcg-icon dcg-x-arrows dcg-display-icon"><i class="dcg-icon-hidden"></i></div>\n\n            <div class="dcg-title-container">\n              <div class="dcg-caret-container"><i class="dcg-icon-caret-down" ></i></div>\n              <div class="dcg-title">'+
( t('X-Axis') )+
'</div>\n            </div>\n            <input class="dcg-axis-label dcg-x-axis-label" placeholder="'+
( t('add label') )+
'" />\n\n            <div class="dcg-readonly-inputs">\n              <div class="dcg-readonly-mathquill-container">\n                <span class="dcg-readonly-xmin dcg-action-editinput"></span><span class="dcg-interval-interior">\\le x\\le </span><span class="dcg-readonly-xmax dcg-action-editinput"></span>\n              </div>\n              <div class="dcg-readonly-mathquill-container dcg-step-container">\n                <span class="dcg-step-label">'+
( t('Step:') )+
'</span>\n                <span class="dcg-readonly-xstep dcg-action-editinput"></span>\n              </div>\n              <div style="clear:both"></div>\n\n            </div>\n\n            <div class="dcg-editable-inputs">\n              <div class="dcg-editable-mathquill-container">\n                <span class="dcg-editable-xmin"></span>\n                <span class="dcg-interval-interior">\\le x\\le </span>\n                <span class="dcg-editable-xmax"></span>\n                <span class="dcg-step-container">\n                  <span class="dcg-step-label">'+
( t('Step:') )+
'</span>\n                  <span class="dcg-editable-xstep"></span>\n                </span>\n              </div>\n            </div>\n\n            <div class="dcg-more-options">\n              <span>\n                <div class="dcg-arrows-label">'+
( t('Arrows:') )+
'</div>\n                <div class="dcg-icon dcg-x-arrows" dcg-arrows="none"></div>\n                <div class="dcg-icon dcg-x-arrows" dcg-arrows="positive"></div>\n                <div class="dcg-icon dcg-x-arrows" dcg-arrows="both"></div>\n              </span>\n              <span class="dcg-checkbox dcg-action-xaxisnumbers">\n                <span class="dcg-checkbox-box"><i class="dcg-icon-check"></i></span>\n                <span class="dcg-checkbox-label">'+
( t('Show Numbers') )+
'</span>\n              </span>\n            </div>\n          </div>\n\n          <div class="dcg-collapsable-options dcg-y-axis-options dcg-collapsed">\n            <div class="dcg-icon dcg-y-arrows dcg-display-icon"><i class="dcg-icon-hidden"></i></div>\n\n            <div class="dcg-title-container">\n              <div class="dcg-caret-container"><i class="dcg-icon-caret-down" ></i></div>\n              <div class="dcg-title">'+
( t('Y-Axis') )+
'</div>\n            </div>\n            <input class="dcg-axis-label dcg-y-axis-label" placeholder="'+
( t('add label') )+
'" />\n\n            <div class="dcg-readonly-inputs">\n              <div class="dcg-readonly-mathquill-container">\n                <span class="dcg-readonly-ymin dcg-action-editinput"></span><span class="dcg-interval-interior">\\le y\\le </span><span class="dcg-readonly-ymax dcg-action-editinput"></span>\n              </div>\n              <div class="dcg-readonly-mathquill-container dcg-step-container">\n                <span class="dcg-step-label">'+
( t('Step:') )+
'</span>\n                <span class="dcg-readonly-ystep dcg-action-editinput"></span>\n              </div>\n              <div style="clear:both"></div>\n            </div>\n\n            <div class="dcg-editable-inputs">\n              <div class="dcg-editable-mathquill-container">\n                <span class="dcg-editable-ymin"></span>\n                <span class="dcg-interval-interior">\\le y\\le </span>\n                <span class="dcg-editable-ymax"></span>\n                <span class="dcg-step-container">\n                  <span class="dcg-step-label">'+
( t('Step:') )+
'</span>\n                  <span class="dcg-editable-ystep"></span>\n                </span>\n              </div>\n            </div>\n            \n            <div class="dcg-more-options">\n              <span>\n                <div class="dcg-arrows-label">'+
( t('Arrows:') )+
'</div>\n                <div class="dcg-icon dcg-y-arrows" dcg-arrows="none"></div>\n                <div class="dcg-icon dcg-y-arrows" dcg-arrows="positive"></div>\n                <div class="dcg-icon dcg-y-arrows" dcg-arrows="both"></div>\n              </span>\n              <span class="dcg-checkbox dcg-action-yaxisnumbers">\n                <span class="dcg-checkbox-box"><i class="dcg-icon-check"></i></span>\n                <span class="dcg-checkbox-label">'+
( t('Show Numbers') )+
'</span>\n              </span>\n            </div>\n          </div>\n\n          <div class="dcg-section-title">\n            '+
( t('Angles') )+
'\n          </div>\n          <div class="dcg-radiangroup">\n            <div class="dcg-action-degreemode dcg-modern-btn">'+
( t('Degrees') )+
'</div>\n            <div class="dcg-action-radianmode dcg-modern-btn">'+
( t('Radians') )+
'</div>\n\n            <div class="dcg-polarnumbers-container">\n              <span class="dcg-checkbox dcg-action-polarnumbers">\n                <span class="dcg-checkbox-box"><i class="dcg-icon-check"></i></span>\n                <span class="dcg-checkbox-label">'+
( t('Show Grid Angles') )+
'</span>\n              </span>\n            </div>\n\n          </div>\n        </div>\n\n      </div>\n      <div class="dcg-arrow"></div>\n    </div>\n</div>';
}
return __p;
};});
define('main/settings_view',['require','loadcss!css/settings','jquery','underscore','pjs','main/popover_view','graphing/viewport','conditional_blur','math/builtinframe','parser','math/parsenode/constant','keys','graphing/label','template!settings','vendor/jquery.html5-placeholder-shim','scroll_helpers'],function(require){
  require('loadcss!css/settings');
  var $ = require('jquery');
  var _ = require('underscore');
  var P = require('pjs');
  var PopoverView = require('main/popover_view');
  var Viewport = require('graphing/viewport');
  var conditionalBlur = require('conditional_blur');
  var BuiltInFrame = require('math/builtinframe');
  var Parser = require('parser');
  var Constant = require('math/parsenode/constant');
  var Keys = require('keys');
  var Label = require('graphing/label');
  var template = require('template!settings');
  require('vendor/jquery.html5-placeholder-shim');
  var scrollHelpers = require('scroll_helpers');

  function formatLatex (num, scale) {
    var label = Label.value(num, scale);
    var latex = '';

    // scientific notation
    if (label.mantissa) {
      latex = label.mantissa.split('').join('\\cdot') + "^{" + label.superscript + "}";
    } else {
      // fraction
      var frac_parts = label.string.split("/");
      if (frac_parts.length === 2) {
        latex = '\\frac{'+ frac_parts[0] +'}{'+ frac_parts[1] +'}';
      } else {
        latex = label.string;
      }
    }
    return latex;
  }

  /*
  * view for the settings bar
  */
  var SettingsView = P(PopoverView, function (view, _super){
    view.viewport = new Viewport();
    view.template = template;
    view.pointToSelector = '.dcg-action-settings i';

    view.init = function (grapher) {
      _super.init.call(this);
      this.grapher = grapher;
      this.settings = this.grapher.settings;
    };

    // don't do anything if we're inside the popover or if we're inside the openButton
    view.eventShouldClosePopover = function (evt) {
      if (this.eventIsWithinPopover(evt)) {
        return false;
      }
      if (this.isMathquillFocused() && $(evt.target).closest('.dcg-keypad').length) {
        return false;
      }
      return true;
    };

    view.renderIsVisible = function () {
      _super.renderIsVisible.call(this);
      if (this.isVisible && $.placeholder) {
        if ($.placeholder) $.placeholder.shim();
      }
    };

    view.setBottom = function (bottom) {
      this.$().css('bottom', bottom);
    };

    view.didCreateElement = function () {
      _super.didCreateElement.call(this);
      var self = this;

      // setup the readonly mathquills
      this.$readonly = {};
      this.$readonly.xmin = this.$('.dcg-readonly-xmin');
      this.$readonly.xmax = this.$('.dcg-readonly-xmax');
      this.$readonly.xstep = this.$('.dcg-readonly-xstep');
      this.$readonly.ymin = this.$('.dcg-readonly-ymin');
      this.$readonly.ymax = this.$('.dcg-readonly-ymax');
      this.$readonly.ystep = this.$('.dcg-readonly-ystep');
      _.each(this.$readonly, function ($mathquill, prop) {
          $mathquill.mathquill()
                    .data('dcg-limit', prop);

          // TODO - revisit after new mathquill. For some reason the readonly mathquills
          // actively blur other mathquills on mousedown. We don't want that in this case.
          // see the comment on .dcg-readonly-inputs.tapstart below for more information.
          $mathquill.unbind('mousedown');
      });


      this.$('.dcg-interval-interior').each(function() {
        var html = $('<span>' + $(this).text() + '<span>').mathquill().mathquill('html');
        $(this).html(html).addClass('mathquill-rendered-math');
      });

      // setup the editable mathquills
      this.$editable = {};
      this.$editable.xmin = this.$('.dcg-editable-xmin');
      this.$editable.xmax = this.$('.dcg-editable-xmax');
      this.$editable.xstep = this.$('.dcg-editable-xstep');
      this.$editable.ymin = this.$('.dcg-editable-ymin');
      this.$editable.ymax = this.$('.dcg-editable-ymax');
      this.$editable.ystep = this.$('.dcg-editable-ystep');
      _.each(this.$editable, function ($mathquill, prop) {
        $mathquill.mathquill('editable')
                  .data('dcg-limit', prop)
                  .addClass('dcg-math-input')
                  .on('focusin', self.focusInMathquill.bind(self))
                  .on('focusout', self.focusOutMathquill.bind(self))
                  .on('render', self.handleMathquillInput.bind(self))
                  .on('keydown', self.handleKeydown.bind(self))
                  .on('enterPressed', conditionalBlur);
      });

      this.$('.dcg-readonly-inputs').on('tapstart', function (evt) {
        // 1) make sure both the x-axis and y-axis options are collapsed.
        // 2) click in the readonly xmin mathquill. => The x-axis won't expand but the mathquills are editable
        // 3) mousedown in the readonly ymin mathquill.
        //
        // The browser wants to blur the xmin input. If that happens the x-axis inputs will go back
        // to readonly. That'll cause the layout to change. When you mouseup on the readonly ymin input, it may
        // no longer be under your mouse. That'd prevent the tap event from firing and making ymin editable.
        //
        // Solution:
        // preventDefault() on mousedown within this area.
        evt.preventDefault();
      });

      this.$('.dcg-readonly-mathquill-container').on('tap', function (evt) {
        var $container = $(this);
        var $target = $(evt.target);
        var $readonly_mathquill = $target.closest('.dcg-action-editinput');

        if (!$readonly_mathquill.length) {
          $readonly_mathquill = $container.find('.dcg-action-editinput:first');
        }

        var limit = $readonly_mathquill.data('dcg-limit');
        var $editable_mathquill = self.$editable[limit];

        $editable_mathquill.mathquill('focus');
      });

      this.$('.dcg-action-polarnumbers').on('tap', function () {
        if ($(this).hasClass('dcg-disabled')) return;
        self.settings.setProperty('polarNumbers', !self.settings.polarNumbers);
      });
      this.$('.dcg-action-xaxisnumbers').on('tap', function () {
        if ($(this).hasClass('dcg-disabled')) return;
        self.settings.setProperty('xAxisNumbers', !self.settings.xAxisNumbers);
      });
      this.$('.dcg-action-yaxisnumbers').on('tap', function () {
        if ($(this).hasClass('dcg-disabled')) return;
        self.settings.setProperty('yAxisNumbers', !self.settings.yAxisNumbers);
      });
      this.$('.dcg-x-axis-label').on('change copy paste cut keypress keydown keyup', function () {
        self.settings.setProperty('xAxisLabel', $(this).val());
      });
      this.$('.dcg-y-axis-label').on('change copy paste cut keypress keydown keyup', function () {
        self.settings.setProperty('yAxisLabel', $(this).val());
      });

      this.$('.dcg-action-polar').on('tap', function () {
        if (self.settings.showGrid && self.settings.polarMode) {
          //break out of polar here, so that we can set step sizes again
          self.settings.setProperty('polarMode', false);
          self.settings.setProperty('showGrid', false);
        } else {
          self.settings.setProperty('showGrid', true);
          self.settings.setProperty('polarMode', true);
        }
      });
      this.$('.dcg-action-cartesian').on('tap', function () {
        if (self.settings.showGrid && !self.settings.polarMode) {
          self.settings.setProperty('showGrid', false);
        } else {
          self.settings.setProperty('showGrid', true);
          self.settings.setProperty('polarMode', false);
        }
      });

      this.$('.dcg-action-radianmode').on('tap', function (){
        self.settings.setProperty(
          'degreeMode',
          false
        );
      });
      this.$('.dcg-action-degreemode').on('tap', function (){
        self.settings.setProperty(
          'degreeMode',
          true
        );
      });
      this.$('.dcg-action-projectormode').on('tap', function (){
        self.settings.setProperty(
          'projectorMode',
          !self.settings.projectorMode
        );
      });
      this.$('.dcg-x-arrows:not(.dcg-display-icon)').on('tap', function () {
        self.settings.setProperty('showXAxis', true);
        self.settings.setProperty('xAxisArrows', self.$(this).attr('dcg-arrows'));
      });
      this.$('.dcg-y-arrows:not(.dcg-display-icon)').on('tap', function () {
        self.settings.setProperty('showYAxis', true);
        self.settings.setProperty('yAxisArrows', self.$(this).attr('dcg-arrows'));
      });
      this.$('.dcg-x-axis-options .dcg-display-icon').on('tap', function () {
        self.settings.setProperty('showXAxis', !self.settings.showXAxis);
      });
      this.$('.dcg-y-axis-options .dcg-display-icon').on('tap', function () {
        self.settings.setProperty('showYAxis', !self.settings.showYAxis);
      });

      // collapses / expand options
      this.$('.dcg-collapsable-options').find('.dcg-caret-container, .dcg-title').on('tap', function (evt) {
        self.$(evt.target).closest('.dcg-collapsable-options').toggleClass('dcg-collapsed');
      });

      this.addSettingsObserver('projectorMode', this.renderProjectorMode);
      this.addSettingsObserver('xAxisArrows showXAxis', this.renderXArrows);
      this.addSettingsObserver('yAxisArrows showYAxis', this.renderYArrows);
      this.addSettingsObserver('polarNumbers showGrid polarMode', this.renderPolarNumbers);
      this.addSettingsObserver('xAxisNumbers showXAxis', this.renderXAxisNumbers);
      this.addSettingsObserver('yAxisNumbers showYAxis', this.renderYAxisNumbers);
      this.addSettingsObserver('xAxisLabel showXAxis', this.renderXAxisLabel);
      this.addSettingsObserver('yAxisLabel showYAxis', this.renderYAxisLabel);
      this.addSettingsObserver('computedStepSizes xAxisStep', this.renderXStep);
      this.addSettingsObserver('computedStepSizes yAxisStep', this.renderYStep);

      this.addSettingsObserver('degreeMode', this.renderDegreeMode);
      this.addSettingsObserver('squareAxes', this.renderSquareAxes);
      this.addSettingsObserver('showGrid polarMode', this.renderPolarMode);

      this.updateMathquillInputs();
    };

    view.handleKeydown = function (evt) {
      var key = Keys.lookup(evt);

      if (key === Keys.ESCAPE) conditionalBlur();
    };

    function evaluateMathquill ($mathquill, useDegrees) {
      var latex = $mathquill.mathquill('latex');

      // TODO avoid duplicating logic for setting degree mode in frame
      var frame = Object.create(BuiltInFrame, {
        trigAngleMultiplier: Constant(useDegrees ? Math.PI / 180 : 1)
      });

      return +Parser.parse(latex).tryGetConcreteTree(frame).constantValue;
    }

    view.handleMathquillInput = function(evt) {
      var degreeMode = !!this.settings.degreeMode;
      var xmin = evaluateMathquill(this.$editable.xmin, degreeMode);
      var xmax = evaluateMathquill(this.$editable.xmax, degreeMode);
      var xstep;
      if (this.$editable.xstep.mathquill('latex') === '') {
        xstep = 0;
      } else {
        xstep = evaluateMathquill(this.$editable.xstep, degreeMode);
      }

      var ymin = evaluateMathquill(this.$editable.ymin, degreeMode);
      var ymax = evaluateMathquill(this.$editable.ymax, degreeMode);
      var ystep;
      if (this.$editable.ystep.mathquill('latex') === '') {
        ystep = 0;
      } else {
        ystep = evaluateMathquill(this.$editable.ystep, degreeMode);
      }

      var invalids = {};

      var isFiniteNumber = function (num) {
        return isFinite(num) && typeof num === 'number';
      };

      var tempViewport = new Viewport(xmin, xmax, ymin, ymax);

      if (isFiniteNumber(xmin) && isFiniteNumber(xmax)) {
        invalids.xmin = !tempViewport.isXValid();
        invalids.xmax = invalids.xmin;
      } else {
        invalids.xmin = !isFiniteNumber(xmin);
        invalids.xmax = !isFiniteNumber(xmax);
      }

      if (isFiniteNumber(ymin) && isFiniteNumber(ymax)) {
        invalids.ymin = !tempViewport.isYValid();
        invalids.ymax = invalids.ymin;
      } else {
        invalids.ymin = !isFiniteNumber(ymin);
        invalids.ymax = !isFiniteNumber(ymax);
      }

      if (isFiniteNumber(xstep)) {
        invalids.xstep = false;
        this.settings.setProperty('xAxisStep', xstep);
      } else {
        invalids.xstep = true;
      }

      if (isFiniteNumber(ystep)) {
        invalids.ystep = false;
        this.settings.setProperty('yAxisStep', ystep);
      } else {
        invalids.ystep = true;
      }

      this.setViewport(tempViewport);

      this.$editable.xmin.toggleClass("dcg-invalid", invalids.xmin);
      this.$editable.xmax.toggleClass("dcg-invalid", invalids.xmax);
      this.$editable.xstep.toggleClass("dcg-invalid", invalids.xstep);
      this.$editable.ymin.toggleClass("dcg-invalid", invalids.ymin);
      this.$editable.ymax.toggleClass("dcg-invalid", invalids.ymax);
      this.$editable.ystep.toggleClass("dcg-invalid", invalids.ystep);

      if (this.grapher && this.grapher.screen) {
        this.settings.setProperty(
          'squareAxes',
          tempViewport.isSquare(this.grapher.screen)
        );
      }
    };

    view.updateNeedsFakeKeypad = function () {
      this.setProperty('needsFakeKeypad', this.isMathquillFocused());
    };

    view.focusInMathquill = function(evt) {
      var input = this.$(evt.target).closest('.dcg-math-input');
      var collapsable = this.$(evt.target).closest('.dcg-collapsable-options');

      //focusin is triggered always, even when reclicking into a selected mathquill
      //we don't want to reselect in that case.
      if (input.hasClass('dcg-focus')) return;

      input.addClass('dcg-focus');
      input.triggerHandler('select_all');
      collapsable.addClass('dcg-input-focused');
      this.updateNeedsFakeKeypad();

      //make sure inputs visible, but put it in a 1 frame timeout so that the keypad has time to show
      var container = this.$('.dcg-popover-interior');
      setTimeout(function() {
        scrollHelpers.scrollVisible(input, container, 50);
      }, 0);
    };

    view.focusOutMathquill = function(evt) {
      var input = this.$(evt.target).closest('.mathquill-editable');
      var collapsable = this.$(evt.target).closest('.dcg-collapsable-options');

      input.removeClass('dcg-focus');
      input.mathquill('clearSelection');

      if (collapsable.find('.dcg-focus').length === 0) {
        collapsable.removeClass('dcg-input-focused');
      }

      // Disable reverting mathquills right after a focusout.
      // If the user pressed 'tab' then there will be a focusin
      // event next. If focus goes into an element in the
      // same row, then we should not update the mathquills.
      clearTimeout(this.focusedOutRecentlyTimeout);
      this.focusedOutRecently = true;
      this.focusedOutRecentlyTimeout = setTimeout(function () {
        this.focusedOutRecently = false;
        this.updateMathquillInputs();
      }.bind(this));

      this.updateNeedsFakeKeypad();
    };

    view.addSettingsObserver = function (prop, func) {
      var f = func.bind(this);
      this.settings.observe(prop, f);
      f();
    };

    view.renderProjectorMode = function () {
      var pmode = this.settings.projectorMode;
      this.$('.dcg-action-projectormode').toggleClass('dcg-active', !!pmode);
    };

    view.renderXArrows = function () {
      var arrows = this.settings.xAxisArrows;
      var showAxis = this.settings.showXAxis;

      this.$(".dcg-x-axis-options .dcg-display-icon").attr('dcg-arrows', arrows);
      this.$(".dcg-x-arrows").toggleClass('dcg-active', false);

      if (showAxis) {
        this.$(".dcg-x-arrows[dcg-arrows="+arrows+"]").toggleClass('dcg-active', true);
      }
    };

    view.renderYArrows = function () {
      var arrows = this.settings.yAxisArrows;
      var showAxis = this.settings.showYAxis;

      this.$(".dcg-y-axis-options .dcg-display-icon").attr('dcg-arrows', arrows);
      this.$(".dcg-y-arrows").toggleClass('dcg-active', false);

      if (showAxis) {
        this.$(".dcg-y-arrows[dcg-arrows="+arrows+"]").toggleClass('dcg-active', true);
      }
    };

    view.renderDegreeMode = function () {
      var degrees = this.settings.degreeMode;
      this.$(".dcg-action-radianmode").toggleClass('dcg-active', !degrees);
      this.$(".dcg-action-degreemode").toggleClass('dcg-active', !!degrees);
    };

    view.renderSquareAxes = function () {
      var square = this.settings.squareAxes;
      this.$(".dcg-action-zoomsquare")
          .toggleClass("dcg-disabled", !!square)
          .toggleClass("dcg-checked", !!square);
    };

    view.renderPolarNumbers = function () {
      var checked = this.settings.polarNumbers;
      var polarMode = this.settings.polarMode;
      var checkbox = this.$('.dcg-action-polarnumbers');

      checkbox.toggleClass('dcg-checked', checked);
      checkbox.toggle(polarMode); //only show the checkbox if we're in polarMode
    };

    view.renderXAxisNumbers = function () {
      var checked = this.settings.xAxisNumbers;
      var axisShown = this.settings.showXAxis;
      var checkbox = this.$('.dcg-action-xaxisnumbers');

      checkbox.toggleClass('dcg-checked', checked);
      checkbox.toggleClass('dcg-disabled', !axisShown);
    };

    view.renderYAxisNumbers = function () {
      var checked = this.settings.yAxisNumbers;
      var axisShown = this.settings.showYAxis;
      var checkbox = this.$('.dcg-action-yaxisnumbers');

      checkbox.toggleClass('dcg-checked', checked);
      checkbox.toggleClass('dcg-disabled', !axisShown);
    };

    view.renderXAxisLabel = function () {
      var input = this.$('.dcg-x-axis-label');
      var axisShown = this.settings.showXAxis;

      // prevent cursor from moving to end unexpectedly
      if (input.val() !== this.settings.xAxisLabel) {
        input.val(this.settings.xAxisLabel);
      }

      if (!axisShown) {
        input.attr('disabled','true');
      } else {
        input.removeAttr('disabled');
      }
    };
    view.renderYAxisLabel = function () {
      var input = this.$('.dcg-y-axis-label');
      var axisShown = this.settings.showYAxis;

      // prevent cursor from moving to end
      if (input.val() !== this.settings.yAxisLabel) {
        input.val(this.settings.yAxisLabel);
      }

      if (!axisShown) {
        input.attr('disabled','true');
      } else {
        input.removeAttr('disabled');
      }
    };

    view.renderXStep = function () {
      var userStep = this.settings.xAxisStep;
      var computedStep = this.settings.computedStepSizes && this.settings.computedStepSizes.majorStepX;
      var outOfBounds = !!(userStep && computedStep && userStep !== computedStep && userStep !== Math.PI);

      this.$editable.xstep.toggleClass('dcg-outofbounds', outOfBounds);
      this.$readonly.xstep.toggleClass('dcg-outofbounds', outOfBounds);
      this.updateMathquillInputs();
    };

    view.renderYStep = function () {
      var userStep = this.settings.yAxisStep;
      var computedStep = this.settings.computedStepSizes && this.settings.computedStepSizes.majorStepY;
      var outOfBounds = !!(userStep && computedStep && userStep !== computedStep && userStep !== Math.PI);

      this.$editable.ystep.toggleClass('dcg-outofbounds', outOfBounds);
      this.$readonly.ystep.toggleClass('dcg-outofbounds', outOfBounds);
      this.updateMathquillInputs();
    };

    view.renderPolarMode = function () {
      var showGrid = this.settings.showGrid;
      this.$('.dcg-action-cartesian').toggleClass('dcg-active', !this.settings.polarMode && showGrid);
      this.$('.dcg-action-polar').toggleClass('dcg-active', !!this.settings.polarMode && showGrid);

      // hide "steps" when in polar mode
      this.$('.dcg-step-container').toggle(!this.settings.polarMode);
    };

    // NOTE: because focusin happens before focusout, we temporarily have two
    // editable mathquills with .dcg-focus when switching between mathquills.
    view.isMathquillFocused = function () {
      return this.$('.mathquill-editable.dcg-focus').length > 0;
    };

    view.isXRangeFocused = function () {
      return this.$('.dcg-x-axis-options .dcg-editable-inputs .dcg-focus').length > 0;
    };

    view.isYRangeFocused = function () {
      return this.$('.dcg-y-axis-options .dcg-editable-inputs .dcg-focus').length > 0;
    };

    view.updateMathquillInputs = function () {
      if (this.focusedOutRecently) return;
      if (!this.$editable) return;

      function setLatexIfChanged ($mathquill) {
        var limit = $mathquill.data('dcg-limit');
        var latex = limits[limit];
        if ($mathquill.mathquill('latex') !== latex) {
          $mathquill.mathquill('latex', latex);
        }
      }

      var limits = {};
      var viewport = this.viewport;
      limits.xmin = formatLatex(viewport.xmin, viewport.xmax - viewport.xmin);
      limits.xmax = formatLatex(viewport.xmax, viewport.xmax - viewport.xmin);
      limits.ymin = formatLatex(viewport.ymin, viewport.ymax - viewport.ymin);
      limits.ymax = formatLatex(viewport.ymax, viewport.ymax - viewport.ymin);

      if (this.settings.xAxisStep) {
        limits.xstep = formatLatex(this.settings.xAxisStep, viewport.xmax - viewport.xmin);
      } else {
        limits.xstep = '';
      }

      if (this.settings.yAxisStep) {
        limits.ystep = formatLatex(this.settings.yAxisStep, viewport.ymax - viewport.ymin);
      } else {
        limits.ystep = '';
      }
      var unfocusedEditable = [];

      // only update x-mathquills if no x-mathquill is focused.
      // aids in range modification when passing through invalid
      // states.
      if (this.isXRangeFocused() === false) {
        unfocusedEditable.push(this.$editable.xmin);
        unfocusedEditable.push(this.$editable.xmax);
        unfocusedEditable.push(this.$editable.xstep);
      }

      // only update y-mathquills if no y-mathquill is focused.
      // aids in range modification when passing through invalid
      // states.
      if (this.isYRangeFocused() === false) {
        unfocusedEditable.push(this.$editable.ymin);
        unfocusedEditable.push(this.$editable.ymax);
        unfocusedEditable.push(this.$editable.ystep);
      }
      _.each(unfocusedEditable, setLatexIfChanged);

      var computedSteps = this.settings.computedStepSizes;
      if (limits.xstep === '' && computedSteps && computedSteps.majorStepX) {
        limits.xstep = formatLatex(computedSteps.majorStepX, viewport.xmax - viewport.xmin);
      }

      if (limits.ystep === '' && computedSteps && computedSteps.majorStepY) {
        limits.ystep = formatLatex(computedSteps.majorStepY, viewport.ymax - viewport.ymin);
      }

      _.each(this.$readonly, setLatexIfChanged);
    };

    view.setViewport = function (newViewport) {
      if (newViewport.equals(this.viewport)) return;
      if (!newViewport.isValid()) return;

      this.viewport = newViewport.clone();

      // set lastChangedAxis
      var oldViewport = this.grapher.viewportController.getViewport();
      if (oldViewport.ymax !== newViewport.ymax || oldViewport.ymin !== newViewport.ymin)
        this.settings.lastChangedAxis = 'y';
      if (oldViewport.xmax !== newViewport.xmax || oldViewport.xmin !== newViewport.xmin)
        this.settings.lastChangedAxis = 'x';

      this.updateMathquillInputs();
      this.grapher.viewportController.setViewport(newViewport);
    };

  });

  return SettingsView;
});

define('loadcss!css/pillboxes', function(){});
define('main/pillbox_view',['require','jquery','pjs','underscore_view','template!pillboxes','main/settings_view','conditional_blur','tipsy','loadcss!css/pillboxes'],function (require) {
  var $ = require('jquery');
  var P = require('pjs');
  var UnderscoreView = require('underscore_view');
  var template = require('template!pillboxes');
  var SettingsView = require('main/settings_view');
  var conditionalBlur = require('conditional_blur');

  require('tipsy');

  require('loadcss!css/pillboxes');

  var ZoomView = P(UnderscoreView, function (view, _super) {
    view.init = function (viewportController) {
      _super.init.call(this);
      this.template = template;
      this.viewportController = viewportController;

      this.settingsView = SettingsView(viewportController.grapher);
      this.settingsView.headerView = this;

      // an easing function for the options menu animation. It does a little bounce.
      $.easing.dcg_open_options = function (t, msSince, startValue, endValue, totalDuration) {
        //we need a 5th order equation to ensure that we go through 1,1, and are flat at 0,0 and 1,1
        //(with 1 degree of freedom left for delight)
        var tPer = msSince/totalDuration;
        var a = 0.6;
        var b = 4;
        var c = -2-3*a-2*b;
        var d = 1-a-b-c;
        var valPercent = a*Math.pow(tPer, 5)+b*Math.pow(tPer, 4) + c*Math.pow(tPer, 3) + d*tPer *tPer;

        if (tPer === 1) {
          valPercent = 1;
        }

        return valPercent;
      };
    };

    view.didCreateElement = function () {
      var self = this;

      view = this.settingsView;
      view.appendTo(this.$());

      this.settingsView.setupOpenButton(this.$('.dcg-action-settings'), 'tap');

      this.$('.dcg-action-zoomin').on('tap', this.zoomIn.bind(this));
      this.$('.dcg-action-zoomrestore').on('tap', this.zoomRestore.bind(this));
      this.$('.dcg-action-zoomout').on('tap', this.zoomOut.bind(this));
      this.$('.dcg-action-zoomsquare').on('tap', this.zoomSquare.bind(this));
      this.$('.dcg-action-moreoptions').on('tap', this.clickToggleOptions.bind(this));

      this.$().tipsy({
        fade: 'fast',
        title: 'tooltip',
        wait: 500,
        delegate: '.dcg-tooltip-e',
        gravity: 'e'
      });

      this.$more_options = this.$('.dcg-zoom-more-options');
      this.$more_options.on('tipsyshow tipsyhide', function (evt) {

        //don't open zoom btns on hover if the settings panel is open
        if (self.settingsView.isVisible) return;

        var hovered = self.$more_options.hasClass('dcg-hovered');
        if (self.animationInfo.isHovered !== hovered) {
          self.animationInfo.isHovered = hovered;
          self.hoverToggleOptions();
        }
      });

      this.viewportController.grapher.settings.observe('squareAxes', this.renderSquareAxes.bind(this));
      this.viewportController.grapher.settings.observe('zoomedDefault', this.renderZoomDefault.bind(this));
    };

    //each of the dropdowns (share_options, graph_settings, help)
    //queries this to find out how tall it should (max)
    //
    // graphpaperHeight is set externally by layout system
    view.popoverHeight = function() {
      return this.graphpaperHeight - 12; //10 px padding on top and 2px on the bottom
    };

    view.computeAnimationSize = function () {
      if (this.animationInfo.openHeight) return;

      var dropDownWidth = this.$more_options.find('.dcg-zoom-options-menu').outerWidth();
      var titleWidth = this.$more_options.find('.dcg-title').outerWidth();

      this.animationInfo.openWidth = Math.max(dropDownWidth, titleWidth);
      this.animationInfo.openHeight =this.$more_options.find('.dcg-zoom-options-menu').outerHeight();
      this.$().addClass('dcg-size-loaded');
    };

    view.didInsertElement = function () {
      this.animationInfo = {
        closedWidth: this.$more_options.outerWidth(),
        closedHeight: this.$more_options.outerHeight(),

        durationX: 200,
        durationY: 400,
        isOpen: false,
        isAnimating: false,

        wasClickedOpen: false,
        isHovered: false
      };

      this.renderSquareAxes();
      this.renderZoomDefault();
      this.computeAnimationSize();
    };

    view.renderSquareAxes = function () {
      var squareAxes = this.viewportController.grapher.settings.squareAxes;
      this.$('.dcg-zoom-options-menu .dcg-action-zoomsquare').toggleClass('dcg-disabled', squareAxes);
    };

    view.renderZoomDefault = function () {
      var isDefault = this.viewportController.grapher.settings.zoomedDefault;
      this.$('.dcg-action-zoomrestore').toggleClass('dcg-disabled', isDefault);
    };

    view.zoomIn = function() {
      this.viewportController.zoom("in");
    };

    view.zoomRestore = function() {
      this.viewportController.zoom("default");
    };

    view.zoomOut = function() {
      this.viewportController.zoom("out");
    };

    view.zoomSquare = function() {
      this.viewportController.grapher.settings.setProperty('squareAxes', true);
    };


    view.cancelAnimation = function () {
      this.$more_options.stop(true, false);
      this.isAnimating = false;

      $(document).off('tapstart.' + this.guid);
    };

    view.hoverToggleOptions = function () {
      if (this.animationInfo.wasClickedOpen) return;
      if (this.animationInfo.isHovered === this.animationInfo.isOpen) return;

      // stop the queued animations
      this.cancelAnimation();

      if (!this.animationInfo.isOpen) {
        this.openOptions();
      } else {
        this.closeOptions();
      }
    };

    view.clickToggleOptions = function () {
      //for touch devices
      conditionalBlur();

      // we've clicked the icon shortly after hovering and opening it. Act like we clicked it to open it.
      if (this.animationInfo.isOpen && this.animationInfo.isAnimating && !this.animationInfo.wasClickedOpen) {
        this.animationInfo.wasClickedOpen = true;
        return;
      }

      if (this.animationInfo.isAnimating) return;

      if (!this.animationInfo.isOpen) {
        this.animationInfo.wasClickedOpen = true;
        this.openOptions();
      } else if (this.animationInfo) {
        this.closeOptions();
      }
    };

    view.openOptions = function () {
      this.cancelAnimation();

      var $options = this.$more_options;
      var animationInfo = this.animationInfo;
      animationInfo.isOpen = true;
      animationInfo.isAnimating = true;

      var self = this;
      $(document).on('tapstart.' + this.guid, function (evt) {
        if ($options.find(evt.target).length === 0) {
          self.closeOptions();
        }
      });

      //no op if we've already computed
      //try again, in case the element wasn't visible when we measured before
      this.computeAnimationSize();

      $options.animate({width: animationInfo.openWidth}, animationInfo.durationX, function () {
        $options.addClass('dcg-full-width');
        $options.animate({height: animationInfo.openHeight}, animationInfo.durationY, 'dcg_open_options', function () {
          animationInfo.isAnimating = false;
        });
      });
    };

    view.closeOptions = function () {
      this.cancelAnimation();

      var $options = this.$more_options;
      var animationInfo = this.animationInfo;
      animationInfo.isOpen = false;
      animationInfo.isAnimating = true;

      $options.animate({height: animationInfo.closedHeight}, animationInfo.durationY / 2, function () {
        $options.removeClass('dcg-full-width');

        $options.animate({width: animationInfo.closedWidth}, animationInfo.durationX / 2, function () {
          animationInfo.isAnimating = false;
          animationInfo.wasClickedOpen = false;
        });
      });
    };

  });

  return ZoomView;
});


define('main/layout_controller',['require','console','pjs','jquery'],function(require){
  var console = require('console');
  var P = require('pjs');
  var $ = require('jquery');

  return P(function (proto) {

    proto.init = function (views, $root, graphSettings) {
      this.views = views;
      this.$root = $root;
      // stores the current screen size at all times
      this.currentScreen = {};

      this.isAnimating = false;
      this.minExpressionWidth = 290;

      this.$grapher = this.views.grapher.$;
      this.graphSettings = graphSettings;

      this.monitorWindowSize();
      // We call the monitorWindowSize() function every 200ms because the
      // window::onResize event just isn't reliable enough. In some browsers
      // (e.g. mobile safari) the event randomly gets dropped.
      if (graphSettings.config.resizeLoop) {
        var resizeLoop = function() {
          this.monitorWindowSize();
          setTimeout(resizeLoop, 200);
        }.bind(this);
        resizeLoop();
      }

      // We call the monitorWindowSize() function on window resize
      // this is triggered even for embedded calculator instances
      // it's a no-op if size hasn't changed
      $(window).resize(this.monitorWindowSize.bind(this));

      if (this.views.expressionsView) {
        this.views.expressionsView.observe('expressionsVisible', function () {
          if (this.views.expressionsView.expressionsVisible) {
            this.$root.removeClass('dcg-fullscreen');
          } else {
            this.$root.addClass('dcg-fullscreen');
          }
          this.resize();
        }.bind(this));
      }

      if (this.views.keypadView) this.views.keypadView.observe('isOpen', this.resize.bind(this));
    };

    proto.resize = function () {
      /* jshint maxcomplexity:12 */
      if (this.views.keypadView) {
        this.$root.toggleClass('dcg-keypad-open', !!this.views.keypadView.isOpen);
      }

      //isAnimating is set by animateSlidingInterior
      //when we either show or hide the expressions list
      if (this.isAnimating) return;

      var h = this.$grapher.height();
      var w = this.$root.width();
      var isFullscreen = (!this.views.expressionsView || !this.views.expressionsView.expressionsVisible);

      this.$root.toggleClass('dcg-narrow', this.isNarrow(w));
      this.$root.toggleClass('dcg-wide', this.isWide(w));
      this.$root.toggleClass('dcg-short', this.isShort(h));

      if (this.views.keypadView && this.views.keypadView.height) {
        var keypad_height = this.views.keypadView.height();
        this.views.expressionsView.setBottom(keypad_height);

        if (this.views.pillboxView && this.views.pillboxView.settingsView) {
          this.views.pillboxView.settingsView.setBottom(keypad_height);
        }
      }

      if (this.views.expressionsView) this.views.expressionsView.setProperty('calcIsNarrow', this.isNarrow(w));

      var newWidth = this.isNarrow(w) ? w : w < 356/0.45 ? Math.floor(0.45 * w) : 356;
      if (newWidth < this.minExpressionWidth) newWidth = this.minExpressionWidth;
      //since our open/close animations use the half-width and we don't want odd numbers
      if (!this.isNarrow(w)) newWidth = 2*Math.floor(0.5*newWidth);

      if (this.views.expressionsView) this.views.expressionsView.setMinWidth(newWidth);

      if (this.views.pillboxView) this.views.pillboxView.setProperty('graphpaperHeight', h);
      if (this.views.keypadView) this.views.keypadView.setProperty('graphpaperHeight', h);

      //on narrow screens, ignore offset
      var leftOffset = (this.isNarrow(w) || isFullscreen) ? 0 : newWidth;

      this.views.grapher.$.css({
        'left': leftOffset+'px',
        //get rid of any transform, in case this was called after doing an animation
        'transform': null
      });

      this.views.grapher.updateScreenSize(w - leftOffset, h);

      //make sure that active expression is scrolled into view
      if (this.views.expressionsView) this.views.expressionsView.ensureActiveChildIsVisible();
    };

    proto.animationIsRunning = function () {
      return this.runningAnimations !== 0;
    };

    proto.isNarrow = function (width) {
      return width < 450;
    };

    proto.isWide = function (width) {
      return width >= 900;
    };

    proto.isShort = function (height) {
      return height <= 480; //small iphone in portrait
    };

    proto.animateSlidingInterior = function () {
      if (this.isAnimating) return;
      this.isAnimating = true;

      setTimeout(function () {
        this.isAnimating = false;
        this.resize();
      }.bind(this), this.parseTransitionDuration('.dcg-sliding-interior'));
    };

    proto.parseTransitionDuration = function (target) {
      var $target = $(target);
      var durationString = $target.css('transition-duration');
      if (durationString[durationString.length - 1] !== 's') {
        console.warn(
          'Unexpected transition-duration format. ' +
          'Expected a number followed by \'s\' but saw ' + durationString
        );
        return 0;
      }

      return 1000*parseFloat(durationString.slice(0, -1));
    };

    proto.defocusMobile = function () {
      var focused = $(document.activeElement);
      // Only want to do this when we have to, since it can cause some bouncing.
      if (focused.filter('input, textarea').length === 0) return;
      // hack to get jquery to remove focus from hidden input.
      // the following steps work for all tested mobile devices.
      //
      // step 1) add an input textbox to body and focus it.
      // step 2) make that textbox disabled and readonly.
      // step 3) blur the textbox and remove from the dom.
      $('<input />').prependTo('body').focus()
      .attr({
        readonly: 'readonly',
        disabled: 'true'
      })
      .blur().remove();
    };

    proto.monitorWindowSize = function () {
      // check if anything actually updated
      var w = this.$root.width() + this.$root.scrollLeft();
      var h = this.$root.height() + this.$root.scrollTop();

      if (w === this.currentScreen.width && h === this.currentScreen.height) return;

      this.currentScreen.width = w;
      this.currentScreen.height = h;

      this.resize();
    };
  });
});

// Defines a simple API used by our screenshot service.
define('lib/external_screenshot',['require','pjs'],function (require) {
  var P = require('pjs');

  var Screenshot = P(function (proto) {
    proto.init = function ($root, expressionsView, grapher, evaluator, stateController) {
      this.$root = $root;
      this.expressionsView = expressionsView;
      this.grapher = grapher;
      this.evaluator = evaluator;
      this.stateController = stateController;
    };

    proto.initialize = function (options, cb) {
      this.$root.addClass('dcg-external-screenshot');
      // Allow expression list to overflow for screenshoting.
      document.styleSheets[0].insertRule(
        '* {overflow: visible !important;}',
        document.styleSheets[0].cssRules.length
      );
      cb();
    };

    function getClipRect (elt) {
      var clientRect = elt.getBoundingClientRect();
      return {
        top: clientRect.top,
        left: clientRect.left,
        width: clientRect.width,
        height: clientRect.height
      };
    }

    function waitFor (pred, cb) {
      if (pred) {
        setTimeout(cb);
      } else {
        setTimeout(function () {
          waitFor(pred, cb);
        }, 100);
      }
    }

    proto.load = function (obj, cb) {
      this.stateController.setState(obj.state);

      var self = this;
      this.evaluator.notifyWhenSynced(function () {
        waitFor(function () {
          return !self.expressionsView || self.expressionsView.$('.dcg-shell.dcg-expressionitem').length === 0;
        }, function () {
          // TODO, after jumping through all these hoops, still need an arbitrary timeout to wait
          // for the expression icons to load. Ugh.
          setTimeout(function () {
            var boxes = {};
            boxes.graphpaper = getClipRect(self.grapher.$[0]);
            if (self.expressionsView) {
              boxes.expressions = getClipRect(self.expressionsView.$('.dcg-expressionlist')[0]);
            }
            cb({boxes: boxes});
          }, 100);
        });
      });
    };
  });

  return Screenshot;
});

/*
 *  Modified (heavily) by Eli for the following reasons:
 *    - keep Trip out of the global namespace
 *    - work with our click events
 *    - pass jshint
 *    - get rid of unused methods
 *    - get rid of the other methods too
 *
 *  Trip.js - A jQuery plugin that can help you customize your tutorial trip easily
 *  Version : 1.2.2
 *
 *  Author : EragonJ <eragonj@eragonj.me>
 *  Blog : http://eragonj.me
 */

 define('trip',['require','jquery','pjs'],function (require) {
    var $ = require('jquery');
    var P = require('pjs');

    var Trip = P({

        init : function(settings) {
                this.settings = settings;
                this.__cachedStepName = null;
        },

        ensureTripBlock : function () {
            if (this.$tripBlock) return;

            var html = [
                '<div class="trip-block">',
                    '<div class="trip-interior">',
                        '<a class="trip-close">&times;</a>',
                        '<div class="trip-content"></div>',
                    '</div>',
                    '<div class="trip-arrow"></div>',
                '</div>'
            ].join('');

            var that = this;
            var $tripBlock = this.$tripBlock = $(html);

            $tripBlock.css({top: '-100px'});

            $('body').append( $tripBlock );

            $tripBlock.find('.trip-close').on("tap", function(e) {
                e.preventDefault();
                that.stop();
            });

            this.bindKeyEvents();
        },

        cleanup : function() {
            this.unbindKeyEvents();

            this.hideTripBlock();
            return false;
        },

        bindKeyEvents : function() {
            var that = this;
            $(document).on({
                'keydown.Trip' : function(e) {
                    // `this` will be bound to #document DOM element here
                    that.keyEvent.call(that, e);
                }
            });
        },

        unbindKeyEvents : function() {
            $(document).off('keydown.Trip');
        },

        keyEvent : function(e) {
            if ( e.which === 27 ) this.stop();  //ESC key
        },

        stop : function() {
            this.hideTripBlock();
            this.settings.onTripStop();
            this.__cachedStepName = null;
        },

        showTripBlock : function( o ) {
            this.ensureTripBlock();

            //soft update will, in general, change neither the contents nor the position
            //the contents can be force updated by setting o.forceTextUpdate=true
            var softUpdate = (o.stepName && o.stepName === this.__cachedStepName);
            this.__cachedStepName = o.stepName;

            if(typeof o.sel === 'string') {
                o.sel = $(o.sel);
            }
            o.sel = o.sel.filter(':visible');

            var $tripBlock = this.$tripBlock;

            if (!softUpdate || o.forceTextUpdate) {
                $tripBlock.find('.trip-content')
                          .html( o.content );
                var $math = $tripBlock.find('.trip-math:not(.mathquill-rendered-math)');
                if ($math.mathquill) {
                    $math.mathquill();
                }
            }

            //get out of here before repositioning
            if (softUpdate) return;

            $tripBlock.toggleClass('trip-hidden', !!o.hidden);

            var $sel = o.sel,
                selWidth = $sel.outerWidth(),
                selHeight = $sel.outerHeight(),
                blockWidth = $tripBlock.outerWidth(),
                blockHeight = $tripBlock.outerHeight(),
                arrowHeight = 10,
                arrowWidth = 10;

            // Take off e/s/w/n classes
            $tripBlock.removeClass('trip-e trip-s trip-w trip-n');

            var horizontalShift = 0;

            switch( o.position ) {
            case 'e':
                $tripBlock.addClass('trip-e');
                $tripBlock.css({
                    left : $sel.offset().left + selWidth + arrowWidth,
                    top : $sel.offset().top - (( blockHeight - selHeight ) / 2)
                });
                break;
            case 's':
                $tripBlock.addClass('trip-s');
                var left = $sel.offset().left + ((selWidth - blockWidth) / 2);
                $tripBlock.css({
                    left : left,
                    top : $sel.offset().top + selHeight + arrowHeight
                });

                if (left + blockWidth > $(window).width() - 1) {
                    horizontalShift = $(window).width() - 1 - left - blockWidth;
                }
                if (left < 1) {
                    horizontalShift = 1 - left;
                }

                break;
            case 'w':
                $tripBlock.addClass('trip-w');
                $tripBlock.css({
                    left : $sel.offset().left - (arrowWidth + blockWidth),
                    top : $sel.offset().top - (( blockHeight - selHeight ) / 2)
                });
                break;
            default:
                $tripBlock.addClass('trip-n');
                $tripBlock.css({
                    left : $sel.offset().left + ((selWidth - blockWidth) / 2),
                    top : $sel.offset().top - arrowHeight - blockHeight
                });

                break;
            }

            $tripBlock.find('.trip-interior')
                .css('transform', 'translate(' + horizontalShift + 'px, 0)');

            $tripBlock.css({
                display : 'inline-block'
            });
        },

        fadeInTripBlock : function () {
            this.ensureTripBlock();

            var $tripBlock = this.$tripBlock;
            //need this on the next cycle so that the animation works
            setTimeout(function () {
                $tripBlock.addClass('trip-is-loaded');
            }, 0);
        },

        hideTripBlock : function() {
            if (this.$tripBlock) this.$tripBlock.removeClass('trip-is-loaded');
        },
    });
    return Trip;
});

define('template!toast', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div class="dcg-toast-container">\n  <span class="dcg-toast">\n    <i class="dcg-icon-error"></i>\n    <i class="dcg-icon-remove dcg-action-hide"></i>\n    <span class="dcg-msg dcg-variable-msg"></span>\n    <a class="dcg-undo dcg-action-toast-undo">'+
( t('Undo') )+
'</a>\n    <a class="dcg-learn-more-link" target="_blank">'+
( t('Learn more') )+
'</a>\n  </span>\n</div>';
}
return __p;
};});
define('loadcss!css/toast', function(){});
//generates a toast (little message near the top of the page)
// lets you do things like switch back into edit-list mode
define('main/toast',['require','pjs','underscore_view','template!toast','loadcss!css/toast'],function (require) {

  var P = require('pjs');
  var UnderscoreView = require('underscore_view');
  var template = require('template!toast');
  require('loadcss!css/toast');

  var ToastView = P(UnderscoreView, function (toast, _super) {
    toast.template = template;

    toast.init = function (undoRedo) {
      _super.init.call(this);
      this.undoRedo = undoRedo;
    };

    toast.didCreateElement = function () {
      var self = this;

      // hide toast when UndoRedo
      self.undoRedo.changesCallbacks.push(function () {
        self.hide();
      });

      this.$('.dcg-action-toast-undo').on('tap', function () {
        self.undoRedo.undo();

        if (self.undoCallback) {
          self.undoCallback();
        }
        self.hide();
      });

      this.$('.dcg-action-hide').on('tap', this.hide.bind(this));
      // start off hidden
      this.$().toggle(false);
    };

    // str: string in the toast message
    // options:
    //   undoCallback: a function that gets called if the "undo" button is pressed.
    //      Note: "undo" is only shown if this is present
    //   hideAfter: integer # of ms (never hide if set to 0)
    //   style: class that we'll add (error is the only option so far)
    //   learnMoreLink: a link that we'll show with the "learn more" text
    toast.show = function (str, options) {
      options = options || {};

      clearTimeout(this.hideTimeout);
      this.$('.dcg-toast-container').fadeOut('fast');
      this.$('.dcg-toast').toggleClass('dcg-show-undo', options.hasOwnProperty('undoCallback'));
      //note: because of how jquery works, this'll strip off the style attr if options.style is undefined
      this.$('.dcg-toast').attr('style', options.style || null);

      if (options.hasOwnProperty('learnMoreLink')) {
        this.$('.dcg-learn-more-link').attr('href', options.learnMoreLink).show();
      } else {
        this.$('.dcg-learn-more-link').hide();
      }

      this.$().fadeIn('fast');

      this.$('.dcg-variable-msg').text(str);
      this.undoCallback = options.undoCallback;

      // hide after (default) 6 seconds
      var hideAfter = (options.hasOwnProperty('hideAfter') ? options.hideAfter : 6000);

      if (hideAfter > 0) {
        var self = this;
        this.hideTimeout = setTimeout(function () {
          self.hide();
        }, hideAfter);
      }
    };

    toast.hide = function () {
      clearTimeout(this.hideTimeout);
      this.$().fadeOut('fast');
    };
  });

  return ToastView;
});

define('undoredo',['require','underscore','pjs'],function (require) {
  var _ = require('underscore');
  var P = require('pjs');

var UndoRedoManager = P(function (manager, _super) {

  manager.CAUSE_OF_CHANGE = 1;
  manager.RESPONSE_TO_CHANGE = 2;

  manager.triggerFlash = function () {};

  manager.init = function () {
    this.undos = [];
    this.redos = [];
    this.changesCallbacks = [];
    this.__isApplyingTransaction = 0;
    this.batchedWrapper = function (cb) {cb()};
  };

  manager.clear = function () {
    this.undos = [];
    this.redos = [];
  };

  manager.pushUndo = function (transaction) {
    this.undos.push(transaction);
    this.triggerChanges();
  };

  manager.pushRedo = function (transaction) {
    this.redos.push(transaction);
    this.triggerChanges();
  };

  manager.canUndo = function () {
    return this.undos.length > 0;
  };

  manager.canRedo = function () {
    return this.redos.length > 0;
  };

  manager.undo = function () {
    if (!this.canUndo()) return;

    var action = this.undos.pop();
    this.applyTransaction(action,true);
    this.pushRedo(action);
  };

  manager.redo = function () {
    if (!this.canRedo()) return;

    var action = this.redos.pop();
    this.applyTransaction(action);
    this.pushUndo(action);
  };

  manager.isApplyingTransaction = function () {
    return !!this.__isApplyingTransaction;
  };

  manager.__applyTransaction = function (transaction, doUndo) {
    var i;
    var batched = transaction.__batched__ ? transaction.__batched__ : [];
    var self = this;

    if (doUndo) {

      if (batched.length) {
        this.batchedWrapper(function () {
          // apply batched transactions in reverse
          for (i=batched.length-1; i>=0; i--) {
            self.__applyTransaction(batched[i], doUndo);
          }

          transaction.undo();
        });
      } else {
        transaction.undo();
      }
    }

    // apply transactions the way they happened the first time
    else {
      if( batched.length) {
        this.batchedWrapper(function () {
          transaction.redo();
          for (i=0; i<batched.length; i++) {
            self.__applyTransaction(batched[i], doUndo);
          }
        });
      } else {
        transaction.redo();
      }
    }
  };

  manager.applyTransaction = function (transaction, doUndo) {
    this.__isApplyingTransaction++;

    try {
      this.__applyTransaction(transaction, doUndo);
    } finally {
      this.__isApplyingTransaction--;
    }
  };

  // sometimes, we want to just do multiple things, and we want them to all
  // be grouped into a single transaction. We want to just do stuff, and all
  // that stuff gets grouped together. It's important to note that oneTransaction
  // requires that all side effects happen synchronously.
  manager.oneTransaction = function (func) {
    if (!this.__oneTransactionDepth) {
      this.__oneTransactionDepth=0;
    }

    this.__oneTransactionDepth++;
    this.batchedWrapper(func);
    this.__oneTransactionDepth--;

    if (!this.__oneTransactionDepth) {
      this.__oneTransaction = null;
    }
  };

  manager.isApplyingOneTransaction = function () {
    return this.__oneTransactionDepth > 0;
  };

  manager.addTransaction = function (transaction) {
    var batched;

    //don't accept changes that are sideffects of applying a transaction.
    //the transaction should've been written in such a way that chained
    //reactions are accounted for.
    if (this.isApplyingTransaction()) {

      // TODO - this exception looks pretty nasty and I'm worried that it's going
      // to change behavior in other places. I don't know why I originally didn't
      // allow addTransaction()'s within other addTransaction()'s. One thought
      // is that doing the first transaction automatically calls the other, so
      // the child transactions would end up getting called multiple times.
      //
      // we do play out the action if it's a CAUSE_OF_CHANGE. We just don't
      // add it to undo/redo.
      if (transaction.type === this.CAUSE_OF_CHANGE) {
        transaction.redo();
      }

      return;
    }

    //automatically apply this if it's what's going to cause the initial
    //change.
    if (transaction.type === this.CAUSE_OF_CHANGE)
      this.applyTransaction(transaction);

    //if nothing really changed, then stop.
    if (transaction.ensureChangeOccured && transaction.ensureChangeOccured())
      return;

    // was this.redos.clear() in the Dark days. this.redos = [] would be
    // simpler, but has different semantics if someone else has a handle to
    // this array.
    this.redos.splice(0);

    if (this.isApplyingOneTransaction()) {
      if (!this.__oneTransaction) {
        this.__oneTransaction = transaction;
      } else {
        batched = this.__oneTransaction.__batched__;
        if (!batched) batched = this.__oneTransaction.__batched__ = [];
        batched.push(transaction);
        return;
      }
    }

    this.pushUndo(transaction);
  };

  manager.triggerChanges = function () {
    _.each(this.changesCallbacks, function (cb) { cb() });
  };

});


return UndoRedoManager;
});

/*
 * The ipad has some quirky scrolling behavior. This module fixes them.
 * NOTE: this module is only for vertical scrolling. Horizontal page scroll
 *       can be turned off by an html setting. If we want, we can enable
 *       this module to monitor horizontal scrolling as well.
 *
 * On the ipad you can scroll an entire page by:
 *     a) Sliding your finger on a non scrollable object.
 *     b) Sliding your finger on a scrollable object in a direction
 *        that the scrollable object is already maxed out.
 *
 * You can preventDefault() the 'touchMove' event and that will prevent
 *  the ipad from scrolling the entire page. The only problem is that this
 *  also prevents any scrollable area from scrolling.
 *
 * The solution is to monitor the 'touchStart' event to predict what will
 *  happen when the user moves their finger. It predicts both movements up
 *  and down. If it predicts that the entire page will be scrolled, it
 *  makes that movement as invalid. If it predicts that a scrollable area
 *  will be scrolled, it makes the movement as valid.
 *
 * On 'touchMove', this module looks up the prediction for the direction the
 *  user moved. If the movement was valid, it lets the movement continue on
 *  and scroll the scrollable area. If the movement was invalid, it does a
 *  preventDefault() on the 'touchMove' event to prevent the entire page from
 *  scrolling.
 *
 * Also important to know is that once you grab a scrollable area and start
 *  scrolling, you're safe. The page won't scroll even if you max the
 *  scrollable area out and keep dragging in that direction.
 *
 * The prediction routine runs up the ancestors of the evt.target and finds
 * the first that:
 *
 *  1) has overflow and overflow-y properties that allow scrolling
 *                 AND
 *    2) has scrollTop != 0 (can be scrolled downward)
 *                          AND/OR
 *    3) has scrollTop that can be incremented (can be scrolled upward)
 */

// TODO - it seems very likely that someone will want to limit scrolling on multiple elements within the page.
// I haven't wrapped my brain aroudn that situation fully, but it seems likely that we'll want to namespace
// the '.scrollfix' events independently per element. Maybe we don't want to try to handle the case where mutliple
// touches are down on multiple elements. Maybe this still works when that happens. But, it isn't obvious to me that
// things will work since we're turning off all events with the '.scrollfix' namespace when a touchend event happens.
define('ipad.scrollfix',['require','jquery'],function (require) {
  /* jshint bitwise: false */

  var $ = require('jquery');

  //some constants
  var NONE = 0;
  var UP = 1;
  var DOWN = 2;

  var limitingScrollOnDocument = false;
  var limitScrollOnDocument = function () {
    limitScrollOnElement(document);
    limitingScrollOnDocument = true;
  };

  //pass in a valid jQuery selector or element
  //this will limit scrolling that occurs inside of that element
  //preventing, for example, full page scrolling
  var limitScrollOnElement = function(el) {

    // if the entire page is being limited, don't apply
    // scrollfix behavior on this element. We aren't sure
    // how multiple listeners within the same dom area
    // will behave.
    //
    // NOTE: This early return requires that
    // the entire document be scrollfixed before any
    // specific elements are.
    if (limitingScrollOnDocument) return;

    //decides which directions an element can be scrolled
    $(el).bind('touchstart', function(evt) {
      /* jshint maxcomplexity:11 */
      var dom = $(evt.target);
      var validMoveDirections = NONE;
      var startTouches = null;

      // some elements (like the slider) can disable scrolling on tapStart.
      // if we're not automatically prevented from scrolling, then let's iterate
      // up the dom to find if we're inside an element that can be scrolled. If so,
      // we'll mark the scroll directions as valid.
      if (!dom.closest('[disablescroll]').length) {
        while (validMoveDirections === NONE && dom.length) {

          //mobile safari throws error if you try to do normal
          //.css() on the top most element
          if (dom[0].tagName === undefined) {
            break;
          }

          var overflow = dom.css('overflow');
          var overflow_y = dom.css('overflow-y');

          //check if overflow allows it to be scrolled
          if (overflow !== "hidden" && overflow !== "visible" &&
              overflow_y !== "hidden" && overflow_y !== "hidden" ) {

            //can be scrolled downward if it isn't scrolled to the very top
            var scrollTop = dom.scrollTop();
            if (scrollTop !== 0) {
              validMoveDirections = DOWN;
            }

            //can be scrolled upward if we try to scroll it upward and
            //it succeeds
            dom.scrollTop(scrollTop+1);
            if (dom.scrollTop() !== scrollTop) {

              //mark up as a valid scroll
              validMoveDirections = UP | validMoveDirections;

              //move it back to where it was
              dom.scrollTop(scrollTop);
            }
          }

          dom = dom.parent();
        }
      }

      //if any scroll is valid, lets save the original touchStart event
      //so that we can compare it with the touchMove event later to decide
      //which direction the user scrolled.
      if (validMoveDirections !== NONE) {
        startTouches = [];

        //We must clone the original touchStart event instead of simply
        //saving a reference to it. For some reason, the original touchStart
        //event updates it's pageY, screenY, etc properties as you scroll.
        //That means that touchStart.screenY will always equal the
        //touchMove.screenY event when you compare them.
        var origTouches = evt.originalEvent.touches;
        for (var i=0; i<origTouches.length; i++) {
          var clonedTouch = {};
          for (var j in origTouches[i] ) {
            if (origTouches[i].hasOwnProperty(j)) {
              clonedTouch[j] = origTouches[i][j];
            }
          }
          startTouches.push( clonedTouch );
        }
      }

      //decides if the the movement is in a valid direction.
      $(document).on('touchmove.scrollfix', function(evt) {

        //makes sure this is the first touchmove after touchstart
        if (startTouches) {

          //get positions of the touch and move events
          var startTouch = startTouches[0];
          var moveTouch = evt.originalEvent.touches[0];

          //find the direction we moved our finger
          //var deltaX = moveTouch.screenX - startTouch.screenX;
          var deltaY = moveTouch.screenY - startTouch.screenY;

          //check if any of the movements weren't allowed
          //and if not, say that NO move is allowed. Will
          //get caught later at bottom of the function.
          if (deltaY > 0 && !(validMoveDirections & DOWN)) {
            validMoveDirections = NONE;
          } else if (deltaY < 0 && !(validMoveDirections & UP)) {
            validMoveDirections = NONE;
          }

          //first touchmove has been processed
          if (deltaY) {
            startTouches = null;
          }
        }

        //don't scroll the entire screen
        if (validMoveDirections === NONE) {
          evt.preventDefault();
        }
      });

      //resets the state
      $(document).on('touchend.scrollfix', function() {
        $(document).off('.scrollfix');
      });
    });

  };

  return {
    limitScrollOnElement: limitScrollOnElement,
    limitScrollOnDocument: limitScrollOnDocument
  };

});


/*
  Papa Parse
  v3.1.2
  https://github.com/mholt/PapaParse

  modified by @eluberoff to make it a valid require module, and remove all worker references
*/


define('vendor/papaparse',['require','jquery'],function(require){


  var $ = require('jquery');

  // A configuration object from which to draw default settings
  var DEFAULTS = {
    delimiter: "",  // empty: auto-detect
    header: false,
    dynamicTyping: false,
    preview: 0,
    step: undefined,
    encoding: "", // browser should default to "UTF-8"
    comments: false,
    complete: undefined,
    error: undefined,
    download: false,
    chunk: undefined,
    keepEmptyRows: false
  };

  var Papa = {};

  Papa.parse = CsvToJson;
  Papa.unparse = JsonToCsv;

  Papa.RECORD_SEP = String.fromCharCode(30);
  Papa.UNIT_SEP = String.fromCharCode(31);
  Papa.BYTE_ORDER_MARK = "\ufeff";
  Papa.BAD_DELIMITERS = ["\r", "\n", "\"", Papa.BYTE_ORDER_MARK];

  // Configurable chunk sizes for local and remote files, respectively
  Papa.LocalChunkSize = 1024 * 1024 * 10;  // 10 MB
  Papa.RemoteChunkSize = 1024 * 1024 * 5;  // 5 MB
  Papa.DefaultDelimiter = ",";       // Used if not specified and detection fails

  // Exposed for testing and development only
  Papa.Parser = Parser;
  Papa.ParserHandle = ParserHandle;
  Papa.NetworkStreamer = NetworkStreamer;
  Papa.FileStreamer = FileStreamer;

  if (true)
  {
    $.fn.parse = function(options)
    {
      var config = options.config || {};
      var queue = [];

      this.each(function(idx)
      {
        var supported = $(this).prop('tagName').toUpperCase() == "INPUT"
                && $(this).attr('type').toLowerCase() == "file"
                && window.FileReader;

        if (!supported || !this.files || this.files.length == 0)
          return true;  // continue to next input element

        for (var i = 0; i < this.files.length; i++)
        {
          queue.push({
            file: this.files[i],
            inputElem: this,
            instanceConfig: $.extend({}, config)
          });
        }
      });

      parseNextFile();  // begin parsing
      return this;    // maintains chainability


      function parseNextFile()
      {
        if (queue.length == 0)
          return;

        var f = queue[0];

        if (isFunction(options.before))
        {
          var returned = options.before(f.file, f.inputElem);

          if (typeof returned === 'object')
          {
            if (returned.action == "abort")
            {
              error("AbortError", f.file, f.inputElem, returned.reason);
              return; // Aborts all queued files immediately
            }
            else if (returned.action == "skip")
            {
              fileComplete(); // parse the next file in the queue, if any
              return;
            }
            else if (typeof returned.config === 'object')
              f.instanceConfig = $.extend(f.instanceConfig, returned.config);
          }
          else if (returned == "skip")
          {
            fileComplete(); // parse the next file in the queue, if any
            return;
          }
        }

        // Wrap up the user's complete callback, if any, so that ours also gets executed
        var userCompleteFunc = f.instanceConfig.complete;
        f.instanceConfig.complete = function(results)
        {
          if (isFunction(userCompleteFunc))
            userCompleteFunc(results, f.file, f.inputElem);
          fileComplete();
        };

        Papa.parse(f.file, f.instanceConfig);
      }

      function error(name, file, elem, reason)
      {
        if (isFunction(options.error))
          options.error({name: name}, file, elem, reason);
      }

      function fileComplete()
      {
        queue.splice(0, 1);
        parseNextFile();
      }
    }
  }


  function CsvToJson(_input, _config)
  {
    var config = copyAndValidateConfig(_config);

    if (typeof _input === 'string')
    {
      if (config.download)
      {
        var streamer = new NetworkStreamer(config);
        streamer.stream(_input);
      }
      else
      {
        var ph = new ParserHandle(config);
        var results = ph.parse(_input);
        return results;
      }
    }
    else if (_input instanceof File)
    {
      if (config.step || config.chunk)
      {
        var streamer = new FileStreamer(config);
        streamer.stream(_input);
      }
      else
      {
        var ph = new ParserHandle(config);

        reader = new FileReader();
        reader.onload = function(event)
        {
          var ph = new ParserHandle(config);
          var results = ph.parse(event.target.result);
        };
        reader.onerror = function()
        {
          if (isFunction(config.error))
            config.error(reader.error, _input);
        };
        reader.readAsText(_input, config.encoding);
      }
    }
  }

  function JsonToCsv(_input, _config)
  {
    var _output = "";
    var _fields = [];

    // Default configuration
    var _quotes = false;  // whether to surround every datum with quotes
    var _delimiter = ","; // delimiting character
    var _newline = "\r\n";  // newline character(s)

    unpackConfig();

    if (typeof _input === 'string')
      _input = JSON.parse(_input);

    if (_input instanceof Array)
    {
      if (!_input.length || _input[0] instanceof Array)
        return serialize(null, _input);
      else if (typeof _input[0] === 'object')
        return serialize(objectKeys(_input[0]), _input);
    }
    else if (typeof _input === 'object')
    {
      if (typeof _input.data === 'string')
        _input.data = JSON.parse(_input.data);

      if (_input.data instanceof Array)
      {
        if (!_input.fields)
          _input.fields = _input.data[0] instanceof Array
                  ? _input.fields
                  : objectKeys(_input.data[0]);

        if (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')
          _input.data = [_input.data];  // handles input like [1,2,3] or ["asdf"]
      }

      return serialize(_input.fields || [], _input.data || []);
    }

    // Default (any valid paths should return before this)
    throw "exception: Unable to serialize unrecognized input";


    function unpackConfig()
    {
      if (typeof _config !== 'object')
        return;

      if (typeof _config.delimiter === 'string'
        && _config.delimiter.length == 1
        && Papa.BAD_DELIMITERS.indexOf(_config.delimiter) == -1)
      {
        _delimiter = _config.delimiter;
      }

      if (typeof _config.quotes === 'boolean'
        || _config.quotes instanceof Array)
        _quotes = _config.quotes;

      if (typeof _config.newline === 'string')
        _newline = _config.newline;
    }


    // Turns an object's keys into an array
    function objectKeys(obj)
    {
      if (typeof obj !== 'object')
        return [];
      var keys = [];
      for (var key in obj)
        keys.push(key);
      return keys;
    }

    // The double for loop that iterates the data and writes out a CSV string including header row
    function serialize(fields, data)
    {
      var csv = "";

      if (typeof fields === 'string')
        fields = JSON.parse(fields);
      if (typeof data === 'string')
        data = JSON.parse(data);

      var hasHeader = fields instanceof Array && fields.length > 0;
      var dataKeyedByField = !(data[0] instanceof Array);

      // If there a header row, write it first
      if (hasHeader)
      {
        for (var i = 0; i < fields.length; i++)
        {
          if (i > 0)
            csv += _delimiter;
          csv += safe(fields[i], i);
        }
        if (data.length > 0)
          csv += _newline;
      }

      // Then write out the data
      for (var row = 0; row < data.length; row++)
      {
        var maxCol = hasHeader ? fields.length : data[row].length;

        for (var col = 0; col < maxCol; col++)
        {
          if (col > 0)
            csv += _delimiter;
          var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
          csv += safe(data[row][colIdx], col);
        }

        if (row < data.length - 1)
          csv += _newline;
      }

      return csv;
    }

    // Encloses a value around quotes if needed (makes a value safe for CSV insertion)
    function safe(str, col)
    {
      if (typeof str === "undefined" || str === null)
        return "";

      str = str.toString().replace(/"/g, '""');

      var needsQuotes = (typeof _quotes === 'boolean' && _quotes)
              || (_quotes instanceof Array && _quotes[col])
              || hasAny(str, Papa.BAD_DELIMITERS)
              || str.indexOf(_delimiter) > -1
              || str.charAt(0) == ' '
              || str.charAt(str.length - 1) == ' ';

      return needsQuotes ? '"' + str + '"' : str;
    }

    function hasAny(str, substrings)
    {
      for (var i = 0; i < substrings.length; i++)
        if (str.indexOf(substrings[i]) > -1)
          return true;
      return false;
    }
  }



  // TODO: Many of the functions of NetworkStreamer and FileStreamer are similar or the same. Consolidate?
  function NetworkStreamer(config)
  {
    config = config || {};
    if (!config.chunkSize)
      config.chunkSize = Papa.RemoteChunkSize;

    var start = 0, fileSize = 0;
    var aggregate = "";
    var partialLine = "";
    var xhr, nextChunk;
    var handle = new ParserHandle(copy(config));

    this.stream = function(url)
    {
      nextChunk = function()
      {
        readChunk();
      };

      nextChunk();  // Starts streaming


      function readChunk()
      {
        xhr = new XMLHttpRequest();

        xhr.onload = chunkLoaded;
        xhr.onerror = chunkError;
        //last argument was !worker
        xhr.open("GET", url, true);
        if (config.step)
        {
          var end = start + config.chunkSize - 1; // minus one because byte range is inclusive
          if (fileSize && end > fileSize) // Hack around a Chrome bug: http://stackoverflow.com/q/24745095/1048862
            end = fileSize;
          xhr.setRequestHeader("Range", "bytes="+start+"-"+end);
        }
        xhr.send();
        start += config.chunkSize;
      }

      function chunkLoaded()
      {
        if (xhr.readyState != 4)
          return;

        if (xhr.status < 200 || xhr.status >= 400)
        {
          chunkError();
          return;
        }

        // Rejoin the line we likely just split in two by chunking the file
        aggregate += partialLine + xhr.responseText;
        partialLine = "";

        var finishedWithEntireFile = !config.step || start > getFileSize(xhr);

        if (!finishedWithEntireFile)
        {
          var lastLineEnd = aggregate.lastIndexOf("\n");

          if (lastLineEnd < 0)
            lastLineEnd = aggregate.lastIndexOf("\r");

          if (lastLineEnd > -1)
          {
            partialLine = aggregate.substring(lastLineEnd + 1); // skip the line ending character
            aggregate = aggregate.substring(0, lastLineEnd);
          }
          else
          {
            // For chunk sizes smaller than a line (a line could not fit in a single chunk)
            // we simply build our aggregate by reading in the next chunk, until we find a newline
            nextChunk();
            return;
          }
        }

        var results = handle.parse(aggregate);
        aggregate = "";

        if (isFunction(config.chunk))
        {
          config.chunk(results);
          results = undefined;
        }

        if (!finishedWithEntireFile && !results.meta.paused)
          nextChunk();
      }

      function chunkError()
      {
        if (isFunction(config.error))
          config.error(xhr.statusText);
      }

      function getFileSize(xhr)
      {
        var contentRange = xhr.getResponseHeader("Content-Range");
        return parseInt(contentRange.substr(contentRange.lastIndexOf("/") + 1));
      }
    };
  }









  function FileStreamer(config)
  {
    config = config || {};
    if (!config.chunkSize)
      config.chunkSize = Papa.LocalChunkSize;

    var start = 0;
    var aggregate = "";
    var partialLine = "";
    var reader, nextChunk, slice;
    var handle = new ParserHandle(copy(config));

    // FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862
    // But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76
    var usingAsyncReader = typeof FileReader === 'function';

    this.stream = function(file)
    {
      var slice = file.slice || file.webkitSlice || file.mozSlice;

      if (usingAsyncReader)
      {
        reader = new FileReader();    // Preferred method of reading files, even in workers
        reader.onload = chunkLoaded;
        reader.onerror = chunkError;
      }
      else
        reader = new FileReaderSync();  // Hack for running in a web worker in Firefox

      nextChunk();  // Starts streaming

      function nextChunk()
      {
        if (start < file.size)
          readChunk();
      }

      function readChunk()
      {
        var end = Math.min(start + config.chunkSize, file.size);
        var txt = reader.readAsText(slice.call(file, start, end), config.encoding);
        if (!usingAsyncReader)
          chunkLoaded({ target: { result: txt } }); // mimic the async signature
      }

      function chunkLoaded(event)
      {
        // Very important to increment start each time before handling results
        start += config.chunkSize;

        // Rejoin the line we likely just split in two by chunking the file
        aggregate += partialLine + event.target.result;
        partialLine = "";

        var finishedWithEntireFile = start >= file.size;

        if (!finishedWithEntireFile)
        {
          var lastLineEnd = aggregate.lastIndexOf("\n");

          if (lastLineEnd < 0)
            lastLineEnd = aggregate.lastIndexOf("\r");

          if (lastLineEnd > -1)
          {
            partialLine = aggregate.substring(lastLineEnd + 1); // skip the line ending character
            aggregate = aggregate.substring(0, lastLineEnd);
          }
          else
          {
            // For chunk sizes smaller than a line (a line could not fit in a single chunk)
            // we simply build our aggregate by reading in the next chunk, until we find a newline
            nextChunk();
            return;
          }
        }

        var results = handle.parse(aggregate);
        aggregate = "";

        if (isFunction(config.chunk))
        {
          config.chunk(results, file);
          results = undefined;
        }

        if (!finishedWithEntireFile && !results.meta.paused)
          nextChunk();
      }

      function chunkError()
      {
        if (isFunction(config.error))
          config.error(reader.error, file);
      }
    };
  }

  // Use one ParserHandle per entire CSV file or string
  function ParserHandle(_config)
  {
    // One goal is to minimize the use of regular expressions...
    var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;

    var self = this;
    var _input;       // The input being parsed
    var _parser;      // The core parser being used
    var _paused = false;  // Whether we are paused or not
    var _delimiterError;  // Temporary state between delimiter detection and processing results
    var _fields = [];   // Fields are from the header row of the input, if there is one
    var _results = {    // The last results returned from the parser
      data: [],
      errors: [],
      meta: {}
    };
    _config = copy(_config);

    this.parse = function(input)
    {
      _delimiterError = false;
      if (!_config.delimiter)
      {
        var delimGuess = guessDelimiter(input);
        if (delimGuess.successful)
          _config.delimiter = delimGuess.bestDelimiter;
        else
        {
          _delimiterError = true; // add error after parsing (otherwise it would be overwritten)
          _config.delimiter = Papa.DefaultDelimiter;
        }
        _results.meta.delimiter = _config.delimiter;
      }

      if (isFunction(_config.step))
      {
        var userStep = _config.step;
        _config.step = function(results)
        {
          _results = results;
          if (needsHeaderRow())
            processResults();
          else
            userStep(processResults(), self);
        };
      }

      if (_config.preview && _config.header)
        _config.preview++;  // to compensate for header row

      _input = input;
      _parser = new Parser(_config);
      _results = _parser.parse(_input);
      processResults();
      if (isFunction(_config.complete) && !_paused)
        _config.complete(_results);
      return _paused ? { meta: { paused: true } } : _results;
    };

    this.pause = function()
    {
      _paused = true;
      _parser.abort();
      _input = _input.substr(_parser.getCharIndex());
    };

    this.resume = function()
    {
      _paused = false;
      _parser = new Parser(_config);
      _parser.parse(_input);
      if (isFunction(_config.complete) && !_paused)
        _config.complete(_results);
    };

    this.abort = function()
    {
      _parser.abort();
      if (isFunction(_config.complete))
        _config.complete(_results);
      _input = "";
    }

    function processResults()
    {
      if (_results && _delimiterError)
      {
        addError("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '"+Papa.DefaultDelimiter+"'");
        _delimiterError = false;
      }

      if (needsHeaderRow())
        fillHeaderFields();

      return applyHeaderAndDynamicTyping();
    }

    function needsHeaderRow()
    {
      return _config.header && _fields.length == 0;
    }

    function fillHeaderFields()
    {
      if (!_results)
        return;
      for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
        for (var j = 0; j < _results.data[i].length; j++)
          _fields.push(_results.data[i][j]);
      _results.data.splice(0, 1);
    }

    function applyHeaderAndDynamicTyping()
    {
      if (!_results || (!_config.header && !_config.dynamicTyping))
        return _results;

      for (var i = 0; i < _results.data.length; i++)
      {
        var row = {};
        for (var j = 0; j < _results.data[i].length; j++)
        {
          if (_config.dynamicTyping)
          {
            var value = _results.data[i][j];
            if (value == "true")
              _results.data[i][j] = true;
            else if (value == "false")
              _results.data[i][j] = false;
            else
              _results.data[i][j] = tryParseFloat(value);
          }

          if (_config.header)
          {
            if (j >= _fields.length)
            {
              if (!row["__parsed_extra"])
                row["__parsed_extra"] = [];
              row["__parsed_extra"].push(_results.data[i][j]);
            }
            else
              row[_fields[j]] = _results.data[i][j];
          }
        }

        if (_config.header)
        {
          _results.data[i] = row;
          if (j > _fields.length)
            addError("FieldMismatch", "TooManyFields", "Too many fields: expected " + _fields.length + " fields but parsed " + j, i);
          else if (j < _fields.length)
            addError("FieldMismatch", "TooFewFields", "Too few fields: expected " + _fields.length + " fields but parsed " + j, i);
        }
      }

      if (_config.header && _results.meta)
        _results.meta.fields = _fields;

      return _results;
    }

    function guessDelimiter(input)
    {
      var delimChoices = [",", "\t", "|", ";", Papa.RECORD_SEP, Papa.UNIT_SEP];
      var bestDelim, bestDelta, fieldCountPrevRow;

      for (var i = 0; i < delimChoices.length; i++)
      {
        var delim = delimChoices[i];
        var delta = 0, avgFieldCount = 0;
        fieldCountPrevRow = undefined;

        var preview = new Parser({
          delimiter: delim,
          preview: 10
        }).parse(input);

        for (var j = 0; j < preview.data.length; j++)
        {
          var fieldCount = preview.data[j].length;
          avgFieldCount += fieldCount;

          if (typeof fieldCountPrevRow === 'undefined')
          {
            fieldCountPrevRow = fieldCount;
            continue;
          }
          else if (fieldCount > 1)
          {
            delta += Math.abs(fieldCount - fieldCountPrevRow);
            fieldCountPrevRow = fieldCount;
          }
        }

        avgFieldCount /= preview.data.length;

        if ((typeof bestDelta === 'undefined' || delta < bestDelta)
          && avgFieldCount > 1.99)
        {
          bestDelta = delta;
          bestDelim = delim;
        }
      }

      _config.delimiter = bestDelim;

      return {
        successful: !!bestDelim,
        bestDelimiter: bestDelim
      }
    }

    function tryParseFloat(val)
    {
      var isNumber = FLOAT.test(val);
      return isNumber ? parseFloat(val) : val;
    }

    function addError(type, code, msg, row)
    {
      _results.errors.push({
        type: type,
        code: code,
        message: msg,
        row: row
      });
    }
  }











  function Parser(config)
  {
    var EMPTY = /^\s*$/;

    var _input;   // The input text being parsed
    var _delimiter; // The delimiting character
    var _comments;  // Comment character (default '#') or boolean
    var _step;    // The step (streaming) function
    var _callback;  // The callback to invoke when finished
    var _preview; // Maximum number of lines (not rows) to parse
    var _ch;    // Current character
    var _i;     // Current character's positional index
    var _inQuotes;  // Whether in quotes or not
    var _lineNum; // Current line number (1-based indexing)
    var _data;    // Parsed data (results)
    var _errors;  // Parse errors
    var _rowIdx;  // Current row index within results (0-based)
    var _colIdx;  // Current col index within result row (0-based)
    var _runningRowIdx;   // Cumulative row index, used by the preview feature
    var _aborted = false; // Abort flag

    // Unpack the config object
    config = config || {};
    _delimiter = config.delimiter;
    _comments = config.comments;
    _step = config.step;
    _preview = config.preview;

    // Delimiter integrity check
    if (typeof _delimiter !== 'string'
      || _delimiter.length != 1
      || Papa.BAD_DELIMITERS.indexOf(_delimiter) > -1)
      _delimiter = ",";

    // Comment character integrity check
    if (_comments === true)
      _comments = "#";
    else if (typeof _comments !== 'string'
      || _comments.length != 1
      || Papa.BAD_DELIMITERS.indexOf(_comments) > -1
      || _comments == _delimiter)
      _comments = false;


    this.parse = function(input)
    {
      if (typeof input !== 'string')
        throw "Input must be a string";
      reset(input);
      return parserLoop();
    };

    this.abort = function()
    {
      _aborted = true;
    };

    this.getCharIndex = function()
    {
       return _i;
    };

    function parserLoop()
    {
      while (_i < _input.length)
      {
        if (_aborted) break;
        if (_preview > 0 && _runningRowIdx >= _preview) break;

        if (_ch == '"')
          parseQuotes();
        else if (_inQuotes)
          parseInQuotes();
        else
          parseNotInQuotes();

        nextChar();
      }

      return finishParsing();
    }

    function nextChar()
    {
      _i++;
      _ch = _input[_i];
    }

    function finishParsing()
    {
      if (_aborted)
        addError("Abort", "ParseAbort", "Parsing was aborted by the user's step function");
      if (_inQuotes)
        addError("Quotes", "MissingQuotes", "Unescaped or mismatched quotes");
      endRow(); // End of input is also end of the last row
      if (!isFunction(_step))
        return returnable();
    }

    function parseQuotes()
    {
      if (quotesOnBoundary() && !quotesEscaped())
        _inQuotes = !_inQuotes;
      else
      {
        saveChar();
        if (_inQuotes && quotesEscaped())
          _i++
        else
          addError("Quotes", "UnexpectedQuotes", "Unexpected quotes");
      }
    }

    function parseInQuotes()
    {
      if (twoCharLineBreak(_i) || oneCharLineBreak(_i))
        _lineNum++;
      saveChar();
    }

    function parseNotInQuotes()
    {
      if (_ch == _delimiter)
        newField();
      else if (twoCharLineBreak(_i))
      {
        newRow();
        nextChar();
      }
      else if (oneCharLineBreak(_i))
        newRow();
      else if (isCommentStart())
        skipLine();
      else
        saveChar();
    }

    function isCommentStart()
    {
      if (!_comments)
        return false;

      var firstCharOfLine = _i == 0
                  || oneCharLineBreak(_i-1)
                  || twoCharLineBreak(_i-2);
      return firstCharOfLine && _input[_i] === _comments;
    }

    function skipLine()
    {
      while (!twoCharLineBreak(_i)
        && !oneCharLineBreak(_i)
        && _i < _input.length)
      {
        nextChar();
      }
    }

    function saveChar()
    {
      _data[_rowIdx][_colIdx] += _ch;
    }

    function newField()
    {
      _data[_rowIdx].push("");
      _colIdx = _data[_rowIdx].length - 1;
    }

    function newRow()
    {
      endRow();

      _lineNum++;
      _runningRowIdx++;
      _data.push([]);
      _rowIdx = _data.length - 1;
      newField();
    }

    function endRow()
    {
      trimEmptyLastRow();
      if (isFunction(_step))
      {
        if (_data[_rowIdx])
          _step(returnable());
        clearErrorsAndData();
      }
    }

    function trimEmptyLastRow()
    {
      if (_data[_rowIdx].length == 1 && EMPTY.test(_data[_rowIdx][0]))
      {
        if (config.keepEmptyRows)
          _data[_rowIdx].splice(0, 1);  // leave row, but no fields
        else
          _data.splice(_rowIdx, 1);   // cut out row entirely
        _rowIdx = _data.length - 1;
      }
    }

    function twoCharLineBreak(i)
    {
      return i < _input.length - 1 &&
        ((_input[i] == "\r" && _input[i+1] == "\n")
        || (_input[i] == "\n" && _input[i+1] == "\r"))
    }

    function oneCharLineBreak(i)
    {
      return _input[i] == "\r" || _input[i] == "\n";
    }

    function quotesEscaped()
    {
      // Quotes as data cannot be on boundary, for example: ,"", are not escaped quotes
      return !quotesOnBoundary() && _i < _input.length - 1 && _input[_i+1] == '"';
    }

    function quotesOnBoundary()
    {
      return (!_inQuotes && isBoundary(_i-1)) || isBoundary(_i+1);
    }

    function isBoundary(i)
    {
      if (typeof i != 'number')
        i = _i;

      var ch = _input[i];

      return (i <= -1 || i >= _input.length)
        || (ch == _delimiter
          || ch == "\r"
          || ch == "\n");
    }

    function addError(type, code, msg)
    {
      _errors.push({
        type: type,
        code: code,
        message: msg,
        line: _lineNum,
        row: _rowIdx,
        index: _i
      });
    }

    function reset(input)
    {
      _input = input;
      _inQuotes = false;
      _i = 0, _runningRowIdx = 0, _lineNum = 1;
      clearErrorsAndData();
      _data = [ [""] ]; // starting parsing requires an empty field
      _ch = _input[_i];
    }

    function clearErrorsAndData()
    {
      _data = [];
      _errors = [];
      _rowIdx = 0;
      _colIdx = 0;
    }

    function returnable()
    {
      return {
        data: _data,
        errors: _errors,
        meta: {
          lines: _lineNum,
          delimiter: _delimiter,
          aborted: _aborted,
          truncated: _preview > 0 && _i < _input.length
        }
      };
    }
  }

  // Replaces bad config values with good, default ones
  function copyAndValidateConfig(origConfig)
  {
    if (typeof origConfig !== 'object')
      origConfig = {};

    var config = copy(origConfig);

    if (typeof config.delimiter !== 'string'
      || config.delimiter.length != 1
      || Papa.BAD_DELIMITERS.indexOf(config.delimiter) > -1)
      config.delimiter = DEFAULTS.delimiter;

    if (typeof config.header !== 'boolean')
      config.header = DEFAULTS.header;

    if (typeof config.dynamicTyping !== 'boolean')
      config.dynamicTyping = DEFAULTS.dynamicTyping;

    if (typeof config.preview !== 'number')
      config.preview = DEFAULTS.preview;

    if (typeof config.step !== 'function')
      config.step = DEFAULTS.step;

    if (typeof config.complete !== 'function')
      config.complete = DEFAULTS.complete;

    if (typeof config.error !== 'function')
      config.error = DEFAULTS.error;

    if (typeof config.encoding !== 'string')
      config.encoding = DEFAULTS.encoding;

    if (typeof config.download !== 'boolean')
      config.download = DEFAULTS.download;

    if (typeof config.keepEmptyRows !== 'boolean')
      config.keepEmptyRows = DEFAULTS.keepEmptyRows;

    return config;
  }

  function copy(obj)
  {
    if (typeof obj !== 'object')
      return obj;
    var cpy = obj instanceof Array ? [] : {};
    for (var key in obj)
      cpy[key] = copy(obj[key]);
    return cpy;
  }

  function isFunction(func)
  {
    return typeof func === 'function';
  }


  return Papa;
});

define('main/data_helpers',['require','vendor/papaparse','underscore','i18n'],function(require) {
  var PapaParse = require('vendor/papaparse');
  var _ = require('underscore');
  var i18n = require('i18n');

  var parse = function (unparsedData) {
    var res = PapaParse.parse(unparsedData, {preview: 50});
    var parsedData =  [], val, i, j;

    if (res && res.data && res.data.length) {
      for (j = 0 ; j < 2 ; j++) {
        parsedData.push([]);
      }

      for (i = 0 ; i < res.data.length ; i++) {
        if (i === 0 && !parseFloat(res.data[i][0])) continue;
        if (res.data[i].length < 2) return null;

        //skip over empty lines
        if (!res.data[i][0] && !res.data[i][1]) continue;

        for (j = 0 ; j < 2 ; j++) {
          val = res.data[i][j].replace(/,/g, '');
          if (val && isNaN(parseFloat(val))) return {
            error: i18n.t(
              "Error: Row __rowNum__, Column __colNum__ isn't a number.",
              { rowNum: i+1, colNum: j+1}
            )
          };
          parsedData[j].push(val);
        }
      }
      if (parsedData[0].length < 3) return null;
    }
    return {data: parsedData};
  };

  //goal of this fn: ensure that all data is visible in the new viewport with reasonable
  //padding (at least 10%, not more than 20%)
  //make sure the origin, likewise, is visible with padding
  //only update currentMin and/or currentMax if that's necessary
  var _findNewRange = function(rawData, currentMin, currentMax) {
    //add zero in so that the origin remains visible
    var data = _.map(rawData, function(datum) {return parseFloat(datum)});
    data = _.filter(data, function(datum) {return isFinite(datum)});
    data.push(0);

    var max = _.max(data);
    var min = _.min(data);

    var estimatedRange = Math.max(max, currentMax) - Math.min(min, currentMin);

    var recommendedMax = currentMax, recommendedMin = currentMin;
    //override the new max is too tight (has less than 10% buffer)
    if ((max + 0.1 * estimatedRange) > currentMax) {
      recommendedMax = max + 0.2 * estimatedRange; //give us a 20% buffer
    }
    if ((min - 0.1 * estimatedRange) < currentMin) {
      recommendedMin = min - 0.2 * estimatedRange;
    }

    return [recommendedMin, recommendedMax];
  };

  //chooses a new viewport that ensures that all data is visible with at last 20% padding
  //for now, we only consider the first two columns (because those are the only ones that get imported)
  var computeNewViewport = function(viewport, data) {
    var recommendedX = _findNewRange(data[0], viewport.xmin, viewport.xmax);
    var recommendedY = _findNewRange(data[1], viewport.ymin, viewport.ymax);

    return {
      xmin: recommendedX[0],
      xmax: recommendedX[1],
      ymin: recommendedY[0],
      ymax: recommendedY[1]
    };
  };

  return {
    parse: parse,
    computeNewViewport: computeNewViewport
  };
});

define('main/calc_embed',['require','console','jquery','pjs','main/evaluator','graphing/grapher','main/graph_settings','graphing/viewport','expressions/list','expressions/list_view','main/keypad_view','main/state_controller','main/propagate_selection','i18n','main/pillbox_view','main/layout_controller','lib/external_screenshot','main/toast','undoredo','ipad.scrollfix','main/data_helpers'],function (require) {
  var console = require('console');
  var $ = require('jquery');
  var P = require('pjs');
  var Evaluator = require('main/evaluator');
  var Grapher = require('graphing/grapher');
  var GraphSettings = require('main/graph_settings');
  var Viewport = require('graphing/viewport');
  var ExpressionList = require('expressions/list');
  var ExpressionListView = require('expressions/list_view');
  var KeypadView = require('main/keypad_view');
  var StateController = require('main/state_controller');
  var propagateSelection = require('main/propagate_selection');
  //To do: render something for unsupported browsers here
  //var Browser = require('browser');

  var i18n = require('i18n');

  var PillboxView = require('main/pillbox_view');
  var LayoutController = require('main/layout_controller');
  var Screenshot = require('lib/external_screenshot');
  var ToastView = require('main/toast');
  var UndoRedo = require('undoredo');

  var ScrollFix = require('ipad.scrollfix');
  var DataHelpers = require('main/data_helpers');

  var Calc = P(function (proto) {
    proto.init = function (elt, workerPool, config) {
      /* jshint maxcomplexity:20 */

      var graphSettings = GraphSettings();
      //populate graphSettings config
      for (var key in config) {
        graphSettings.config.setProperty(key, config[key]);
      }

      //disable onscreen keypad, iff:
      // * the expression list is enabled (otherwise doesn't matter)
      // * the keypad is enabled (otherwise, it's a feature to have an onscreen)
      // * the user hasn't set nativeOnscreenKeypad to true
      //
      //note: this is undoable -- if you invoke for one calculator, it'll be
      //true for all subsequent ones. Ideally, new mathquill will allow us to
      //set this kind of thing on a mathquill-by-mathquill basis
      if (
        graphSettings.config.keypad &&
        graphSettings.config.expressions &&
        !graphSettings.config.nativeOnscreenKeypad
      ) {
        window.overrideNativeOnscreenKeypad = true;
      }

      var containerClasses = ['dcg-container', 'dcg-tap-container'];
      if (!graphSettings.config.settingsMenu) containerClasses.push('dcg-no-settings-menu');
      if (!graphSettings.config.expressionsTopbar) containerClasses.push('dcg-no-expression-topbar');
      if (!graphSettings.config.zoomButtons) containerClasses.push('dcg-no-zoom');
      if (!graphSettings.config.branding) containerClasses.push('dcg-no-branding');
      if (graphSettings.config.border) containerClasses.push('dcg-default-border');
      var $embedContainer = $('<div class="' + containerClasses.join(' ') + '">');
      var $graphpaper = $('<div class="dcg-grapher">');

      ScrollFix.limitScrollOnElement($embedContainer);

      var undoRedo = UndoRedo();

      // make sure that anything that is batched within undo/redo is also batched in the evaluator
      undoRedo.batchedWrapper = function (cb) {
        evaluator.batch(cb);
      };

      var toastView = ToastView(undoRedo);
      var evaluator = Evaluator(workerPool);
      var keypadView;
      var expressionsModel = ExpressionList(undoRedo);
      var expressionsView;

      if (!graphSettings.config.expressions || graphSettings.config.expressionsCollapsed) {
        $embedContainer.addClass('dcg-fullscreen');
      }

      if (graphSettings.config.expressions) {
        expressionsView = ExpressionListView(expressionsModel, $embedContainer, toastView, graphSettings);
      }

      $graphpaper.appendTo($embedContainer);
      toastView.appendTo($embedContainer);

      // TODO - what happens when we want a keypad but not the expressionsView? Is that
      // a valid usecase, or is this catch fine?
      if (graphSettings.config.keypad && expressionsView) {
        keypadView = KeypadView();
        keypadView.appendTo($embedContainer);
      }
      if (!graphSettings.config.graphpaper) {
        $embedContainer.addClass('dcg-no-graphpaper');
      }
      $embedContainer.appendTo(elt);
      var grapher = new Grapher($graphpaper, graphSettings, $embedContainer);

      graphSettings.registerCallbacks(grapher, expressionsView, $embedContainer);

      graphSettings.observe('degreeMode', function(){
        evaluator.setDegreeMode(graphSettings.degreeMode);
      });

      var pillboxView = PillboxView(grapher.viewportController);
      pillboxView.appendTo($embedContainer);

      var stateController = StateController(
        grapher,
        expressionsModel,
        graphSettings,
        evaluator
      );

      this.Screenshot = Screenshot($embedContainer, expressionsView, grapher, evaluator, stateController);

      if (!graphSettings.config.redrawSlowly) {
        grapher.redrawSlowly = grapher.redrawAllLayers;
      }

      var onChangeCallbacks = [];
      var notifyChange = function () {
        for (var i=0; i<onChangeCallbacks.length; i++) {
          onChangeCallbacks[i]();
        }
      };
      var addChangeCallback = function (cb) {
        onChangeCallbacks.push(cb);
      };

      undoRedo.changesCallbacks.push(notifyChange);
      graphSettings.stateProperties.forEach(function (prop) {
        graphSettings.observe(prop, notifyChange);
      });

      grapher.viewportController.triggerViewportStable = function () {
        if (!grapher.screen) return;
        var projection = grapher.createProjection();
        evaluator.setViewState({
          viewport: projection.viewport.toObject(),
          screen: projection.screen
        });

        // if we've set it back to square, keep it square on changes
        if (grapher.viewport.isSquare(grapher.screen)) {
          grapher.settings.setProperty('squareAxes', true);
        }

        grapher.settings.setProperty('zoomedDefault', grapher.viewportController.isZoomRestored());
        pillboxView.settingsView.setViewport(grapher.viewportController.getViewport());

        notifyChange();
      };

      evaluator.triggerStatusChange = function (changes) {
        expressionsModel.onChange(changes);
      };
      evaluator.triggerGraphComputed = function (id, graphData) {
        grapher.updateSketch(id, graphData);
        expressionsModel.onGraphComputed(id, graphData);
      };

      evaluator.triggerRemove = function (id) { grapher.hide(id); };

      evaluator.triggerUpdateIntersections = function (id, intersections) {
        grapher.updateIntersections(id, intersections);
        grapher.redrawPOILayer();
      };

      evaluator.triggerRender = function () {
        grapher.poiController.handleTraceUpdate(); //Needed for updating trace with animation
        grapher.redrawContentLayers();
      };
      evaluator.triggerRenderSlowly = function () { grapher.redrawSlowly(); };

      expressionsModel.triggerAddExp = function (obj) {
        if (!obj) return;
        // if we've completely erased the contents of this expression, then
        // we need to act like it's a new expression. We remove the old sketch
        // so that we don't remember POI information.
        if (obj.latex === '' && this.type !== 'table') {
          grapher.removeGraphSketch(obj.id);
        }

        evaluator.addStatement(obj);
      };

      expressionsModel.triggerRemoveExp = function (id) {
        evaluator.removeStatement(id);
      };
      expressionsModel.triggerRemoveExps = function (ids) {
        evaluator.removeStatements(ids);
      };

      expressionsModel.observe('drawOrder', function(){
        grapher.setSketchOrder(expressionsModel.getProperty('drawOrder'));
      });

      expressionsModel.batchEvaluation = evaluator.batch.bind(evaluator);

      if (expressionsView) {
        expressionsView.triggerClearGraph = function () {
          stateController.setBlank();
          expressionsModel.setSelected(0);
          expressionsView.getSelectedView().addFocus();
        };
      }

      expressionsModel.triggerAddImage = function (image) {
        // add the image only when it's loaded
        if (image.imageObj.width && image.imageObj.height) {
          grapher.addGraphImage(image);
          grapher.redrawImageLayer();
        } else {
          $(image.imageObj).on('load.calc_load', function () {
            grapher.addGraphImage(image);
            grapher.redrawImageLayer();
          });
        }
      };
      expressionsModel.triggerRemoveImage = function (image) {
        $(image.imageObj).off('load.calc_load');
        grapher.removeGraphImage(image.id);
        grapher.redrawImageLayer();
      };
      expressionsModel.triggerRedrawImages = function () {
        grapher.redrawImageLayer();
      };

      propagateSelection(expressionsModel, grapher, evaluator);

      if (keypadView && expressionsView) {
        keypadView.registerEditableView(expressionsView);
      }

      if (keypadView && pillboxView && pillboxView.settingsView) {
        keypadView.registerEditableView(pillboxView.settingsView);
      }

      var layoutController = LayoutController(
        {
          expressionsView: expressionsView,
          keypadView: keypadView,
          pillboxView: pillboxView,
          grapher: grapher
        },
        $embedContainer,
        graphSettings
      );

      grapher.poiController.triggerStartMovingPoint = function (id) {
        expressionsModel.onStartMovingPoint(id);
      };

      grapher.poiController.triggerMovePoint = function (id, screen_pt, projection) {
        expressionsModel.onMovePoint(id, screen_pt, projection);
      };

      grapher.poiController.triggerStopMovingPoint = function (id) {
        expressionsModel.onStopMovingPoint(id);
      };

      grapher.poiController.triggerSelectExpression = function (id) {
        expressionsModel.setSelected(expressionsModel.getItemById(id));
      };

      if (expressionsView) {
        expressionsView.appendTo($embedContainer);
      }

      //blur if there's a click outside of our container.
      //note: has a special catch for if you click on dcg-shell, because as part of our handlers
      //for clicking on that, we remove the dcg-shell from the DOM
      $(window).on('tapstart', function(evt) {
        var $target = $(evt.target);
        if (!$target.closest($embedContainer).length && !$target.hasClass('dcg-shell')) {
          expressionsModel.setSelected(null);
        }
      });

      //Setup undo-redo listeners -- only if globalKeyboardUndo was enabled
      //TODO: verify naming
      if (graphSettings.config.globalKeyboardUndo) {
        $(document).bind('keydown', function (evt) {

          // TODO - a different way to listen for z and y keys than hardcoding the numbers
          //Default ctrl-z, ctrl-y behavior
          if (evt.ctrlKey || evt.metaKey) {
            switch(evt.which) {
              case 90: //z
                if (evt.shiftKey) {
                  undoRedo.redo();
                } else {
                  undoRedo.undo();
                }
                return false;
              case 89: //y
                undoRedo.redo();
                return false;
            }
          }
        });
      }

      this.expressionsModel = expressionsModel;

      if (expressionsView) {
        this.expressions = expressionsView;
      }
      this.grapher = grapher;
      this.evaluator = evaluator;
      this.stateController = stateController;
      this.setState = stateController.setState.bind(stateController);
      this.setBlank = stateController.setBlank.bind(stateController);
      this.getState = stateController.getState.bind(stateController);
      this.setStateFromURL = stateController.setStateFromURL.bind(stateController);
      this.expressionsView = expressionsView;
      this.undoRedo = undoRedo;
      this.addChangeCallback = addChangeCallback;
      this.toast = function(str, options) {
        toastView.show(str, options);
      };

      this.setViewport = function (bounds) {
        grapher.viewportController.setViewport(new Viewport(
          bounds[0], bounds[1], bounds[2], bounds[3]
        ));
      };
      this.resize = function () {
        layoutController.resize();
      };

      this.addFocus = function () {
        if (!expressionsView) return;
        expressionsModel.setSelected(0);
        expressionsView.getSelectedView().addFocus();
      };

      //undocumented (for now) method for adding a data table programatically
      this.createAndPopulateTable = function(parsedData) {

        this.expressionsView.addExpressionView.newTable(parsedData);
        //calc viewport
        var cvp = this.grapher.viewport.toObject();
        //new viewport
        var nvp = DataHelpers.computeNewViewport(cvp, parsedData);
        var self = this;
        if (nvp.xmax > cvp.xmax || nvp.xmin < cvp.xmin || nvp.ymax > cvp.ymax || nvp.ymin < cvp.ymin) {

          self.undoRedo.addTransaction({
            type: self.undoRedo.CAUSE_OF_CHANGE,
            undo: function () {
              self.setViewport([cvp.xmin, cvp.xmax, cvp.ymin, cvp.ymax]);
            },
            redo: function () {
              self.setViewport([nvp.xmin, nvp.xmax, nvp.ymin, nvp.ymax]);
            }
          });
          this.toast(i18n.t('We zoomed to fit your data.'), { undoCallback: function () {}});
        }
      };

      this.interceptTouch = function () {
        var elts = $graphpaper;
        if (expressionsView) {
          elts = elts.add(expressionsView.$('.dcg-expression-top-bar'));
        }
        if (keypadView) elts = elts.add(keypadView.$());
        // Don't allow legacy scrolling or legacy clicks on the graphpaper or keypad
        elts.on('touchstart', function (evt) {
          evt.preventDefault();
        });
        // Since we're preventing default, we need to take responsibility for closing
        // the system keypad, and fixing scroll.
        elts.on('touchend', layoutController.defocusMobile);
      };

      this.setOptions = function (options) {
        var needsResize = false;
        if (options.hasOwnProperty('solutions')) {
          $embedContainer.toggleClass('dcg-no-solutions', !options.solutions);
        }
        if (options.hasOwnProperty('settingsMenu')) {
          $embedContainer.toggleClass('dcg-no-settings-menu', !options.settingsMenu);
        }

        if (options.hasOwnProperty('border')) {
          $embedContainer.toggleClass('dcg-default-border', !!options.border);
        }
        if (options.hasOwnProperty('branding')) {
          $embedContainer.toggleClass('dcg-no-branding', !options.branding);
        }
        if (options.hasOwnProperty('expressionsTopbar')) {
          $embedContainer.toggleClass('dcg-no-expression-topbar', !options.expressionsTopbar);
          needsResize = true;
        }
        if (options.hasOwnProperty('graphpaper')) {
          $embedContainer.toggleClass('dcg-no-graphpaper', !options.graphpaper);
          needsResize = true;
        }
        if (options.hasOwnProperty('zoomButtons')) {
          $embedContainer.toggleClass('dcg-no-zoom', !options.zoomButtons);
        }
        if (options.hasOwnProperty('expressionsCollapsed') && expressionsView) {
          if (options.expressionsCollapsed) {
            expressionsView.hideExpressions();
          } else {
            expressionsView.showExpressions();
          }
        }
        if (options.hasOwnProperty('keypad')) {
          console.warn(
            'Bad option {keypad: ' +
            options.keypad +
            '}. The keypad can only be added or removed at load time, not at runtime.'
          );
        }
        if (options.hasOwnProperty('expressions')) {
          console.warn(
            'Bad option {expressions: ' +
            options.expressions +
            '}. The expressions can only be added or removed at load time, not at runtime.'
          );
        }

        if (needsResize) layoutController.resize();
      };

      layoutController.resize();
      stateController.setBlank();

      if (graphSettings.config.expressionsCollapsed) this.setOptions({expressionsCollapsed: true});

      grapher.viewportController.triggerViewportStable();
    };
  });

  return Calc;
});


define('api/calculator',['require','console','pjs','underscore','main/calc_embed','expressions/helperexpression','underscore_model','worker/workerpool','browser','expressions/colors'],function (require) {
  var console = require('console');
  var P = require('pjs');
  var _ = require('underscore');
  var Calc = require('main/calc_embed');
  var HelperExpression = require('expressions/helperexpression');
  var UnderscoreModel = require('underscore_model');
  var WorkerPool = require('worker/workerpool');
  var Browser = require('browser');

  var Colors = require('expressions/colors');

  function _parseExpression (expression) {
    var obj;

    if (typeof expression === 'string') {
      obj = { latex: expression };
    } else if (expression.headings !== undefined) {
      obj = expression;
      obj.headings = obj.headings.map(function (heading) {
        return (typeof heading === 'string') ? { latex: heading } : heading;
      });
    } else {
      obj = expression;
    }

    return obj;
  }


  function validatedOptions (options) {
    var out = {};
    if (!options) options = {};

    var addOption = function (property, defaultValue) {
      if (options.hasOwnProperty(property)) {
        out[property] = options[property];
      } else {
        out[property] = defaultValue;
      }
    };
    addOption('keypad', true);
    addOption('graphpaper', true);
    addOption('settingsMenu', true);
    addOption('expressionsTopbar', true);
    addOption('branding', true);
    //zoomButtons don't make sense w/o graphpaper
    addOption('zoomButtons', out.graphpaper);
    addOption('solutions', true);
    addOption('expressionsCollapsed', false);
    addOption('lockViewport', false);
    addOption('globalKeyboardUndo', false);
    //default to useShellsOffscreen on mobile
    addOption('useShellsOffscreen', Browser.IS_MOBILE);
    addOption('redrawSlowly', false);
    addOption('onlyTraceSelected', false);
    addOption('disableMouseInteractions', false);
    addOption('folders', true);
    //images don't make much sense w/o graphpaper (but aren't strictly disallowed)
    addOption('images', out.graphpaper);
    addOption('expressions', true);
    addOption('border', true);
    addOption('nativeOnscreenKeypad', false);

    //secret option for resizing in a loop
    addOption('resizeLoop', false);

    if (options.hasOwnProperty('menus')) {
      console.warn(
        'As of API version 0.4, the \'menus\' option is deprecated and has been split into ' +
        'settingsMenu (boolean) and expressionsTopbar (boolean).'
      );
      if (!options.hasOwnProperty('settingsMenu')) out.settingsMenu = !!options.menus;
      if (!options.hasOwnProperty('expressionsTopbar')) out.expressionsTopbar = !!options.menus;
    }


    if (!out.graphpaper) {
      if (out.expressionsCollapsed) {
        out.expressionsCollapsed = false;
        console.warn(
          'Desmos API initialized with bad options. graphpaper: false ' +
          'and expressionsCollapsed: true are incompatible. Proceeding ' +
          'with expressionsCollapsed: false.'
        );
      }
      if (out.zoomButtons) {
        out.zoomButtons = false;
        console.warn(
          'Desmos API initialized with bad options. graphpaper: false ' +
          'and zoomButtons: true are incompatible. Proceeding ' +
          'with zoomButtons: false.'
        );
      }
    }

    return out;
  }
  //this always needs to be set on window (for now)
  var nworkers = (window.Desmos.config.hasOwnProperty('nworkers') ? window.Desmos.config.nworkers : 8);
  var workerPool = WorkerPool(window.Desmos.config.workerURL, nworkers);

  var Calculator = P(function (proto) {
    proto.init = function (elt, options, onReady) {
      this._calc = Calc(elt, workerPool, validatedOptions(options));
      this._calc.interceptTouch();
      //let the world know that we're ready
      if (typeof onReady === 'function') onReady(this);
    };

    proto.setExpression = function (expression) {
      var expressions = this._calc.expressionsModel;
      var validatedState = {};
      var id = validatedState.id = expression.id.toString();
      if (!id) return;
      if (expression.hasOwnProperty('latex')) {
        validatedState.latex = expression.latex.toString();
      }
      if (expression.hasOwnProperty('color')) {
        validatedState.color = expression.color.toString();
      }
      if (expression.hasOwnProperty('style')) {
        validatedState.style = expression.style.toString();
      }
      if (expression.hasOwnProperty('hidden')) {
        validatedState.hidden = !!expression.hidden;
      }

      if (expressions.getItemById(id)) {
        //Update
        expressions.updateItemById(id, validatedState);
      } else {
        //Set
        var obj = expressions.fromState(_parseExpression(validatedState));
        expressions.addItem(obj);
      }
    };

    proto.setExpressions = function (expressions) {
      expressions.forEach(this.setExpression.bind(this));
    };

    proto.removeExpression = function (expression) {
      var expressions = this._calc.expressionsModel;
      var id = expression.id.toString();
      expressions.removeItemById(id);
    };

    proto.removeExpressions = function (expressions) {
      expressions.forEach(this.removeExpression.bind(this));
    };

    proto.setViewport = function (bounds) {
      if (
        bounds.length == 4 &&
        bounds[1] > bounds[0] &&
        bounds[3] > bounds[2]
      ) {
        this._calc.setViewport(bounds);
      } else {
        console.warn('Invalid viewport.  Expected [xmin, xmax, ymin, ymax].  Got ' + bounds);
      }
    };

    proto.resize = function () {
      this._calc.resize();
    };

    proto.setBlank = function () { return this._calc.setBlank.apply(this._calc, arguments); };
    proto.setState = function () { return this._calc.setState.apply(this._calc, arguments); };
    proto.getState = function () { return this._calc.getState.apply(this._calc, arguments); };

    proto.screenshot = function (opts) {
      opts = opts ? opts : {};
      return this._calc.grapher.screenshot(opts.width, opts.height);
    };

    proto.setOptions = function () { return this._calc.setOptions.apply(this._calc, arguments)};

    proto.HelperExpression = function (obj) {
      var proxy = UnderscoreModel();

      var h = HelperExpression(obj, this._calc.expressionsModel);
      this._calc.expressionsModel.addHelperItem(h);

      proxy.latex = h.latex;

      h.observe('formula', function () {
        // Notify proxy of changed properties at the end so that the externally
        // exposed values are consistent. Might want to make this an optional feature
        // of UnderscoreModel. Maybe model.batchUpdate(function () { /* do updates */ });
        var props = ['numericValue'];
        var oldValues = props.map(function (prop) {return proxy[prop]});

        var formula = h.formula;

        var val;
        if (formula.zero_values && formula.zero_values.length === 1) {
          val = formula.zero_values[0].val;
        }
        var valType = typeof val;
        proxy.numericValue = valType === 'number' ? val : NaN;

        props.forEach(function (prop) {
          if (!_.isEqual(proxy[prop], oldValues[prop])) proxy.notifyPropertyChange(prop);
        });
      });

      return proxy;
    };
  });

  // Spelling these out to avoid giving access to Colors.all. This is a
  // mutable array, and changing it would change the colors we cycle through.
  // That might be desirable, but we would want a better API for doing it.
  window.Desmos.Colors = {
    RED: Colors.RED,
    BLUE: Colors.BLUE,
    GREEN: Colors.GREEN,
    ORANGE: Colors.ORANGE,
    PURPLE: Colors.PURPLE,
    BLACK: Colors.BLACK,
    next: Colors.next
  };

  window.Desmos.Calculator = Calculator;

  return Calculator;
});

define('mygraphs/view',['require','loadcss!css/mygraphs','jquery','underscore','pjs','i18n','keys','config','underscore_view','./examplegraphitem_view','./savedgraphitem_view','template!mygraphs','api/calculator','scroll_helpers','vendor/jquery.html5-placeholder-shim'],function(require) {
  require('loadcss!css/mygraphs');

  var $ = require('jquery');
  var _ = require('underscore');
  var P = require('pjs');
  var i18n = require('i18n');
  var Keys = require('keys');
  var Config = require('config');
  var UnderscoreView = require('underscore_view');
  var ExampleGraphItemView = require('./examplegraphitem_view');
  var SavedGraphItemView = require('./savedgraphitem_view');
  var template = require('template!mygraphs');
  var CalcAPI = require('api/calculator');
  var scrollHelpers = require('scroll_helpers');

  require('vendor/jquery.html5-placeholder-shim');

  var MyGraphsView = P(UnderscoreView, function (view, _super) {
    view.template = template;

    view.init = function (model, Calc, modals) {
      _super.init.call(this);
      this.model = model;
      this.Calc = Calc;
      this.modals = modals;
      this.itemViews = {};

      this.model.triggerItemAdded = this.onItemAdded.bind(this);
      this.model.triggerItemRemoved = this.onItemRemoved.bind(this);
      this.model.observe('selectedItem', this.onSelectedItemChange.bind(this));
      this.model.observe('searchQuery', this.onSearchQueryChange.bind(this));

      this.accountsEnabled = false;

      this.model.observe('isSpinning searchQuery filteredItemCount', this.renderLayout.bind(this));

      this.observe('isOpen', this.renderIsOpen.bind(this));
    };

    view.getTemplateParams = function() {
      return {
        maintenance: Config.get('maintenance'),
        previewMode: Config.get('previewMode'),
        previewFeedbackUrl: Config.get('previewFeedbackUrl'),
        previewMessage: Config.get('previewMessage'),
        accountsEnabled: this.accountsEnabled
      };
    };

    view.createItemView = function (itemModel) {
      if (itemModel.isSavedGraph) {
        return SavedGraphItemView(itemModel);
      } else if (itemModel.isExampleGraph) {
        return ExampleGraphItemView(itemModel);
      }
    };

    view.onItemAdded = function (itemModel, index) {
      if (!this.$()[0]) return; // don't do anything if not in dom

      var itemView = this.createItemView(itemModel);
      this.__itemViews[itemModel.guid] = itemView;

      if (index === 0) {
        itemView.prependTo(this.$('.template-list'));
      } else {
        itemView.insertAfter(this.$('.template-list > :nth-child('+index+')'));
      }
    };

    view.onItemRemoved = function (itemModel) {
      if (!this.$()[0]) return; // don't do anything if not in dom

      var itemView = this.__itemViews[itemModel.guid];
      delete this.__itemViews[itemModel.guid];

      itemView.remove();
    };

    view.getViewFromModel = function (itemModel) {
      return itemModel ? this.__itemViews[itemModel.guid] : null;
    };

    view.getSelectedView = function () {
      return this.getViewFromModel(this.model.selectedItem);
    };

    view.getSelectedGraph = function () {
      var selectedItemModel = this.model.selectedItem;
      if (!selectedItemModel) return null;

      return selectedItemModel.graph;
    };

    view.clearSelection = function () {
      var selectedItemModel = this.model.selectedItem;
      if (selectedItemModel) {
        selectedItemModel.setProperty('selected', false);
      }
    };

    view.onSelectedItemChange = function () {
      if (this.getSelectedGraph()) {
        this.showPreview();
      } else {
        this.hidePreview();
      }
    };

    view.focusSearchBar = function () {
      this.$('#search-mygraphs').focus();
    };

    view.toggleVisible = function () {
      if (this.isOpen) {
        this.close();
      } else {
        this.open();
      }
    };

    view.updateSearchQuery = function (evt) {
      //escape pressed -- clear input? just bikeshedding.
      if (Keys.lookup(evt) === Keys.ESCAPE) {
        this.$('#search-mygraphs').attr('value','');
        this.model.setProperty('searchQuery','');
      }

      //don't run the filter graphs code on  enter, up, or down
      else if ([Keys.UP, Keys.DOWN, Keys.ENTER].indexOf(Keys.lookup(evt)) === -1) {
        this.model.setProperty('searchQuery', this.$('#search-mygraphs').val());

        // close preview if it's open when typing in search box
        this.clearSelection();
      }

    };

    view.newBlankGraph = function () {
      this.clearSelection();
      this.model.graphsController.clearGraph();

      var self = this;
      var undoCallback = function () {
        self.open();
      };
      this.Calc._calc.toast(i18n.t("New graph created."), {undoCallback: undoCallback});
      this.close();
    };

    view.onSearchQueryChange = function () {
      this.$('.new-blank-graph').toggle(this.model.searchQuery.length === 0);
    };

    view.didCreateElement = function () {
      var self = this;
      var previewDiv = this.$('#preview-calculator')[0];
      var previewOpts = {
        settingsMenu: false,
        expressionsTopbar: false,
        keypad: false,
        zoomButtons: false,
        useShellsOffscreen: true,
        border: false,
        branding: false
      };
      this.previewCalc = new CalcAPI(previewDiv, previewOpts);

      var throttledResize = _.throttle(function() {
        this.positionPreview();
      }.bind(this), 100);
      $(window).on('resize', throttledResize);

      this.$preview = this.$('.graph-preview');
      this.$previewArrow = this.$preview.children('.active-arrow');
      this.$previewTitle = this.$preview.children('.dcg-title');
      this.$scrollable = this.$('.scrollable');

      this.$scrollable.on('scroll', this.hidePreviewIfTooScrolled.bind(this));
      this.$('#search-mygraphs').on('change keypress keyup keydown copy paste cut', this.updateSearchQuery.bind(this));

      this.$('.dcg-action-login').on('tap', this.login.bind(this));
      this.$('.dcg-action-createaccount').on('tap', this.createAccount.bind(this));
      this.$().on('click', 'a', function (evt) {
        if (!$(this).attr('href')) evt.preventDefault();
      });

      this.$().on('tap', '.dcg-action-newblankgraph', this.newBlankGraph.bind(this));
      this.$().on('tap', '.dcg-action-cancel', this.clearSelection.bind(this));

      this.$('.dcg-action-open-graph').on('tap', this.openPreview.bind(this));

      //background cover
      // if clicked and a preview is open, close that preview
      // otherwise, close the resources tab
      this.$('.dcg-action-close-resources').on('tapstart', function (evt) {
        if (self.getSelectedGraph()) {
          self.clearSelection();
        } else {
          self.close();
        }
      });

      // add examples to dom
      var list = this.$('.template-list');
      this.__itemViews = {};
      this.model.getItems().forEach(function (itemModel) {
        var itemView = self.createItemView(itemModel);
        self.__itemViews[itemModel.guid] = itemView;

        // TODO - optimize by adding all starting items at once rather than one at a time
        itemView.appendTo(list);
      });

      this.renderLayout();
    };

    view.createAccount = function () {
      //_kmq.push(['record', 'started signup', {
      //  'signup location': 'mygraphs-drawer'
      //}]);
      this.modals.createAccountDialog.show();
    };

    view.login = function () {
      //_kmq.push(['record', 'started login', {'login location': 'mygraphs-drawer'}]);
      this.modals.loginDialog.show();
    };

    view.renderLayout = function () {
      // exit early if the dom isn't created yet
      if (!this.$()[0]) return;

      var userIsLoggedIn = !!(this.accountsEnabled && false);
      var isSpinning = !!this.model.isSpinning;

      //show login options. no-op on tablet because login-reminder doesn't exist in the DOM
      this.$('.login-reminder').toggle(!userIsLoggedIn);
      // only show spinner if user is logged in
      this.$('.template-spinning').toggle(userIsLoggedIn && isSpinning);
      // only show 'no matches' if a search query is entered and the're not matches
      this.$('.no-matches').toggle(this.model.filteredItemCount === 0 && this.model.searchQuery.length !== 0);
    };

    view.openPreview = function () {
      var self = this;
      var selectedGraph = self.getSelectedGraph();
      if (!selectedGraph) return;

      setTimeout(function () {
        self.model.graphsController.loadGraph(selectedGraph.copy());

        var graphTitle;
        if (!selectedGraph.title) {
          graphTitle = i18n.t("Untitled Graph");
        } else {
          if (selectedGraph.title.length > 15) {
            graphTitle = selectedGraph.title.substr(0, 15) + "...";
          } else {
            graphTitle = selectedGraph.title;
          }
        }

        var str = i18n.t("Opened '__graphTitle__'", {graphTitle: graphTitle});
        var undoCallback = function() {
          self.open();
        };
        self.Calc._calc.toast(str, {undoCallback: undoCallback});
      });
      self.close();
    };

    view.showPreview = function () {
      var selectedGraph = this.getSelectedGraph();
      if (!selectedGraph) return;

      //do all of these things before showing & setState so that it feels more responsive
      $('body').addClass('preview-open');
      this.positionPreview();
      this.$previewTitle.text(selectedGraph.displayTitle);

      //dcg-visible fades in on a slight delay. remove it and re-add it
      //so that the animation is triggered when you switch between graphs
      this.$('.screenshot-clickjack').removeClass('dcg-visible');
      this.$('.dcg-loading-container').show();
      setTimeout(function(){
        this.previewCalc.resize();
        this.previewCalc.setState(selectedGraph.graphData);
        this.$('.dcg-loading-container').hide();
        this.$('.screenshot-clickjack').addClass('dcg-visible');
      }.bind(this), 1);
      this.$preview.show();
    };

    view.hidePreview = function () {
      this.$preview.hide();
      $('body').removeClass('preview-open');
    };

    view.selectUp = function (evt) {
      if (this.model.selectPrev()) {
        evt.preventDefault();
      }
    };

    view.selectDown = function (evt) {
      if (this.model.selectNext()) {
        evt.preventDefault();
      }
    };

    //if we scroll enough that the arrow's not pointing at the list item
    //hide preview
    view.hidePreviewIfTooScrolled = function () {
      var selectedView = this.getSelectedView();
      if (!selectedView) return;

      var $target = selectedView.$();
      if (
        $target.offset().top >= this.$previewArrow.offset().top ||
        $target.offset().top + $target.outerHeight() <= this.$previewArrow.offset().top
      ) {
        this.clearSelection();
      }
    };

    // our strategy is to try to keep the arrow in it's natural
    // position and move the entire preview up or down to line the
    // arrow up. That should be possible unless it'd require the
    // preview to go below the bottom of the screen. In that case,
    // we put the preview on the bottom of the screen and move the
    // arrow.
    view.positionPreview = function () {

      var selectedView = this.getSelectedView();
      if (!selectedView) return;

      var $target = selectedView.$();

      // scroll the target into view.
      var targetHeight = $target.outerHeight();

      scrollHelpers.scrollVisible($target, this.$scrollable, targetHeight);

      // restores the arrow to it's natural position
      this.$previewArrow.css('top','60px');
      var arrowOffset = 60;

      // check where the arrow *should* point
      var centerArrowY = $target.offset().top + targetHeight / 2;

      // figure out how far down we can move the preview before it is uncomfortably low on the screen
      var previewHeight = this.$preview.outerHeight();
      var maxBottom = $(window).height() - 5;
      var maxPreviewTop = maxBottom - previewHeight;
      var newPreviewTop = centerArrowY - arrowOffset;

      // the preview is too low, we must put the preview at the bottom of the screen
      // and move the arrow itself
      if (newPreviewTop > maxPreviewTop) {
       newPreviewTop = maxPreviewTop;
       this.$previewArrow.css('top', centerArrowY - newPreviewTop);
      }

      // move the preview to where it needs to go
      this.$preview.css('top', newPreviewTop);
    };

    view.renderIsOpen = function() {
      $('body').toggleClass('resources-open', !!this.isOpen);
    };

    view.close = function () {
      this.setProperty('isOpen', false);
      this.clearSelection();


      this.$('#search-mygraphs').blur().attr('value', '');
      this.model.setProperty('searchQuery', '');
      $(document).off('keydown.mygraphs-view');

      // TODO - do we still need this lastRemoved?
      this.model.graphsController.setProperty('lastRemoved', undefined);
    };

    view.open = function () {
      this.setProperty('isOpen', true);
      // update the dates and fix placeholder
      this.model.updateDisplayDates();
      if ($.placeholder) $.placeholder.shim();

      var self = this;
      //listen for arrow keys
      $(document).on('keydown.mygraphs-view', function(evt) {
        var key = Keys.lookup(evt);

        if (key === Keys.UP) {
          self.selectUp(evt);
          evt.preventDefault();
        } else if (key === Keys.DOWN) {
          self.selectDown(evt);
          evt.preventDefault();
        } else if (key === Keys.ENTER) {
          self.openPreview();
        } else if (key === Keys.ESCAPE) {
          self.clearSelection();
        }
      });
    };
  });

  return MyGraphsView;
});

define('template!header_desktop', ['underscore'], function(_) {return function(obj){
var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};
with(obj||{}){
__p+='<div>\n  <div class=\'left-floaters\'>\n      <span class="dcg-header-btn dcg-action-opendrawer dcg-tooltip" tooltip="'+
( t('Open Graph (ctrl+o)') )+
'">\n        <i class="dcg-icon-hamburger"></i>\n      </span>\n\n      <span class=\'divider\'></span>\n\n      ';
 if (maintenance) {
;__p+='\n        <span class="title-div">\n          <span class="dcg-variable-title dcg-tooltip" tooltip="'+
( t('Desmos is in maintenance mode, you won\'t be able to save changes to this graph. We\'re so sorry for the inconvenience!') )+
'"></span>\n        </span>\n      ';
 } else if (previewMode) {
;__p+='\n\n      <span class="title-div">\n        <span class="dcg-variable-title dcg-tooltip" tooltip="'+
( t('Desmos is in preview mode, so you won\'t be able to save graphs.') )+
'"></span>\n      </span>\n\n      ';
 } else {
;__p+='\n          <span class="title-div">\n            <span class="dcg-variable-title dcg-tooltip dcg-action-savedialog"\n              tooltip="'+
( t('Save As or Rename (ctrl+shift+s)') )+
'"\n            ></span>\n            ';
 if (user) {
;__p+='\n            <span class="dcg-action-save">\n              <span class="save-btn tooltip-offset" tooltip="'+
( t('Save (ctrl+s)') )+
'">\n                <i class="dcg-icon-save"></i>\n              </span>\n              <span class="saving-notice">\n                <img src="/img/spinner.gif" />\n              </span>\n              <span class="save-success"><i class="dcg-icon-check"></i>'+
( t('saved') )+
'</span>\n              <span class="save-failure"><i class="dcg-icon-remove"></i>'+
( t('error saving') )+
'</span>\n            </span>\n            ';
 }
;__p+='\n          </span>\n\n      ';
 }
;__p+='\n  </div>\n\n  <div class=\'right-floaters\'>\n    <!-- reverse order, because these all float right -->\n\n    <span\n      class="dcg-header-btn dcg-action-language dcg-tooltip"\n      tooltip="'+
( t('Language') )+
'"\n    >\n        <i class="dcg-icon-world"></i>\n    </span>\n    <span class=\'divider\'></span>\n    <span\n      class="dcg-header-btn dcg-action-help dcg-tooltip"\n      tooltip="'+
( t('Help') )+
'"\n    >\n        <i class="dcg-icon-question-sign"></i>\n    </span>\n\n    <span class=\'divider\'></span>\n\n    ';
 if (maintenance || previewMode) {
;__p+='\n\n    <div class="dcg-toast-container">\n      <span class="dcg-toast dcg-maintenance-toast">\n        <span class="dcg-msg">\n\n          ';
 if (maintenance) {
;__p+='\n            '+
( t('Desmos is in Maintenance Mode.') )+
'\n          ';
 } else {
;__p+='\n            '+
( previewMessage )+
'\n          ';
 }
;__p+='\n        </span>\n\n        ';
 if (maintenance) {
;__p+='\n          <a class="undo" target=\'_blank\' href=\'http://desmos.zendesk.com/entries/25429616-What-is-Maintenance-Mode-/\'>\n            '+
( t('Learn More') )+
'\n          </a>\n        ';
 } else {
;__p+='\n          <a class="undo" target=\'_blank\' href=\''+
(previewFeedbackUrl)+
'\'>\n            '+
( t('Share your thoughts!') )+
'\n          </a>\n        ';
 }
;__p+='\n\n\n      </span>\n    </div>\n\n    ';
 } else if (user) {
;__p+='\n\n      ';
 if (IS_ANDROID) {
;__p+='\n\n        <span \n          class="dcg-share-btn"\n          class=\'android-share dcg-action-share dcg-header-btn\'\n        >\n          <i class="dcg-icon-android-share"></i>\n        </span>\n\n      ';
 } else {
;__p+='\n        <span class=\'dcg-btn-group\'>\n        <span\n          class=\'dcg-print-btn tooltip-offset dcg-btn dcg-btn-green dcg-action-print\'\n          tooltip="'+
( t('Print') )+
'"\n        >\n            <i class="dcg-icon-print"></i>\n        </span>\n        <span\n          class=\'dcg-share-btn tooltip-offset dcg-btn dcg-btn-green dcg-action-share\'\n          tooltip="'+
( t('Share Graph') )+
'"\n        >\n            <i class="dcg-icon-share"></i>\n        </span>\n      </span>\n\n      ';
 }
;__p+='\n\n      <span class=\'divider\'></span>\n\n      <span class="dcg-account-link">\n        <span class="dcg-edit-acct-success">\n          <i class="dcg-icon-check"></i> '+
( t('saved') )+
'\n        </span>\n        <span class="email">\n          '+
( name )+
'\n          <i class=\'dcg-icon-caret-down\'></i>\n        </span>\n      </span>\n    ';
 } else {
;__p+='\n      <span class="dcg-login">\n      <a class="dcg-create-account dcg-btn dcg-btn-green dcg-action-createaccount">'+
( t('Create Account') )+
'</a> '+
( t('or') )+
'\n      <a class="dcg-sign-in dcg-action-login">'+
( t('Sign In') )+
'</a>\n      </span>\n    ';
 }
;__p+='\n  </div>\n\n  <div class=\'dcg-center\'>\n    <a href="/" target=\'_blank\' class="dcg-home-link-icon" title="dcg-title">\n      <i class="dcg-icon-desmos"></i>\n    </a>\n  </div>\n\n</div>\n';
}
return __p;
};});
/*
* this is the row of buttons above the calc on desktop
*/

define('main/header_desktop',['require','console','loadcss!css/header_desktop','jquery','underscore_view','pjs','browser','config','i18n','tipsy','main/share_options','main/help_desktop','main/language','main/account_dropdown','mygraphs/examples','mygraphs/model','mygraphs/view','template!header_desktop'],function(require){
  var console = require('console');
  require('loadcss!css/header_desktop');
  var $ = require('jquery');
  var UnderscoreView = require('underscore_view');
  var P = require('pjs');
  var Browser = require('browser');
  var Config = require('config');
  var i18n = require('i18n');
  require('tipsy');

  var ShareView = require('main/share_options');
  var HelpView = require('main/help_desktop');
  var LanguageView = require('main/language');
  var AccountView = require('main/account_dropdown');
  var myGraphExamples = require('mygraphs/examples');
  var MyGraphsModel = require('mygraphs/model');
  var MyGraphsView = require('mygraphs/view');

  var template = require('template!header_desktop');

  var HeaderView = P(UnderscoreView, function (view, _super) {
    view.template = template;
    view.$saveBtn = null;

    view.init = function (
      graphsController,
      Calc,
      modals
    ) {
      _super.init.call(this);
      this.graphsController = graphsController;
      this.Calc = Calc;
      this.modals = modals;

      this.shareView = ShareView(
        graphsController,
        Calc
      );
      this.helpView = HelpView(
        graphsController,
        Calc,
        modals
      );

      this.languageView = LanguageView(Calc);
      this.myGraphsModel = MyGraphsModel(myGraphExamples, graphsController);
      this.myGraphsView = MyGraphsView(this.myGraphsModel, Calc, modals);


      //needs helpview to be able to open up the feedback box
      this.accountView = AccountView(this.helpView, modals);

      this.childViews = [
        this.shareView,
        this.helpView,
        this.languageView,
        this.accountView
      ];
    };

    view.didCreateElement = function () {
      var self = this;

      this.$saveBtn = this.$('.dcg-action-save');

      this.$().tipsy({
        fade: 'fast',
        title: 'tooltip',
        wait: 500,
        delegate: '.dcg-tooltip'
      });

      //a few need extra offset
      this.$().tipsy({
        fade: 'fast',
        title: 'tooltip',
        wait: 500,
        offset: 7,
        delegate: '.tooltip-offset'
      });

      this.childViews.forEach(function(view) {
        view.setPointTo(self.$(view.pointToSelector));
        view.appendTo('.dcg-sliding-interior');
      });

      this.myGraphsView.appendTo('body');

      //bind to events in the graphs controller
      this.graphsController.startSavingCallbacks.push(this.saveStart.bind(this));
      this.graphsController.saveSuccessCallbacks.push(this.saveSuccess.bind(this));
      this.graphsController.saveErrorCallbacks.push(this.saveFailure.bind(this));

      this.helpView.setupOpenButton(this.$('.dcg-action-help'), 'tap');
      this.languageView.setupOpenButton(this.$('.dcg-action-language'), 'tap');
      this.shareView.setupOpenButton(this.$('.dcg-action-share'), 'tap');
      this.accountView.setupOpenButton(this.$('.dcg-account-link'), 'tap');


      this.$('.dcg-action-opendrawer').on('tap', this.openDrawer.bind(this));
      this.$('.dcg-action-savedialog').on('tap', this.saveDialog.bind(this));
      this.$saveBtn.on('tap', this.simpleSave.bind(this));
      this.$('.dcg-action-print').on('tap', this.print.bind(this));
      this.$('.dcg-action-login').on('tap', this.login.bind(this));
      this.$('.dcg-action-createaccount').on('tap', this.createAccount.bind(this));
      this.updateTitle();

      this.graphsController.observe('currentGraph', function () {
        self.updateTitle();
      });

      this.observe('graphChanged', this.renderGraphChanged.bind(this));
      this.renderGraphChanged();
    };

    view.renderGraphChanged = function() {
      var hasChanges = !!this.graphChanged;
      this.$('.save-btn').attr(
        'tooltip', (hasChanges ? i18n.t("Save Changes (ctrl+s)") : i18n.t("No Unsaved Changes")));
      this.$('.title-div').toggleClass('has-changes', hasChanges);
    };

    view.openDrawer = function () {
      this.myGraphsView.toggleVisible();
    };

    view.getTemplateParams = function (){
      var name = null;
      return  {
        IS_ANDROID: Browser.IS_ANDROID,
        name: name,
        maintenance: Config.get('maintenance'),
        previewMode: Config.get('previewMode'),
        previewFeedbackUrl: Config.get('previewFeedbackUrl'),
        previewMessage: Config.get('previewMessage')
      };
    };

    view.updateTitle = function () {
      var graph = this.graphsController.currentGraph;
      var title = (graph && graph.title ? graph.title : i18n.t('Untitled Graph'));
      this.$('.dcg-variable-title').text(title);
    };

    //this can be called by ctrl-S or by clicking the save icon
    //it executes the save, but doesn't pop up the dialog unless it's your first save
    view.simpleSave = function () {
        this.saveDialog();
    };

    // TODO - switch from keyCode to something that identifies which keys we're talking about.
    view.handleKeydown = function (evt) {
      if (evt.ctrlKey || evt.metaKey) {
        if (evt.keyCode == 83) {
          evt.preventDefault();
          if (evt.shiftKey) {
            this.saveDialog();
          } else {
            this.simpleSave();
          }
        } else if (evt.keyCode == 79) {

          //power user feature: focus search box when you press ctrl-o or cmd-o
          evt.preventDefault();
          this.openDrawer();
          var self= this;

          if ($('body').hasClass('resources-open')) {
            setTimeout(function() {
              self.myGraphsView.focusSearchBar();
            }, 1);
          }
        }
      }
    };
    view.saveDialog = function() {
      this.modals.createAccountDialog.showThenSave();
    };

    view.saveStart = function() {
      this.$saveBtn.addClass('saving');
      console.log("start saving animation");
    };
    view.saveSuccess = function() {
      this.$saveBtn.removeClass('saving').addClass('success');

      var self = this;
      setTimeout(function() {
        self.$saveBtn.removeClass('success');
      }, 2000);

    };
    view.saveFailure = function() {
      this.$saveBtn.removeClass('saving').addClass('failure');
      var self = this;
      setTimeout(function() {
        self.$saveBtn.removeClass('failure');
      }, 2000);
    };

    view.print = function(evt) {
      //execute a window.print
      window.print();
      return;
    };

    //
    // right hand tools
    //

    view.login = function() {
      //_kmq.push(['record', 'started login', {'login location': 'header'}]);
      this.modals.loginDialog.show();
    };

    view.createAccount = function() {
      //_kmq.push(['record', 'started signup', {
      //  'signup location': 'header'
      //}]);
      this.modals.createAccountDialog.show();
    };

  });

  return HeaderView;
});

define('lib/urlparser',['require'],function (require) {

  var UrlParser = {
    //from http://stackoverflow.com/questions/1403888/get-url-parameter-with-javascript-or-jquery
    getParameter: function(name) {
      return decodeURIComponent((new RegExp('[?|&]' + name + '=' + '([^&;]+?)(&|#|;|$)')
             .exec(location.search)||[,""])[1]
             .replace(/\+/g, '%20'))||null;
    }
  };

  return UrlParser;
});

// TODO - our calls to Calc.getState() don't work as we expect. The problem is that
// we expect full results immediately. Slider information, for example, isn't populated
// until after the parsing is done in the worker. That means the first .getState() we do will
// not have slider information at all. Every comparison we do between the first state and the
// other states will return not equal. We need to do one of the following:
//
// 1) Parse synchronously (already proven difficult)
// 2) Call .getState() asynchronously after everything is parsed. (tedious and ugly)
// 3) Build a much smarter state comparison function that doesn't need parsing information (redundant)
//
// The solution I'm using right now is brittle and incomplete. I'm simply passing the slider information
// in the setState back out during getState until we do a parse. It greatly improves things, but it'll
// break if you load an old graph that didn't get saved with the latest slider properties. We really
// want a better solution here.
define('main/graph_change_monitor',['require','pjs','underscore','underscore_model'],function (require) {
  var P = require('pjs');
  var _ = require('underscore');
  var UnderscoreModel = require('underscore_model');

  var GraphChangeMonitor = P(UnderscoreModel, function (model, _super) {

   model.init = function (Calc, graphsController) {
     _super.init.call(this);

     this.Calc = Calc;
     this.graphsController = graphsController;
     this.graphChanged = false;
     this._savedStates = {};


     Calc._calc.stateController.triggerSetState = this._useCurrentStateAsSavedState.bind(this);
     graphsController.observe('currentGraph', this._useCurrentStateAsSavedState.bind(this));
     graphsController.observe('currentGraph', this._markPotentialChange.bind(this));

     Calc._calc.addChangeCallback(this._markPotentialChange.bind(this));
   };

   model._statesAreEqual = function (state1, state2) {

     // creates cloned copies and also strips out undefined values in objects.
     // For instance, the .sliderInterval property can legitamely be set to undefined.
     // The problem with that is when we saved the state, that value would not have
     // been included because JSON.stringify() would have left it out. The _.isEqual()
     // function differentiates 'undefined' because it wasn't set and 'undefined' because
     // it was set to 'undefined' by using the .hasOwnProperty() method. One more reason
     // that we don't want to be doing this stuff manually here. Would be better to be
     // comparing full states here rather than piecing in information that should be here
     // but isn't simply because parsing is asynchronous.
     state1 = JSON.parse(JSON.stringify(state1));
     state2 = JSON.parse(JSON.stringify(state2));

     function ignoreAnimatedSliders (state) {
       var animatedSliders = _.filter(state.expressions.list, function(expr) {
         return expr.sliderIsPlaying;
       });

       _.each(animatedSliders, function (expr) {
         delete expr.latex;
         delete expr.sliderPlayDirection;
       });
     }

     ignoreAnimatedSliders(state1);
     ignoreAnimatedSliders(state2);

     return _.isEqual(state1, state2);
   };

   // It's impossible to directly compare two states. We make changes to
   // our datastructure over time. So, we can't read the currentGraph.graphData
   // directly. Instead, we wait to read the Calc.getState() after setting
   // a state. We only do this the first time we setState for a given hash.
   model._useCurrentStateAsSavedState = function () {
     var hash = this.getSavedHash();
     if (!this.getSavedStateForHash(hash)) {
       this.setSavedStateForHash(hash, this.Calc.getState());
     }
   };

   model.getSavedHash = function () {
     var currentGraph = this.graphsController.currentGraph;
     return (currentGraph && currentGraph.hash) || '';
   };

   model.getSavedStateForHash = function (hash) {
     return this._savedStates[hash];
   };

   model.setSavedStateForHash = function (hash, state) {
     this._savedStates[hash] = state;
   };

   model.getSavedState = function () {
     return this.getSavedStateForHash(this.getSavedHash());
   };

   model.setSavedState = function (state) {
     this.setSavedStateForHash(this.getSavedHash(), state);
   };

   // Collapses multiple changes into a single check. The check happens the next
   // event loop to make sure all changes are processed.
   model._markPotentialChange = function () {
     clearTimeout(this._checkForChangesTimeout);
     this._checkForChangesTimeout = setTimeout(this.checkForChanges.bind(this), 0);
   };

   model.checkForChanges = function () {
     var savedState = this.getSavedStateForHash(this.getSavedHash());
     var unsavedState = this.Calc.getState();
     var graphChanged = !this._statesAreEqual(savedState, unsavedState);

     this.setProperty('graphChanged', graphChanged);
   };
  });

  return GraphChangeMonitor;

});
define('locales/all',['require'],function (require) {return {"lt":{}}; });
define('text!data/betchacant_graphs.json',[],function () { return '[{\n  "title": "Peg Game",\n  "graphHash": "iqinawqpdc",\n  "state": {"graph":{"viewport":{"xmin":-12.288,"ymin":-13.657,"xmax":13.025,"ymax":6.374},"showLabels":false,"degreeMode":false,"showGrid":false,"polarMode":false,"showAxes":false,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":99,"text":"Slide or animate T:"},{"id":19,"latex":"T=0","domain":{"min":0,"max":1},"hidden":false,"color":"#000000","sliderMin":0,"sliderMax":12},{"id":45,"text":"Number of peg rows"},{"id":1,"latex":"N=4","domain":{"min":0,"max":1},"hidden":false,"color":"#C0504D","sliderMin":1,"sliderMax":10,"sliderInterval":1},{"id":47,"text":"Depth of capture coumns"},{"id":36,"latex":"M=5.81","domain":{"min":0,"max":1},"hidden":false,"color":"#8064A2","sliderMin":-10,"sliderMax":10},{"id":51,"text":"Pins"},{"id":79,"latex":"\\\\left(2P_i-P_j+.1\\\\sin\\\\left(\\\\tau tN^2\\\\right)\\\\left\\\\{P_i\\\\le P_j\\\\right\\\\},-1-w-P_j+.1\\\\cos\\\\left(\\\\tau tN^2\\\\right)\\\\right)","domain":{"min":0,"max":1},"hidden": false,"color":"#9BBB59"},{"id":84,"latex":"P_i=\\\\mod\\\\left(\\\\floor\\\\left(N^2t\\\\right),N\\\\right)","domain":{"min":0,"max":1},"hidden":true,"color":"#C0504D"},{"id":85,"latex":"P_j=\\\\floor\\\\left(Nt\\\\right)","domain":{"min":0,"max":1},"hidden":true,"color":"#4F81BD"},{"id":77,"text":"Falling balls"},{"id":78,"latex":"\\\\left(\\\\left\\\\{r\\\\floor\\\\left(t\\\\right)>T-1:X\\\\left(\\\\floor\\\\left(t\\\\right),T\\\\right)+w\\\\sin\\\\left(\\\\tau t\\\\right)\\\\right\\\\},\\\\left\\\\{r\\\\floor\\\\left(t\\\\right)>T-1:Y_f\\\\left(\\\\floor\\\\left(t\\\\right),T\\\\right)+w\\\\cos\\\\left(\\\\tau t\\\\right)\\\\right\\\\}\\\\right)","domain":{"min":0,"max":15},"hidden": false,"color":"#4F81BD"},{"id":53,"text":"Dropped balls"},{"id":90,"latex":"\\\\left(\\\\left\\\\{r\\\\floor\\\\left(t\\\\right)<T-1:X\\\\left(\\\\floor\\\\left(t\\\\right),T\\\\right)+w\\\\sin\\\\left(\\\\tau t\\\\right)\\\\right\\\\},\\\\left\\\\{r\\\\floor\\\\left(t\\\\right)<T-1:Y\\\\left(\\\\floor\\\\left(t\\\\right),T\\\\right)+w\\\\cos\\\\left(\\\\tau t\\\\right)\\\\right\\\\}\\\\right)","domain":{"min":0,"max":15},"hidden": false,"color":"#4F81BD"},{"id":96,"text":"Collection columns"},{"id":97,"latex":"\\\\left(\\\\floor\\\\left(\\\\left(N+1\\\\right)t\\\\right)+.5,-N-\\\\frac{M}{2}-\\\\frac{M}{2}\\\\mod\\\\left(\\\\left(N+1\\\\right)t,1\\\\right)-w\\\\right)","domain":{"min":-1,"max":1},"hidden":true,"color":"#C0504D"},{"id":58,"text":"Direction ball i goes at peg layer j"},{"id":2,"latex":"f\\\\left(i,j\\\\right)=2\\\\floor\\\\left(\\\\mod\\\\left(\\\\frac{1000\\\\sin\\\\left(ai\\\\right)}{2^j},1\\\\right)-.499\\\\right)+1","domain":{"min":0,"max":1},"hidden":false,"color":"#4F81BD"},{"id":89,"latex":"a=2.49","domain":{"min":0,"max":1},"hidden":true,"color":"#000000","sliderMin":-10,"sliderMax":10},{"id":60,"text":"End position of ball i"},{"id":3,"latex":"p\\\\left(i\\\\right)=\\\\sum_{n=1}^Nf\\\\left(i,n\\\\right)","domain":{"min":0,"max":1},"hidden":true,"color":"#9BBB59"},{"id":62,"text":"Horizontal position of ball i at height d"},{"id":4,"latex":"h\\\\left(i,d\\\\right)=\\\\sum_{n=1}^Nf\\\\left(i,n\\\\right)g\\\\left(-d-n\\\\right)","domain":{"min":0,"max":1},"hidden":false,"color":"#8064A2"},{"id":12,"latex":"g\\\\left(x\\\\right)=\\\\frac{\\\\left(\\\\tanh\\\\left(5x\\\\right)+1\\\\right)}{2}","domain":{"min":0,"max":1},"hidden":true,"color":"#F79646"},{"id":65,"text":"Height of ball i at time x"},{"id":66,"latex":"Y\\\\left(i,x\\\\right)=\\\\left\\\\{x<ri:-\\\\frac{2w}{r}\\\\left(x-ri\\\\right),\\\\max\\\\left(N\\\\left(ri-x\\\\right),-\\\\left(N+M\\\\right)+2wc\\\\left(i\\\\right)\\\\right)\\\\right\\\\}","domain":{"min":0,"max":1},"hidden":true,"color":"#F79646"},{"id":92,"latex":"Y_f\\\\left(i,x\\\\right)=\\\\left\\\\{x<ri:-\\\\frac{2w}{r}\\\\left(x-ri\\\\right),N\\\\left(ri-x\\\\right)\\\\right\\\\}","domain":{"min":0,"max":1},"hidden":false,"color":"#9BBB59"},{"id":88,"latex":"r=\\\\frac{1}{\\\\pi}","domain":{"min":0,"max":1},"hidden":true,"color":"#F79646"},{"id":86,"latex":"Y\\\\left(1,x\\\\right)","domain":{"min":0,"max":1},"hidden":true,"color":"#9BBB59"},{"id":87,"latex":"Y\\\\left(2,x\\\\right)","domain":{"min":0,"max":1},"hidden":true,"color":"#8064A2"},{"id":68,"text":"Horizontal position of ball i at time x"},{"id":69,"latex":"X\\\\left(i,x\\\\right)=h\\\\left(i,Y\\\\left(i,x\\\\right)\\\\right)","domain":{"min":0,"max":1},"hidden":false,"color":"#C0504D"},{"id":80,"latex":"\\\\left(X\\\\left(1,t\\\\right),Y\\\\left(1,t\\\\right)\\\\right)","domain":{"min":0,"max":20},"hidden":true,"color":"#8064A2"},{"id":72,"text":"Height of ball in resting column"},{"id":22,"latex":"c\\\\left(x\\\\right)=\\\\sum_{n=0}^{x-1}\\\\left\\\\{p\\\\left(n\\\\right)=p\\\\left(x\\\\right):1,0\\\\right\\\\}","domain":{"min":0,"max":1},"hidden":true,"color":"#9BBB59"},{"id":74,"latex":"w=0.3","domain":{"min":0,"max":1},"hidden":false,"color":"#F79646","sliderMin":0.1,"sliderMax":0.4}]}}\n},\n{\n  "title": "Electric Field Lines",\n  "graphHash": "op7ngl243e",\n  "state": {"graph":{"viewport":{"xmin":-11.25,"ymin":-8.9,"xmax":11.25,"ymax":8.903},"showLabels":true,"degreeMode":false,"showGrid":true,"polarMode":false,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":32,"text":"Electric field lines generated by two point charges:"},{"id":30,"latex":"\\\\left(x_1,y_1\\\\right)","domain":{"min":0,"max":10},"hidden": false,"color":"#8064A2"},{"id":31,"latex":"\\\\left(x_2,y_2\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646"},{"id":101,"text":"This is the position and charge of the purple point charge"},{"id":24,"latex":"q_1=1","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":-10,"sliderMax":10},{"id":26,"latex":"x_1=2","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":-10,"sliderMax":10},{"id":27,"latex":"y_1=0","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":-10,"sliderMax":10},{"id":103,"text":"This is the position and charge of the orange point charge "},{"id":25,"latex":"q_2=-1","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":-10,"sliderMax":10},{"id":28,"latex":"x_2=-2","domain":{"min":0,"max":10},"hidden":false,"color":"#9BBB59","sliderMin":-10,"sliderMax":10},{"id":29,"latex":"y_2=0","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D","sliderMin":-10,"sliderMax":10},{"id":105,"text":"The rest of this calculates and draws the field lines"},{"id":6,"latex":"f_x\\\\left(x,y\\\\right)=\\\\frac{q_1\\\\left(x-x_1\\\\right)}{\\\\left(\\\\left(x-x_1\\\\right)^2+\\\\left(y-y_1\\\\right)^2\\\\right)^{\\\\frac{3}{2}}}+\\\\frac{q_2\\\\left(x-x_2\\\\right)}{\\\\left(\\\\left(x-x_2\\\\right)^2+\\\\left(y-y_2\\\\right)^2\\\\right)^{\\\\frac{3}{2}}}","domain":{"min":0,"max":10},"hidden":false,"color":"#9BBB59"},{"id":7,"latex":"f_y\\\\left(x,y\\\\right)=\\\\frac{q_1\\\\left(y-y_1\\\\right)}{\\\\left(\\\\left(x-x_1\\\\right)^2+\\\\left(y-y_1\\\\right)^2\\\\right)^{\\\\frac{3}{2}}}+\\\\frac{q_2\\\\left(y-y_2\\\\right)}{\\\\left(\\\\left(x-x_2\\\\right)^2+\\\\left(y-y_2\\\\right)^2\\\\right)^{\\\\frac{3}{2}}}","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":16,"latex":"m=0.686","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":0,"sliderMax":1,"sliderInterval":""},{"id":2,"latex":"n\\\\space=\\\\space10","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":4,"sliderMax":20,"sliderInterval":1},{"id":9,"latex":"a\\\\space=\\\\space0","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":-10,"sliderMax":10},{"id":10,"latex":"b\\\\space=\\\\space0","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":-10,"sliderMax":10},{"id":3,"latex":"x_o=\\\\mod\\\\left(\\\\floor\\\\left(n^2t\\\\right),n\\\\right)-\\\\frac{n-1}{2}+a","domain":{"min":0,"max":10},"hidden":true,"color":"#F79646"},{"id":4,"latex":"y_o=\\\\frac{\\\\left(n^2t-\\\\mod\\\\left(n^2t,n\\\\right)\\\\right)}{n}-\\\\frac{n-1}{2}+b","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":17,"latex":"x_s=\\\\frac{f_x\\\\left(x_o,y_o\\\\right)}{\\\\sqrt{\\\\left(f_x\\\\left(x_o,y_o\\\\right)\\\\right)^2+\\\\left(f_y\\\\left(x_o,y_o\\\\right)\\\\right)^2}}","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":18,"latex":"y_s=\\\\frac{f_y\\\\left(x_o,y_o\\\\right)}{\\\\sqrt{\\\\left(f_x\\\\left(x_o,y_o\\\\right)\\\\right)^2+\\\\left(f_y\\\\left(x_o,y_o\\\\right)\\\\right)^2}}","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":19,"latex":"t_m=\\\\mod\\\\left(n^2t,1\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59"},{"id":23,"latex":"o=2.5","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":0,"sliderMax":3.14},{"id":21,"latex":"x_p=\\\\left\\\\{0<t_m<.6:x_st_m,\\\\space.6<t_m<.8:.6x_s+\\\\cos\\\\left(o\\\\right)x_s\\\\left(t_m-.6\\\\right)-\\\\sin\\\\left(o\\\\right)y_s\\\\left(t_m-.6\\\\right),\\\\space.8<t_m<1:.6x_s+\\\\sin\\\\left(o\\\\right)y_s\\\\left(t_m-.8\\\\right)+\\\\cos\\\\left(o\\\\right)x_s\\\\left(t_m-.8\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2"},{"id":22,"latex":"y_p=\\\\left\\\\{0<t_m<.6:y_st_m,\\\\space.6<t_m<.8:.6y_s+\\\\sin\\\\left(o\\\\right)x_s\\\\left(t_m-.6\\\\right)+\\\\cos\\\\left(o\\\\right)y_s\\\\left(t_m-.6\\\\right),\\\\space.8<t_m<1:.6y_s-\\\\sin\\\\left(o\\\\right)x_s\\\\left(t_m-.8\\\\right)+\\\\cos\\\\left(o\\\\right)y_s\\\\left(t_m-.8\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#F79646"},{"id":107,"text":"Finally: we draw the field lines"},{"id":20,"latex":"\\\\left[x_o+mx_p-.3mx_s,y_o-.3my_s+my_p\\\\right]","domain":{"min":0,"max":1},"hidden": false,"color":"#4F81BD"}]}}\n},\n{\n  "title": "Pac-man",\n  "graphHash": "kmnnpjxs9s",\n  "state": {"graph":{"viewport":{"xmin":-4.292,"ymin":-5.249,"xmax":9.755,"ymax":5.865},"showLabels":false,"degreeMode":false,"showGrid":false,"polarMode":false,"showAxes":false,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":2,"latex":"a=8.2","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":0,"sliderMax":19.978000000000065},{"id":1,"latex":"r\\\\le\\\\left\\\\{\\\\cos\\\\left(\\\\theta-h\\\\left(a\\\\right)\\\\right)<.8+.2\\\\sin2\\\\pi a\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646"},{"id":3,"latex":"\\\\left[f\\\\left(n\\\\right)-f\\\\left(a\\\\right)+x_c,g\\\\left(n\\\\right)-g\\\\left(a\\\\right)+y_c\\\\right]","domain":{"min":0,"max":20},"hidden":false,"color":"#C0504D"},{"id":4,"latex":"f_1\\\\left(x\\\\right)=\\\\left\\\\{x<3:x,x<7:3,x-3\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":5,"latex":"g_1\\\\left(x\\\\right)=\\\\left\\\\{x<3:0,x<7:x-3,3\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":13,"latex":"f\\\\left(x\\\\right)=x","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D"},{"id":14,"latex":"g\\\\left(x\\\\right)=\\\\sin x","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2"},{"id":11,"latex":"h\\\\left(x\\\\right)=\\\\arctan\\\\left(\\\\frac{\\\\frac{d}{dx}g\\\\left(x\\\\right)}{\\\\frac{d}{dx}f\\\\left(x\\\\right)}\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":8,"latex":"x_c=.1\\\\sin\\\\left(2\\\\pi\\\\mod\\\\left(t,1\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2"},{"id":10,"latex":"y_c=.1\\\\cos\\\\left(2\\\\pi\\\\mod\\\\left(t,1\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":7,"latex":"n=\\\\floor\\\\left(t\\\\right)\\\\left\\\\{\\\\floor\\\\left(t\\\\right)>a\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D"},{"id":6,"latex":"\\\\left[f\\\\left(t\\\\right),g\\\\left(t\\\\right)\\\\right]","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59"}]}}\n},\n{\n  "title": "Regular Sine Wave?",\n  "graphHash": "c1u72uowae",\n  "state": {"graph":{"viewport":{"xmin":-1.463,"ymin":-4.468,"xmax":16.313,"ymax":9.597},"showLabels":true,"degreeMode":false,"showGrid":true,"polarMode":false,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":47,"text":"Slide (or animate) a:"},{"id":45,"latex":"a=0","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":0,"sliderMax":1},{"id":25,"latex":"x_m\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t<\\\\frac{1}{6}:0,\\\\frac{1}{6}\\\\le t<\\\\frac{1}{3}:.85+.85\\\\cos\\\\left(\\\\pi-6\\\\pi\\\\left(t-\\\\frac{1}{6}\\\\right)\\\\right),\\\\frac{1}{3}\\\\le t<\\\\frac{2}{3}:1.7,\\\\frac{2}{3}\\\\le t<\\\\frac{5}{6}:2.55+.85\\\\cos\\\\left(\\\\pi-6\\\\pi\\\\left(t-\\\\frac{2}{3}\\\\right)\\\\right),\\\\frac{5}{6}\\\\le t\\\\le1:3.4\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2"},{"id":27,"latex":"y_m\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t<\\\\frac{1}{6}:11.4t,\\\\frac{1}{6}\\\\le t<\\\\frac{1}{3}:1.9+.6\\\\sin\\\\left(\\\\pi-6\\\\pi\\\\left(t-\\\\frac{1}{6}\\\\right)\\\\right),\\\\frac{1}{3}\\\\le t<\\\\frac{1}{2}:1.9-11.4\\\\left(t-\\\\frac{1}{3}\\\\right),\\\\frac{1}{2}\\\\le t<\\\\frac{2}{3}:11.4\\\\left(t-.5\\\\right),\\\\frac{2}{3}\\\\le t<\\\\frac{5}{6}:1.9+.6\\\\sin\\\\left(\\\\pi-6\\\\pi\\\\left(t-\\\\frac{2}{3}\\\\right)\\\\right),\\\\frac{5}{6}\\\\le t\\\\le1:1.9-11.4\\\\left(t-\\\\frac{5}{6}\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":38,"latex":"L_x\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t<1:x_d\\\\left(t\\\\right),\\\\space1\\\\le t<2:x_e\\\\left(t-1\\\\right)+s_2,2\\\\le t<3:x_s\\\\left(t-2\\\\right)+s_3,3\\\\le t<4:x_m\\\\left(t-3\\\\right)+s_4,4\\\\le t<5:x_0\\\\left(t-4\\\\right)+s_5,5\\\\le t\\\\le6:x_s\\\\left(t-5\\\\right)+s_6\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#F79646"},{"id":39,"latex":"L_y\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t<1:y_d\\\\left(t\\\\right),\\\\space1\\\\le t<2:y_e\\\\left(t-1\\\\right),2\\\\le t<3:y_s\\\\left(t-2\\\\right),3\\\\le t<4:y_m\\\\left(t-3\\\\right),4\\\\le t<5:y_0\\\\left(t-4\\\\right),5\\\\le t\\\\le6:y_s\\\\left(t-5\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":40,"latex":"\\\\left[G_x\\\\left(t\\\\right)\\\\left(1-a\\\\right)+aL_x\\\\left(t\\\\right),G_y\\\\left(t\\\\right)\\\\left(1-a\\\\right)+aL_y\\\\left(t\\\\right)\\\\right]","domain":{"min":0,"max":6},"hidden":false,"color":"#9BBB59"},{"id":43,"latex":"\\\\left[G_x\\\\left(t\\\\right),G_y\\\\left(t\\\\right)\\\\right]","domain":{"min":0,"max":6},"hidden":true,"color":"#8064A2"},{"id":41,"latex":"G_x\\\\left(t\\\\right)=2.3t","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59"},{"id":42,"latex":"G_y\\\\left(t\\\\right)=\\\\sin\\\\left(2\\\\pi t\\\\right)+1","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D"},{"id":1,"latex":"x_d\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t\\\\le\\\\frac{2}{3}:1.1+1.1\\\\cos\\\\left(3\\\\pi t\\\\right),\\\\frac{2}{3}\\\\le t\\\\le1:2.2\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D"},{"id":2,"latex":"y_d\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t\\\\le\\\\frac{2}{3}:1.25+1.25\\\\sin\\\\left(3\\\\pi t\\\\right),\\\\frac{2}{3}\\\\le t\\\\le1:1.25+9.6\\\\left(t-\\\\frac{2}{3}\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2"},{"id":4,"latex":"x_e\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t<\\\\frac{1}{3}:6.9t,\\\\frac{1}{3}\\\\le t\\\\le\\\\frac{19}{21}:1.15+1.15\\\\cos\\\\left(1.5\\\\cdot1.75\\\\pi\\\\left(t-\\\\frac{1}{3}\\\\right)\\\\right),\\\\frac{19}{21}\\\\le t\\\\le1:1.15+1.45\\\\cos\\\\left(1.5\\\\cdot1.75\\\\pi\\\\left(t-\\\\frac{1}{3}\\\\right)\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":5,"latex":"y_e\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t<\\\\frac{1}{3}:1.25,\\\\frac{1}{3}\\\\le t\\\\le1:1.25+1.25\\\\sin\\\\left(1.5\\\\cdot1.75\\\\pi\\\\left(t-\\\\frac{1}{3}\\\\right)\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":7,"latex":"s_{tx}\\\\left(t\\\\right)=L+.6\\\\cos\\\\left(2\\\\pi t\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D"},{"id":15,"latex":"s_{ty}\\\\left(t\\\\right)=2+.5\\\\sin\\\\left(2\\\\pi t\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":16,"latex":"s_{bx}\\\\left(t\\\\right)=.9+.9\\\\cos\\\\left(2\\\\pi t\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":17,"latex":"s_{by}\\\\left(t\\\\right)=.6+.6\\\\sin\\\\left(2\\\\pi t\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59"},{"id":19,"latex":"s_{mx}\\\\left(t\\\\right)=11.4-4L+162\\\\left(2.4-L\\\\right)\\\\left(-\\\\frac{t^3}{3}+\\\\frac{t^2}{2}-\\\\frac{2t}{9}\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2"},{"id":20,"latex":"s_{my}\\\\left(t\\\\right)=2-4.2\\\\left(t-\\\\frac{1}{3}\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#F79646"},{"id":21,"latex":"x_s\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t<\\\\frac{1}{3}:\\\\space s_{tx}\\\\left(.1+1.2t\\\\right),\\\\frac{1}{3}\\\\le t<\\\\frac{2}{3}:s_{mx}\\\\left(t\\\\right),\\\\frac{2}{3}\\\\le t\\\\le1:s_{bx}\\\\left(-1.5\\\\left(t-\\\\frac{2}{3}\\\\right)\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":22,"latex":"y_s\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t<\\\\frac{1}{3}:\\\\space s_{ty}\\\\left(.1+1.2t\\\\right),\\\\frac{1}{3}\\\\le t<\\\\frac{2}{3}:s_{my}\\\\left(t\\\\right),\\\\frac{2}{3}\\\\le t\\\\le1:s_{by}\\\\left(-1.5\\\\left(t-\\\\frac{2}{3}\\\\right)\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":14,"latex":"L=1","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":0,"sliderMax":1},{"id":28,"latex":"x_0\\\\left(t\\\\right)=1.1+1.1\\\\cos\\\\left(2\\\\pi\\\\left(t+.25\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":29,"latex":"y_0\\\\left(t\\\\right)=1.25+1.25\\\\sin\\\\left(2\\\\pi\\\\left(t+.25\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59"},{"id":35,"latex":"s_2=2.4","domain":{"min":0,"max":10},"hidden":false,"color":"#9BBB59","sliderMin":0,"sliderMax":10},{"id":36,"latex":"s_3=4.76","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D","sliderMin":0,"sliderMax":10},{"id":34,"latex":"s_4=6.77","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":0,"sliderMax":20},{"id":31,"latex":"s_5=10.37","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":0,"sliderMax":20},{"id":33,"latex":"s_6=12.65","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":0,"sliderMax":20}]}}\n},\n{\n  "title": "3D World",\n  "graphHash": "neyobpzndu",\n  "state": {"graph":{"viewport":{"xmin":-28.11,"ymin":-25.9,"xmax":67.4,"ymax":21.54},"showLabels":false,"degreeMode":false,"showGrid":false,"polarMode":false,"showAxes":false,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":31,"text":"You\'re at the black dot (u_p, v_p) looking at the world..."},{"id":4,"latex":"\\\\left(u_p,v_p\\\\right)","domain":{"min":0,"max":10},"hidden": false,"color":"#000000"},{"id":1,"latex":"u_p=1.1","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D","sliderMin":-29.34,"sliderMax":11.3},{"id":2,"latex":"v_p=0.4","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":-20,"sliderMax":20},{"id":33,"text":"These are the endpoints of the purple wall (you can drag those points too)"},{"id":43,"latex":"\\\\left(u_a,v_a\\\\right)","domain":{"min":0,"max":1},"hidden":false,"color":"#8064A2"},{"id":44,"latex":"\\\\left(u_b,v_b\\\\right)","domain":{"min":0,"max":1},"hidden":false,"color":"#8064A2"},{"id":5,"latex":"u_a=-2.001","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":-10.001,"sliderMax":10,"sliderInterval":0.01},{"id":6,"latex":"v_a=4.299","domain":{"min":0,"max":10},"hidden":false,"color":"#9BBB59","sliderMin":-10.001,"sliderMax":10.5,"sliderInterval":0.01},{"id":7,"latex":"u_b=6","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D","sliderMin":-10,"sliderMax":10.5},{"id":8,"latex":"v_b=2.8","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":-10,"sliderMax":10.9},{"id":35,"text":"These all draws the world:"},{"id":24,"latex":"y\\\\le-y_0","domain":{"min":0,"max":10},"hidden":false,"color":"#9BBB59"},{"id":9,"latex":"\\\\left(u_a+t\\\\left(u_b-u_a\\\\right),v_a+t\\\\left(v_b-v_a\\\\right)\\\\right)","domain":{"min":0,"max":1},"hidden":false,"color":"#8064A2"},{"id":28,"latex":"r_w\\\\left(\\\\theta\\\\right)=\\\\sec\\\\left(\\\\theta+.2\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D"},{"id":10,"latex":"r_b\\\\left(\\\\theta\\\\right)=\\\\floor\\\\left(\\\\frac{\\\\theta}{2\\\\pi}\\\\right)\\\\sec\\\\left(\\\\theta+\\\\frac{\\\\pi}{2}\\\\floor\\\\left(\\\\frac{2\\\\theta}{\\\\pi}+.5\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":14,"latex":"\\\\left[r_b\\\\left(2\\\\pi t\\\\right)\\\\sin2\\\\pi t,r_b\\\\left(2\\\\pi t\\\\right)\\\\cos2\\\\pi t\\\\right]","domain":{"min":0,"max":10},"hidden": false,"color":"#F79646"},{"id":16,"text":"Project (u, v) to (x, y) coordinates"},{"id":17,"latex":"X\\\\left(u,\\\\space v\\\\right)=5\\\\frac{\\\\left(u-u_p\\\\right)}{\\\\left(v-v_p\\\\right)}-x_0","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":18,"latex":"Y\\\\left(u,\\\\space v,\\\\space z\\\\right)=\\\\frac{-8+z}{\\\\left(v-v_p\\\\right)}-y_0","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":47,"latex":"c_{ond}\\\\space=\\\\space v_a+\\\\left(\\\\frac{u_p-u_a}{u_b-u_a}\\\\right)\\\\left(v_b-v_a\\\\right)-v_p","domain":{"min":0,"max":1},"hidden":true,"color":"#9BBB59"},{"id":36,"latex":"f\\\\left(x,z\\\\right)=\\\\frac{\\\\left(Y\\\\left(u_b,v_b,z\\\\right)-Y\\\\left(u_a,v_a,z\\\\right)\\\\right)}{X\\\\left(u_b,v_b\\\\right)-X\\\\left(u_a,v_a\\\\right)}\\\\left(x-X\\\\left(u_a,v_a\\\\right)\\\\right)+Y\\\\left(u_a,v_a,z\\\\right)","domain":{"min":0,"max":1},"hidden":false,"color":"#4F81BD"},{"id":40,"latex":"x_m=\\\\left\\\\{v_p<v_a:X\\\\left(u_a,v_a\\\\right),-1000\\\\right\\\\}","domain":{"min":0,"max":1},"hidden":false,"color":"#000000"},{"id":41,"latex":"X_m=\\\\left\\\\{v_p<v_b:X\\\\left(u_b,v_b\\\\right),\\\\space1000\\\\right\\\\}","domain":{"min":0,"max":1},"hidden":false,"color":"#C0504D"},{"id":39,"latex":"f\\\\left(x,0\\\\right)\\\\le y\\\\le f\\\\left(x,16\\\\right)\\\\left\\\\{c_{ond}>0\\\\right\\\\}\\\\left\\\\{x_m<x<X_m\\\\right\\\\}","domain":{"min":0,"max":1},"hidden": false,"color":"#8064A2"},{"id":22,"latex":"\\\\left(X\\\\left(r_b\\\\left(t\\\\right)\\\\sin t,r_b\\\\left(t\\\\right)\\\\cos t\\\\right)\\\\left\\\\{r_b\\\\left(t\\\\right)\\\\cos t-v_p>1\\\\right\\\\},Y\\\\left(r_b\\\\left(t\\\\right)\\\\sin t,r_b\\\\left(t\\\\right)\\\\cos t,0\\\\right)\\\\right)","domain":{"min":0,"max":62.831853},"hidden": false,"color":"#F79646"},{"id":11,"latex":"x_0=-31","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":-60,"sliderMax":10},{"id":13,"latex":"y_0=11","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D","sliderMin":-10,"sliderMax":20},{"id":46,"latex":"y\\\\le-8-y_0","domain":{"min":0,"max":1},"hidden":false,"color":"#000000"}]}}\n}]';});

define('main/betchacant',['require','loadcss!css/mygraphs','pjs','main/graph','text!data/betchacant_graphs.json'],function(require) {
  require('loadcss!css/mygraphs');

  var P = require('pjs');
  var Graph = require('main/graph');

  var betchacantString = require('text!data/betchacant_graphs.json');

  var betchaCant = P(function (proto, _super) {
    proto.init = function (Calc, graphsController) {
      this.Calc = Calc;
      this.expressionsView = Calc._calc.expressionsView;
      this.graphsController = graphsController;

      var self = this;
      this.expressionsView.__latexChangeCallbacks.push(function(latex) {
        if (latex === "betchacant") self.acceptChallenge();
      });

      this.betchacantGraphs = JSON.parse(betchacantString);
    };

    proto.acceptChallenge = function () {
      var graphData = this.betchacantGraphs[Math.floor(Math.random()*this.betchacantGraphs.length)];

      this.expressionsView.model.getSelected().setProperty('latex', '');
      var graph = Graph({
                  hash: graphData.graphHash,
                  title: graphData.title,
                  graphData: JSON.stringify(graphData.state)
                });

      this.selectedIndex = this.expressionsView.model.getSelected().index;
      this.graphsController.loadGraph(graph);
      var self = this;

      var undoCallback = function() {
        var model = self.expressionsView.model.getItemByIndex(self.selectedIndex);
        var view = self.expressionsView.getItemView(model.id);
        setTimeout(function() {
          view.addFocus();
        },100);
      };

      this.Calc._calc.toast('Challenge accepted.', {undoCallback: undoCallback});
    };
  });

  return betchaCant;
});

define('main/heartbeat',['require','jquery'],function(require){
  var pageload_timestamp = new Date();
  var $ = require('jquery');

  var wasActiveInInterval = false;

  function heartbeat () {
    //Low resolution since google analytics only allows 500 events per user-session
    var n = Math.round((new Date() - pageload_timestamp) / (60 * 1000));
    var eventName = 'Heartbeat' + (wasActiveInInterval ? '-active' : '-passive');
    wasActiveInInterval = false;
  }

  $(document).on('tap keypress', function () {
    wasActiveInInterval = true;
  });

  // Record heartbeat every minute
  setInterval(heartbeat, 60*1000);
});


define('main/log_errors',['require','jquery'],function(require){
  var $ = require('jquery');

  // use google analytics to log client javascript errors
  window.onerror = function(message, file, line) {
     var sFormattedMessage = '[' + file + ' (' + line + ')] ' + message;
  };

  // Also log ajax errors
  $(document).ajaxError(function (event, request, settings, thrownError) {
      // Would be nice to include settings.data, but I'm afraid of (among other things),
      // ending up with a bunch of plain text passwords in our analytics
      var sFormattedMessage = (
        settings.type + ' ' + window.location.protocol + '//' + window.location.host + settings.url +
        ' ' + request.status + ' (' + request.statusText + ')'
      );
  });
});

define('main/calc_desktop',['require','jquery','config','main/load_data','main/graphs_controller','main/graph','main/modals_controller','main/header_desktop','main/preserved_state','main/graph_change_monitor','browser','main/data_helpers','ipad.scrollfix','locales/all','i18n','api/calculator','main/betchacant','main/heartbeat','main/log_errors'],function (require) {

  var $ = require('jquery');
  var Config = require('config');
  var LOAD_DATA = require('main/load_data');

  //these manage the user and the loaded graph (graph hash, etc)
  var GraphsController = require('main/graphs_controller');
  var Graph = require('main/graph');

  var ModalsController = require('main/modals_controller');
  var HeaderView = require('main/header_desktop');

  //for page reloads when, for example, you switch language
  var preservedState = require('main/preserved_state');
  var GraphChangeMonitor = require('main/graph_change_monitor');

  //TODO: move browser detection into the API
  var Browser = require('browser');

  var DataHelpers = require('main/data_helpers');

  // prevent scrolling of entire page (includes the UI around embedded API)
  var ScrollFix = require('ipad.scrollfix');
  ScrollFix.limitScrollOnDocument();

  // set the dictionary for translations
  // TODO: move some of this logic into calc_embed (probably setLanguage)
  var i18n_dict = require('locales/all');
  var i18n = require('i18n');
  var lang = i18n.detectLanguage();
  i18n.init(lang, i18n_dict);

  //load up and insert the calculator!
  var CalcAPI = require('api/calculator');

  var options = Config.all();
  options.globalKeyboardUndo = true;
  options.redrawSlowly = !Browser.IS_MOBILE;
  options.border = false;
  var elt = document.getElementById('graph-container');
  var Calc = CalcAPI(elt, options);

  //we need this for tests
  var Betchacant = require('main/betchacant');

  // Send a heartbeat to google analytics once per minute
  require('main/heartbeat');
  // Send js and ajax errors to google analytics
  require('main/log_errors');

  //hook up graphsController
  var graphsController = GraphsController(Calc, LOAD_DATA.seed);
  graphsController.driveAccessErrorCallbacks.push(function () {
    Calc._calc.toast(
      'Error saving. Google login expired. Please log in again.',
      {
        style: 'error',
        hideAfter: 0
      }
    );
  });

  // some versions of webkit fire a ghost 'popstate ' event after and in the same event-loop as
  // the 'load' event. So, we disable 'popstate' events for the rest of the 'load' event-loop.
  var isGhostPopStateEvent = false;
  $(window).on('load', function () {
    isGhostPopStateEvent = true;
    setTimeout(function () {isGhostPopStateEvent = false;}, 0);
  });

  // back button support
  $(window).on('popstate', function(evt) {
    if (isGhostPopStateEvent) return;

    var state = evt.originalEvent.state;

    //If you have unsaved work, back will take you *not* to your last on this graph
    //But to the save (or load) before that. This warns you in the same way
    //That reload or a hard back does.
    if (Calc.hasUnsavedChanges()) {
      if (!confirm(i18n.t("Are you sure you want to leave this graph? Your unsaved work will be lost."))) {
        history.forward();
        return;
      }
    }

    if (state === null) {
      // If there is null state then we came from the calculator, but from a blank (or unsaved one) graph.
      graphsController.loadGraph(Graph());
      return;
    } else if (graphsController.currentGraph.hash === state.hash) {
      //If we read a popstate but the user wants to cancel it,
      //We execute a ".forward()". This triggers another popstate,
      //but right back to the graph we started with. We don't need to do
      //anything in this case.
      return;
    } else {
      graphsController.loadGraph(Graph(state));
    }

    //Toast when you navigate between graphs
    var graphTitle;
    if (!state.title) {
      graphTitle = i18n.t('Untitled Graph');
    } else {
      if (state.title.length > 15) {
        graphTitle = state.title.substr(0,15) + '...';
      } else {
        graphTitle = state.title;
      }
    }

    var str = i18n.t("Opened '__graphTitle__'", {graphTitle: graphTitle});
    //include a blank undo function so that the "undo" option still shows up
    Calc._calc.toast(str, {undoCallback: function() {}});
  });

  var modalsController = ModalsController(graphsController);
  var modals = modalsController.modals;

  var headerView = HeaderView(
    graphsController,
    Calc,
    modals
  );

  if (Config.get('expressions') !== false) Betchacant(
    Calc,
    graphsController
  );

  //make sure the user doesn't accidentally leave the page!
  if(!Config.get('no_navigation_warning')){
    $(window).bind('beforeunload', function(){
      if (Calc.hasUnsavedChanges() && !preservedState.hasState()) {
        return i18n.t('Are you sure you want to leave this graph? Your unsaved work will be lost.');
      }
      return null;
    });
  }

  var graphChangeMonitor = GraphChangeMonitor(Calc, graphsController);
  Calc.graphChangeMonitor = graphChangeMonitor;

  graphChangeMonitor.observe('graphChanged', function () {
    headerView.setProperty('graphChanged', Calc.hasUnsavedChanges());
  });

  Calc.hasUnsavedChanges = function () {
    return graphChangeMonitor.graphChanged;
  };

  $(window).on('paste', function (e) {
    var pastedText;
    if (window.clipboardData && window.clipboardData.getData) { // IE
      pastedText = window.clipboardData.getData('Text');
    } else if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {
      pastedText = e.originalEvent.clipboardData.getData('text/plain');
    }

    var parsedData = DataHelpers.parse(pastedText);
    if (parsedData) {
      e.stopPropagation();
      e.preventDefault();

      if (parsedData.error) {
        return Calc._calc.toast(parsedData.error, {style: 'error', hideAfter: 12000});
      }
      //undocumented method inside of calc_embed.js
      Calc._calc.createAndPopulateTable(parsedData.data);
    }
  });

  //This top-level location should becomes the place where all nontrivial document.ready() activities happen
  $(document).ready(function () {
    /* jshint maxcomplexity: 11 */

    //Setup save shortcut listener
    $(document).bind('keydown', headerView.handleKeydown.bind(headerView));

    modalsController.ready();
    //Show warning modal for unsupported browsers (because of screensize, for example)
    if (Browser.IS_ANDROID && !Browser.IS_CHROME) {
      modals.unsupportedBrowserDialog.show();
    }

    // headerView.appendTo('.dcg-header');

    $('.dcg-loading-div').fadeOut();

    if (LOAD_DATA.flash) {
      switch (LOAD_DATA.flash) {
        case 'clever_welcome':
          Calc._calc.toast(i18n.t('Logged in with Clever!'));
          break;
        case 'clever_no_email':
          Calc._calc.toast(i18n.t('Visiting anonymously from Clever.'), {
            hideAfter: 12000,
            learnMoreLink: 'http://support.desmos.com/entries/47595905-Signed-in-Anonymously-with-Clever'
          });
          break;
        case 'clever_communication_error':
          Calc._calc.toast(i18n.t('Error signing in with Clever.'), {
            hideAfter: 0,
            style: 'error',
            learnMoreLink: 'http://support.desmos.com/entries/47595625-Error-Signing-in-with-Clever'
          });
          break;
        default:
          Calc._calc.toast(LOAD_DATA.flash);
          break;
      }
    }

    if (LOAD_DATA.graph) {
      graphsController.loadGraph(Graph.fromAjax(LOAD_DATA.graph));
    } else {
      // The graph state either needs to be set or cleared to get the
      // calculator into a consistent state.
      graphsController.clearGraph();
    }

    if (preservedState.hasState()) {
      var stateInfo = preservedState.popState();
      graphChangeMonitor.setSavedState(stateInfo.savedState);
      Calc.setState(stateInfo.unsavedState);
    }


    if (Config.get('expressions') !== false) Calc._calc.expressionsView.triggerClearGraph = function () {
      graphsController.clearGraph();
    };
  });

  return Calc;
});


requirejs(['main/calc_desktop'], function (Calc) {
  // Calc global has singletons like expressions that are useful for debugging and testing.
  window.Calc = Calc;
});

define("toplevel/calculator_desktop", function(){});
